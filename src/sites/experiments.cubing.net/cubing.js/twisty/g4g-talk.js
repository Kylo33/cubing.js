var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateWrapper = (obj, member, setter, getter) => {
  return {
    set _(value) {
      __privateSet(obj, member, value, setter);
    },
    get _() {
      return __privateGet(obj, member, getter);
    }
  };
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// src/cubing/twisty/model/PromiseFreshener.ts
var _latestAssignedIdx, _latestResolvedIdx, PromiseFreshener, _latestAssignedIdx2, _latestResolvedIdx2, StaleDropper;
var init_PromiseFreshener = __esm({
  "src/cubing/twisty/model/PromiseFreshener.ts"() {
    PromiseFreshener = class {
      constructor() {
        __privateAdd(this, _latestAssignedIdx, 0);
        __privateAdd(this, _latestResolvedIdx, 0);
      }
      async queue(p) {
        const idx = ++__privateWrapper(this, _latestAssignedIdx)._;
        const result = await p;
        if (idx > __privateGet(this, _latestResolvedIdx)) {
          __privateSet(this, _latestResolvedIdx, idx);
          return {
            fresh: true,
            result
          };
        } else {
          return { fresh: false };
        }
      }
    };
    _latestAssignedIdx = new WeakMap();
    _latestResolvedIdx = new WeakMap();
    StaleDropper = class {
      constructor() {
        __privateAdd(this, _latestAssignedIdx2, 0);
        __privateAdd(this, _latestResolvedIdx2, 0);
      }
      queue(p) {
        return new Promise(async (resolve, reject) => {
          try {
            const idx = ++__privateWrapper(this, _latestAssignedIdx2)._;
            const result = await p;
            if (idx > __privateGet(this, _latestResolvedIdx2)) {
              __privateSet(this, _latestResolvedIdx2, idx);
              resolve(result);
            }
          } catch (e) {
            reject(e);
          }
        });
      }
    };
    _latestAssignedIdx2 = new WeakMap();
    _latestResolvedIdx2 = new WeakMap();
  }
});

// src/cubing/vendor/p-lazy/p-lazy.ts
function from(function_) {
  return new PLazy((resolve) => {
    resolve(function_());
  });
}
var PLazy;
var init_p_lazy = __esm({
  "src/cubing/vendor/p-lazy/p-lazy.ts"() {
    PLazy = class extends Promise {
      constructor(executor) {
        super((resolve) => {
          resolve();
        });
        this._executor = executor;
      }
      static from(function_) {
        return new PLazy((resolve) => {
          resolve(function_());
        });
      }
      static resolve(value) {
        return new PLazy((resolve) => {
          resolve(value);
        });
      }
      static reject(error) {
        return new PLazy((_resolve, reject) => {
          reject(error);
        });
      }
      then(onFulfilled, onRejected) {
        this._promise = this._promise || new Promise(this._executor);
        return this._promise.then(onFulfilled, onRejected);
      }
      catch(onRejected) {
        this._promise = this._promise || new Promise(this._executor);
        return this._promise.catch(onRejected);
      }
    };
  }
});

// src/cubing/twisty/model/props/TwistyProp.ts
var globalSourceGeneration, _children, _rawListeners, _scheduleRawDispatch, scheduleRawDispatch_fn, _rawDispatchPending, _dispatchRawListeners, dispatchRawListeners_fn, _freshListeners, TwistyPropParent, _value, TwistyPropSource, SimpleTwistyPropSource, NO_VALUE, _parents, _cachedLastSuccessfulCalculation, _cachedLatestGenerationCalculation, _getParents, getParents_fn, _cacheDerive, cacheDerive_fn, TwistyPropDerived, _disconnectionFunctions, FreshListenerManager;
var init_TwistyProp = __esm({
  "src/cubing/twisty/model/props/TwistyProp.ts"() {
    init_p_lazy();
    init_PromiseFreshener();
    globalSourceGeneration = 0;
    TwistyPropParent = class {
      constructor() {
        __privateAdd(this, _scheduleRawDispatch);
        __privateAdd(this, _dispatchRawListeners);
        __privateAdd(this, _children, /* @__PURE__ */ new Set());
        this.lastSourceGeneration = 0;
        __privateAdd(this, _rawListeners, /* @__PURE__ */ new Set());
        __privateAdd(this, _rawDispatchPending, false);
        __privateAdd(this, _freshListeners, /* @__PURE__ */ new Map());
      }
      canReuse(v1, v2) {
        return v1 === v2 || this.canReuseValue(v1, v2);
      }
      canReuseValue(_v12, _v22) {
        return false;
      }
      debugGetChildren() {
        return Array.from(__privateGet(this, _children).values());
      }
      addChild(child) {
        __privateGet(this, _children).add(child);
      }
      removeChild(child) {
        __privateGet(this, _children).delete(child);
      }
      markStale(sourceEvent) {
        if (sourceEvent.detail.generation !== globalSourceGeneration) {
          throw new Error("A TwistyProp was marked stale too late!");
        }
        if (this.lastSourceGeneration === sourceEvent.detail.generation) {
          return;
        }
        this.lastSourceGeneration = sourceEvent.detail.generation;
        for (const child of __privateGet(this, _children)) {
          child.markStale(sourceEvent);
        }
        __privateMethod(this, _scheduleRawDispatch, scheduleRawDispatch_fn).call(this);
      }
      addRawListener(listener, options) {
        __privateGet(this, _rawListeners).add(listener);
        if (options?.initial) {
          listener();
        }
      }
      removeRawListener(listener) {
        __privateGet(this, _rawListeners).delete(listener);
      }
      addFreshListener(listener) {
        const staleDropper = new StaleDropper();
        let lastResult = null;
        const callback = async () => {
          const result = await staleDropper.queue(this.get());
          if (lastResult !== null && this.canReuse(lastResult, result)) {
            return;
          }
          lastResult = result;
          listener(result);
        };
        __privateGet(this, _freshListeners).set(listener, callback);
        this.addRawListener(callback, { initial: true });
      }
      removeFreshListener(listener) {
        this.removeRawListener(__privateGet(this, _freshListeners).get(listener));
        __privateGet(this, _freshListeners).delete(listener);
      }
    };
    _children = new WeakMap();
    _rawListeners = new WeakMap();
    _scheduleRawDispatch = new WeakSet();
    scheduleRawDispatch_fn = function() {
      if (!__privateGet(this, _rawDispatchPending)) {
        __privateSet(this, _rawDispatchPending, true);
        setTimeout(() => __privateMethod(this, _dispatchRawListeners, dispatchRawListeners_fn).call(this), 0);
      }
    };
    _rawDispatchPending = new WeakMap();
    _dispatchRawListeners = new WeakSet();
    dispatchRawListeners_fn = function() {
      if (!__privateGet(this, _rawDispatchPending)) {
        throw new Error("Invalid dispatch state!");
      }
      for (const listener of __privateGet(this, _rawListeners)) {
        listener();
      }
      __privateSet(this, _rawDispatchPending, false);
    };
    _freshListeners = new WeakMap();
    TwistyPropSource = class extends TwistyPropParent {
      constructor(initialValue) {
        super();
        __privateAdd(this, _value, void 0);
        __privateSet(this, _value, from(() => this.getDefaultValue()));
        if (initialValue) {
          __privateSet(this, _value, this.deriveFromPromiseOrValue(initialValue, __privateGet(this, _value)));
        }
      }
      set(input) {
        __privateSet(this, _value, this.deriveFromPromiseOrValue(input, __privateGet(this, _value)));
        const sourceEventDetail = {
          sourceProp: this,
          value: __privateGet(this, _value),
          generation: ++globalSourceGeneration
        };
        this.markStale(new CustomEvent("stale", {
          detail: sourceEventDetail
        }));
      }
      async get() {
        return __privateGet(this, _value);
      }
      async deriveFromPromiseOrValue(input, oldValuePromise) {
        return this.derive(await input, oldValuePromise);
      }
    };
    _value = new WeakMap();
    SimpleTwistyPropSource = class extends TwistyPropSource {
      derive(input) {
        return input;
      }
    };
    NO_VALUE = Symbol("no value");
    TwistyPropDerived = class extends TwistyPropParent {
      constructor(parents, userVisibleErrorTracker) {
        super();
        this.userVisibleErrorTracker = userVisibleErrorTracker;
        __privateAdd(this, _getParents);
        __privateAdd(this, _cacheDerive);
        __privateAdd(this, _parents, void 0);
        __privateAdd(this, _cachedLastSuccessfulCalculation, null);
        __privateAdd(this, _cachedLatestGenerationCalculation, null);
        __privateSet(this, _parents, parents);
        for (const parent of Object.values(parents)) {
          parent.addChild(this);
        }
      }
      async get() {
        const generation = this.lastSourceGeneration;
        if (__privateGet(this, _cachedLatestGenerationCalculation)?.generation === generation) {
          return __privateGet(this, _cachedLatestGenerationCalculation).output;
        }
        const latestGenerationCalculation = {
          generation,
          output: __privateMethod(this, _cacheDerive, cacheDerive_fn).call(this, __privateMethod(this, _getParents, getParents_fn).call(this), generation, __privateGet(this, _cachedLastSuccessfulCalculation))
        };
        __privateSet(this, _cachedLatestGenerationCalculation, latestGenerationCalculation);
        this.userVisibleErrorTracker?.reset();
        return latestGenerationCalculation.output;
      }
    };
    _parents = new WeakMap();
    _cachedLastSuccessfulCalculation = new WeakMap();
    _cachedLatestGenerationCalculation = new WeakMap();
    _getParents = new WeakSet();
    getParents_fn = async function() {
      const inputValuePromises = {};
      for (const [key, parent] of Object.entries(__privateGet(this, _parents))) {
        inputValuePromises[key] = parent.get();
      }
      const inputs = {};
      for (const key in __privateGet(this, _parents)) {
        inputs[key] = await inputValuePromises[key];
      }
      return inputs;
    };
    _cacheDerive = new WeakSet();
    cacheDerive_fn = async function(inputsPromise, generation, cachedLatestGenerationCalculation = null) {
      const inputs = await inputsPromise;
      const cache = (output) => {
        __privateSet(this, _cachedLastSuccessfulCalculation, {
          inputs,
          output: Promise.resolve(output),
          generation
        });
        return output;
      };
      if (!cachedLatestGenerationCalculation) {
        return cache(await this.derive(inputs));
      }
      const cachedInputs = cachedLatestGenerationCalculation.inputs;
      for (const key in __privateGet(this, _parents)) {
        const parent = __privateGet(this, _parents)[key];
        if (!parent.canReuse(inputs[key], cachedInputs[key])) {
          return cache(await this.derive(inputs));
        }
      }
      return cachedLatestGenerationCalculation.output;
    };
    FreshListenerManager = class {
      constructor() {
        __privateAdd(this, _disconnectionFunctions, []);
      }
      addListener(prop, listener) {
        let disconnected = false;
        const wrappedListener = (value) => {
          if (disconnected) {
            return;
          }
          listener(value);
        };
        prop.addFreshListener(wrappedListener);
        __privateGet(this, _disconnectionFunctions).push(() => {
          prop.removeFreshListener(wrappedListener);
          disconnected = true;
        });
      }
      addMultiListener(props, listener) {
        let disconnected = false;
        let initialIgnoresLeft = props.length - 1;
        const wrappedListener = async (_) => {
          if (initialIgnoresLeft > 0) {
            initialIgnoresLeft--;
            return;
          }
          if (disconnected) {
            return;
          }
          const promises = props.map((prop) => prop.get());
          const values = await Promise.all(promises);
          listener(values);
        };
        for (const prop of props) {
          prop.addFreshListener(wrappedListener);
        }
        __privateGet(this, _disconnectionFunctions).push(() => {
          for (const prop of props) {
            prop.removeFreshListener(wrappedListener);
          }
          disconnected = true;
        });
      }
      disconnect() {
        for (const disconnectionFunction of __privateGet(this, _disconnectionFunctions)) {
          disconnectionFunction();
        }
      }
    };
    _disconnectionFunctions = new WeakMap();
  }
});

// src/cubing/alg/common.ts
var writeAlgDebugField, Comparable, AlgCommon;
var init_common = __esm({
  "src/cubing/alg/common.ts"() {
    writeAlgDebugField = false;
    Comparable = class {
      is(c) {
        return this instanceof c;
      }
      as(c) {
        return this instanceof c ? this : null;
      }
    };
    AlgCommon = class extends Comparable {
      constructor() {
        super();
        if (writeAlgDebugField) {
          Object.defineProperty(this, "_debugStr", {
            get: () => {
              return this.toString();
            }
          });
        }
      }
      get log() {
        return console.log.bind(console, this, this.toString());
      }
    };
  }
});

// src/cubing/alg/iteration.ts
function toggleDirection(iterationDirection, flip = true) {
  if (!flip) {
    return iterationDirection;
  }
  switch (iterationDirection) {
    case 1 /* Forwards */:
      return -1 /* Backwards */;
    case -1 /* Backwards */:
      return 1 /* Forwards */;
  }
}
function direct(g, iterDir) {
  return iterDir === -1 /* Backwards */ ? Array.from(g).reverse() : g;
}
function reverse(g) {
  return Array.from(g).reverse();
}
function* directedGenerator(g, direction) {
  direction === -1 /* Backwards */ ? yield* reverseGenerator(g) : yield* g;
}
function* reverseGenerator(g) {
  for (const t2 of Array.from(g).reverse()) {
    yield t2;
  }
}
var init_iteration = __esm({
  "src/cubing/alg/iteration.ts"() {
  }
});

// src/cubing/alg/limits.ts
var MAX_INT, MAX_INT_DESCRIPTION, MIN_INT;
var init_limits = __esm({
  "src/cubing/alg/limits.ts"() {
    MAX_INT = 2147483647;
    MAX_INT_DESCRIPTION = "2^31 - 1";
    MIN_INT = -2147483648;
  }
});

// src/cubing/alg/AlgBuilder.ts
var _units, AlgBuilder;
var init_AlgBuilder = __esm({
  "src/cubing/alg/AlgBuilder.ts"() {
    init_Alg();
    AlgBuilder = class {
      constructor() {
        __privateAdd(this, _units, []);
      }
      push(u) {
        __privateGet(this, _units).push(u);
      }
      experimentalPushAlg(alg) {
        for (const u of alg.units()) {
          this.push(u);
        }
      }
      experimentalNumUnits() {
        return __privateGet(this, _units).length;
      }
      toAlg() {
        return new Alg(__privateGet(this, _units));
      }
      reset() {
        __privateSet(this, _units, []);
      }
    };
    _units = new WeakMap();
  }
});

// src/cubing/alg/units/containers/Commutator.ts
var _A, _B, _Commutator, Commutator;
var init_Commutator = __esm({
  "src/cubing/alg/units/containers/Commutator.ts"() {
    init_Alg();
    init_common();
    init_iteration();
    _Commutator = class extends AlgCommon {
      constructor(aSource, bSource) {
        super();
        __privateAdd(this, _A, void 0);
        __privateAdd(this, _B, void 0);
        __privateSet(this, _A, experimentalEnsureAlg(aSource));
        __privateSet(this, _B, experimentalEnsureAlg(bSource));
      }
      get A() {
        return __privateGet(this, _A);
      }
      get B() {
        return __privateGet(this, _B);
      }
      isIdentical(other) {
        const otherAsCommutator = other.as(_Commutator);
        return !!(otherAsCommutator?.A.isIdentical(this.A) && otherAsCommutator?.B.isIdentical(this.B));
      }
      invert() {
        return new _Commutator(__privateGet(this, _B), __privateGet(this, _A));
      }
      *experimentalExpand(iterDir = 1 /* Forwards */, depth) {
        depth ?? (depth = Infinity);
        if (depth === 0) {
          yield iterDir === 1 /* Forwards */ ? this : this.invert();
        } else {
          if (iterDir === 1 /* Forwards */) {
            yield* this.A.experimentalExpand(1 /* Forwards */, depth - 1);
            yield* this.B.experimentalExpand(1 /* Forwards */, depth - 1);
            yield* this.A.experimentalExpand(-1 /* Backwards */, depth - 1);
            yield* this.B.experimentalExpand(-1 /* Backwards */, depth - 1);
          } else {
            yield* this.B.experimentalExpand(1 /* Forwards */, depth - 1);
            yield* this.A.experimentalExpand(1 /* Forwards */, depth - 1);
            yield* this.B.experimentalExpand(-1 /* Backwards */, depth - 1);
            yield* this.A.experimentalExpand(-1 /* Backwards */, depth - 1);
          }
        }
      }
      toString() {
        return `[${__privateGet(this, _A).toString()}, ${__privateGet(this, _B).toString()}]`;
      }
    };
    Commutator = _Commutator;
    _A = new WeakMap();
    _B = new WeakMap();
  }
});

// src/cubing/alg/units/containers/Conjugate.ts
var _A2, _B2, _Conjugate, Conjugate;
var init_Conjugate = __esm({
  "src/cubing/alg/units/containers/Conjugate.ts"() {
    init_Alg();
    init_common();
    init_iteration();
    _Conjugate = class extends AlgCommon {
      constructor(aSource, bSource) {
        super();
        __privateAdd(this, _A2, void 0);
        __privateAdd(this, _B2, void 0);
        __privateSet(this, _A2, experimentalEnsureAlg(aSource));
        __privateSet(this, _B2, experimentalEnsureAlg(bSource));
      }
      get A() {
        return __privateGet(this, _A2);
      }
      get B() {
        return __privateGet(this, _B2);
      }
      isIdentical(other) {
        const otherAsConjugate = other.as(_Conjugate);
        return !!(otherAsConjugate?.A.isIdentical(this.A) && otherAsConjugate?.B.isIdentical(this.B));
      }
      invert() {
        return new _Conjugate(__privateGet(this, _A2), __privateGet(this, _B2).invert());
      }
      *experimentalExpand(iterDir, depth) {
        depth ?? (depth = Infinity);
        if (depth === 0) {
          yield iterDir === 1 /* Forwards */ ? this : this.invert();
        } else {
          yield* this.A.experimentalExpand(1 /* Forwards */, depth - 1);
          yield* this.B.experimentalExpand(iterDir, depth - 1);
          yield* this.A.experimentalExpand(-1 /* Backwards */, depth - 1);
        }
      }
      toString() {
        return `[${this.A}: ${this.B}]`;
      }
    };
    Conjugate = _Conjugate;
    _A2 = new WeakMap();
    _B2 = new WeakMap();
  }
});

// src/cubing/alg/units/leaves/LineComment.ts
var _text, _LineComment, LineComment;
var init_LineComment = __esm({
  "src/cubing/alg/units/leaves/LineComment.ts"() {
    init_common();
    init_iteration();
    _LineComment = class extends AlgCommon {
      constructor(commentText) {
        super();
        __privateAdd(this, _text, void 0);
        if (commentText.includes("\n") || commentText.includes("\r")) {
          throw new Error("LineComment cannot contain newline");
        }
        __privateSet(this, _text, commentText);
      }
      get text() {
        return __privateGet(this, _text);
      }
      isIdentical(other) {
        const otherAsLineComment = other;
        return other.is(_LineComment) && __privateGet(this, _text) === __privateGet(otherAsLineComment, _text);
      }
      invert() {
        return this;
      }
      *experimentalExpand(_iterDir = 1 /* Forwards */, _depth = Infinity) {
        yield this;
      }
      toString() {
        return `//${__privateGet(this, _text)}`;
      }
    };
    LineComment = _LineComment;
    _text = new WeakMap();
  }
});

// src/cubing/alg/units/leaves/Newline.ts
var Newline;
var init_Newline = __esm({
  "src/cubing/alg/units/leaves/Newline.ts"() {
    init_common();
    init_iteration();
    Newline = class extends AlgCommon {
      toString() {
        return `
`;
      }
      isIdentical(other) {
        return other.is(Newline);
      }
      invert() {
        return this;
      }
      *experimentalExpand(_iterDir = 1 /* Forwards */, _depth = Infinity) {
        yield this;
      }
    };
  }
});

// src/cubing/alg/units/leaves/Pause.ts
var Pause;
var init_Pause = __esm({
  "src/cubing/alg/units/leaves/Pause.ts"() {
    init_common();
    init_iteration();
    Pause = class extends AlgCommon {
      toString() {
        return `.`;
      }
      isIdentical(other) {
        return other.is(Pause);
      }
      invert() {
        return this;
      }
      *experimentalExpand(_iterDir = 1 /* Forwards */, _depth = Infinity) {
        yield this;
      }
    };
  }
});

// src/cubing/alg/parse.ts
function parseIntWithEmptyFallback(n, emptyFallback) {
  return n ? parseInt(n) : emptyFallback;
}
function parseAlg(s) {
  return new AlgParser().parseAlg(s);
}
function parseMove(s) {
  return new AlgParser().parseMove(s);
}
function parseQuantumMove(s) {
  return new AlgParser().parseQuantumMove(s);
}
function addCharIndices(t2, startCharIndex, endCharIndex) {
  const parsedT = t2;
  parsedT.startCharIndex = startCharIndex;
  parsedT.endCharIndex = endCharIndex;
  return parsedT;
}
function transferCharIndex(from2, to) {
  if ("startCharIndex" in from2) {
    to.startCharIndex = from2.startCharIndex;
  }
  if ("endCharIndex" in from2) {
    to.endCharIndex = from2.endCharIndex;
  }
  return to;
}
var amountRegex, moveStartRegex, quantumMoveRegex, commentTextRegex, square1PairStart, square1PairEnd, _input, _idx, AlgParser;
var init_parse = __esm({
  "src/cubing/alg/parse.ts"() {
    init_Alg();
    init_AlgBuilder();
    init_Commutator();
    init_Conjugate();
    init_Grouping();
    init_LineComment();
    init_Move();
    init_Newline();
    init_Pause();
    amountRegex = /^(\d+)?('?)/;
    moveStartRegex = /^[_\dA-Za-z]/;
    quantumMoveRegex = /^((([1-9]\d*)-)?([1-9]\d*))?([_A-Za-z]+)?/;
    commentTextRegex = /^[^\n]*/;
    square1PairStart = /^(-?\d+), ?/;
    square1PairEnd = /^(-?\d+)\)/;
    AlgParser = class {
      constructor() {
        __privateAdd(this, _input, "");
        __privateAdd(this, _idx, 0);
      }
      parseAlg(input) {
        __privateSet(this, _input, input);
        __privateSet(this, _idx, 0);
        const alg = this.parseAlgWithStopping([]);
        this.mustBeAtEndOfInput();
        return alg;
      }
      parseMove(input) {
        __privateSet(this, _input, input);
        __privateSet(this, _idx, 0);
        const move = this.parseMoveImpl();
        this.mustBeAtEndOfInput();
        return move;
      }
      parseQuantumMove(input) {
        __privateSet(this, _input, input);
        __privateSet(this, _idx, 0);
        const quantumMove = this.parseQuantumMoveImpl();
        this.mustBeAtEndOfInput();
        return quantumMove;
      }
      mustBeAtEndOfInput() {
        if (__privateGet(this, _idx) !== __privateGet(this, _input).length) {
          throw new Error("parsing unexpectedly ended early");
        }
      }
      parseAlgWithStopping(stopBefore) {
        let algStartIdx = __privateGet(this, _idx);
        let algEndIdx = __privateGet(this, _idx);
        const algBuilder = new AlgBuilder();
        let crowded = false;
        const mustNotBeCrowded = (idx) => {
          if (crowded) {
            throw new Error(`Unexpected character at index ${idx}. Are you missing a space?`);
          }
        };
        mainLoop:
          while (__privateGet(this, _idx) < __privateGet(this, _input).length) {
            const savedCharIndex = __privateGet(this, _idx);
            if (stopBefore.includes(__privateGet(this, _input)[__privateGet(this, _idx)])) {
              return addCharIndices(algBuilder.toAlg(), algStartIdx, algEndIdx);
            }
            if (this.tryConsumeNext(" ")) {
              crowded = false;
              if (algBuilder.experimentalNumUnits() === 0) {
                algStartIdx = __privateGet(this, _idx);
              }
              continue mainLoop;
            } else if (moveStartRegex.test(__privateGet(this, _input)[__privateGet(this, _idx)])) {
              mustNotBeCrowded(savedCharIndex);
              const move = this.parseMoveImpl();
              algBuilder.push(move);
              crowded = true;
              algEndIdx = __privateGet(this, _idx);
              continue mainLoop;
            } else if (this.tryConsumeNext("(")) {
              mustNotBeCrowded(savedCharIndex);
              const sq1PairStartMatch = this.tryRegex(square1PairStart);
              if (sq1PairStartMatch) {
                const topAmountString = sq1PairStartMatch[1];
                const savedCharIndexD = __privateGet(this, _idx);
                const sq1PairEndMatch = this.parseRegex(square1PairEnd);
                const uMove = addCharIndices(new Move(new QuantumMove("U_SQ_"), parseInt(topAmountString)), savedCharIndex + 1, savedCharIndex + 1 + topAmountString.length);
                const dMove = addCharIndices(new Move(new QuantumMove("D_SQ_"), parseInt(sq1PairEndMatch[1])), savedCharIndexD, __privateGet(this, _idx) - 1);
                const alg = addCharIndices(new Alg([uMove, dMove]), savedCharIndex + 1, __privateGet(this, _idx) - 1);
                algBuilder.push(addCharIndices(new Grouping(alg), savedCharIndex, __privateGet(this, _idx)));
                crowded = true;
                algEndIdx = __privateGet(this, _idx);
                continue mainLoop;
              } else {
                const alg = this.parseAlgWithStopping([")"]);
                this.mustConsumeNext(")");
                const amount = this.parseAmount();
                algBuilder.push(addCharIndices(new Grouping(alg, amount), savedCharIndex, __privateGet(this, _idx)));
                crowded = true;
                algEndIdx = __privateGet(this, _idx);
                continue mainLoop;
              }
            } else if (this.tryConsumeNext("[")) {
              mustNotBeCrowded(savedCharIndex);
              const A = this.parseAlgWithStopping([",", ":"]);
              const separator = this.popNext();
              const B = this.parseAlgWithStopping(["]"]);
              this.mustConsumeNext("]");
              switch (separator) {
                case ":":
                  algBuilder.push(addCharIndices(new Conjugate(A, B), savedCharIndex, __privateGet(this, _idx)));
                  crowded = true;
                  algEndIdx = __privateGet(this, _idx);
                  continue mainLoop;
                case ",":
                  algBuilder.push(addCharIndices(new Commutator(A, B), savedCharIndex, __privateGet(this, _idx)));
                  crowded = true;
                  algEndIdx = __privateGet(this, _idx);
                  continue mainLoop;
                default:
                  throw "unexpected parsing error";
              }
            } else if (this.tryConsumeNext("\n")) {
              algBuilder.push(addCharIndices(new Newline(), savedCharIndex, __privateGet(this, _idx)));
              crowded = false;
              algEndIdx = __privateGet(this, _idx);
              continue mainLoop;
            } else if (this.tryConsumeNext("/")) {
              if (this.tryConsumeNext("/")) {
                mustNotBeCrowded(savedCharIndex);
                const [text] = this.parseRegex(commentTextRegex);
                algBuilder.push(addCharIndices(new LineComment(text), savedCharIndex, __privateGet(this, _idx)));
                crowded = false;
                algEndIdx = __privateGet(this, _idx);
                continue mainLoop;
              } else {
                algBuilder.push(addCharIndices(new Move("_SLASH_"), savedCharIndex, __privateGet(this, _idx)));
                crowded = true;
                algEndIdx = __privateGet(this, _idx);
                continue mainLoop;
              }
            } else if (this.tryConsumeNext(".")) {
              mustNotBeCrowded(savedCharIndex);
              algBuilder.push(addCharIndices(new Pause(), savedCharIndex, __privateGet(this, _idx)));
              crowded = true;
              algEndIdx = __privateGet(this, _idx);
              continue mainLoop;
            } else {
              throw new Error(`Unexpected character: ${this.popNext()}`);
            }
          }
        if (__privateGet(this, _idx) !== __privateGet(this, _input).length) {
          throw new Error("did not finish parsing?");
        }
        if (stopBefore.length > 0) {
          throw new Error("expected stopping");
        }
        return addCharIndices(algBuilder.toAlg(), algStartIdx, algEndIdx);
      }
      parseQuantumMoveImpl() {
        const [, , , outerLayerStr, innerLayerStr, family] = this.parseRegex(quantumMoveRegex);
        return new QuantumMove(family, parseIntWithEmptyFallback(innerLayerStr, void 0), parseIntWithEmptyFallback(outerLayerStr, void 0));
      }
      parseMoveImpl() {
        const savedCharIndex = __privateGet(this, _idx);
        if (this.tryConsumeNext("/")) {
          return addCharIndices(new Move("_SLASH_"), savedCharIndex, __privateGet(this, _idx));
        }
        let quantumMove = this.parseQuantumMoveImpl();
        let [amount, hadEmptyAbsAmount] = this.parseAmountAndTrackEmptyAbsAmount();
        const suffix = this.parseMoveSuffix();
        if (suffix) {
          if (amount < 0) {
            throw new Error("uh-oh");
          }
          if ((suffix === "++" || suffix === "--") && amount !== 1) {
            throw new Error("Pochmann ++ or -- moves cannot have an amount other than 1.");
          }
          if ((suffix === "++" || suffix === "--") && !hadEmptyAbsAmount) {
            throw new Error("Pochmann ++ or -- moves cannot have an amount written as a number.");
          }
          if ((suffix === "+" || suffix === "-") && hadEmptyAbsAmount) {
            throw new Error("Clock dial moves must have an amount written as a natural number followed by + or -.");
          }
          if (suffix.startsWith("+")) {
            quantumMove = quantumMove.modified({
              family: `${quantumMove.family}_${suffix === "+" ? "PLUS" : "PLUSPLUS"}_`
            });
          }
          if (suffix.startsWith("-")) {
            quantumMove = quantumMove.modified({
              family: `${quantumMove.family}_${suffix === "-" ? "PLUS" : "PLUSPLUS"}_`
            });
            amount *= -1;
          }
        }
        const move = addCharIndices(new Move(quantumMove, amount), savedCharIndex, __privateGet(this, _idx));
        return move;
      }
      parseMoveSuffix() {
        if (this.tryConsumeNext("+")) {
          if (this.tryConsumeNext("+")) {
            return "++";
          }
          return "+";
        }
        if (this.tryConsumeNext("-")) {
          if (this.tryConsumeNext("-")) {
            return "--";
          }
          return "-";
        }
        return null;
      }
      parseAmountAndTrackEmptyAbsAmount() {
        const savedIdx = __privateGet(this, _idx);
        const [, absAmountStr, primeStr] = this.parseRegex(amountRegex);
        if (absAmountStr?.startsWith("0") && absAmountStr !== "0") {
          throw new Error(`Error at char index ${savedIdx}: An amount can only start with 0 if it's exactly the digit 0.`);
        }
        return [
          parseIntWithEmptyFallback(absAmountStr, 1) * (primeStr === "'" ? -1 : 1),
          !absAmountStr
        ];
      }
      parseAmount() {
        const savedIdx = __privateGet(this, _idx);
        const [, absAmountStr, primeStr] = this.parseRegex(amountRegex);
        if (absAmountStr?.startsWith("0") && absAmountStr !== "0") {
          throw new Error(`Error at char index ${savedIdx}: An amount number can only start with 0 if it's exactly the digit 0.`);
        }
        return parseIntWithEmptyFallback(absAmountStr, 1) * (primeStr === "'" ? -1 : 1);
      }
      parseRegex(regex) {
        const arr = regex.exec(this.remaining());
        if (arr === null) {
          throw new Error("internal parsing error");
        }
        __privateSet(this, _idx, __privateGet(this, _idx) + arr[0].length);
        return arr;
      }
      tryRegex(regex) {
        const arr = regex.exec(this.remaining());
        if (arr === null) {
          return null;
        }
        __privateSet(this, _idx, __privateGet(this, _idx) + arr[0].length);
        return arr;
      }
      remaining() {
        return __privateGet(this, _input).slice(__privateGet(this, _idx));
      }
      popNext() {
        const next = __privateGet(this, _input)[__privateGet(this, _idx)];
        __privateWrapper(this, _idx)._++;
        return next;
      }
      tryConsumeNext(expected) {
        if (__privateGet(this, _input)[__privateGet(this, _idx)] === expected) {
          __privateWrapper(this, _idx)._++;
          return true;
        }
        return false;
      }
      mustConsumeNext(expected) {
        const next = this.popNext();
        if (next !== expected) {
          throw new Error(`expected \`${expected}\` while parsing, encountered ${next}`);
        }
        return next;
      }
    };
    _input = new WeakMap();
    _idx = new WeakMap();
  }
});

// src/cubing/alg/warnOnce.ts
function warnOnce(s) {
  if (!warned.has(s)) {
    console.warn(s);
    warned.add(s);
  }
}
var warned;
var init_warnOnce = __esm({
  "src/cubing/alg/warnOnce.ts"() {
    warned = /* @__PURE__ */ new Set();
  }
});

// src/cubing/alg/units/QuantumWithAmount.ts
var QuantumWithAmount;
var init_QuantumWithAmount = __esm({
  "src/cubing/alg/units/QuantumWithAmount.ts"() {
    init_iteration();
    init_limits();
    QuantumWithAmount = class {
      constructor(quantum, amount = 1) {
        this.quantum = quantum;
        this.amount = amount;
        if (!Number.isInteger(this.amount) || this.amount < MIN_INT || this.amount > MAX_INT) {
          throw new Error(`Unit amount absolute value must be a non-negative integer from ${MAX_INT_DESCRIPTION} to ${MAX_INT_DESCRIPTION}.`);
        }
      }
      suffix() {
        let s = "";
        const absAmount = Math.abs(this.amount);
        if (absAmount !== 1) {
          s += absAmount;
        }
        if (this.amount < 0) {
          s += "'";
        }
        return s;
      }
      isIdentical(other) {
        return this.quantum.isIdentical(other.quantum) && this.amount === other.amount;
      }
      *experimentalExpand(iterDir, depth) {
        const absAmount = Math.abs(this.amount);
        const newIterDir = toggleDirection(iterDir, this.amount < 0);
        for (let i2 = 0; i2 < absAmount; i2++) {
          yield* this.quantum.experimentalExpand(newIterDir, depth);
        }
      }
    };
  }
});

// src/cubing/alg/units/leaves/Move.ts
var _family, _innerLayer, _outerLayer, _QuantumMove, QuantumMove, _quantumWithAmount, _Move, Move;
var init_Move = __esm({
  "src/cubing/alg/units/leaves/Move.ts"() {
    init_common();
    init_iteration();
    init_limits();
    init_parse();
    init_warnOnce();
    init_QuantumWithAmount();
    _QuantumMove = class extends Comparable {
      constructor(family, innerLayer, outerLayer) {
        super();
        __privateAdd(this, _family, void 0);
        __privateAdd(this, _innerLayer, void 0);
        __privateAdd(this, _outerLayer, void 0);
        __privateSet(this, _family, family);
        __privateSet(this, _innerLayer, innerLayer ?? null);
        __privateSet(this, _outerLayer, outerLayer ?? null);
        Object.freeze(this);
        if (__privateGet(this, _innerLayer) !== null && (!Number.isInteger(__privateGet(this, _innerLayer)) || __privateGet(this, _innerLayer) < 1 || __privateGet(this, _innerLayer) > MAX_INT)) {
          throw new Error(`QuantumMove inner layer must be a positive integer below ${MAX_INT_DESCRIPTION}.`);
        }
        if (__privateGet(this, _outerLayer) !== null && (!Number.isInteger(__privateGet(this, _outerLayer)) || __privateGet(this, _outerLayer) < 1 || __privateGet(this, _outerLayer) > MAX_INT)) {
          throw new Error(`QuantumMove outer layer must be a positive integer below ${MAX_INT_DESCRIPTION}.`);
        }
        if (__privateGet(this, _outerLayer) !== null && __privateGet(this, _innerLayer) !== null && __privateGet(this, _innerLayer) <= __privateGet(this, _outerLayer)) {
          throw new Error("QuantumMove outer layer must be smaller than inner layer.");
        }
        if (__privateGet(this, _outerLayer) !== null && __privateGet(this, _innerLayer) === null) {
          throw new Error("QuantumMove with an outer layer must have an inner layer");
        }
      }
      static fromString(s) {
        return parseQuantumMove(s);
      }
      modified(modifications) {
        return new _QuantumMove(modifications.family ?? __privateGet(this, _family), modifications.innerLayer ?? __privateGet(this, _innerLayer), modifications.outerLayer ?? __privateGet(this, _outerLayer));
      }
      isIdentical(other) {
        const otherAsQuantumMove = other;
        return other.is(_QuantumMove) && __privateGet(this, _family) === __privateGet(otherAsQuantumMove, _family) && __privateGet(this, _innerLayer) === __privateGet(otherAsQuantumMove, _innerLayer) && __privateGet(this, _outerLayer) === __privateGet(otherAsQuantumMove, _outerLayer);
      }
      get family() {
        return __privateGet(this, _family);
      }
      get outerLayer() {
        return __privateGet(this, _outerLayer);
      }
      get innerLayer() {
        return __privateGet(this, _innerLayer);
      }
      experimentalExpand() {
        throw new Error("experimentalExpand() cannot be called on a `QuantumMove` directly.");
      }
      toString() {
        let s = __privateGet(this, _family);
        if (__privateGet(this, _innerLayer) !== null) {
          s = String(__privateGet(this, _innerLayer)) + s;
          if (__privateGet(this, _outerLayer) !== null) {
            s = String(__privateGet(this, _outerLayer)) + "-" + s;
          }
        }
        return s;
      }
    };
    QuantumMove = _QuantumMove;
    _family = new WeakMap();
    _innerLayer = new WeakMap();
    _outerLayer = new WeakMap();
    _Move = class extends AlgCommon {
      constructor(...args) {
        super();
        __privateAdd(this, _quantumWithAmount, void 0);
        if (typeof args[0] === "string") {
          if (args[1] ?? null) {
            __privateSet(this, _quantumWithAmount, new QuantumWithAmount(QuantumMove.fromString(args[0]), args[1]));
            return;
          } else {
            return _Move.fromString(args[0]);
          }
        }
        __privateSet(this, _quantumWithAmount, new QuantumWithAmount(args[0], args[1]));
      }
      isIdentical(other) {
        const otherAsMove = other.as(_Move);
        return !!otherAsMove && __privateGet(this, _quantumWithAmount).isIdentical(__privateGet(otherAsMove, _quantumWithAmount));
      }
      invert() {
        return transferCharIndex(this, new _Move(__privateGet(this, _quantumWithAmount).quantum, -this.amount));
      }
      *experimentalExpand(iterDir = 1 /* Forwards */) {
        if (iterDir === 1 /* Forwards */) {
          yield this;
        } else {
          yield this.modified({
            amount: -this.amount
          });
        }
      }
      get quantum() {
        return __privateGet(this, _quantumWithAmount).quantum;
      }
      modified(modifications) {
        return new _Move(__privateGet(this, _quantumWithAmount).quantum.modified(modifications), modifications.amount ?? this.amount);
      }
      static fromString(s) {
        return parseMove(s);
      }
      get amount() {
        return __privateGet(this, _quantumWithAmount).amount;
      }
      get type() {
        warnOnce("deprecated: type");
        return "blockMove";
      }
      get family() {
        return __privateGet(this, _quantumWithAmount).quantum.family ?? void 0;
      }
      get outerLayer() {
        return __privateGet(this, _quantumWithAmount).quantum.outerLayer ?? void 0;
      }
      get innerLayer() {
        return __privateGet(this, _quantumWithAmount).quantum.innerLayer ?? void 0;
      }
      toString() {
        if (this.family === "_SLASH_") {
          return "/";
        }
        if (this.family.endsWith("_PLUS_")) {
          return __privateGet(this, _quantumWithAmount).quantum.toString().slice(0, -6) + Math.abs(this.amount) + (this.amount < 0 ? "-" : "+");
        }
        if (this.family.endsWith("_PLUSPLUS_")) {
          const absAmount = Math.abs(this.amount);
          return __privateGet(this, _quantumWithAmount).quantum.toString().slice(0, -10) + (absAmount === 1 ? "" : absAmount) + (this.amount < 0 ? "--" : "++");
        }
        return __privateGet(this, _quantumWithAmount).quantum.toString() + __privateGet(this, _quantumWithAmount).suffix();
      }
    };
    Move = _Move;
    _quantumWithAmount = new WeakMap();
  }
});

// src/cubing/alg/units/containers/Grouping.ts
var Square1TupleFormatter, square1TupleFormatterInstance, _quantumWithAmount2, _Grouping, Grouping;
var init_Grouping = __esm({
  "src/cubing/alg/units/containers/Grouping.ts"() {
    init_Alg();
    init_common();
    init_iteration();
    init_Move();
    init_QuantumWithAmount();
    Square1TupleFormatter = class {
      constructor() {
        this.quantumU_SQ_ = null;
        this.quantumD_SQ_ = null;
      }
      format(grouping) {
        const amounts = this.tuple(grouping);
        if (!amounts) {
          return null;
        }
        return `(${amounts.map((move) => move.amount).join(", ")})`;
      }
      tuple(grouping) {
        this.quantumU_SQ_ || (this.quantumU_SQ_ = new QuantumMove("U_SQ_"));
        this.quantumD_SQ_ || (this.quantumD_SQ_ = new QuantumMove("D_SQ_"));
        const quantumAlg = grouping.alg;
        if (quantumAlg.experimentalNumUnits() === 2) {
          const [U, D] = quantumAlg.units();
          if (U.as(Move)?.quantum.isIdentical(this.quantumU_SQ_) && D.as(Move)?.quantum.isIdentical(this.quantumD_SQ_)) {
            if (grouping.amount !== 1) {
              throw new Error("Square-1 tuples cannot have an amount other than 1.");
            }
            return [U, D];
          }
        }
        return null;
      }
    };
    square1TupleFormatterInstance = new Square1TupleFormatter();
    _Grouping = class extends AlgCommon {
      constructor(algSource, amount) {
        super();
        __privateAdd(this, _quantumWithAmount2, void 0);
        const alg = experimentalEnsureAlg(algSource);
        __privateSet(this, _quantumWithAmount2, new QuantumWithAmount(alg, amount));
      }
      isIdentical(other) {
        const otherAsGrouping = other;
        return other.is(_Grouping) && __privateGet(this, _quantumWithAmount2).isIdentical(__privateGet(otherAsGrouping, _quantumWithAmount2));
      }
      get alg() {
        return __privateGet(this, _quantumWithAmount2).quantum;
      }
      get amount() {
        return __privateGet(this, _quantumWithAmount2).amount;
      }
      get experimentalRepetitionSuffix() {
        return __privateGet(this, _quantumWithAmount2).suffix();
      }
      invert() {
        return new _Grouping(__privateGet(this, _quantumWithAmount2).quantum, -__privateGet(this, _quantumWithAmount2).amount);
      }
      *experimentalExpand(iterDir = 1 /* Forwards */, depth) {
        depth ?? (depth = Infinity);
        if (depth === 0) {
          yield iterDir === 1 /* Forwards */ ? this : this.invert();
        } else {
          yield* __privateGet(this, _quantumWithAmount2).experimentalExpand(iterDir, depth - 1);
        }
      }
      static fromString() {
        throw new Error("unimplemented");
      }
      toString() {
        return square1TupleFormatterInstance.format(this) ?? `(${__privateGet(this, _quantumWithAmount2).quantum.toString()})${__privateGet(this, _quantumWithAmount2).suffix()}`;
      }
      experimentalAsSquare1Tuple() {
        return square1TupleFormatterInstance.tuple(this);
      }
    };
    Grouping = _Grouping;
    _quantumWithAmount2 = new WeakMap();
  }
});

// src/cubing/alg/units/index.ts
var init_units = __esm({
  "src/cubing/alg/units/index.ts"() {
    init_Grouping();
    init_LineComment();
    init_Commutator();
    init_Conjugate();
    init_Move();
    init_Newline();
    init_Pause();
  }
});

// src/cubing/alg/is.ts
function experimentalIs(v, c) {
  return v instanceof c;
}
function experimentalIsUnit(v) {
  return experimentalIs(v, Grouping) || experimentalIs(v, LineComment) || experimentalIs(v, Commutator) || experimentalIs(v, Conjugate) || experimentalIs(v, Move) || experimentalIs(v, Newline) || experimentalIs(v, Pause);
}
var init_is = __esm({
  "src/cubing/alg/is.ts"() {
    init_units();
  }
});

// src/cubing/alg/traversal.ts
function dispatch(t2, unit, dataDown) {
  if (unit.is(Grouping)) {
    return t2.traverseGrouping(unit, dataDown);
  }
  if (unit.is(Move)) {
    return t2.traverseMove(unit, dataDown);
  }
  if (unit.is(Commutator)) {
    return t2.traverseCommutator(unit, dataDown);
  }
  if (unit.is(Conjugate)) {
    return t2.traverseConjugate(unit, dataDown);
  }
  if (unit.is(Pause)) {
    return t2.traversePause(unit, dataDown);
  }
  if (unit.is(Newline)) {
    return t2.traverseNewline(unit, dataDown);
  }
  if (unit.is(LineComment)) {
    return t2.traverseLineComment(unit, dataDown);
  }
  throw new Error(`unknown unit`);
}
function assertIsUnit(t2) {
  if (t2.is(Grouping) || t2.is(Move) || t2.is(Commutator) || t2.is(Conjugate) || t2.is(Pause) || t2.is(Newline) || t2.is(LineComment)) {
    return t2;
  }
  throw "internal error: expected unit";
}
var TraversalDownUp, TraversalUp, _newAmount, newAmount_fn, _Simplify, Simplify, simplifyInstance, simplify;
var init_traversal = __esm({
  "src/cubing/alg/traversal.ts"() {
    init_Grouping();
    init_Commutator();
    init_Move();
    init_Newline();
    init_Pause();
    init_Conjugate();
    init_LineComment();
    TraversalDownUp = class {
      traverseUnit(unit, dataDown) {
        return dispatch(this, unit, dataDown);
      }
      traverseIntoUnit(unit, dataDown) {
        return assertIsUnit(this.traverseUnit(unit, dataDown));
      }
    };
    TraversalUp = class extends TraversalDownUp {
      traverseUnit(unit) {
        return dispatch(this, unit, void 0);
      }
      traverseIntoUnit(unit) {
        return assertIsUnit(this.traverseUnit(unit));
      }
    };
    _Simplify = class extends TraversalDownUp {
      *traverseAlg(alg, options) {
        if (options.depth === 0) {
          yield* alg.units();
          return;
        }
        const newUnits = [];
        let lastUnit = null;
        const collapseMoves = options?.collapseMoves ?? true;
        function appendMoveWithNewAmount(move, deltaAmount) {
          var _a;
          const newAmount = __privateMethod(_a = _Simplify, _newAmount, newAmount_fn).call(_a, move, deltaAmount, options);
          if (newAmount === 0) {
            return false;
          }
          const newMove = new Move(move.quantum, newAmount);
          newUnits.push(newMove);
          lastUnit = newMove;
          return true;
        }
        function appendCollapsed(newUnit) {
          if (collapseMoves && lastUnit?.is(Move) && newUnit.is(Move) && lastUnit.quantum.isIdentical(newUnit.quantum)) {
            newUnits.pop();
            if (!appendMoveWithNewAmount(lastUnit, newUnit.amount)) {
              lastUnit = newUnits.slice(-1)[0];
            }
          } else {
            if (newUnit.is(Move)) {
              appendMoveWithNewAmount(newUnit, 0);
            } else {
              newUnits.push(newUnit);
              lastUnit = newUnit;
            }
          }
        }
        const newOptions = {
          depth: options.depth ? options.depth - 1 : null
        };
        for (const unit of alg.units()) {
          for (const ancestorUnit of this.traverseUnit(unit, newOptions)) {
            appendCollapsed(ancestorUnit);
          }
        }
        for (const unit of newUnits) {
          yield unit;
        }
      }
      *traverseGrouping(grouping, options) {
        if (options.depth === 0) {
          yield grouping;
          return;
        }
        const newOptions = {
          depth: options.depth ? options.depth - 1 : null
        };
        yield new Grouping(this.traverseAlg(grouping.alg, newOptions));
      }
      *traverseMove(move, _options) {
        yield move;
      }
      *traverseCommutator(commutator, options) {
        if (options.depth === 0) {
          yield commutator;
          return;
        }
        const newOptions = {
          depth: options.depth ? options.depth - 1 : null
        };
        yield new Commutator(this.traverseAlg(commutator.A, newOptions), this.traverseAlg(commutator.B, newOptions));
      }
      *traverseConjugate(conjugate, options) {
        if (options.depth === 0) {
          yield conjugate;
          return;
        }
        const newOptions = {
          depth: options.depth ? options.depth - 1 : null
        };
        yield new Conjugate(this.traverseAlg(conjugate.A, newOptions), this.traverseAlg(conjugate.B, newOptions));
      }
      *traversePause(pause, _options) {
        yield pause;
      }
      *traverseNewline(newline, _options) {
        yield newline;
      }
      *traverseLineComment(comment, _options) {
        yield comment;
      }
    };
    Simplify = _Simplify;
    _newAmount = new WeakSet();
    newAmount_fn = function(move, deltaAmount, options) {
      let newAmount = move.amount + deltaAmount;
      if (options?.quantumMoveOrder) {
        const order = options.quantumMoveOrder(move.quantum);
        const min = Math.floor(order / 2) + 1 - order;
        newAmount = (newAmount % order + order - min) % order + min;
      }
      return newAmount;
    };
    __privateAdd(Simplify, _newAmount);
    simplifyInstance = new Simplify();
    simplify = simplifyInstance.traverseAlg.bind(simplifyInstance);
  }
});

// src/cubing/alg/Alg.ts
function toIterable(input) {
  if (!input) {
    return [];
  }
  if (experimentalIs(input, Alg)) {
    return input.units();
  }
  if (typeof input === "string") {
    return parseAlg(input).units();
  }
  const iter = input;
  if (typeof iter[Symbol.iterator] === "function") {
    return iter;
  }
  throw "Invalid unit";
}
function experimentalEnsureAlg(alg) {
  if (experimentalIs(alg, Alg)) {
    return alg;
  }
  return new Alg(alg);
}
function spaceBetween(u1, u2) {
  if (u1.is(Newline) || u2.is(Newline)) {
    return "";
  }
  if (u1.is(LineComment) && !u2.is(Newline)) {
    return "\n";
  }
  return " ";
}
var _units2, _Alg, Alg;
var init_Alg = __esm({
  "src/cubing/alg/Alg.ts"() {
    init_common();
    init_is();
    init_iteration();
    init_parse();
    init_traversal();
    init_LineComment();
    init_Move();
    init_Newline();
    init_warnOnce();
    _Alg = class extends AlgCommon {
      constructor(alg) {
        super();
        __privateAdd(this, _units2, void 0);
        __privateSet(this, _units2, Array.from(toIterable(alg)));
        for (const unit of __privateGet(this, _units2)) {
          if (!experimentalIsUnit(unit)) {
            throw new Error("An alg can only contain units.");
          }
        }
      }
      isIdentical(other) {
        const otherAsAlg = other;
        if (!other.is(_Alg)) {
          return false;
        }
        const l1 = Array.from(__privateGet(this, _units2));
        const l2 = Array.from(__privateGet(otherAsAlg, _units2));
        if (l1.length !== l2.length) {
          return false;
        }
        for (let i2 = 0; i2 < l1.length; i2++) {
          if (!l1[i2].isIdentical(l2[i2])) {
            return false;
          }
        }
        return true;
      }
      invert() {
        return new _Alg(reverse(Array.from(__privateGet(this, _units2)).map((u) => u.invert())));
      }
      *experimentalExpand(iterDir = 1 /* Forwards */, depth) {
        depth ?? (depth = Infinity);
        for (const unit of direct(__privateGet(this, _units2), iterDir)) {
          yield* unit.experimentalExpand(iterDir, depth);
        }
      }
      expand(options) {
        return new _Alg(this.experimentalExpand(1 /* Forwards */, options?.depth ?? Infinity));
      }
      *experimentalLeafMoves() {
        for (const leaf of this.experimentalExpand()) {
          if (leaf.is(Move)) {
            yield leaf;
          }
        }
      }
      concat(input) {
        return new _Alg(Array.from(__privateGet(this, _units2)).concat(Array.from(toIterable(input))));
      }
      experimentalIsEmpty() {
        for (const _ of __privateGet(this, _units2)) {
          return false;
        }
        return true;
      }
      static fromString(s) {
        return parseAlg(s);
      }
      *units() {
        for (const unit of __privateGet(this, _units2)) {
          yield unit;
        }
      }
      experimentalNumUnits() {
        return Array.from(__privateGet(this, _units2)).length;
      }
      get type() {
        warnOnce("deprecated: type");
        return "sequence";
      }
      toString() {
        let output = "";
        let previousUnit = null;
        for (const unit of __privateGet(this, _units2)) {
          if (previousUnit) {
            output += spaceBetween(previousUnit, unit);
          }
          output += unit.toString();
          previousUnit = unit;
        }
        return output;
      }
      simplify(options) {
        return new _Alg(simplify(this, options ?? {}));
      }
    };
    Alg = _Alg;
    _units2 = new WeakMap();
  }
});

// src/cubing/alg/example.ts
var Example;
var init_example = __esm({
  "src/cubing/alg/example.ts"() {
    init_Alg();
    init_units();
    init_Commutator();
    init_Conjugate();
    init_Move();
    init_Pause();
    Example = {
      Sune: new Alg([
        new Move("R", 1),
        new Move("U", 1),
        new Move("R", -1),
        new Move("U", 1),
        new Move("R", 1),
        new Move("U", -2),
        new Move("R", -1)
      ]),
      AntiSune: new Alg([
        new Move("R", 1),
        new Move("U", 2),
        new Move("R", -1),
        new Move("U", -1),
        new Move("R", 1),
        new Move("U", -1),
        new Move("R", -1)
      ]),
      SuneCommutator: new Alg([
        new Commutator(new Alg([new Move("R", 1), new Move("U", 1), new Move("R", -2)]), new Alg([
          new Conjugate(new Alg([new Move("R", 1)]), new Alg([new Move("U", 1)]))
        ]))
      ]),
      Niklas: new Alg([
        new Move("R", 1),
        new Move("U", -1),
        new Move("L", -1),
        new Move("U", 1),
        new Move("R", -1),
        new Move("U", -1),
        new Move("L", 1),
        new Move("U", 1)
      ]),
      EPerm: new Alg([
        new Move("x", -1),
        new Commutator(new Alg([
          new Conjugate(new Alg([new Move("R", 1)]), new Alg([new Move("U", -1)]))
        ]), new Alg([new Move("D", 1)])),
        new Commutator(new Alg([
          new Conjugate(new Alg([new Move("R", 1)]), new Alg([new Move("U", 1)]))
        ]), new Alg([new Move("D", 1)])),
        new Move("x", 1)
      ]),
      FURURFCompact: new Alg([
        new Conjugate(new Alg([new Move("F", 1)]), new Alg([
          new Commutator(new Alg([new Move("U", 1)]), new Alg([new Move("R", 1)]))
        ]))
      ]),
      APermCompact: new Alg([
        new Conjugate(new Alg([new Move("R", 2)]), new Alg([
          new Commutator(new Alg([new Move("F", 2)]), new Alg([new Move("R", -1), new Move("B", -1), new Move("R", 1)]))
        ]))
      ]),
      FURURFMoves: new Alg([
        new Move("F", 1),
        new Move("U", 1),
        new Move("R", 1),
        new Move("U", -1),
        new Move("R", -1),
        new Move("F", -1)
      ]),
      TPerm: new Alg([
        new Move("R", 1),
        new Move("U", 1),
        new Move("R", -1),
        new Move("U", -1),
        new Move("R", -1),
        new Move("F", 1),
        new Move("R", 2),
        new Move("U", -1),
        new Move("R", -1),
        new Move("U", -1),
        new Move("R", 1),
        new Move("U", 1),
        new Move("R", -1),
        new Move("F", -1)
      ]),
      HeadlightSwaps: new Alg([
        new Conjugate(new Alg([new Move("F", 1)]), new Alg([
          new Grouping(new Alg([
            new Commutator(new Alg([new Move("R", 1)]), new Alg([new Move("U", 1)]))
          ]), 3)
        ]))
      ]),
      TriplePause: new Alg([new Pause(), new Pause(), new Pause()])
    };
  }
});

// src/cubing/alg/keyboard.ts
var cubeKeyMapping;
var init_keyboard = __esm({
  "src/cubing/alg/keyboard.ts"() {
    init_Move();
    cubeKeyMapping = {
      73: new Move("R"),
      75: new Move("R'"),
      87: new Move("B"),
      79: new Move("B'"),
      83: new Move("D"),
      76: new Move("D'"),
      68: new Move("L"),
      69: new Move("L'"),
      74: new Move("U"),
      70: new Move("U'"),
      72: new Move("F"),
      71: new Move("F'"),
      78: new Move("x'"),
      67: new Move("l"),
      82: new Move("l'"),
      85: new Move("r"),
      77: new Move("r'"),
      88: new Move("d"),
      188: new Move("d'"),
      84: new Move("x"),
      89: new Move("x"),
      66: new Move("x'"),
      186: new Move("y"),
      59: new Move("y"),
      65: new Move("y'"),
      80: new Move("z"),
      81: new Move("z'"),
      90: new Move("M'"),
      190: new Move("M'")
    };
  }
});

// src/cubing/alg/url.ts
var init_url = __esm({
  "src/cubing/alg/url.ts"() {
  }
});

// src/cubing/alg/operation.ts
function experimentalAppendMove(alg, newMove, options) {
  const oldUnits = Array.from(alg.units());
  const oldLastMove = oldUnits[oldUnits.length - 1];
  if (options?.coalesce && oldLastMove && oldLastMove.quantum && oldLastMove.quantum.isIdentical(newMove.quantum)) {
    const newUnits = oldUnits.slice(0, oldUnits.length - 1);
    let newAmount = oldLastMove.amount + newMove.amount;
    const mod2 = options?.mod;
    if (mod2) {
      newAmount = (newAmount % mod2 + mod2) % mod2;
      if (newAmount * 2 > mod2) {
        newAmount -= mod2;
      }
    }
    if (newAmount !== 0) {
      newUnits.push(oldLastMove.modified({ amount: newAmount }));
    }
    return new Alg(newUnits);
  } else {
    return new Alg([...oldUnits, newMove]);
  }
}
var init_operation = __esm({
  "src/cubing/alg/operation.ts"() {
    init_Alg();
  }
});

// src/cubing/alg/index.ts
var init_alg = __esm({
  "src/cubing/alg/index.ts"() {
    init_Alg();
    init_AlgBuilder();
    init_traversal();
    init_example();
    init_keyboard();
    init_units();
    init_Move();
    init_url();
    init_operation();
    init_is();
    init_iteration();
  }
});

// src/cubing/kpuzzle/combine.ts
function combineTransformationData(definition, transformationData1, transformationData2) {
  const newTransformationData = {};
  for (const orbitName in definition.orbits) {
    const orbitDefinition = definition.orbits[orbitName];
    const orbit1 = transformationData1[orbitName];
    const orbit2 = transformationData2[orbitName];
    if (isOrbitTransformationDataIdentityUncached(orbitDefinition.numOrientations, orbit2)) {
      newTransformationData[orbitName] = orbit1;
    } else if (isOrbitTransformationDataIdentityUncached(orbitDefinition.numOrientations, orbit1)) {
      newTransformationData[orbitName] = orbit2;
    } else {
      const newPerm = new Array(orbitDefinition.numPieces);
      if (orbitDefinition.numOrientations === 1) {
        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {
          newPerm[idx] = orbit1.permutation[orbit2.permutation[idx]];
        }
        newTransformationData[orbitName] = {
          permutation: newPerm,
          orientation: orbit1.orientation
        };
      } else {
        const newOri = new Array(orbitDefinition.numPieces);
        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {
          newOri[idx] = (orbit1.orientation[orbit2.permutation[idx]] + orbit2.orientation[idx]) % orbitDefinition.numOrientations;
          newPerm[idx] = orbit1.permutation[orbit2.permutation[idx]];
        }
        newTransformationData[orbitName] = {
          permutation: newPerm,
          orientation: newOri
        };
      }
    }
  }
  return newTransformationData;
}
function applyTransformationDataToStateData(definition, stateData, transformationData) {
  const newStateData = {};
  for (const orbitName in definition.orbits) {
    const orbitDefinition = definition.orbits[orbitName];
    const orbit1 = stateData[orbitName];
    const orbit2 = transformationData[orbitName];
    if (isOrbitTransformationDataIdentityUncached(orbitDefinition.numOrientations, orbit2)) {
      newStateData[orbitName] = orbit1;
    } else {
      const newPieces = new Array(orbitDefinition.numPieces);
      if (orbitDefinition.numOrientations === 1) {
        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {
          newPieces[idx] = orbit1.pieces[orbit2.permutation[idx]];
        }
        newStateData[orbitName] = {
          pieces: newPieces,
          orientation: orbit1.orientation
        };
      } else {
        const newOri = new Array(orbitDefinition.numPieces);
        for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {
          newOri[idx] = (orbit1.orientation[orbit2.permutation[idx]] + orbit2.orientation[idx]) % orbitDefinition.numOrientations;
          newPieces[idx] = orbit1.pieces[orbit2.permutation[idx]];
        }
        newStateData[orbitName] = {
          pieces: newPieces,
          orientation: newOri
        };
      }
    }
  }
  return newStateData;
}
var init_combine = __esm({
  "src/cubing/kpuzzle/combine.ts"() {
    init_calculate();
  }
});

// src/cubing/kpuzzle/construct.ts
function constructIdentityOrbitTransformation(numPieces) {
  const cached = identityOrbitCache.get(numPieces);
  if (cached) {
    return cached;
  }
  const newPermutation = new Array(numPieces);
  const newOrientation = new Array(numPieces);
  for (let i2 = 0; i2 < numPieces; i2++) {
    newPermutation[i2] = i2;
    newOrientation[i2] = 0;
  }
  const orbitTransformation = {
    permutation: newPermutation,
    orientation: newOrientation
  };
  if (FREEZE) {
    Object.freeze(newPermutation);
    Object.freeze(newOrientation);
    Object.freeze(orbitTransformation);
  }
  identityOrbitCache.set(numPieces, orbitTransformation);
  return orbitTransformation;
}
function constructIdentityTransformationDataUncached(definition) {
  const transformation = {};
  for (const [orbitName, orbitDefinition] of Object.entries(definition.orbits)) {
    transformation[orbitName] = constructIdentityOrbitTransformation(orbitDefinition.numPieces);
  }
  if (FREEZE) {
    Object.freeze(transformation);
  }
  return transformation;
}
function moveToTransformationUncached(kpuzzle, move) {
  const quantumKey = move.quantum.toString();
  let quantumMoveDefinition = kpuzzle.definition.moves[quantumKey];
  if (!quantumMoveDefinition) {
    const derivedFrom = kpuzzle.definition.experimentalDerivedMoves?.[quantumKey];
    if (derivedFrom) {
      quantumMoveDefinition = kpuzzle.algToTransformation(derivedFrom).transformationData;
    }
  }
  if (quantumMoveDefinition) {
    return repeatTransformationUncached(kpuzzle, quantumMoveDefinition, move.amount);
  }
  const moveDefinition = kpuzzle.definition.moves[move.toString()];
  if (moveDefinition) {
    return moveDefinition;
  }
  const inverseMoveDefinition = kpuzzle.definition.moves[move.invert().toString()];
  if (inverseMoveDefinition) {
    return repeatTransformationUncached(kpuzzle, inverseMoveDefinition, -1);
  }
  throw new Error(`Invalid move for KPuzzle (${kpuzzle.name()}): ${move}`);
}
var FREEZE, identityOrbitCache;
var init_construct = __esm({
  "src/cubing/kpuzzle/construct.ts"() {
    init_calculate();
    FREEZE = false;
    identityOrbitCache = /* @__PURE__ */ new Map();
  }
});

// src/cubing/protocol/binary/orbit-indexing.ts
var init_orbit_indexing = __esm({
  "src/cubing/protocol/binary/orbit-indexing.ts"() {
  }
});

// src/cubing/protocol/binary/puzzle-orientation.ts
function puzzleOrientationIdx(state) {
  const idxU = state.stateData["CENTERS"].pieces[0];
  const idxD = state.stateData["CENTERS"].pieces[5];
  const unadjustedIdxL = state.stateData["CENTERS"].pieces[1];
  let idxL = unadjustedIdxL;
  if (idxU < unadjustedIdxL) {
    idxL--;
  }
  if (idxD < unadjustedIdxL) {
    idxL--;
  }
  return [idxU, idxL];
}
function puzzleOrientationCache() {
  if (!puzzleOrientationCacheInitialized) {
    {
      const uAlgs = ["", "z", "x", "z'", "x'", "x2"].map((s) => Alg.fromString(s));
      const yAlg = new Alg("y");
      for (const uAlg of uAlgs) {
        let transformation = experimental3x3x3KPuzzle.algToTransformation(uAlg);
        for (let i2 = 0; i2 < 4; i2++) {
          transformation = transformation.applyAlg(yAlg);
          const [idxU, idxL] = puzzleOrientationIdx(transformation.toKState());
          puzzleOrientationCacheRaw[idxU][idxL] = transformation.invert();
        }
      }
    }
  }
  return puzzleOrientationCacheRaw;
}
function normalizePuzzleOrientation(state) {
  const [idxU, idxL] = puzzleOrientationIdx(state);
  const orientationTransformation = puzzleOrientationCache()[idxU][idxL];
  return state.applyTransformation(orientationTransformation);
}
var puzzleOrientationCacheRaw, puzzleOrientationCacheInitialized;
var init_puzzle_orientation = __esm({
  "src/cubing/protocol/binary/puzzle-orientation.ts"() {
    init_alg();
    init_kpuzzle();
    puzzleOrientationCacheRaw = new Array(6).fill(0).map(() => {
      return new Array(6);
    });
    puzzleOrientationCacheInitialized = false;
  }
});

// src/cubing/protocol/binary/binary3x3x3.ts
var init_binary3x3x3 = __esm({
  "src/cubing/protocol/binary/binary3x3x3.ts"() {
    init_kpuzzle();
    init_orbit_indexing();
    init_puzzle_orientation();
  }
});

// src/cubing/protocol/binary/hex.ts
var init_hex = __esm({
  "src/cubing/protocol/binary/hex.ts"() {
  }
});

// src/cubing/protocol/index.ts
var init_protocol = __esm({
  "src/cubing/protocol/index.ts"() {
    init_binary3x3x3();
    init_hex();
    init_puzzle_orientation();
    init_binary3x3x3();
  }
});

// src/cubing/kpuzzle/3x3x3/puzzle-orientation.ts
function experimentalIs3x3x3Solved(state, options) {
  if (options.ignorePuzzleOrientation) {
    state = normalizePuzzleOrientation(state);
  }
  if (options.ignoreCenterOrientation) {
    state = new KState(state.kpuzzle, {
      EDGES: state.stateData.EDGES,
      CORNERS: state.stateData.CORNERS,
      CENTERS: {
        pieces: state.stateData.CENTERS.pieces,
        orientation: new Array(6).fill(0)
      }
    });
  }
  return !!state.experimentalToTransformation()?.isIdentityTransformation();
}
var init_puzzle_orientation2 = __esm({
  "src/cubing/kpuzzle/3x3x3/puzzle-orientation.ts"() {
    init_protocol();
    init_KState();
  }
});

// src/cubing/kpuzzle/KState.ts
var KState;
var init_KState = __esm({
  "src/cubing/kpuzzle/KState.ts"() {
    init_puzzle_orientation2();
    init_combine();
    init_KTransformation();
    KState = class {
      constructor(kpuzzle, stateData) {
        this.kpuzzle = kpuzzle;
        this.stateData = stateData;
      }
      toJSON() {
        return {
          experimentalPuzzleName: this.kpuzzle.name(),
          stateData: this.stateData
        };
      }
      static fromTransformation(transformation) {
        const newStateData = applyTransformationDataToStateData(transformation.kpuzzle.definition, transformation.kpuzzle.definition.startStateData, transformation.transformationData);
        return new KState(transformation.kpuzzle, newStateData);
      }
      apply(source) {
        return this.applyTransformation(this.kpuzzle.toTransformation(source));
      }
      applyTransformation(transformation) {
        if (transformation.isIdentityTransformation()) {
          return new KState(this.kpuzzle, this.stateData);
        }
        const newStateData = applyTransformationDataToStateData(this.kpuzzle.definition, this.stateData, transformation.transformationData);
        return new KState(this.kpuzzle, newStateData);
      }
      applyMove(move) {
        return this.applyTransformation(this.kpuzzle.moveToTransformation(move));
      }
      applyAlg(alg) {
        return this.applyTransformation(this.kpuzzle.algToTransformation(alg));
      }
      experimentalToTransformation() {
        if (!this.kpuzzle.canConvertStateToUniqueTransformation()) {
          return null;
        }
        const transformationData = {};
        for (const [orbitName, stateOrbitData] of Object.entries(this.stateData)) {
          const transformationOrbit = {
            permutation: stateOrbitData.pieces,
            orientation: stateOrbitData.orientation
          };
          transformationData[orbitName] = transformationOrbit;
        }
        return new KTransformation2(this.kpuzzle, transformationData);
      }
      experimentalIs3x3x3Solved(options) {
        if (this.kpuzzle.name() !== "3x3x3") {
          throw new Error("`KState.experimentalIs3x3x3Solved()` only supports 3x3x3 states.");
        }
        return experimentalIs3x3x3Solved(this, options);
      }
    };
  }
});

// src/cubing/kpuzzle/KTransformation.ts
var _cachedIsIdentity, _KTransformation, KTransformation2;
var init_KTransformation = __esm({
  "src/cubing/kpuzzle/KTransformation.ts"() {
    init_calculate();
    init_combine();
    init_construct();
    init_KState();
    _KTransformation = class {
      constructor(kpuzzle, transformationData) {
        this.kpuzzle = kpuzzle;
        this.transformationData = transformationData;
        __privateAdd(this, _cachedIsIdentity, void 0);
      }
      toJSON() {
        return {
          experimentalPuzzleName: this.kpuzzle.name(),
          transformationData: this.transformationData
        };
      }
      invert() {
        return new _KTransformation(this.kpuzzle, invertTransformation(this.kpuzzle, this.transformationData));
      }
      isIdentityTransformation() {
        return __privateGet(this, _cachedIsIdentity) ?? __privateSet(this, _cachedIsIdentity, this.isIdentical(this.kpuzzle.identityTransformation()));
      }
      static experimentalConstructIdentity(kpuzzle) {
        const transformation = new _KTransformation(kpuzzle, constructIdentityTransformationDataUncached(kpuzzle.definition));
        __privateSet(transformation, _cachedIsIdentity, true);
        return transformation;
      }
      isIdentical(t2) {
        return isTransformationDataIdentical(this.kpuzzle, this.transformationData, t2.transformationData);
      }
      apply(source) {
        return this.applyTransformation(this.kpuzzle.toTransformation(source));
      }
      applyTransformation(t2) {
        if (this.kpuzzle !== t2.kpuzzle) {
          throw new Error(`Tried to apply a transformation for a KPuzzle (${t2.kpuzzle.name()}) to a different KPuzzle (${this.kpuzzle.name()}).`);
        }
        if (__privateGet(this, _cachedIsIdentity)) {
          return new _KTransformation(this.kpuzzle, t2.transformationData);
        }
        if (__privateGet(t2, _cachedIsIdentity)) {
          return new _KTransformation(this.kpuzzle, this.transformationData);
        }
        return new _KTransformation(this.kpuzzle, combineTransformationData(this.kpuzzle.definition, this.transformationData, t2.transformationData));
      }
      applyMove(move) {
        return this.applyTransformation(this.kpuzzle.moveToTransformation(move));
      }
      applyAlg(alg) {
        return this.applyTransformation(this.kpuzzle.algToTransformation(alg));
      }
      toKState() {
        return KState.fromTransformation(this);
      }
      repetitionOrder() {
        return transformationRepetitionOrder(this.kpuzzle.definition, this);
      }
      selfMultiply(amount) {
        return new _KTransformation(this.kpuzzle, repeatTransformationUncached(this.kpuzzle, this.transformationData, amount));
      }
    };
    KTransformation2 = _KTransformation;
    _cachedIsIdentity = new WeakMap();
  }
});

// src/cubing/kpuzzle/calculate.ts
function isOrbitTransformationDataIdentityUncached(numOrientations, orbitTransformationData) {
  const { permutation } = orbitTransformationData;
  const numPieces = permutation.length;
  for (let idx = 0; idx < numPieces; idx++) {
    if (permutation[idx] !== idx) {
      return false;
    }
  }
  if (numOrientations > 1) {
    const { orientation } = orbitTransformationData;
    for (let idx = 0; idx < numPieces; idx++) {
      if (orientation[idx] !== 0) {
        return false;
      }
    }
  }
  return true;
}
function isOrbitTransformationDataIdentical(orbitDefinition, orbitTransformationData1, orbitTransformationData2, options = {}) {
  for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {
    if (!options?.ignoreOrientation && orbitTransformationData1.orientation[idx] !== orbitTransformationData2.orientation[idx]) {
      return false;
    }
    if (!options?.ignorePermutation && orbitTransformationData1.permutation[idx] !== orbitTransformationData2.permutation[idx]) {
      return false;
    }
  }
  return true;
}
function isTransformationDataIdentical(kpuzzle, transformationData1, transformationData2) {
  for (const [orbitName, orbitDefinition] of Object.entries(kpuzzle.definition.orbits)) {
    if (!isOrbitTransformationDataIdentical(orbitDefinition, transformationData1[orbitName], transformationData2[orbitName])) {
      return false;
    }
  }
  return true;
}
function invertTransformation(kpuzzle, transformationData) {
  const newTransformationData = {};
  for (const orbitName in kpuzzle.definition.orbits) {
    const orbitDefinition = kpuzzle.definition.orbits[orbitName];
    const orbitTransformationData = transformationData[orbitName];
    if (isOrbitTransformationDataIdentityUncached(orbitDefinition.numOrientations, orbitTransformationData)) {
      newTransformationData[orbitName] = orbitTransformationData;
    } else if (orbitDefinition.numOrientations === 1) {
      const newPerm = new Array(orbitDefinition.numPieces);
      for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {
        newPerm[orbitTransformationData.permutation[idx]] = idx;
      }
      newTransformationData[orbitName] = {
        permutation: newPerm,
        orientation: orbitTransformationData.orientation
      };
    } else {
      const newPerm = new Array(orbitDefinition.numPieces);
      const newOri = new Array(orbitDefinition.numPieces);
      for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {
        const fromIdx = orbitTransformationData.permutation[idx];
        newPerm[fromIdx] = idx;
        newOri[fromIdx] = (orbitDefinition.numOrientations - orbitTransformationData.orientation[idx] + orbitDefinition.numOrientations) % orbitDefinition.numOrientations;
      }
      newTransformationData[orbitName] = {
        permutation: newPerm,
        orientation: newOri
      };
    }
  }
  return newTransformationData;
}
function repeatTransformationUncached(kpuzzle, transformationData, amount) {
  if (amount === 1) {
    return transformationData;
  }
  if (amount < 0) {
    return repeatTransformationUncached(kpuzzle, invertTransformation(kpuzzle, transformationData), -amount);
  }
  if (amount === 0) {
    const { transformationData: transformationData2 } = kpuzzle.identityTransformation();
    return transformationData2;
  }
  let halfish = transformationData;
  if (amount !== 2) {
    halfish = repeatTransformationUncached(kpuzzle, transformationData, Math.floor(amount / 2));
  }
  const twiceHalfish = combineTransformationData(kpuzzle.definition, halfish, halfish);
  if (amount % 2 === 0) {
    return twiceHalfish;
  } else {
    return combineTransformationData(kpuzzle.definition, transformationData, twiceHalfish);
  }
}
function gcd(a, b2) {
  if (b2) {
    return gcd(b2, a % b2);
  }
  return a;
}
function transformationRepetitionOrder(definition, transformation) {
  let order = 1;
  for (const orbitName in definition.orbits) {
    const orbitDefinition = definition.orbits[orbitName];
    const transformationOrbit = transformation.transformationData[orbitName];
    const orbitPieces = new Array(orbitDefinition.numPieces);
    for (let startIdx = 0; startIdx < orbitDefinition.numPieces; startIdx++) {
      if (!orbitPieces[startIdx]) {
        let currentIdx = startIdx;
        let orientationSum = 0;
        let cycleLength = 0;
        for (; ; ) {
          orbitPieces[currentIdx] = true;
          orientationSum = orientationSum + transformationOrbit.orientation[currentIdx];
          cycleLength = cycleLength + 1;
          currentIdx = transformationOrbit.permutation[currentIdx];
          if (currentIdx === startIdx) {
            break;
          }
        }
        if (orientationSum !== 0) {
          cycleLength = cycleLength * orbitDefinition.numOrientations / gcd(orbitDefinition.numOrientations, orientationSum);
        }
        order = order * cycleLength / gcd(order, cycleLength);
      }
    }
  }
  return order;
}
var AlgToTransformationTraversal, algToTransformationInstance, algToTransformation;
var init_calculate = __esm({
  "src/cubing/kpuzzle/calculate.ts"() {
    init_alg();
    init_combine();
    init_KTransformation();
    AlgToTransformationTraversal = class extends TraversalDownUp {
      traverseAlg(alg, kpuzzle) {
        let transformation = null;
        for (const unit of alg.units()) {
          if (transformation) {
            transformation = transformation.applyTransformation(this.traverseUnit(unit, kpuzzle));
          } else {
            transformation = this.traverseUnit(unit, kpuzzle);
          }
        }
        return transformation ?? kpuzzle.identityTransformation();
      }
      traverseGrouping(grouping, kpuzzle) {
        const algTransformation = this.traverseAlg(grouping.alg, kpuzzle);
        return new KTransformation2(kpuzzle, repeatTransformationUncached(kpuzzle, algTransformation.transformationData, grouping.amount));
      }
      traverseMove(move, kpuzzle) {
        return kpuzzle.moveToTransformation(move);
      }
      traverseCommutator(commutator, kpuzzle) {
        const aTransformation = this.traverseAlg(commutator.A, kpuzzle);
        const bTransformation = this.traverseAlg(commutator.B, kpuzzle);
        return aTransformation.applyTransformation(bTransformation).applyTransformation(aTransformation.invert()).applyTransformation(bTransformation.invert());
      }
      traverseConjugate(conjugate, kpuzzle) {
        const aTransformation = this.traverseAlg(conjugate.A, kpuzzle);
        const bTransformation = this.traverseAlg(conjugate.B, kpuzzle);
        return aTransformation.applyTransformation(bTransformation).applyTransformation(aTransformation.invert());
      }
      traversePause(_, kpuzzle) {
        return kpuzzle.identityTransformation();
      }
      traverseNewline(_, kpuzzle) {
        return kpuzzle.identityTransformation();
      }
      traverseLineComment(_, kpuzzle) {
        return kpuzzle.identityTransformation();
      }
    };
    algToTransformationInstance = new AlgToTransformationTraversal();
    algToTransformation = algToTransformationInstance.traverseAlg.bind(algToTransformationInstance);
  }
});

// src/cubing/kpuzzle/KPuzzle.ts
var _moveToTransformationDataCache, _cachedCanConvertStateToUniqueTransformation, KPuzzle;
var init_KPuzzle = __esm({
  "src/cubing/kpuzzle/KPuzzle.ts"() {
    init_alg();
    init_calculate();
    init_construct();
    init_KState();
    init_KTransformation();
    KPuzzle = class {
      constructor(definition, options) {
        this.definition = definition;
        __privateAdd(this, _moveToTransformationDataCache, /* @__PURE__ */ new Map());
        __privateAdd(this, _cachedCanConvertStateToUniqueTransformation, void 0);
        this.experimentalPGNotation = options?.experimentalPGNotation;
      }
      name() {
        return this.definition.name;
      }
      identityTransformation() {
        return KTransformation2.experimentalConstructIdentity(this);
      }
      moveToTransformation(move) {
        if (typeof move === "string") {
          move = new Move(move);
        }
        const cacheKey = move.toString();
        const cachedTransformationData = __privateGet(this, _moveToTransformationDataCache).get(cacheKey);
        if (cachedTransformationData) {
          return new KTransformation2(this, cachedTransformationData);
        }
        if (this.experimentalPGNotation) {
          const transformationData2 = this.experimentalPGNotation.lookupMove(move);
          if (!transformationData2) {
            throw new Error(`could not map to internal move: ${move}`);
          }
          __privateGet(this, _moveToTransformationDataCache).set(cacheKey, transformationData2);
          return new KTransformation2(this, transformationData2);
        }
        const transformationData = moveToTransformationUncached(this, move);
        __privateGet(this, _moveToTransformationDataCache).set(cacheKey, transformationData);
        return new KTransformation2(this, transformationData);
      }
      algToTransformation(alg) {
        if (typeof alg === "string") {
          alg = new Alg(alg);
        }
        return algToTransformation(alg, this);
      }
      toTransformation(source) {
        if (typeof source === "string") {
          return this.algToTransformation(source);
        } else if (source?.is?.(Alg)) {
          return this.algToTransformation(source);
        } else if (source?.is?.(Move)) {
          return this.moveToTransformation(source);
        } else {
          return source;
        }
      }
      startState() {
        return new KState(this, this.definition.startStateData);
      }
      canConvertStateToUniqueTransformation() {
        return __privateGet(this, _cachedCanConvertStateToUniqueTransformation) ?? __privateSet(this, _cachedCanConvertStateToUniqueTransformation, (() => {
          for (const [orbitName, orbitDefinition] of Object.entries(this.definition.orbits)) {
            const pieces = new Array(orbitDefinition.numPieces).fill(false);
            for (const piece of this.definition.startStateData[orbitName].pieces) {
              pieces[piece] = true;
            }
            for (const piece of pieces) {
              if (!piece) {
                return false;
              }
            }
          }
          return true;
        })());
      }
      get state() {
        throw new Error("KPuzzle is now a different (stateless) class.");
      }
      reset() {
        throw new Error("KPuzzle is now a different (stateless) class.");
      }
      applyMove(_move) {
        throw new Error("KPuzzle is now a different class. Try `.moveToTransformation()` to get the transformation for a move.");
      }
      applyAlg(_alg) {
        throw new Error("KPuzzle is now a different class. Try `.algToTransformation()` to get the transformation for an alg.");
      }
    };
    _moveToTransformationDataCache = new WeakMap();
    _cachedCanConvertStateToUniqueTransformation = new WeakMap();
  }
});

// src/cubing/kpuzzle/3x3x3/3x3x3.kpuzzle.json.ts
var cube3x3x3KPuzzleDefinition;
var init_x3x3_kpuzzle_json = __esm({
  "src/cubing/kpuzzle/3x3x3/3x3x3.kpuzzle.json.ts"() {
    cube3x3x3KPuzzleDefinition = {
      name: "3x3x3",
      orbits: {
        EDGES: { numPieces: 12, numOrientations: 2 },
        CORNERS: { numPieces: 8, numOrientations: 3 },
        CENTERS: { numPieces: 6, numOrientations: 4 }
      },
      startStateData: {
        EDGES: {
          pieces: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
          orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        },
        CORNERS: {
          pieces: [0, 1, 2, 3, 4, 5, 6, 7],
          orientation: [0, 0, 0, 0, 0, 0, 0, 0]
        },
        CENTERS: {
          pieces: [0, 1, 2, 3, 4, 5],
          orientation: [0, 0, 0, 0, 0, 0]
        }
      },
      moves: {
        U: {
          EDGES: {
            permutation: [1, 2, 3, 0, 4, 5, 6, 7, 8, 9, 10, 11],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
          },
          CORNERS: {
            permutation: [1, 2, 3, 0, 4, 5, 6, 7],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0]
          },
          CENTERS: {
            permutation: [0, 1, 2, 3, 4, 5],
            orientation: [1, 0, 0, 0, 0, 0]
          }
        },
        y: {
          EDGES: {
            permutation: [1, 2, 3, 0, 5, 6, 7, 4, 10, 8, 11, 9],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1]
          },
          CORNERS: {
            permutation: [1, 2, 3, 0, 7, 4, 5, 6],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0]
          },
          CENTERS: {
            permutation: [0, 2, 3, 4, 1, 5],
            orientation: [1, 0, 0, 0, 0, 3]
          }
        },
        x: {
          EDGES: {
            permutation: [4, 8, 0, 9, 6, 10, 2, 11, 5, 7, 1, 3],
            orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0]
          },
          CORNERS: {
            permutation: [4, 0, 3, 5, 7, 6, 2, 1],
            orientation: [2, 1, 2, 1, 1, 2, 1, 2]
          },
          CENTERS: {
            permutation: [2, 1, 5, 3, 0, 4],
            orientation: [0, 3, 0, 1, 2, 2]
          }
        },
        L: {
          EDGES: {
            permutation: [0, 1, 2, 11, 4, 5, 6, 9, 8, 3, 10, 7],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
          },
          CORNERS: {
            permutation: [0, 1, 6, 2, 4, 3, 5, 7],
            orientation: [0, 0, 2, 1, 0, 2, 1, 0]
          },
          CENTERS: {
            permutation: [0, 1, 2, 3, 4, 5],
            orientation: [0, 1, 0, 0, 0, 0]
          }
        },
        F: {
          EDGES: {
            permutation: [9, 1, 2, 3, 8, 5, 6, 7, 0, 4, 10, 11],
            orientation: [1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0]
          },
          CORNERS: {
            permutation: [3, 1, 2, 5, 0, 4, 6, 7],
            orientation: [1, 0, 0, 2, 2, 1, 0, 0]
          },
          CENTERS: {
            permutation: [0, 1, 2, 3, 4, 5],
            orientation: [0, 0, 1, 0, 0, 0]
          }
        },
        R: {
          EDGES: {
            permutation: [0, 8, 2, 3, 4, 10, 6, 7, 5, 9, 1, 11],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
          },
          CORNERS: {
            permutation: [4, 0, 2, 3, 7, 5, 6, 1],
            orientation: [2, 1, 0, 0, 1, 0, 0, 2]
          },
          CENTERS: {
            permutation: [0, 1, 2, 3, 4, 5],
            orientation: [0, 0, 0, 1, 0, 0]
          }
        },
        B: {
          EDGES: {
            permutation: [0, 1, 10, 3, 4, 5, 11, 7, 8, 9, 6, 2],
            orientation: [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1]
          },
          CORNERS: {
            permutation: [0, 7, 1, 3, 4, 5, 2, 6],
            orientation: [0, 2, 1, 0, 0, 0, 2, 1]
          },
          CENTERS: {
            permutation: [0, 1, 2, 3, 4, 5],
            orientation: [0, 0, 0, 0, 1, 0]
          }
        },
        D: {
          EDGES: {
            permutation: [0, 1, 2, 3, 7, 4, 5, 6, 8, 9, 10, 11],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
          },
          CORNERS: {
            permutation: [0, 1, 2, 3, 5, 6, 7, 4],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0]
          },
          CENTERS: {
            permutation: [0, 1, 2, 3, 4, 5],
            orientation: [0, 0, 0, 0, 0, 1]
          }
        },
        z: {
          EDGES: {
            permutation: [9, 3, 11, 7, 8, 1, 10, 5, 0, 4, 2, 6],
            orientation: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
          },
          CORNERS: {
            permutation: [3, 2, 6, 5, 0, 4, 7, 1],
            orientation: [1, 2, 1, 2, 2, 1, 2, 1]
          },
          CENTERS: {
            permutation: [1, 5, 2, 0, 4, 3],
            orientation: [1, 1, 1, 1, 3, 1]
          }
        },
        M: {
          EDGES: {
            permutation: [2, 1, 6, 3, 0, 5, 4, 7, 8, 9, 10, 11],
            orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0]
          },
          CORNERS: {
            permutation: [0, 1, 2, 3, 4, 5, 6, 7],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0]
          },
          CENTERS: {
            permutation: [4, 1, 0, 3, 5, 2],
            orientation: [2, 0, 0, 0, 2, 0]
          }
        },
        E: {
          EDGES: {
            permutation: [0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 8, 10],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1]
          },
          CORNERS: {
            permutation: [0, 1, 2, 3, 4, 5, 6, 7],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0]
          },
          CENTERS: {
            permutation: [0, 4, 1, 2, 3, 5],
            orientation: [0, 0, 0, 0, 0, 0]
          }
        },
        S: {
          EDGES: {
            permutation: [0, 3, 2, 7, 4, 1, 6, 5, 8, 9, 10, 11],
            orientation: [0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0]
          },
          CORNERS: {
            permutation: [0, 1, 2, 3, 4, 5, 6, 7],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0]
          },
          CENTERS: {
            permutation: [1, 5, 2, 0, 4, 3],
            orientation: [1, 1, 0, 1, 0, 1]
          }
        },
        u: {
          EDGES: {
            permutation: [1, 2, 3, 0, 4, 5, 6, 7, 10, 8, 11, 9],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1]
          },
          CORNERS: {
            permutation: [1, 2, 3, 0, 4, 5, 6, 7],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0]
          },
          CENTERS: {
            permutation: [0, 2, 3, 4, 1, 5],
            orientation: [1, 0, 0, 0, 0, 0]
          }
        },
        l: {
          EDGES: {
            permutation: [2, 1, 6, 11, 0, 5, 4, 9, 8, 3, 10, 7],
            orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0]
          },
          CORNERS: {
            permutation: [0, 1, 6, 2, 4, 3, 5, 7],
            orientation: [0, 0, 2, 1, 0, 2, 1, 0]
          },
          CENTERS: {
            permutation: [4, 1, 0, 3, 5, 2],
            orientation: [2, 1, 0, 0, 2, 0]
          }
        },
        f: {
          EDGES: {
            permutation: [9, 3, 2, 7, 8, 1, 6, 5, 0, 4, 10, 11],
            orientation: [1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0]
          },
          CORNERS: {
            permutation: [3, 1, 2, 5, 0, 4, 6, 7],
            orientation: [1, 0, 0, 2, 2, 1, 0, 0]
          },
          CENTERS: {
            permutation: [1, 5, 2, 0, 4, 3],
            orientation: [1, 1, 1, 1, 0, 1]
          }
        },
        r: {
          EDGES: {
            permutation: [4, 8, 0, 3, 6, 10, 2, 7, 5, 9, 1, 11],
            orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0]
          },
          CORNERS: {
            permutation: [4, 0, 2, 3, 7, 5, 6, 1],
            orientation: [2, 1, 0, 0, 1, 0, 0, 2]
          },
          CENTERS: {
            permutation: [2, 1, 5, 3, 0, 4],
            orientation: [0, 0, 0, 1, 2, 2]
          }
        },
        b: {
          EDGES: {
            permutation: [0, 5, 10, 1, 4, 7, 11, 3, 8, 9, 6, 2],
            orientation: [0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1]
          },
          CORNERS: {
            permutation: [0, 7, 1, 3, 4, 5, 2, 6],
            orientation: [0, 2, 1, 0, 0, 0, 2, 1]
          },
          CENTERS: {
            permutation: [3, 0, 2, 5, 4, 1],
            orientation: [3, 3, 0, 3, 1, 3]
          }
        },
        d: {
          EDGES: {
            permutation: [0, 1, 2, 3, 7, 4, 5, 6, 9, 11, 8, 10],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1]
          },
          CORNERS: {
            permutation: [0, 1, 2, 3, 5, 6, 7, 4],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0]
          },
          CENTERS: {
            permutation: [0, 4, 1, 2, 3, 5],
            orientation: [0, 0, 0, 0, 0, 1]
          }
        }
      }
    };
    cube3x3x3KPuzzleDefinition.moves["Uw"] = cube3x3x3KPuzzleDefinition.moves["u"];
    cube3x3x3KPuzzleDefinition.moves["Lw"] = cube3x3x3KPuzzleDefinition.moves["l"];
    cube3x3x3KPuzzleDefinition.moves["Fw"] = cube3x3x3KPuzzleDefinition.moves["f"];
    cube3x3x3KPuzzleDefinition.moves["Rw"] = cube3x3x3KPuzzleDefinition.moves["r"];
    cube3x3x3KPuzzleDefinition.moves["Bw"] = cube3x3x3KPuzzleDefinition.moves["b"];
    cube3x3x3KPuzzleDefinition.moves["Dw"] = cube3x3x3KPuzzleDefinition.moves["d"];
    cube3x3x3KPuzzleDefinition.moves["Rv"] = cube3x3x3KPuzzleDefinition.moves["x"];
    cube3x3x3KPuzzleDefinition.moves["Uv"] = cube3x3x3KPuzzleDefinition.moves["y"];
    cube3x3x3KPuzzleDefinition.moves["Fv"] = cube3x3x3KPuzzleDefinition.moves["z"];
    cube3x3x3KPuzzleDefinition.moves["Lv"] = {
      EDGES: {
        permutation: [2, 10, 6, 11, 0, 8, 4, 9, 1, 3, 5, 7],
        orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0]
      },
      CORNERS: {
        permutation: [1, 7, 6, 2, 0, 3, 5, 4],
        orientation: [2, 1, 2, 1, 1, 2, 1, 2]
      },
      CENTERS: {
        permutation: [4, 1, 0, 3, 5, 2],
        orientation: [2, 1, 0, 3, 2, 0]
      }
    };
    cube3x3x3KPuzzleDefinition.moves["Dv"] = {
      EDGES: {
        permutation: [3, 0, 1, 2, 7, 4, 5, 6, 9, 11, 8, 10],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1]
      },
      CORNERS: {
        permutation: [3, 0, 1, 2, 5, 6, 7, 4],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0]
      },
      CENTERS: {
        permutation: [0, 4, 1, 2, 3, 5],
        orientation: [3, 0, 0, 0, 0, 1]
      }
    };
    cube3x3x3KPuzzleDefinition.moves["Bv"] = {
      EDGES: {
        permutation: [8, 5, 10, 1, 9, 7, 11, 3, 4, 0, 6, 2],
        orientation: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
      },
      CORNERS: {
        permutation: [4, 7, 1, 0, 5, 3, 2, 6],
        orientation: [1, 2, 1, 2, 2, 1, 2, 1]
      },
      CENTERS: {
        permutation: [3, 0, 2, 5, 4, 1],
        orientation: [3, 3, 3, 3, 1, 3]
      }
    };
  }
});

// src/cubing/kpuzzle/index.ts
var experimental3x3x3KPuzzle;
var init_kpuzzle = __esm({
  "src/cubing/kpuzzle/index.ts"() {
    init_KPuzzle();
    init_KState();
    init_KTransformation();
    init_x3x3_kpuzzle_json();
    init_KPuzzle();
    experimental3x3x3KPuzzle = new KPuzzle(cube3x3x3KPuzzleDefinition);
  }
});

// src/cubing/puzzle-geometry/FaceNameSwizzler.ts
var FaceNameSwizzler;
var init_FaceNameSwizzler = __esm({
  "src/cubing/puzzle-geometry/FaceNameSwizzler.ts"() {
    FaceNameSwizzler = class {
      constructor(facenames, gripnames_arg) {
        this.facenames = facenames;
        this.prefixFree = true;
        this.gripnames = [];
        if (gripnames_arg) {
          this.gripnames = gripnames_arg;
        }
        for (let i2 = 0; this.prefixFree && i2 < facenames.length; i2++) {
          for (let j = 0; this.prefixFree && j < facenames.length; j++) {
            if (i2 !== j && facenames[i2].startsWith(facenames[j])) {
              this.prefixFree = false;
            }
          }
        }
      }
      setGripNames(names) {
        this.gripnames = names;
      }
      splitByFaceNames(s) {
        const r3 = [];
        let at = 0;
        while (at < s.length) {
          if (at > 0 && at < s.length && s[at] === "_") {
            at++;
          }
          let currentMatch = -1;
          for (let i2 = 0; i2 < this.facenames.length; i2++) {
            if (s.substr(at).startsWith(this.facenames[i2]) && (currentMatch < 0 || this.facenames[i2].length > this.facenames[currentMatch].length)) {
              currentMatch = i2;
            }
          }
          if (currentMatch >= 0) {
            r3.push(currentMatch);
            at += this.facenames[currentMatch].length;
          } else {
            throw new Error("Could not split " + s + " into face names.");
          }
        }
        return r3;
      }
      joinByFaceIndices(list) {
        let sep = "";
        const r3 = [];
        for (let i2 = 0; i2 < list.length; i2++) {
          r3.push(sep);
          r3.push(this.facenames[list[i2]]);
          if (!this.prefixFree) {
            sep = "_";
          }
        }
        return r3.join("");
      }
      spinmatch(userinput, longname) {
        if (userinput === longname) {
          return true;
        }
        try {
          const e1 = this.splitByFaceNames(userinput);
          const e2 = this.splitByFaceNames(longname);
          if (e1.length !== e2.length && e1.length < 3) {
            return false;
          }
          for (let i2 = 0; i2 < e1.length; i2++) {
            for (let j = 0; j < i2; j++) {
              if (e1[i2] === e1[j]) {
                return false;
              }
            }
            let found = false;
            for (let j = 0; j < e2.length; j++) {
              if (e1[i2] === e2[j]) {
                found = true;
                break;
              }
            }
            if (!found) {
              return false;
            }
          }
          return true;
        } catch (e) {
          return false;
        }
      }
      spinmatchv(userinput, longname) {
        if (userinput.endsWith("v") && longname.endsWith("v")) {
          return this.spinmatch(userinput.slice(0, userinput.length - 1), longname.slice(0, longname.length - 1));
        } else {
          return this.spinmatch(userinput, longname);
        }
      }
      unswizzle(s) {
        if ((s.endsWith("v") || s.endsWith("w")) && s[0] <= "Z") {
          s = s.slice(0, s.length - 1);
        }
        const upperCaseGrip = s.toUpperCase();
        for (let i2 = 0; i2 < this.gripnames.length; i2++) {
          const g = this.gripnames[i2];
          if (this.spinmatch(upperCaseGrip, g)) {
            return g;
          }
        }
        return s;
      }
    };
  }
});

// src/cubing/puzzle-geometry/notation-mapping/NullMapper.ts
var NullMapper;
var init_NullMapper = __esm({
  "src/cubing/puzzle-geometry/notation-mapping/NullMapper.ts"() {
    NullMapper = class {
      notationToInternal(move) {
        return move;
      }
      notationToExternal(move) {
        return move;
      }
    };
  }
});

// src/cubing/puzzle-geometry/notation-mapping/FTONotationMapper.ts
var FTONotationMapper;
var init_FTONotationMapper = __esm({
  "src/cubing/puzzle-geometry/notation-mapping/FTONotationMapper.ts"() {
    init_alg();
    FTONotationMapper = class {
      constructor(child, sw) {
        this.child = child;
        this.sw = sw;
      }
      notationToInternal(move) {
        if (move.family === "T" && move.innerLayer === void 0 && move.outerLayer === void 0) {
          return new Move(new QuantumMove("FLRv", move.innerLayer, move.outerLayer), move.amount);
        } else {
          const r3 = this.child.notationToInternal(move);
          return r3;
        }
      }
      notationToExternal(move) {
        let fam = move.family;
        if (fam.length > 0 && fam[fam.length - 1] === "v") {
          fam = fam.substring(0, fam.length - 1);
        }
        if (this.sw.spinmatch(fam, "FLUR")) {
          return new Move(new QuantumMove("T", move.innerLayer, move.outerLayer), move.amount);
        }
        return this.child.notationToExternal(move);
      }
    };
  }
});

// src/cubing/puzzle-geometry/notation-mapping/FaceRenamingMapper.ts
var FaceRenamingMapper;
var init_FaceRenamingMapper = __esm({
  "src/cubing/puzzle-geometry/notation-mapping/FaceRenamingMapper.ts"() {
    init_alg();
    FaceRenamingMapper = class {
      constructor(internalNames, externalNames) {
        this.internalNames = internalNames;
        this.externalNames = externalNames;
      }
      convertString(grip, a, b2) {
        let suffix = "";
        if ((grip.endsWith("v") || grip.endsWith("v")) && grip <= "_") {
          suffix = grip.slice(grip.length - 1);
          grip = grip.slice(0, grip.length - 1);
        }
        const upper = grip.toUpperCase();
        let isLowerCase = false;
        if (grip !== upper) {
          isLowerCase = true;
          grip = upper;
        }
        grip = b2.joinByFaceIndices(a.splitByFaceNames(grip));
        if (isLowerCase) {
          grip = grip.toLowerCase();
        }
        return grip + suffix;
      }
      convert(move, a, b2) {
        const grip = move.family;
        const ngrip = this.convertString(grip, a, b2);
        if (grip === ngrip) {
          return move;
        } else {
          return new Move(new QuantumMove(ngrip, move.innerLayer, move.outerLayer), move.amount);
        }
      }
      notationToInternal(move) {
        const r3 = this.convert(move, this.externalNames, this.internalNames);
        return r3;
      }
      notationToExternal(move) {
        return this.convert(move, this.internalNames, this.externalNames);
      }
    };
  }
});

// src/cubing/puzzle-geometry/notation-mapping/MegaminxScramblingNotationMapper.ts
var MegaminxScramblingNotationMapper;
var init_MegaminxScramblingNotationMapper = __esm({
  "src/cubing/puzzle-geometry/notation-mapping/MegaminxScramblingNotationMapper.ts"() {
    init_alg();
    MegaminxScramblingNotationMapper = class {
      constructor(child) {
        this.child = child;
      }
      notationToInternal(move) {
        if (move.innerLayer === void 0 && move.outerLayer === void 0) {
          if (Math.abs(move.amount) === 1) {
            if (move.family === "R++") {
              return new Move(new QuantumMove("L", 3, 2), -2 * move.amount);
            } else if (move.family === "R--") {
              return new Move(new QuantumMove("L", 3, 2), 2 * move.amount);
            } else if (move.family === "D++") {
              return new Move(new QuantumMove("U", 3, 2), -2 * move.amount);
            } else if (move.family === "D--") {
              return new Move(new QuantumMove("U", 3, 2), 2 * move.amount);
            }
            if (move.family === "R_PLUSPLUS_") {
              return new Move(new QuantumMove("L", 3, 2), -2 * move.amount);
            } else if (move.family === "D_PLUSPLUS_") {
              return new Move(new QuantumMove("U", 3, 2), -2 * move.amount);
            }
          }
          if (move.family === "y") {
            return new Move("Uv", move.amount);
          }
        }
        return this.child.notationToInternal(move);
      }
      notationToExternal(move) {
        if (move.family === "Uv") {
          return new Move(new QuantumMove("y", move.innerLayer, move.outerLayer), move.amount);
        }
        if (move.family === "Dv") {
          return new Move("y", -move.amount);
        }
        return this.child.notationToExternal(move);
      }
    };
  }
});

// src/cubing/puzzle-geometry/notation-mapping/NxNxNCubeMapper.ts
var NxNxNCubeMapper;
var init_NxNxNCubeMapper = __esm({
  "src/cubing/puzzle-geometry/notation-mapping/NxNxNCubeMapper.ts"() {
    init_alg();
    NxNxNCubeMapper = class {
      constructor(slices) {
        this.slices = slices;
      }
      notationToInternal(move) {
        const grip = move.family;
        if (!move.innerLayer && !move.outerLayer) {
          if (grip === "x") {
            move = new Move("Rv", move.amount);
          } else if (grip === "y") {
            move = new Move("Uv", move.amount);
          } else if (grip === "z") {
            move = new Move("Fv", move.amount);
          }
          if ((this.slices & 1) === 1) {
            if (grip === "E") {
              move = new Move(new QuantumMove("D", (this.slices + 1) / 2), move.amount);
            } else if (grip === "M") {
              move = new Move(new QuantumMove("L", (this.slices + 1) / 2), move.amount);
            } else if (grip === "S") {
              move = new Move(new QuantumMove("F", (this.slices + 1) / 2), move.amount);
            }
          }
          if (this.slices > 2) {
            if (grip === "e") {
              move = new Move(new QuantumMove("D", this.slices - 1, 2), move.amount);
            } else if (grip === "m") {
              move = new Move(new QuantumMove("L", this.slices - 1, 2), move.amount);
            } else if (grip === "s") {
              move = new Move(new QuantumMove("F", this.slices - 1, 2), move.amount);
            }
          }
        }
        return move;
      }
      notationToExternal(move) {
        const grip = move.family;
        if (!move.innerLayer && !move.outerLayer) {
          if (grip === "Rv") {
            return new Move("x", move.amount);
          } else if (grip === "Uv") {
            return new Move("y", move.amount);
          } else if (grip === "Fv") {
            return new Move("z", move.amount);
          } else if (grip === "Lv") {
            return new Move("x", -move.amount);
          } else if (grip === "Dv") {
            return new Move("y", -move.amount);
          } else if (grip === "Bv") {
            return new Move("z", -move.amount);
          }
        }
        return move;
      }
    };
  }
});

// src/cubing/puzzle-geometry/notation-mapping/PyraminxNotationMapper.ts
var pyraminxFamilyMap, tetraminxFamilyMap, pyraminxFamilyMapWCA, pyraminxExternalQuantumY, pyraminxInternalQuantumY, PyraminxNotationMapper, TetraminxNotationMapper;
var init_PyraminxNotationMapper = __esm({
  "src/cubing/puzzle-geometry/notation-mapping/PyraminxNotationMapper.ts"() {
    init_alg();
    pyraminxFamilyMap = {
      U: "frl",
      L: "fld",
      R: "fdr",
      B: "dlr",
      u: "FRL",
      l: "FLD",
      r: "FDR",
      b: "DLR",
      Uv: "FRLv",
      Lv: "FLDv",
      Rv: "FDRv",
      Bv: "DLRv",
      D: "D",
      F: "F",
      BL: "L",
      BR: "R"
    };
    tetraminxFamilyMap = {
      U: "FRL",
      L: "FLD",
      R: "FDR",
      B: "DLR",
      u: "frl",
      l: "fld",
      r: "fdr",
      b: "dlr",
      Uv: "FRLv",
      Lv: "FLDv",
      Rv: "FDRv",
      Bv: "DLRv",
      D: "D",
      F: "F",
      BL: "L",
      BR: "R",
      d: "d",
      f: "f",
      bl: "l",
      br: "r"
    };
    pyraminxFamilyMapWCA = {
      U: "FRL",
      L: "FLD",
      R: "FDR",
      B: "DLR"
    };
    pyraminxExternalQuantumY = new QuantumMove("y");
    pyraminxInternalQuantumY = new QuantumMove("Dv");
    PyraminxNotationMapper = class {
      constructor(child) {
        this.child = child;
        this.wcaHack = false;
        this.map = pyraminxFamilyMap;
      }
      notationToInternal(move) {
        if (this.wcaHack && move.innerLayer === 2 && move.outerLayer === null) {
          const newFamilyWCA = pyraminxFamilyMapWCA[move.family];
          if (newFamilyWCA) {
            return new Move(new QuantumMove(newFamilyWCA, move.innerLayer, move.outerLayer), move.amount);
          }
        }
        const newFamily = this.map[move.family];
        if (newFamily) {
          return new Move(new QuantumMove(newFamily, move.innerLayer, move.outerLayer), move.amount);
        } else if (pyraminxExternalQuantumY.isIdentical(move.quantum)) {
          return new Move(pyraminxInternalQuantumY, -move.amount);
        } else {
          return null;
        }
      }
      notationToExternal(move) {
        if (this.wcaHack && move.innerLayer === 2 && move.outerLayer === null) {
          for (const [external, internal] of Object.entries(pyraminxFamilyMapWCA)) {
            if (this.child.spinmatch(move.family, internal)) {
              return new Move(new QuantumMove(external, move.innerLayer, move.outerLayer), move.amount);
            }
          }
        }
        for (const [external, internal] of Object.entries(this.map)) {
          if (this.child.spinmatch(move.family, internal)) {
            return new Move(new QuantumMove(external, move.innerLayer, move.outerLayer), move.amount);
          }
        }
        if (pyraminxInternalQuantumY.isIdentical(move.quantum)) {
          return new Move(pyraminxExternalQuantumY, -move.amount);
        } else {
          return null;
        }
      }
    };
    TetraminxNotationMapper = class extends PyraminxNotationMapper {
      constructor(child) {
        super(child);
        this.wcaHack = true;
        this.map = tetraminxFamilyMap;
      }
    };
  }
});

// src/cubing/puzzle-geometry/notation-mapping/SkewbNotationMapper.ts
var skewbFamilyMap, skewbExternalQuantumX, skewbInternalQuantumX, skewbInternalQuantumXPrime, skewbExternalQuantumY, skewbInternalQuantumY, skewbInternalQuantumYPrime, skewbExternalQuantumZ, skewbInternalQuantumZ, skewbInternalQuantumZPrime, SkewbNotationMapper;
var init_SkewbNotationMapper = __esm({
  "src/cubing/puzzle-geometry/notation-mapping/SkewbNotationMapper.ts"() {
    init_alg();
    skewbFamilyMap = {
      U: "UBL",
      UL: "ULF",
      F: "UFR",
      UR: "URB",
      B: "DBL",
      D: "DFR",
      L: "DLF",
      R: "DRB",
      Uv: "UBLv",
      ULv: "ULFv",
      Fv: "UFRv",
      URv: "URBv",
      Bv: "DBLv",
      Dv: "DFRv",
      Lv: "DLFv",
      Rv: "DRBv"
    };
    skewbExternalQuantumX = new QuantumMove("x");
    skewbInternalQuantumX = new QuantumMove("Rv");
    skewbInternalQuantumXPrime = new QuantumMove("Lv");
    skewbExternalQuantumY = new QuantumMove("y");
    skewbInternalQuantumY = new QuantumMove("Uv");
    skewbInternalQuantumYPrime = new QuantumMove("Dv");
    skewbExternalQuantumZ = new QuantumMove("z");
    skewbInternalQuantumZ = new QuantumMove("Fv");
    skewbInternalQuantumZPrime = new QuantumMove("Bv");
    SkewbNotationMapper = class {
      constructor(child) {
        this.child = child;
      }
      notationToInternal(move) {
        if (move.innerLayer || move.outerLayer) {
          return null;
        }
        const newFamily = skewbFamilyMap[move.family];
        if (newFamily) {
          return new Move(new QuantumMove(newFamily, move.outerLayer, move.innerLayer), move.amount);
        }
        if (skewbExternalQuantumX.isIdentical(move.quantum)) {
          return new Move(skewbInternalQuantumX, move.amount);
        }
        if (skewbExternalQuantumY.isIdentical(move.quantum)) {
          return new Move(skewbInternalQuantumY, move.amount);
        }
        if (skewbExternalQuantumZ.isIdentical(move.quantum)) {
          return new Move(skewbInternalQuantumZ, move.amount);
        }
        return null;
      }
      notationToExternal(move) {
        for (const [external, internal] of Object.entries(skewbFamilyMap)) {
          if (this.child.spinmatchv(move.family, internal)) {
            return new Move(new QuantumMove(external, move.innerLayer, move.outerLayer), move.amount);
          }
        }
        if (skewbInternalQuantumX.isIdentical(move.quantum)) {
          return new Move(skewbExternalQuantumX, move.amount);
        }
        if (skewbInternalQuantumXPrime.isIdentical(move.quantum)) {
          return new Move(skewbExternalQuantumX, -move.amount);
        }
        if (skewbInternalQuantumY.isIdentical(move.quantum)) {
          return new Move(skewbExternalQuantumY, move.amount);
        }
        if (skewbInternalQuantumYPrime.isIdentical(move.quantum)) {
          return new Move(skewbExternalQuantumY, -move.amount);
        }
        if (skewbInternalQuantumZ.isIdentical(move.quantum)) {
          return new Move(skewbExternalQuantumZ, move.amount);
        }
        if (skewbInternalQuantumZPrime.isIdentical(move.quantum)) {
          return new Move(skewbExternalQuantumZ, -move.amount);
        }
        return null;
      }
    };
  }
});

// src/cubing/puzzle-geometry/notation-mapping/index.ts
var init_notation_mapping = __esm({
  "src/cubing/puzzle-geometry/notation-mapping/index.ts"() {
    init_NullMapper();
    init_FTONotationMapper();
    init_FaceRenamingMapper();
    init_MegaminxScramblingNotationMapper();
    init_NxNxNCubeMapper();
    init_PyraminxNotationMapper();
    init_SkewbNotationMapper();
  }
});

// src/cubing/puzzle-geometry/Options.ts
function parseOptions(argv) {
  let argp = 0;
  const options = {};
  while (argp < argv.length && argv[argp][0] === "-") {
    const option = argv[argp++];
    if (option === "--rotations") {
      options.addRotations = true;
    } else if (option === "--allmoves") {
      options.allMoves = true;
    } else if (option === "--outerblockmoves") {
      options.outerBlockMoves = true;
    } else if (option === "--vertexmoves") {
      options.vertexMoves = true;
    } else if (option === "--nocorners") {
      options.includeCornerOrbits = false;
    } else if (option === "--noedges") {
      options.includeEdgeOrbits = false;
    } else if (option === "--noorientation") {
      options.fixedOrientation = true;
    } else if (option === "--nocenters") {
      options.includeCenterOrbits = false;
    } else if (option === "--omit") {
      options.excludeOrbits = argv[argp].split(",");
      argp++;
    } else if (option === "--moves") {
      options.moveList = argv[argp].split(",");
      argp++;
    } else if (option === "--optimize") {
      options.optimizeOrbits = true;
    } else if (option === "--scramble") {
      options.scrambleAmount = 100;
    } else if (option === "--fixcorner") {
      options.fixedPieceType = "v";
    } else if (option === "--fixedge") {
      options.fixedPieceType = "e";
    } else if (option === "--fixcenter") {
      options.fixedPieceType = "f";
    } else if (option === "--orientcenters") {
      options.orientCenters = true;
    } else if (option === "--puzzleorientation") {
      options.puzzleOrientation = JSON.parse(argv[argp]);
      argp++;
    } else {
      throw new Error("Bad option: " + option);
    }
  }
  const puzzleDescription = parsePuzzleDescription(argv.slice(argp).join(" "));
  return { puzzleDescription, options };
}
var PuzzleGeometryFullOptions;
var init_Options = __esm({
  "src/cubing/puzzle-geometry/Options.ts"() {
    init_PuzzleGeometry();
    PuzzleGeometryFullOptions = class {
      constructor(options = {}) {
        this.verbosity = 0;
        this.allMoves = false;
        this.vertexMoves = false;
        this.addRotations = false;
        this.moveList = null;
        this.fixedOrientation = false;
        this.fixedPieceType = null;
        this.orientCenters = false;
        this.includeCornerOrbits = true;
        this.includeCenterOrbits = true;
        this.includeEdgeOrbits = true;
        this.excludeOrbits = [];
        this.optimizeOrbits = false;
        this.grayCorners = false;
        this.grayCenters = false;
        this.grayEdges = false;
        this.puzzleOrientation = null;
        this.puzzleOrientations = null;
        this.scrambleAmount = 0;
        Object.assign(this, options);
      }
    };
  }
});

// src/cubing/puzzle-geometry/Perm.ts
function zeros(n) {
  if (!zeroCache[n]) {
    const c = Array(n);
    for (let i2 = 0; i2 < n; i2++) {
      c[i2] = 0;
    }
    zeroCache[n] = c;
  }
  return zeroCache[n];
}
function iota(n) {
  if (!iotaCache[n]) {
    const c = Array(n);
    for (let i2 = 0; i2 < n; i2++) {
      c[i2] = i2;
    }
    iotaCache[n] = c;
  }
  return iotaCache[n];
}
function identity(n) {
  return new Perm(iota(n));
}
function factorial(a) {
  let r3 = 1;
  while (a > 1) {
    r3 *= a;
    a--;
  }
  return r3;
}
function gcd2(a, b2) {
  if (a > b2) {
    const t2 = a;
    a = b2;
    b2 = t2;
  }
  while (a > 0) {
    const m = b2 % a;
    b2 = a;
    a = m;
  }
  return b2;
}
function lcm(a, b2) {
  return a / gcd2(a, b2) * b2;
}
var zeroCache, iotaCache, Perm;
var init_Perm = __esm({
  "src/cubing/puzzle-geometry/Perm.ts"() {
    zeroCache = [];
    iotaCache = [];
    Perm = class {
      constructor(a) {
        this.n = a.length;
        this.p = a;
      }
      toString() {
        return "Perm[" + this.p.join(" ") + "]";
      }
      mul(p2) {
        const c = Array(this.n);
        for (let i2 = 0; i2 < this.n; i2++) {
          c[i2] = p2.p[this.p[i2]];
        }
        return new Perm(c);
      }
      rmul(p2) {
        const c = Array(this.n);
        for (let i2 = 0; i2 < this.n; i2++) {
          c[i2] = this.p[p2.p[i2]];
        }
        return new Perm(c);
      }
      inv() {
        const c = Array(this.n);
        for (let i2 = 0; i2 < this.n; i2++) {
          c[this.p[i2]] = i2;
        }
        return new Perm(c);
      }
      compareTo(p2) {
        for (let i2 = 0; i2 < this.n; i2++) {
          if (this.p[i2] !== p2.p[i2]) {
            return this.p[i2] - p2.p[i2];
          }
        }
        return 0;
      }
      toGap() {
        const cyc = new Array();
        const seen = new Array(this.n);
        for (let i2 = 0; i2 < this.p.length; i2++) {
          if (seen[i2] || this.p[i2] === i2) {
            continue;
          }
          const incyc = new Array();
          for (let j = i2; !seen[j]; j = this.p[j]) {
            incyc.push(1 + j);
            seen[j] = true;
          }
          cyc.push("(" + incyc.join(",") + ")");
        }
        return cyc.join("");
      }
      order() {
        let r3 = 1;
        const seen = new Array(this.n);
        for (let i2 = 0; i2 < this.p.length; i2++) {
          if (seen[i2] || this.p[i2] === i2) {
            continue;
          }
          let cs = 0;
          for (let j = i2; !seen[j]; j = this.p[j]) {
            cs++;
            seen[j] = true;
          }
          r3 = lcm(r3, cs);
        }
        return r3;
      }
    };
  }
});

// src/cubing/puzzle-geometry/PermOriSet.ts
function externalName(mapper, moveString) {
  const mv = Move.fromString(moveString);
  const mv2 = mapper.notationToExternal(mv);
  if (mv2 === null || mv === mv2) {
    return moveString;
  }
  return mv2.toString();
}
function showcanon(g, disp) {
  const n = g.moveops.length;
  if (n > 30) {
    throw new Error("Canon info too big for bitmask");
  }
  const orders = [];
  const commutes = [];
  for (let i2 = 0; i2 < n; i2++) {
    const permA = g.moveops[i2];
    orders.push(permA.order());
    let bits = 0;
    for (let j = 0; j < n; j++) {
      if (j === i2) {
        continue;
      }
      const permB = g.moveops[j];
      if (permA.mul(permB).equal(permB.mul(permA))) {
        bits |= 1 << j;
      }
    }
    commutes.push(bits);
  }
  let curlev = {};
  curlev[0] = 1;
  for (let d2 = 0; d2 < 100; d2++) {
    let sum = 0;
    const nextlev = {};
    let uniq = 0;
    for (const sti in curlev) {
      const st = +sti;
      const cnt = curlev[st];
      sum += cnt;
      uniq++;
      for (let mv = 0; mv < orders.length; mv++) {
        if ((st >> mv & 1) === 0 && (st & commutes[mv] & (1 << mv) - 1) === 0) {
          const nst = st & commutes[mv] | 1 << mv;
          if (nextlev[nst] === void 0) {
            nextlev[nst] = 0;
          }
          nextlev[nst] += (orders[mv] - 1) * cnt;
        }
      }
    }
    disp(`${d2}: canonseq ${sum} states ${uniq}`);
    curlev = nextlev;
  }
}
var PGOrbitDef, lastGlobalDefinitionCounter, PGOrbitsDef, _PGOrbit, PGOrbit, PGTransformBase, PGTransform, VisibleState, DisjointUnion;
var init_PermOriSet = __esm({
  "src/cubing/puzzle-geometry/PermOriSet.ts"() {
    init_alg();
    init_notation_mapping();
    init_Perm();
    PGOrbitDef = class {
      constructor(size, mod2) {
        this.size = size;
        this.mod = mod2;
      }
      reassemblySize() {
        return factorial(this.size) * Math.pow(this.mod, this.size);
      }
    };
    lastGlobalDefinitionCounter = 0;
    PGOrbitsDef = class {
      constructor(orbitnames, orbitdefs, solved, movenames, moveops) {
        this.orbitnames = orbitnames;
        this.orbitdefs = orbitdefs;
        this.solved = solved;
        this.movenames = movenames;
        this.moveops = moveops;
      }
      transformToKTransformationData(t2) {
        const mp = {};
        for (let j = 0; j < this.orbitnames.length; j++) {
          mp[this.orbitnames[j]] = t2.orbits[j].toKPuzzle();
        }
        return mp;
      }
      static transformToKTransformationData(orbitnames, t2) {
        const mp = {};
        for (let j = 0; j < orbitnames.length; j++) {
          mp[orbitnames[j]] = t2.orbits[j].toKPuzzle();
        }
        return mp;
      }
      toKsolve(name, mapper = new NullMapper()) {
        const result = [];
        result.push("Name " + name);
        result.push("");
        for (let i2 = 0; i2 < this.orbitnames.length; i2++) {
          result.push(`Set ${this.orbitnames[i2]} ${this.orbitdefs[i2].size} ${this.orbitdefs[i2].mod}`);
        }
        result.push("");
        result.push("Solved");
        for (let i2 = 0; i2 < this.orbitnames.length; i2++) {
          this.solved.orbits[i2].appendDefinition(result, this.orbitnames[i2], false, false);
        }
        result.push("End");
        for (let i2 = 0; i2 < this.movenames.length; i2++) {
          result.push("");
          let name2 = externalName(mapper, this.movenames[i2]);
          let doinv = false;
          if (name2[name2.length - 1] === "'") {
            doinv = true;
            name2 = name2.substring(0, name2.length - 1);
          }
          result.push("Move " + name2);
          for (let j = 0; j < this.orbitnames.length; j++) {
            if (doinv) {
              this.moveops[i2].orbits[j].inv().appendDefinition(result, this.orbitnames[j], true);
            } else {
              this.moveops[i2].orbits[j].appendDefinition(result, this.orbitnames[j], true);
            }
          }
          result.push("End");
        }
        return result;
      }
      toKPuzzleDefinition(includemoves) {
        const orbits = {};
        const start = {};
        for (let i2 = 0; i2 < this.orbitnames.length; i2++) {
          orbits[this.orbitnames[i2]] = {
            numPieces: this.orbitdefs[i2].size,
            numOrientations: this.orbitdefs[i2].mod
          };
          const startTransformation = this.solved.orbits[i2].toKPuzzle();
          start[this.orbitnames[i2]] = {
            pieces: startTransformation.permutation,
            orientation: startTransformation.orientation
          };
        }
        const moves = {};
        if (includemoves) {
          for (let i2 = 0; i2 < this.movenames.length; i2++) {
            moves[this.movenames[i2]] = this.transformToKTransformationData(this.moveops[i2]);
          }
        }
        return {
          name: `PG3D #${++lastGlobalDefinitionCounter}`,
          orbits,
          startStateData: start,
          moves
        };
      }
      optimize() {
        const neworbitnames = [];
        const neworbitdefs = [];
        const newsolved = [];
        const newmoveops = [];
        for (let j = 0; j < this.moveops.length; j++) {
          newmoveops.push([]);
        }
        for (let i2 = 0; i2 < this.orbitdefs.length; i2++) {
          const om = this.orbitdefs[i2].mod;
          const n = this.orbitdefs[i2].size;
          const du = new DisjointUnion(n);
          const changed = new Array(this.orbitdefs[i2].size);
          for (let k = 0; k < n; k++) {
            changed[k] = false;
          }
          for (let j = 0; j < this.moveops.length; j++) {
            for (let k = 0; k < n; k++) {
              if (this.moveops[j].orbits[i2].perm[k] !== k || this.moveops[j].orbits[i2].ori[k] !== 0) {
                changed[k] = true;
                du.union(k, this.moveops[j].orbits[i2].perm[k]);
              }
            }
          }
          let keepori = true;
          if (om > 1) {
            keepori = false;
            const duo = new DisjointUnion(this.orbitdefs[i2].size * om);
            for (let j = 0; j < this.moveops.length; j++) {
              for (let k = 0; k < n; k++) {
                if (this.moveops[j].orbits[i2].perm[k] !== k || this.moveops[j].orbits[i2].ori[k] !== 0) {
                  for (let o2 = 0; o2 < om; o2++) {
                    duo.union(k * om + o2, this.moveops[j].orbits[i2].perm[k] * om + (o2 + this.moveops[j].orbits[i2].ori[k]) % om);
                  }
                }
              }
            }
            for (let j = 0; !keepori && j < n; j++) {
              for (let o2 = 1; o2 < om; o2++) {
                if (duo.find(j * om) === duo.find(j * om + o2)) {
                  keepori = true;
                }
              }
            }
            for (let j = 0; !keepori && j < n; j++) {
              for (let k = 0; k < j; k++) {
                if (this.solved.orbits[i2].perm[j] === this.solved.orbits[i2].perm[k]) {
                  keepori = true;
                }
              }
            }
          }
          let nontriv = -1;
          let multiple = false;
          for (let j = 0; j < this.orbitdefs[i2].size; j++) {
            if (changed[j]) {
              const h = du.find(j);
              if (nontriv < 0) {
                nontriv = h;
              } else if (nontriv !== h) {
                multiple = true;
              }
            }
          }
          for (let j = 0; j < this.orbitdefs[i2].size; j++) {
            if (!changed[j]) {
              continue;
            }
            const h = du.find(j);
            if (h !== j) {
              continue;
            }
            const no = [];
            const on = [];
            let nv = 0;
            for (let k = 0; k < this.orbitdefs[i2].size; k++) {
              if (du.find(k) === j) {
                no[nv] = k;
                on[k] = nv;
                nv++;
              }
            }
            if (multiple) {
              neworbitnames.push(`${this.orbitnames[i2]}_p${j}`);
            } else {
              neworbitnames.push(this.orbitnames[i2]);
            }
            if (keepori) {
              neworbitdefs.push(new PGOrbitDef(nv, this.orbitdefs[i2].mod));
              newsolved.push(this.solved.orbits[i2].remapVS(no, nv));
              for (let k = 0; k < this.moveops.length; k++) {
                newmoveops[k].push(this.moveops[k].orbits[i2].remap(no, on, nv));
              }
            } else {
              neworbitdefs.push(new PGOrbitDef(nv, 1));
              newsolved.push(this.solved.orbits[i2].remapVS(no, nv).killOri());
              for (let k = 0; k < this.moveops.length; k++) {
                newmoveops[k].push(this.moveops[k].orbits[i2].remap(no, on, nv).killOri());
              }
            }
          }
        }
        return new PGOrbitsDef(neworbitnames, neworbitdefs, new VisibleState(newsolved), this.movenames, newmoveops.map((_) => new PGTransform(_)));
      }
      scramble(n) {
        this.solved = this.solved.mul(this.getScrambleTransformation(n));
      }
      getScrambleTransformation(n) {
        if (n < 100) {
          n = 100;
        }
        const pool = [];
        for (let i2 = 0; i2 < this.moveops.length; i2++) {
          pool[i2] = this.moveops[i2];
        }
        for (let i2 = 0; i2 < pool.length; i2++) {
          const j = Math.floor(Math.random() * pool.length);
          const t2 = pool[i2];
          pool[i2] = pool[j];
          pool[j] = t2;
        }
        if (n < pool.length) {
          n = pool.length;
        }
        for (let i2 = 0; i2 < n; i2++) {
          const ri = Math.floor(Math.random() * pool.length);
          const rj = Math.floor(Math.random() * pool.length);
          const rm = Math.floor(Math.random() * this.moveops.length);
          pool[ri] = pool[ri].mul(pool[rj]).mul(this.moveops[rm]);
          if (Math.random() < 0.1) {
            pool[ri] = pool[ri].mul(this.moveops[rm]);
          }
        }
        let s = pool[0];
        for (let i2 = 1; i2 < pool.length; i2++) {
          s = s.mul(pool[i2]);
        }
        return s;
      }
      reassemblySize() {
        let n = 1;
        for (let i2 = 0; i2 < this.orbitdefs.length; i2++) {
          n *= this.orbitdefs[i2].reassemblySize();
        }
        return n;
      }
    };
    _PGOrbit = class {
      constructor(perm, ori, orimod) {
        this.perm = perm;
        this.ori = ori;
        this.orimod = orimod;
      }
      static e(n, mod2) {
        return new _PGOrbit(iota(n), zeros(n), mod2);
      }
      mul(b2) {
        const n = this.perm.length;
        const newPerm = new Array(n);
        if (this.orimod === 1) {
          for (let i2 = 0; i2 < n; i2++) {
            newPerm[i2] = this.perm[b2.perm[i2]];
          }
          return new _PGOrbit(newPerm, this.ori, this.orimod);
        } else {
          const newOri = new Array(n);
          for (let i2 = 0; i2 < n; i2++) {
            newPerm[i2] = this.perm[b2.perm[i2]];
            newOri[i2] = (this.ori[b2.perm[i2]] + b2.ori[i2]) % this.orimod;
          }
          return new _PGOrbit(newPerm, newOri, this.orimod);
        }
      }
      inv() {
        const n = this.perm.length;
        const newPerm = new Array(n);
        const newOri = new Array(n);
        for (let i2 = 0; i2 < n; i2++) {
          newPerm[this.perm[i2]] = i2;
          newOri[this.perm[i2]] = (this.orimod - this.ori[i2]) % this.orimod;
        }
        return new _PGOrbit(newPerm, newOri, this.orimod);
      }
      equal(b2) {
        const n = this.perm.length;
        for (let i2 = 0; i2 < n; i2++) {
          if (this.perm[i2] !== b2.perm[i2] || this.ori[i2] !== b2.ori[i2]) {
            return false;
          }
        }
        return true;
      }
      killOri() {
        const n = this.perm.length;
        for (let i2 = 0; i2 < n; i2++) {
          this.ori[i2] = 0;
        }
        this.orimod = 1;
        return this;
      }
      toPerm() {
        const o2 = this.orimod;
        if (o2 === 1) {
          return new Perm(this.perm);
        }
        const n = this.perm.length;
        const newPerm = new Array(n * o2);
        for (let i2 = 0; i2 < n; i2++) {
          for (let j = 0; j < o2; j++) {
            newPerm[i2 * o2 + j] = o2 * this.perm[i2] + (this.ori[i2] + j) % o2;
          }
        }
        return new Perm(newPerm);
      }
      identicalPieces() {
        const done = [];
        const n = this.perm.length;
        const r3 = [];
        for (let i2 = 0; i2 < n; i2++) {
          const v = this.perm[i2];
          if (done[v] === void 0) {
            const s = [i2];
            done[v] = true;
            for (let j = i2 + 1; j < n; j++) {
              if (this.perm[j] === v) {
                s.push(j);
              }
            }
            r3.push(s);
          }
        }
        return r3;
      }
      order() {
        return this.toPerm().order();
      }
      isIdentity() {
        const n = this.perm.length;
        if (this.perm === iota(n) && this.ori === zeros(n)) {
          return true;
        }
        for (let i2 = 0; i2 < n; i2++) {
          if (this.perm[i2] !== i2 || this.ori[i2] !== 0) {
            return false;
          }
        }
        return true;
      }
      zeroOris() {
        const n = this.perm.length;
        if (this.ori === zeros(n)) {
          return true;
        }
        for (let i2 = 0; i2 < n; i2++) {
          if (this.ori[i2] !== 0) {
            return false;
          }
        }
        return true;
      }
      remap(no, on, nv) {
        const newPerm = new Array(nv);
        const newOri = new Array(nv);
        for (let i2 = 0; i2 < nv; i2++) {
          newPerm[i2] = on[this.perm[no[i2]]];
          newOri[i2] = this.ori[no[i2]];
        }
        return new _PGOrbit(newPerm, newOri, this.orimod);
      }
      remapVS(no, nv) {
        const newPerm = new Array(nv);
        const newOri = new Array(nv);
        let nextNew = 0;
        const reassign = [];
        for (let i2 = 0; i2 < nv; i2++) {
          const ov = this.perm[no[i2]];
          if (reassign[ov] === void 0) {
            reassign[ov] = nextNew++;
          }
          newPerm[i2] = reassign[ov];
          newOri[i2] = this.ori[no[i2]];
        }
        return new _PGOrbit(newPerm, newOri, this.orimod);
      }
      appendDefinition(result, name, useVS, concise = true) {
        if (concise && this.isIdentity()) {
          return;
        }
        result.push(name);
        result.push(this.perm.map((_) => _ + 1).join(" "));
        if (!this.zeroOris()) {
          if (useVS) {
            const newori = new Array(this.ori.length);
            for (let i2 = 0; i2 < newori.length; i2++) {
              newori[this.perm[i2]] = this.ori[i2];
            }
            result.push(newori.join(" "));
          } else {
            result.push(this.ori.join(" "));
          }
        }
      }
      toKPuzzle() {
        const n = this.perm.length;
        if (this.isIdentity()) {
          if (!_PGOrbit.kcache[n]) {
            _PGOrbit.kcache[n] = { permutation: iota(n), orientation: zeros(n) };
          }
          return _PGOrbit.kcache[n];
        } else {
          return { permutation: this.perm, orientation: this.ori };
        }
      }
    };
    PGOrbit = _PGOrbit;
    PGOrbit.kcache = [];
    PGTransformBase = class {
      constructor(orbits) {
        this.orbits = orbits;
      }
      internalMul(b2) {
        const newOrbits = [];
        for (let i2 = 0; i2 < this.orbits.length; i2++) {
          newOrbits.push(this.orbits[i2].mul(b2.orbits[i2]));
        }
        return newOrbits;
      }
      internalInv() {
        const newOrbits = [];
        for (const orbit of this.orbits) {
          newOrbits.push(orbit.inv());
        }
        return newOrbits;
      }
      equal(b2) {
        for (let i2 = 0; i2 < this.orbits.length; i2++) {
          if (!this.orbits[i2].equal(b2.orbits[i2])) {
            return false;
          }
        }
        return true;
      }
      killOri() {
        for (const orbit of this.orbits) {
          orbit.killOri();
        }
        return this;
      }
      toPerm() {
        const perms = new Array();
        let n = 0;
        for (const orbit of this.orbits) {
          const p = orbit.toPerm();
          perms.push(p);
          n += p.n;
        }
        const newPerm = new Array(n);
        n = 0;
        for (const p of perms) {
          for (let j = 0; j < p.n; j++) {
            newPerm[n + j] = n + p.p[j];
          }
          n += p.n;
        }
        return new Perm(newPerm);
      }
      identicalPieces() {
        const r3 = [];
        let n = 0;
        for (const orbit of this.orbits) {
          const o2 = orbit.orimod;
          const s = orbit.identicalPieces();
          for (let j = 0; j < s.length; j++) {
            r3.push(s[j].map((_) => _ * o2 + n));
          }
          n += o2 * orbit.perm.length;
        }
        return r3;
      }
      order() {
        let r3 = 1;
        for (const orbit of this.orbits) {
          r3 = lcm(r3, orbit.order());
        }
        return r3;
      }
    };
    PGTransform = class extends PGTransformBase {
      constructor(orbits) {
        super(orbits);
      }
      mul(b2) {
        return new PGTransform(this.internalMul(b2));
      }
      mulScalar(n) {
        if (n === 0) {
          return this.e();
        }
        let t2 = this;
        if (n < 0) {
          t2 = t2.inv();
          n = -n;
        }
        while ((n & 1) === 0) {
          t2 = t2.mul(t2);
          n >>= 1;
        }
        if (n === 1) {
          return t2;
        }
        let s = t2;
        let r3 = this.e();
        while (n > 0) {
          if (n & 1) {
            r3 = r3.mul(s);
          }
          if (n > 1) {
            s = s.mul(s);
          }
          n >>= 1;
        }
        return r3;
      }
      inv() {
        return new PGTransform(this.internalInv());
      }
      e() {
        return new PGTransform(this.orbits.map((_) => PGOrbit.e(_.perm.length, _.orimod)));
      }
    };
    VisibleState = class extends PGTransformBase {
      constructor(orbits) {
        super(orbits);
      }
      mul(b2) {
        return new VisibleState(this.internalMul(b2));
      }
    };
    DisjointUnion = class {
      constructor(n) {
        this.n = n;
        this.heads = new Array(n);
        for (let i2 = 0; i2 < n; i2++) {
          this.heads[i2] = i2;
        }
      }
      find(v) {
        let h = this.heads[v];
        if (this.heads[h] === h) {
          return h;
        }
        h = this.find(this.heads[h]);
        this.heads[v] = h;
        return h;
      }
      union(a, b2) {
        const ah = this.find(a);
        const bh = this.find(b2);
        if (ah < bh) {
          this.heads[bh] = ah;
        } else if (ah > bh) {
          this.heads[ah] = bh;
        }
      }
    };
  }
});

// src/cubing/puzzle-geometry/PGPuzzles.ts
var PGPuzzles;
var init_PGPuzzles = __esm({
  "src/cubing/puzzle-geometry/PGPuzzles.ts"() {
    PGPuzzles = {
      "2x2x2": "c f 0",
      "3x3x3": "c f 0.333333333333333",
      "4x4x4": "c f 0.5 f 0",
      "5x5x5": "c f 0.6 f 0.2",
      "6x6x6": "c f 0.666666666666667 f 0.333333333333333 f 0",
      "7x7x7": "c f 0.714285714285714 f 0.428571428571429 f 0.142857142857143",
      "8x8x8": "c f 0.75 f 0.5 f 0.25 f 0",
      "9x9x9": "c f 0.777777777777778 f 0.555555555555556 f 0.333333333333333 f 0.111111111111111",
      "10x10x10": "c f 0.8 f 0.6 f 0.4 f 0.2 f 0",
      "11x11x11": "c f 0.818181818181818 f 0.636363636363636 f 0.454545454545455 f 0.272727272727273 f 0.0909090909090909",
      "12x12x12": "c f 0.833333333333333 f 0.666666666666667 f 0.5 f 0.333333333333333 f 0.166666666666667 f 0",
      "13x13x13": "c f 0.846153846153846 f 0.692307692307692 f 0.538461538461538 f 0.384615384615385 f 0.230769230769231 f 0.0769230769230769",
      "20x20x20": "c f 0 f .1 f .2 f .3 f .4 f .5 f .6 f .7 f .8 f .9",
      "30x30x30": "c f 0 f .066667 f .133333 f .2 f .266667 f .333333 f .4 f .466667 f .533333 f .6 f .666667 f .733333 f .8 f .866667 f .933333",
      "40x40x40": "c f 0 f .05 f .1 f .15 f .2 f .25 f .3 f .35 f .4 f .45 f .5 f .55 f .6 f .65 f .7 f .75 f .8 f .85 f .9 f .95",
      "skewb": "c v 0",
      "master skewb": "c v 0.275",
      "professor skewb": "c v 0 v 0.38",
      "compy cube": "c v 0.915641442663986",
      "helicopter": "c e 0.707106781186547",
      "curvy copter": "c e 0.83",
      "dino": "c v 0.577350269189626",
      "little chop": "c e 0",
      "pyramorphix": "t e 0",
      "mastermorphix": "t e 0.346184634065199",
      "pyraminx": "t v 0.333333333333333 v 1.66666666666667",
      "tetraminx": "t v 0.333333333333333",
      "master pyraminx": "t v 0 v 1 v 2",
      "master tetraminx": "t v 0 v 1",
      "professor pyraminx": "t v -0.2 v 0.6 v 1.4 v 2.2",
      "professor tetraminx": "t v -0.2 v 0.6 v 1.4",
      "Jing pyraminx": "t f 0",
      "master pyramorphix": "t e 0.866025403784437",
      "megaminx": "d f 0.7",
      "gigaminx": "d f 0.64 f 0.82",
      "teraminx": "d f 0.64 f 0.76 f 0.88",
      "petaminx": "d f 0.64 f 0.73 f 0.82 f 0.91",
      "examinx": "d f 0.64 f 0.712 f 0.784 f 0.856 f 0.928",
      "zetaminx": "d f 0.64 f 0.7 f 0.76 f 0.82 f 0.88 f 0.94",
      "yottaminx": "d f 0.64 f 0.6914 f 0.7429 f 0.7943 f 0.8457 f 0.8971 f 0.9486",
      "pentultimate": "d f 0",
      "master pentultimate": "d f 0.1",
      "elite pentultimate": "d f 0 f 0.145905",
      "starminx": "d v 0.937962370425399",
      "starminx 2": "d f 0.23606797749979",
      "pyraminx crystal": "d f 0.447213595499989",
      "chopasaurus": "d v 0",
      "big chop": "d e 0",
      "skewb diamond": "o f 0",
      "FTO": "o f 0.333333333333333",
      "master FTO": "o f 0.5 f 0",
      "Christopher's jewel": "o v 0.577350269189626",
      "octastar": "o e 0",
      "Trajber's octahedron": "o v 0.433012701892219",
      "radio chop": "i f 0",
      "icosamate": "i v 0",
      "icosahedron 2": "i v 0.18759247376021",
      "icosahedron 3": "i v 0.18759247376021 e 0",
      "icosahedron static faces": "i v 0.84",
      "icosahedron moving faces": "i v 0.73",
      "Eitan's star": "i f 0.61803398874989",
      "2x2x2 + dino": "c f 0 v 0.577350269189626",
      "2x2x2 + little chop": "c f 0 e 0",
      "dino + little chop": "c v 0.577350269189626 e 0",
      "2x2x2 + dino + little chop": "c f 0 v 0.577350269189626 e 0",
      "megaminx + chopasaurus": "d f 0.61803398875 v 0",
      "starminx combo": "d f 0.23606797749979 v 0.937962370425399"
    };
  }
});

// src/cubing/puzzle-geometry/Quat.ts
function centermassface(face2) {
  let s = new Quat(0, 0, 0, 0);
  for (let i2 = 0; i2 < face2.length; i2++) {
    s = s.sum(face2[i2]);
  }
  return s.smul(1 / face2.length);
}
function solvethreeplanes(p1, p2, p3, planes) {
  const p = planes[p1].intersect3(planes[p2], planes[p3]);
  if (!p) {
    return p;
  }
  for (let i2 = 0; i2 < planes.length; i2++) {
    if (i2 !== p1 && i2 !== p2 && i2 !== p3) {
      const dt = planes[i2].b * p.b + planes[i2].c * p.c + planes[i2].d * p.d;
      if (planes[i2].a > 0 && dt > planes[i2].a || planes[i2].a < 0 && dt < planes[i2].a) {
        return false;
      }
    }
  }
  return p;
}
var eps, Quat;
var init_Quat = __esm({
  "src/cubing/puzzle-geometry/Quat.ts"() {
    eps = 1e-9;
    Quat = class {
      constructor(a, b2, c, d2) {
        this.a = a;
        this.b = b2;
        this.c = c;
        this.d = d2;
      }
      mul(q) {
        return new Quat(this.a * q.a - this.b * q.b - this.c * q.c - this.d * q.d, this.a * q.b + this.b * q.a + this.c * q.d - this.d * q.c, this.a * q.c - this.b * q.d + this.c * q.a + this.d * q.b, this.a * q.d + this.b * q.c - this.c * q.b + this.d * q.a);
      }
      toString() {
        return `Q[${this.a},${this.b},${this.c},${this.d}]`;
      }
      dist(q) {
        return Math.hypot(this.a - q.a, this.b - q.b, this.c - q.c, this.d - q.d);
      }
      len() {
        return Math.hypot(this.a, this.b, this.c, this.d);
      }
      cross(q) {
        return new Quat(0, this.c * q.d - this.d * q.c, this.d * q.b - this.b * q.d, this.b * q.c - this.c * q.b);
      }
      dot(q) {
        return this.b * q.b + this.c * q.c + this.d * q.d;
      }
      normalize() {
        const d2 = Math.sqrt(this.dot(this));
        return new Quat(this.a / d2, this.b / d2, this.c / d2, this.d / d2);
      }
      makenormal() {
        return new Quat(0, this.b, this.c, this.d).normalize();
      }
      normalizeplane() {
        const d2 = Math.hypot(this.b, this.c, this.d);
        return new Quat(this.a / d2, this.b / d2, this.c / d2, this.d / d2);
      }
      smul(m) {
        return new Quat(this.a * m, this.b * m, this.c * m, this.d * m);
      }
      sum(q) {
        return new Quat(this.a + q.a, this.b + q.b, this.c + q.c, this.d + q.d);
      }
      sub(q) {
        return new Quat(this.a - q.a, this.b - q.b, this.c - q.c, this.d - q.d);
      }
      angle() {
        return 2 * Math.acos(this.a);
      }
      invrot() {
        return new Quat(this.a, -this.b, -this.c, -this.d);
      }
      det3x3(a00, a01, a02, a10, a11, a12, a20, a21, a22) {
        return a00 * (a11 * a22 - a12 * a21) + a01 * (a12 * a20 - a10 * a22) + a02 * (a10 * a21 - a11 * a20);
      }
      rotateplane(q) {
        const t2 = q.mul(new Quat(0, this.b, this.c, this.d)).mul(q.invrot());
        t2.a = this.a;
        return t2;
      }
      orthogonal() {
        const ab = Math.abs(this.b);
        const ac = Math.abs(this.c);
        const ad = Math.abs(this.d);
        if (ab < ac && ab < ad) {
          return this.cross(new Quat(0, 1, 0, 0)).normalize();
        } else if (ac < ab && ac < ad) {
          return this.cross(new Quat(0, 0, 1, 0)).normalize();
        } else {
          return this.cross(new Quat(0, 0, 0, 1)).normalize();
        }
      }
      pointrotation(b2) {
        const a = this.normalize();
        b2 = b2.normalize();
        if (a.sub(b2).len() < eps) {
          return new Quat(1, 0, 0, 0);
        }
        let h = a.sum(b2);
        if (h.len() < eps) {
          h = h.orthogonal();
        } else {
          h = h.normalize();
        }
        const r3 = a.cross(h);
        r3.a = a.dot(h);
        return r3;
      }
      unproject(b2) {
        return this.sum(b2.smul(-this.dot(b2) / (this.len() * b2.len())));
      }
      rotatepoint(q) {
        return q.mul(this).mul(q.invrot());
      }
      rotateface(face2) {
        return face2.map((_) => _.rotatepoint(this));
      }
      intersect3(p2, p3) {
        const det = this.det3x3(this.b, this.c, this.d, p2.b, p2.c, p2.d, p3.b, p3.c, p3.d);
        if (Math.abs(det) < eps) {
          return false;
        }
        return new Quat(0, this.det3x3(this.a, this.c, this.d, p2.a, p2.c, p2.d, p3.a, p3.c, p3.d) / det, this.det3x3(this.b, this.a, this.d, p2.b, p2.a, p2.d, p3.b, p3.a, p3.d) / det, this.det3x3(this.b, this.c, this.a, p2.b, p2.c, p2.a, p3.b, p3.c, p3.a) / det);
      }
      side(x) {
        if (x > eps) {
          return 1;
        }
        if (x < -eps) {
          return -1;
        }
        return 0;
      }
      cutface(face2) {
        const d2 = this.a;
        let seen = 0;
        let r3 = null;
        for (let i2 = 0; i2 < face2.length; i2++) {
          seen |= 1 << this.side(face2[i2].dot(this) - d2) + 1;
        }
        if ((seen & 5) === 5) {
          r3 = [];
          const inout = face2.map((_) => this.side(_.dot(this) - d2));
          for (let s = -1; s <= 1; s += 2) {
            const nface = [];
            for (let k = 0; k < face2.length; k++) {
              if (inout[k] === s || inout[k] === 0) {
                nface.push(face2[k]);
              }
              const kk = (k + 1) % face2.length;
              if (inout[k] + inout[kk] === 0 && inout[k] !== 0) {
                const vk = face2[k].dot(this) - d2;
                const vkk = face2[kk].dot(this) - d2;
                const r4 = vk / (vk - vkk);
                const pt = face2[k].smul(1 - r4).sum(face2[kk].smul(r4));
                nface.push(pt);
              }
            }
            r3.push(nface);
          }
        }
        return r3;
      }
      cutfaces(faces) {
        const nfaces = [];
        for (let j = 0; j < faces.length; j++) {
          const face2 = faces[j];
          const t2 = this.cutface(face2);
          if (t2) {
            nfaces.push(t2[0]);
            nfaces.push(t2[1]);
          } else {
            nfaces.push(face2);
          }
        }
        return nfaces;
      }
      faceside(face2) {
        const d2 = this.a;
        for (let i2 = 0; i2 < face2.length; i2++) {
          const s = this.side(face2[i2].dot(this) - d2);
          if (s !== 0) {
            return s;
          }
        }
        throw new Error("Could not determine side of plane in faceside");
      }
      sameplane(p) {
        const a = this.normalize();
        const b2 = p.normalize();
        return a.dist(b2) < eps || a.dist(b2.smul(-1)) < eps;
      }
      makecut(r3) {
        return new Quat(r3, this.b, this.c, this.d);
      }
    };
  }
});

// src/cubing/puzzle-geometry/PlatonicGenerator.ts
function cube() {
  const s5 = Math.sqrt(0.5);
  return [new Quat(s5, s5, 0, 0), new Quat(s5, 0, s5, 0)];
}
function tetrahedron() {
  return [new Quat(0.5, 0.5, 0.5, 0.5), new Quat(0.5, 0.5, 0.5, -0.5)];
}
function dodecahedron() {
  const d36 = 2 * Math.PI / 10;
  let dx = 0.5 + 0.3 * Math.sqrt(5);
  let dy = 0.5 + 0.1 * Math.sqrt(5);
  const dd = Math.sqrt(dx * dx + dy * dy);
  dx /= dd;
  dy /= dd;
  return [
    new Quat(Math.cos(d36), dx * Math.sin(d36), dy * Math.sin(d36), 0),
    new Quat(0.5, 0.5, 0.5, 0.5)
  ];
}
function icosahedron() {
  let dx = 1 / 6 + Math.sqrt(5) / 6;
  let dy = 2 / 3 + Math.sqrt(5) / 3;
  const dd = Math.sqrt(dx * dx + dy * dy);
  dx /= dd;
  dy /= dd;
  const ang = 2 * Math.PI / 6;
  return [
    new Quat(Math.cos(ang), dx * Math.sin(ang), dy * Math.sin(ang), 0),
    new Quat(Math.cos(ang), -dx * Math.sin(ang), dy * Math.sin(ang), 0)
  ];
}
function octahedron() {
  const s5 = Math.sqrt(0.5);
  return [new Quat(0.5, 0.5, 0.5, 0.5), new Quat(s5, 0, 0, s5)];
}
function closure(g) {
  const q = [new Quat(1, 0, 0, 0)];
  for (let i2 = 0; i2 < q.length; i2++) {
    for (let j = 0; j < g.length; j++) {
      const ns = g[j].mul(q[i2]);
      const negns = ns.smul(-1);
      let wasseen = false;
      for (let k = 0; k < q.length; k++) {
        if (ns.dist(q[k]) < eps2 || negns.dist(q[k]) < eps2) {
          wasseen = true;
          break;
        }
      }
      if (!wasseen) {
        q.push(ns);
      }
    }
  }
  return q;
}
function uniqueplanes(p, g) {
  const planes = [];
  const planerot = [];
  for (let i2 = 0; i2 < g.length; i2++) {
    const p2 = p.rotateplane(g[i2]);
    let wasseen = false;
    for (let j = 0; j < planes.length; j++) {
      if (p2.dist(planes[j]) < eps2) {
        wasseen = true;
        break;
      }
    }
    if (!wasseen) {
      planes.push(p2);
      planerot.push(g[i2]);
    }
  }
  return planerot;
}
function getface(planes) {
  const face2 = [];
  for (let i2 = 1; i2 < planes.length; i2++) {
    for (let j = i2 + 1; j < planes.length; j++) {
      const p = solvethreeplanes(0, i2, j, planes);
      if (p) {
        let wasseen = false;
        for (let k = 0; k < face2.length; k++) {
          if (p.dist(face2[k]) < eps2) {
            wasseen = true;
            break;
          }
        }
        if (!wasseen) {
          face2.push(p);
        }
      }
    }
  }
  for (; ; ) {
    let changed = false;
    for (let i2 = 0; i2 < face2.length; i2++) {
      const j = (i2 + 1) % face2.length;
      if (planes[0].dot(face2[i2].cross(face2[j])) < 0) {
        const t2 = face2[i2];
        face2[i2] = face2[j];
        face2[j] = t2;
        changed = true;
      }
    }
    if (!changed) {
      break;
    }
  }
  return face2;
}
var eps2;
var init_PlatonicGenerator = __esm({
  "src/cubing/puzzle-geometry/PlatonicGenerator.ts"() {
    init_Quat();
    eps2 = 1e-9;
  }
});

// src/cubing/puzzle-geometry/SchreierSims.ts
function schreierSims(g, disp) {
  const n = g[0].p.length;
  const e = identity(n);
  let sgs = [];
  let sgsi = [];
  let sgslen = [];
  let Tk = [];
  let Tklen = [];
  function resolve(p) {
    for (let i2 = p.p.length - 1; i2 >= 0; i2--) {
      const j = p.p[i2];
      if (j !== i2) {
        if (!sgs[i2][j]) {
          return false;
        }
        p = p.mul(sgsi[i2][j]);
      }
    }
    return true;
  }
  function knutha(k, p, len) {
    Tk[k].push(p);
    Tklen[k].push(len);
    for (let i2 = 0; i2 < sgs[k].length; i2++) {
      if (sgs[k][i2]) {
        knuthb(k, sgs[k][i2].mul(p), len + sgslen[k][i2]);
      }
    }
  }
  function knuthb(k, p, len) {
    const j = p.p[k];
    if (!sgs[k][j]) {
      sgs[k][j] = p;
      sgsi[k][j] = p.inv();
      sgslen[k][j] = len;
      for (let i2 = 0; i2 < Tk[k].length; i2++) {
        knuthb(k, p.mul(Tk[k][i2]), len + Tklen[k][i2]);
      }
      return;
    }
    const p2 = p.mul(sgsi[k][j]);
    if (!resolve(p2)) {
      knutha(k - 1, p2, len + sgslen[k][j]);
    }
  }
  function getsgs() {
    sgs = [];
    sgsi = [];
    Tk = [];
    sgslen = [];
    Tklen = [];
    for (let i2 = 0; i2 < n; i2++) {
      sgs.push([]);
      sgsi.push([]);
      sgslen.push([]);
      Tk.push([]);
      Tklen.push([]);
      sgs[i2][i2] = e;
      sgsi[i2][i2] = e;
      sgslen[i2][i2] = 0;
    }
    let none = 0;
    let sz = 1;
    for (let i2 = 0; i2 < g.length; i2++) {
      knutha(n - 1, g[i2], 1);
      sz = 1;
      let tks = 0;
      let sollen = 0;
      const avgs = [];
      const mults = new FactoredNumber();
      for (let j = 0; j < n; j++) {
        let cnt = 0;
        let lensum = 0;
        for (let k = 0; k < n; k++) {
          if (sgs[j][k]) {
            cnt++;
            lensum += sgslen[j][k];
            if (j !== k) {
              none++;
            }
          }
        }
        tks += Tk[j].length;
        sz *= cnt;
        if (cnt > 1) {
          mults.multiply(cnt);
        }
        const avg = lensum / cnt;
        avgs.push(avg);
        sollen += avg;
      }
      disp(`${i2}: sz ${sz} T ${tks} sol ${sollen} none ${none} mults ${mults.toString()}`);
    }
    return sz;
  }
  return getsgs();
}
var FactoredNumber;
var init_SchreierSims = __esm({
  "src/cubing/puzzle-geometry/SchreierSims.ts"() {
    init_Perm();
    FactoredNumber = class {
      constructor() {
        this.mult = [];
      }
      multiply(n) {
        for (let f = 2; f * f <= n; f++) {
          while (n % f === 0) {
            if (this.mult[f] !== void 0) {
              this.mult[f]++;
            } else {
              this.mult[f] = 1;
            }
            n /= f;
          }
        }
        if (n > 1) {
          if (this.mult[n] !== void 0) {
            this.mult[n]++;
          } else {
            this.mult[n] = 1;
          }
        }
      }
      toString() {
        let r3 = "";
        for (let i2 = 0; i2 < this.mult.length; i2++) {
          if (this.mult[i2] !== void 0) {
            if (r3 !== "") {
              r3 += "*";
            }
            r3 += i2;
            if (this.mult[i2] > 1) {
              r3 += `^${this.mult[i2]}`;
            }
          }
        }
        return r3;
      }
    };
  }
});

// src/cubing/puzzle-geometry/PuzzleGeometry.ts
function tstart(s) {
  return s;
}
function tend(_) {
}
function expandfaces(rots, faces) {
  const nfaces = [];
  for (const rot of rots) {
    for (const face2 of faces) {
      nfaces.push(face2.rotate(rot));
    }
  }
  return nfaces;
}
function defaultnets() {
  return {
    4: [["F", "D", "L", "R"]],
    6: [
      ["F", "D", "L", "U", "R"],
      ["R", "F", "", "B", ""]
    ],
    8: [
      ["F", "D", "L", "R"],
      ["D", "F", "BR", ""],
      ["BR", "D", "", "BB"],
      ["BB", "BR", "U", "BL"]
    ],
    12: [
      ["U", "F", "", "", "", ""],
      ["F", "U", "R", "C", "A", "L"],
      ["R", "F", "", "", "E", ""],
      ["E", "R", "", "BF", "", ""],
      ["BF", "E", "BR", "BL", "I", "D"]
    ],
    20: [
      ["R", "C", "F", "E"],
      ["F", "R", "L", "U"],
      ["L", "F", "A", ""],
      ["E", "R", "G", "I"],
      ["I", "E", "S", "H"],
      ["S", "I", "J", "B"],
      ["B", "S", "K", "D"],
      ["K", "B", "M", "O"],
      ["O", "K", "P", "N"],
      ["P", "O", "Q", ""]
    ]
  };
}
function defaultcolors() {
  return {
    4: { F: "#00ff00", D: "#ffff00", L: "#ff0000", R: "#0000ff" },
    6: {
      U: "#ffffff",
      F: "#00ff00",
      R: "#ff0000",
      D: "#ffff00",
      B: "#0000ff",
      L: "#ff8000"
    },
    8: {
      U: "#ffffff",
      F: "#ff0000",
      R: "#00bb00",
      D: "#ffff00",
      BB: "#1122ff",
      L: "#9524c5",
      BL: "#ff8800",
      BR: "#aaaaaa"
    },
    12: {
      U: "#ffffff",
      F: "#006633",
      R: "#ff0000",
      C: "#ffffd0",
      A: "#3399ff",
      L: "#660099",
      E: "#ff66cc",
      BF: "#99ff00",
      BR: "#0000ff",
      BL: "#ffff00",
      I: "#ff6633",
      D: "#999999"
    },
    20: {
      R: "#db69f0",
      C: "#178fde",
      F: "#23238b",
      E: "#9cc726",
      L: "#2c212d",
      U: "#177fa7",
      A: "#e0de7f",
      G: "#2b57c0",
      I: "#41126b",
      S: "#4b8c28",
      H: "#7c098d",
      J: "#7fe7b4",
      B: "#85fb74",
      K: "#3f4bc3",
      D: "#0ff555",
      M: "#f1c2c8",
      O: "#58d340",
      P: "#c514f2",
      N: "#14494e",
      Q: "#8b1be1"
    }
  };
}
function defaultfaceorders() {
  return {
    4: ["F", "D", "L", "R"],
    6: ["U", "D", "F", "B", "L", "R"],
    8: ["F", "BB", "D", "U", "BR", "L", "R", "BL"],
    12: ["L", "E", "F", "BF", "R", "I", "U", "D", "BR", "A", "BL", "C"],
    20: [
      "L",
      "S",
      "E",
      "O",
      "F",
      "B",
      "I",
      "P",
      "R",
      "K",
      "U",
      "D",
      "J",
      "A",
      "Q",
      "H",
      "G",
      "N",
      "M",
      "C"
    ]
  };
}
function defaultOrientations() {
  return {
    4: [
      ["FLR", [0, 1, 0]],
      ["F", [0, 0, 1]]
    ],
    6: [
      ["U", [0, 1, 0]],
      ["F", [0, 0, 1]]
    ],
    8: [
      ["U", [0, 1, 0]],
      ["F", [0, 0, 1]]
    ],
    12: [
      ["U", [0, 1, 0]],
      ["F", [0, 0, 1]]
    ],
    20: [
      ["GUQMJ", [0, 1, 0]],
      ["F", [0, 0, 1]]
    ]
  };
}
function findelement(a, p) {
  for (let i2 = 0; i2 < a.length; i2++) {
    if (a[i2][0].dist(p) < eps3) {
      return i2;
    }
  }
  throw new Error("Element not found");
}
function getPG3DNamedPuzzles() {
  return PGPuzzles;
}
function getPuzzleDescriptionString(puzzleName) {
  return PGPuzzles[puzzleName];
}
function parsePuzzleDescription(s) {
  const a = s.split(/ /).filter(Boolean);
  if (a.length % 2 === 0) {
    return null;
  }
  const shape = a[0];
  if (shape !== "o" && shape !== "c" && shape !== "i" && shape !== "d" && shape !== "t") {
    return null;
  }
  const cuts = [];
  for (let i2 = 1; i2 < a.length; i2 += 2) {
    if (a[i2] !== "f" && a[i2] !== "v" && a[i2] !== "e") {
      return null;
    }
    cuts.push({ cutType: a[i2], distance: parseFloat(a[i2 + 1]) });
  }
  return { shape, cuts };
}
function getPuzzleGeometryByDesc(desc, options = {}) {
  const parsed = parsePuzzleDescription(desc);
  if (parsed === null) {
    throw new Error("Could not parse the puzzle description");
  }
  const pg = new PuzzleGeometry(parsed, Object.assign({}, { allMoves: true }, options));
  pg.allstickers();
  pg.genperms();
  return pg;
}
function getPuzzleGeometryByName(puzzleName, options) {
  return getPuzzleGeometryByDesc(PGPuzzles[puzzleName], options);
}
function getmovename(geo, bits, slices) {
  let inverted = false;
  if (slices - bits[1] < bits[0]) {
    geo = [geo[2], geo[3], geo[0], geo[1]];
    bits = [slices - bits[1], slices - bits[0]];
    inverted = true;
  }
  let movenameFamily = geo[0];
  let movenamePrefix = "";
  if (bits[0] === 0 && bits[1] === slices) {
    movenameFamily = movenameFamily + "v";
  } else if (bits[0] === bits[1]) {
    if (bits[1] > 0) {
      movenamePrefix = String(bits[1] + 1);
    }
  } else if (bits[0] === 0) {
    movenameFamily = movenameFamily.toLowerCase();
    if (bits[1] > 1) {
      movenamePrefix = String(bits[1] + 1);
    }
  } else {
    throw `We only support slice and outer block moves right now. ${bits}`;
  }
  return [movenamePrefix + movenameFamily, inverted];
}
function splitByFaceNames(s, facenames) {
  const r3 = [];
  let at = 0;
  while (at < s.length) {
    if (at > 0 && at < s.length && s[at] === "_") {
      at++;
    }
    let currentMatch = "";
    for (const facename of facenames) {
      if (s.substr(at).startsWith(facename[1]) && facename[1].length > currentMatch.length) {
        currentMatch = facename[1];
      }
    }
    if (currentMatch !== "") {
      r3.push(currentMatch);
      at += currentMatch.length;
    } else {
      throw new Error("Could not split " + s + " into face names.");
    }
  }
  return r3;
}
function toCoords(q, maxdist) {
  return [q.b / maxdist, -q.c / maxdist, q.d / maxdist];
}
function toFaceCoords(q, maxdist) {
  const r3 = [];
  const n = q.length;
  for (let i2 = 0; i2 < n; i2++) {
    const pt = toCoords(q.get(n - i2 - 1), maxdist);
    r3[3 * i2] = pt[0];
    r3[3 * i2 + 1] = pt[1];
    r3[3 * i2 + 2] = pt[2];
  }
  return r3;
}
var Face, FaceTree, eps3, copyright, permissivieMoveParsing, PuzzleGeometry, PGNotation;
var init_PuzzleGeometry = __esm({
  "src/cubing/puzzle-geometry/PuzzleGeometry.ts"() {
    init_alg();
    init_FaceNameSwizzler();
    init_notation_mapping();
    init_Options();
    init_Perm();
    init_PermOriSet();
    init_PGPuzzles();
    init_PlatonicGenerator();
    init_Quat();
    init_SchreierSims();
    Face = class {
      constructor(q) {
        this.coords = new Array(q.length * 3);
        for (let i2 = 0; i2 < q.length; i2++) {
          this.coords[3 * i2] = q[i2].b;
          this.coords[3 * i2 + 1] = q[i2].c;
          this.coords[3 * i2 + 2] = q[i2].d;
        }
        this.length = q.length;
      }
      get(off) {
        return new Quat(0, this.coords[3 * off], this.coords[3 * off + 1], this.coords[3 * off + 2]);
      }
      centermass() {
        let sx = 0;
        let sy = 0;
        let sz = 0;
        for (let i2 = 0; i2 < this.length; i2++) {
          sx += this.coords[3 * i2];
          sy += this.coords[3 * i2 + 1];
          sz += this.coords[3 * i2 + 2];
        }
        return new Quat(0, sx / this.length, sy / this.length, sz / this.length);
      }
      rotate(q) {
        const a = [];
        for (let i2 = 0; i2 < this.length; i2++) {
          a.push(this.get(i2).rotatepoint(q));
        }
        return new Face(a);
      }
      rotateforward() {
        const a = [];
        for (let i2 = 1; i2 < this.length; i2++) {
          a.push(this.get(i2));
        }
        a.push(this.get(0));
        return new Face(a);
      }
    };
    FaceTree = class {
      constructor(face2, left, right) {
        this.face = face2;
        this.left = left;
        this.right = right;
      }
      split(q) {
        const t2 = q.cutface(this.face);
        if (t2 !== null) {
          if (this.left === void 0) {
            this.left = new FaceTree(t2[0]);
            this.right = new FaceTree(t2[1]);
          } else {
            this.left = this.left?.split(q);
            this.right = this.right?.split(q);
          }
        }
        return this;
      }
      collect(arr, leftfirst) {
        if (this.left === void 0) {
          arr.push(new Face(this.face));
        } else if (leftfirst) {
          this.left?.collect(arr, false);
          this.right?.collect(arr, true);
        } else {
          this.right?.collect(arr, false);
          this.left?.collect(arr, true);
        }
        return arr;
      }
    };
    eps3 = 1e-9;
    copyright = "PuzzleGeometry 0.1 Copyright 2018 Tomas Rokicki.";
    permissivieMoveParsing = false;
    PuzzleGeometry = class {
      constructor(puzzleDescription, options) {
        this.puzzleDescription = puzzleDescription;
        this.cmovesbyslice = [];
        this.duplicatedFaces = [];
        this.duplicatedCubies = [];
        this.fixedCubie = -1;
        this.net = [];
        this.colors = [];
        this.faceorder = [];
        this.faceprecedence = [];
        this.notationMapper = new NullMapper();
        this.addNotationMapper = "";
        this.setReidOrder = false;
        const t1 = tstart("genperms");
        this.options = new PuzzleGeometryFullOptions(options);
        if (this.options.verbosity > 0) {
          console.log(this.header("# "));
        }
        this.create(puzzleDescription);
        tend(t1);
      }
      create(puzzleDescription) {
        const { shape, cuts } = puzzleDescription;
        this.moveplanes = [];
        this.moveplanes2 = [];
        this.faces = [];
        this.cubies = [];
        let g = null;
        switch (shape) {
          case "c":
            g = cube();
            break;
          case "o":
            g = octahedron();
            break;
          case "i":
            g = icosahedron();
            break;
          case "t":
            g = tetrahedron();
            break;
          case "d":
            g = dodecahedron();
            break;
          default:
            throw new Error("Bad shape argument: " + shape);
        }
        this.rotations = closure(g);
        if (this.options.verbosity) {
          console.log("# Rotations: " + this.rotations.length);
        }
        const baseplane = g[0];
        this.baseplanerot = uniqueplanes(baseplane, this.rotations);
        const baseplanes = this.baseplanerot.map((_) => baseplane.rotateplane(_));
        this.baseplanes = baseplanes;
        this.baseFaceCount = baseplanes.length;
        const net = defaultnets()[baseplanes.length];
        this.net = net;
        this.colors = defaultcolors()[baseplanes.length];
        this.faceorder = defaultfaceorders()[baseplanes.length];
        if (this.options.verbosity > 0) {
          console.log("# Base planes: " + baseplanes.length);
        }
        const baseface = getface(baseplanes);
        const zero = new Quat(0, 0, 0, 0);
        if (this.options.verbosity > 0) {
          console.log("# Face vertices: " + baseface.length);
        }
        const facenormal = baseplanes[0].makenormal();
        const edgenormal = baseface[0].sum(baseface[1]).makenormal();
        const vertexnormal = baseface[0].makenormal();
        const boundary = new Quat(1, facenormal.b, facenormal.c, facenormal.d);
        if (this.options.verbosity > 0) {
          console.log("# Boundary is " + boundary);
        }
        const planerot = uniqueplanes(boundary, this.rotations);
        const planes = planerot.map((_) => boundary.rotateplane(_));
        const firstface = getface(planes);
        this.edgedistance = firstface[0].sum(firstface[1]).smul(0.5).dist(zero);
        this.vertexdistance = firstface[0].dist(zero);
        const cutplanes = [];
        const intersects2 = [];
        let sawface = false;
        let sawedge = false;
        let sawvertex = false;
        for (const cut of cuts) {
          let normal2 = null;
          let distance = 0;
          switch (cut.cutType) {
            case "f":
              normal2 = facenormal;
              distance = 1;
              sawface = true;
              break;
            case "v":
              normal2 = vertexnormal;
              distance = this.vertexdistance;
              sawvertex = true;
              break;
            case "e":
              normal2 = edgenormal;
              distance = this.edgedistance;
              sawedge = true;
              break;
            default:
              throw new Error("Bad cut argument: " + cut.cutType);
          }
          cutplanes.push(normal2.makecut(cut.distance));
          intersects2.push(cut.distance < distance);
        }
        if (this.options.addRotations) {
          if (!sawface) {
            cutplanes.push(facenormal.makecut(10));
          }
          if (!sawvertex) {
            cutplanes.push(vertexnormal.makecut(10));
          }
          if (!sawedge) {
            cutplanes.push(edgenormal.makecut(10));
          }
        }
        this.basefaces = [];
        for (const baseplanerot of this.baseplanerot) {
          const face2 = baseplanerot.rotateface(firstface);
          this.basefaces.push(new Face(face2));
        }
        const facenames = [];
        const faceplanes = [];
        const vertexnames = [];
        const edgenames = [];
        const edgesperface = firstface.length;
        function searchaddelement(a, p, name) {
          for (const el of a) {
            if (el[0].dist(p) < eps3) {
              el.push(name);
              return;
            }
          }
          a.push([p, name]);
        }
        for (let i2 = 0; i2 < this.baseplanerot.length; i2++) {
          const face2 = this.baseplanerot[i2].rotateface(firstface);
          for (let j = 0; j < face2.length; j++) {
            const jj = (j + 1) % face2.length;
            const midpoint = face2[j].sum(face2[jj]).smul(0.5);
            searchaddelement(edgenames, midpoint, i2);
          }
        }
        const otherfaces = [];
        for (let i2 = 0; i2 < this.baseplanerot.length; i2++) {
          const face2 = this.baseplanerot[i2].rotateface(firstface);
          const facelist = [];
          for (let j = 0; j < face2.length; j++) {
            const jj = (j + 1) % face2.length;
            const midpoint = face2[j].sum(face2[jj]).smul(0.5);
            const el = edgenames[findelement(edgenames, midpoint)];
            if (i2 === el[1]) {
              facelist.push(el[2]);
            } else if (i2 === el[2]) {
              facelist.push(el[1]);
            } else {
              throw new Error("Could not find edge");
            }
          }
          otherfaces.push(facelist);
        }
        const facenametoindex = {};
        const faceindextoname = [];
        faceindextoname.push(net[0][0]);
        facenametoindex[net[0][0]] = 0;
        faceindextoname[otherfaces[0][0]] = net[0][1];
        facenametoindex[net[0][1]] = otherfaces[0][0];
        for (const neti of net) {
          const f0 = neti[0];
          const fi = facenametoindex[f0];
          if (fi === void 0) {
            throw new Error("Bad edge description; first edge not connected");
          }
          let ii = -1;
          for (let j = 0; j < otherfaces[fi].length; j++) {
            const fn2 = faceindextoname[otherfaces[fi][j]];
            if (fn2 !== void 0 && fn2 === neti[1]) {
              ii = j;
              break;
            }
          }
          if (ii < 0) {
            throw new Error("First element of a net not known");
          }
          for (let j = 2; j < neti.length; j++) {
            if (neti[j] === "") {
              continue;
            }
            const of = otherfaces[fi][(j + ii - 1) % edgesperface];
            const fn2 = faceindextoname[of];
            if (fn2 !== void 0 && fn2 !== neti[j]) {
              throw new Error("Face mismatch in net");
            }
            faceindextoname[of] = neti[j];
            facenametoindex[neti[j]] = of;
          }
        }
        for (let i2 = 0; i2 < faceindextoname.length; i2++) {
          let found = false;
          for (let j = 0; j < this.faceorder.length; j++) {
            if (faceindextoname[i2] === this.faceorder[j]) {
              this.faceprecedence[i2] = j;
              found = true;
              break;
            }
          }
          if (!found) {
            throw new Error("Could not find face " + faceindextoname[i2] + " in face order list " + this.faceorder);
          }
        }
        for (let i2 = 0; i2 < this.baseplanerot.length; i2++) {
          const face2 = this.baseplanerot[i2].rotateface(firstface);
          const faceplane = boundary.rotateplane(this.baseplanerot[i2]);
          const facename = faceindextoname[i2];
          facenames.push([face2, facename]);
          faceplanes.push([faceplane, facename]);
        }
        for (let i2 = 0; i2 < this.baseplanerot.length; i2++) {
          const face2 = this.baseplanerot[i2].rotateface(firstface);
          const facename = faceindextoname[i2];
          for (let j = 0; j < face2.length; j++) {
            const jj = (j + 1) % face2.length;
            const midpoint = face2[j].sum(face2[jj]).smul(0.5);
            const jjj = (j + 2) % face2.length;
            const midpoint2 = face2[jj].sum(face2[jjj]).smul(0.5);
            const e1 = findelement(edgenames, midpoint);
            const e2 = findelement(edgenames, midpoint2);
            searchaddelement(vertexnames, face2[jj], [facename, e2, e1]);
          }
        }
        this.swizzler = new FaceNameSwizzler(facenames.map((_) => _[1]));
        const sep = this.swizzler.prefixFree ? "" : "_";
        for (let i2 = 0; i2 < edgenames.length; i2++) {
          if (edgenames[i2].length !== 3) {
            throw new Error("Bad length in edge names " + edgenames[i2]);
          }
          let c1 = faceindextoname[edgenames[i2][1]];
          const c2 = faceindextoname[edgenames[i2][2]];
          if (this.faceprecedence[edgenames[i2][1]] < this.faceprecedence[edgenames[i2][2]]) {
            c1 = c1 + sep + c2;
          } else {
            c1 = c2 + sep + c1;
          }
          edgenames[i2] = [edgenames[i2][0], c1];
        }
        for (let i2 = 0; i2 < vertexnames.length; i2++) {
          if (vertexnames[i2].length < 4) {
            throw new Error("Bad length in vertex names");
          }
          let st = 1;
          for (let j = 2; j < vertexnames[i2].length; j++) {
            if (this.faceprecedence[facenametoindex[vertexnames[i2][j][0]]] < this.faceprecedence[facenametoindex[vertexnames[i2][st][0]]]) {
              st = j;
            }
          }
          let r3 = "";
          for (let j = 1; j < vertexnames[i2].length; j++) {
            if (j === 1) {
              r3 = vertexnames[i2][st][0];
            } else {
              r3 = r3 + sep + vertexnames[i2][st][0];
            }
            for (let k = 1; k < vertexnames[i2].length; k++) {
              if (vertexnames[i2][st][1] === vertexnames[i2][k][2]) {
                st = k;
                break;
              }
            }
          }
          vertexnames[i2] = [vertexnames[i2][0], r3];
        }
        if (this.options.verbosity > 1) {
          console.log("# Face precedence list: " + this.faceorder.join(" "));
          console.log("# Face names: " + facenames.map((_) => _[1]).join(" "));
          console.log("# Edge names: " + edgenames.map((_) => _[1]).join(" "));
          console.log("# Vertex names: " + vertexnames.map((_) => _[1]).join(" "));
        }
        const geonormals = [];
        for (const faceplane of faceplanes) {
          geonormals.push([faceplane[0].makenormal(), faceplane[1], "f"]);
        }
        for (const edgename of edgenames) {
          geonormals.push([edgename[0].makenormal(), edgename[1], "e"]);
        }
        for (const vertexname of vertexnames) {
          geonormals.push([vertexname[0].makenormal(), vertexname[1], "v"]);
        }
        this.facenames = facenames;
        this.faceplanes = faceplanes;
        this.edgenames = edgenames;
        this.vertexnames = vertexnames;
        this.geonormals = geonormals;
        const geonormalnames = geonormals.map((_) => _[1]);
        this.swizzler.setGripNames(geonormalnames);
        if (this.options.verbosity > 0) {
          console.log("# Distances: face " + 1 + " edge " + this.edgedistance + " vertex " + this.vertexdistance);
        }
        for (let c = 0; c < cutplanes.length; c++) {
          for (const rotation of this.rotations) {
            const q = cutplanes[c].rotateplane(rotation);
            let wasseen = false;
            for (const moveplane of this.moveplanes) {
              if (q.sameplane(moveplane)) {
                wasseen = true;
                break;
              }
            }
            if (!wasseen) {
              this.moveplanes.push(q);
              if (intersects2[c]) {
                this.moveplanes2.push(q);
              }
            }
          }
        }
        let ft = new FaceTree(firstface);
        const tar = this.moveplanes2.slice();
        let rval = 31;
        for (let i2 = 0; i2 < tar.length; i2++) {
          const j = i2 + Math.floor((tar.length - i2) * (rval / 65536));
          ft = ft.split(tar[j]);
          tar[j] = tar[i2];
          rval = (rval * 1657 + 101) % 65536;
        }
        const faces = ft.collect([], true);
        this.faces = faces;
        if (this.options.verbosity > 0) {
          console.log("# Faces is now " + faces.length);
        }
        this.stickersperface = faces.length;
        const simplerot = [];
        const cm = centermassface(firstface);
        for (const rotation of this.rotations) {
          const f = rotation.rotateface(firstface);
          if (cm.dist(centermassface(f)) < eps3) {
            simplerot.push(rotation);
          }
        }
        const finished = new Array(faces.length);
        const sortme = [];
        for (let i2 = 0; i2 < faces.length; i2++) {
          const cm2 = faces[i2].centermass();
          sortme.push([cm.dist(cm2), cm2, i2]);
        }
        sortme.sort((a, b2) => a[0] - b2[0]);
        for (let ii = 0; ii < faces.length; ii++) {
          const i2 = sortme[ii][2];
          if (!finished[i2]) {
            finished[i2] = true;
            for (const rot of simplerot) {
              const f2 = faces[i2].rotate(rot);
              const cm2 = f2.centermass();
              for (let kk = ii + 1; kk < faces.length; kk++) {
                if (sortme[kk][0] - sortme[ii][0] > eps3) {
                  break;
                }
                const k = sortme[kk][2];
                if (!finished[k] && cm2.dist(sortme[kk][1]) < eps3) {
                  finished[k] = true;
                  faces[k] = f2;
                  break;
                }
              }
            }
          }
        }
        this.shortedge = 1e99;
        for (const face2 of faces) {
          for (let j = 0; j < face2.length; j++) {
            const k = (j + 1) % face2.length;
            const t2 = face2.get(j).dist(face2.get(k));
            if (t2 < this.shortedge) {
              this.shortedge = t2;
            }
          }
        }
        if (this.options.verbosity > 0) {
          console.log("# Short edge is " + this.shortedge);
        }
        if (shape === "c" && sawface && !sawedge && !sawvertex) {
          this.addNotationMapper = "NxNxNCubeMapper";
          this.setReidOrder = true;
        }
        if (shape === "c" && sawvertex && !sawface && !sawedge) {
          this.addNotationMapper = "SkewbMapper";
        }
        if (shape === "t" && (sawvertex || sawface) && !sawedge) {
          this.addNotationMapper = "PyraminxOrTetraminxMapper";
        }
        if (shape === "o" && sawface) {
          this.notationMapper = new FaceRenamingMapper(this.swizzler, new FaceNameSwizzler(["F", "D", "L", "BL", "R", "U", "BR", "B"]));
          if (!sawedge && !sawvertex) {
            this.addNotationMapper = "FTOMapper";
          }
        }
        if (shape === "d" && sawface) {
          this.addNotationMapper = "MegaminxMapper";
          this.notationMapper = new FaceRenamingMapper(this.swizzler, new FaceNameSwizzler([
            "U",
            "F",
            "L",
            "BL",
            "BR",
            "R",
            "FR",
            "FL",
            "DL",
            "B",
            "DR",
            "D"
          ]));
        }
      }
      keyface(face2) {
        return this.keyface2(face2.centermass());
      }
      keyface2(cm) {
        let s = "";
        const sfcc = String.fromCharCode;
        for (const moveplaneset of this.moveplanesets) {
          if (moveplaneset.length > 0) {
            const dv = cm.dot(moveplaneset[0]);
            let t2 = 0;
            let b2 = 1;
            while (b2 * 2 <= moveplaneset.length) {
              b2 *= 2;
            }
            for (; b2 > 0; b2 >>= 1) {
              if (t2 + b2 <= moveplaneset.length && dv > moveplaneset[t2 + b2 - 1].a) {
                t2 += b2;
              }
            }
            if (t2 < 47) {
              s = s + sfcc(33 + t2);
            } else if (t2 < 47 + 47 * 47) {
              s = s + sfcc(33 + 47 + Math.floor(t2 / 47) - 1) + sfcc(33 + t2 % 47);
            } else if (t2 < 47 + 47 * 47 + 47 * 47 * 47) {
              s = s + sfcc(33 + 47 + Math.floor((t2 - 47) / (47 * 47) - 1)) + sfcc(33 + 47 + Math.floor((t2 - 47) / 47) % 47) + sfcc(33 + t2 % 47);
            } else {
              throw Error("Too many slices for cubie encoding");
            }
          }
        }
        return s;
      }
      keyface3(face2) {
        const cm = face2.centermass();
        const r3 = [];
        for (const moveplaneset of this.moveplanesets) {
          if (moveplaneset.length > 0) {
            const dv = cm.dot(moveplaneset[0]);
            let t2 = 0;
            let b2 = 1;
            while (b2 * 2 <= moveplaneset.length) {
              b2 *= 2;
            }
            for (; b2 > 0; b2 >>= 1) {
              if (t2 + b2 <= moveplaneset.length && dv > moveplaneset[t2 + b2 - 1].a) {
                t2 += b2;
              }
            }
            r3.push(t2);
          }
        }
        return r3;
      }
      findface(cm) {
        const key = this.keyface2(cm);
        const arr = this.facelisthash.get(key);
        if (arr.length === 1) {
          return arr[0];
        }
        for (let i2 = 0; i2 + 1 < arr.length; i2++) {
          const face2 = this.facelisthash.get(key)[i2];
          if (Math.abs(cm.dist(this.facecentermass[face2])) < eps3) {
            return face2;
          }
        }
        return arr[arr.length - 1];
      }
      project2d(facen, edgen, targvec) {
        const face2 = this.facenames[facen][0];
        const edgen2 = (edgen + 1) % face2.length;
        const plane = this.baseplanes[facen];
        let x0 = face2[edgen2].sub(face2[edgen]);
        const olen = x0.len();
        x0 = x0.normalize();
        const y0 = x0.cross(plane).normalize();
        let delta = targvec[1].sub(targvec[0]);
        const len = delta.len() / olen;
        delta = delta.normalize();
        const cosr = delta.b;
        const sinr = delta.c;
        const x1 = x0.smul(cosr).sub(y0.smul(sinr)).smul(len);
        const y1 = y0.smul(cosr).sum(x0.smul(sinr)).smul(len);
        const off = new Quat(0, targvec[0].b - x1.dot(face2[edgen]), targvec[0].c - y1.dot(face2[edgen]), 0);
        return [x1, y1, off];
      }
      allstickers() {
        const t1 = tstart("allstickers");
        this.faces = expandfaces(this.baseplanerot, this.faces);
        if (this.options.verbosity > 0) {
          console.log("# Total stickers is now " + this.faces.length);
        }
        this.facecentermass = new Array(this.faces.length);
        for (let i2 = 0; i2 < this.faces.length; i2++) {
          this.facecentermass[i2] = this.faces[i2].centermass();
        }
        const moveplanesets = [];
        const moveplanenormals = [];
        for (const q of this.moveplanes) {
          const qnormal = q.makenormal();
          let wasseen = false;
          for (const moveplanenormal of moveplanenormals) {
            if (qnormal.sameplane(moveplanenormal.makenormal())) {
              wasseen = true;
            }
          }
          if (!wasseen) {
            moveplanenormals.push(qnormal);
            moveplanesets.push([]);
          }
        }
        for (const q of this.moveplanes2) {
          const qnormal = q.makenormal();
          for (let j = 0; j < moveplanenormals.length; j++) {
            if (qnormal.sameplane(moveplanenormals[j])) {
              moveplanesets[j].push(q);
              break;
            }
          }
        }
        for (let i2 = 0; i2 < moveplanesets.length; i2++) {
          const q = moveplanesets[i2].map((_) => _.normalizeplane());
          const goodnormal = moveplanenormals[i2];
          for (let j = 0; j < q.length; j++) {
            if (q[j].makenormal().dist(goodnormal) > eps3) {
              q[j] = q[j].smul(-1);
            }
          }
          q.sort((a, b2) => a.a - b2.a);
          moveplanesets[i2] = q;
        }
        this.moveplanesets = moveplanesets;
        this.moveplanenormals = moveplanenormals;
        const sizes = moveplanesets.map((_) => _.length);
        if (this.options.verbosity > 0) {
          console.log("# Move plane sets: " + sizes);
        }
        const moverotations = [];
        for (let i2 = 0; i2 < moveplanesets.length; i2++) {
          moverotations.push([]);
        }
        for (const q of this.rotations) {
          if (Math.abs(Math.abs(q.a) - 1) < eps3) {
            continue;
          }
          const qnormal = q.makenormal();
          for (let j = 0; j < moveplanesets.length; j++) {
            if (qnormal.sameplane(moveplanenormals[j])) {
              moverotations[j].push(q);
              break;
            }
          }
        }
        this.moverotations = moverotations;
        for (let i2 = 0; i2 < moverotations.length; i2++) {
          const r3 = moverotations[i2];
          const goodnormal = r3[0].makenormal();
          for (let j = 0; j < r3.length; j++) {
            if (goodnormal.dist(r3[j].makenormal()) > eps3) {
              r3[j] = r3[j].smul(-1);
            }
          }
          r3.sort((a, b2) => a.angle() - b2.angle());
          if (moverotations[i2][0].dot(moveplanenormals[i2]) < 0) {
            r3.reverse();
          }
        }
        const sizes2 = moverotations.map((_) => 1 + _.length);
        this.movesetorders = sizes2;
        const movesetgeos = [];
        let gtype = "?";
        for (let i2 = 0; i2 < moveplanesets.length; i2++) {
          const p0 = moveplanenormals[i2];
          let neg = null;
          let pos = null;
          for (const geonormal of this.geonormals) {
            const d2 = p0.dot(geonormal[0]);
            if (Math.abs(d2 - 1) < eps3) {
              pos = [geonormal[1], geonormal[2]];
              gtype = geonormal[2];
            } else if (Math.abs(d2 + 1) < eps3) {
              neg = [geonormal[1], geonormal[2]];
              gtype = geonormal[2];
            }
          }
          if (pos === null || neg === null) {
            throw new Error("Saw positive or negative sides as null");
          }
          movesetgeos.push([
            pos[0],
            pos[1],
            neg[0],
            neg[1],
            1 + moveplanesets[i2].length
          ]);
          if (this.addNotationMapper === "NxNxNCubeMapper" && gtype === "f") {
            this.notationMapper = new NxNxNCubeMapper(1 + moveplanesets[i2].length);
            this.addNotationMapper = "";
          }
          if (this.addNotationMapper === "SkewbMapper" && moveplanesets[0].length === 1) {
            this.notationMapper = new SkewbNotationMapper(this.swizzler);
            this.addNotationMapper = "";
          }
          if (this.addNotationMapper === "PyraminxOrTetraminxMapper") {
            if (moveplanesets[0].length === 2 && moveplanesets[0][0].a === 0.333333333333333 && moveplanesets[0][1].a === 1.66666666666667) {
              this.notationMapper = new PyraminxNotationMapper(this.swizzler);
              this.addNotationMapper = "";
            } else {
              this.notationMapper = new TetraminxNotationMapper(this.swizzler);
              this.addNotationMapper = "";
            }
          }
          if (this.addNotationMapper === "MegaminxMapper" && gtype === "f") {
            if (1 + moveplanesets[i2].length === 3) {
              this.notationMapper = new MegaminxScramblingNotationMapper(this.notationMapper);
            }
            this.addNotationMapper = "";
          }
          if (this.addNotationMapper === "FTOMapper" && gtype === "f") {
            if (1 + moveplanesets[i2].length === 3) {
              this.notationMapper = new FTONotationMapper(this.notationMapper, this.swizzler);
            }
            this.addNotationMapper = "";
          }
        }
        this.movesetgeos = movesetgeos;
        const facelisthash = /* @__PURE__ */ new Map();
        const faces = this.faces;
        for (let i2 = 0; i2 < faces.length; i2++) {
          const face2 = faces[i2];
          const s = this.keyface(face2);
          if (!facelisthash.get(s)) {
            facelisthash.set(s, [i2]);
          } else {
            const arr = facelisthash.get(s);
            arr.push(i2);
            if (arr.length === this.baseFaceCount) {
              if (this.options.verbosity > 0) {
                console.log("# Splitting core.");
              }
              for (let suff = 0; suff < arr.length; suff++) {
                const s2 = s + " " + suff;
                facelisthash.set(s2, [arr[suff]]);
              }
            }
          }
        }
        this.facelisthash = facelisthash;
        if (this.options.verbosity > 0) {
          console.log("# Cubies: " + facelisthash.size);
        }
        const cubies = [];
        const facetocubie = [];
        const facetoord = [];
        for (const facelist of facelisthash.values()) {
          if (facelist.length === this.baseFaceCount) {
            continue;
          }
          if (facelist.length > 1) {
            const cm = facelist.map((_) => faces[_].centermass());
            const cmall = centermassface(cm);
            for (let looplimit = 0; facelist.length > 2; looplimit++) {
              let changed = false;
              for (let i2 = 0; i2 < facelist.length; i2++) {
                const j = (i2 + 1) % facelist.length;
                if (cmall.dot(cm[i2].cross(cm[j])) < 0) {
                  const u = cm[i2];
                  cm[i2] = cm[j];
                  cm[j] = u;
                  const v = facelist[i2];
                  facelist[i2] = facelist[j];
                  facelist[j] = v;
                  changed = true;
                }
              }
              if (!changed) {
                break;
              }
              if (looplimit > 1e3) {
                throw new Error("Bad epsilon math; too close to border");
              }
            }
            let mini = 0;
            let minf = facelist[mini];
            for (let i2 = 1; i2 < facelist.length; i2++) {
              const temp = facelist[i2];
              if (this.faceprecedence[this.getfaceindex(temp)] < this.faceprecedence[this.getfaceindex(minf)]) {
                mini = i2;
                minf = temp;
              }
            }
            if (mini !== 0) {
              const ofacelist = facelist.slice();
              for (let i2 = 0; i2 < facelist.length; i2++) {
                facelist[i2] = ofacelist[(mini + i2) % facelist.length];
              }
            }
          }
          for (let j = 0; j < facelist.length; j++) {
            const k = facelist[j];
            facetocubie[k] = cubies.length;
            facetoord[k] = j;
          }
          cubies.push(facelist);
        }
        this.cubies = cubies;
        this.facetocubie = facetocubie;
        this.facetoord = facetoord;
        const typenames = ["?", "CENTERS", "EDGES", "CORNERS", "C4RNER", "C5RNER"];
        const cubiesetnames = [];
        const cubietypecounts = [0, 0, 0, 0, 0, 0];
        const orbitoris = [];
        const seen = [];
        let cubiesetnum = 0;
        const cubiesetnums = [];
        const cubieordnums = [];
        const cubieords = [];
        const cubievaluemap = [];
        const getcolorkey = (cubienum) => {
          return cubies[cubienum].map((_) => this.getfaceindex(_)).join(" ");
        };
        const cubiesetcubies = [];
        for (let i2 = 0; i2 < cubies.length; i2++) {
          if (seen[i2]) {
            continue;
          }
          const cubie = cubies[i2];
          if (cubie.length === 0) {
            continue;
          }
          const cubiekeymap = {};
          let cubievalueid = 0;
          cubieords.push(0);
          cubiesetcubies.push([]);
          const facecnt = cubie.length;
          const typectr = cubietypecounts[facecnt]++;
          let typename = typenames[facecnt];
          if (typename === void 0 || facecnt === this.baseFaceCount) {
            typename = "CORE";
          }
          typename = typename + (typectr === 0 ? "" : typectr + 1);
          cubiesetnames[cubiesetnum] = typename;
          orbitoris[cubiesetnum] = facecnt;
          const queue = [i2];
          let qg = 0;
          seen[i2] = true;
          while (qg < queue.length) {
            const cind = queue[qg++];
            const cubiecolorkey = getcolorkey(cind);
            if (cubie.length > 1 || cubiekeymap[cubiecolorkey] === void 0) {
              cubiekeymap[cubiecolorkey] = cubievalueid++;
            }
            cubievaluemap[cind] = cubiekeymap[cubiecolorkey];
            cubiesetnums[cind] = cubiesetnum;
            cubiesetcubies[cubiesetnum].push(cind);
            cubieordnums[cind] = cubieords[cubiesetnum]++;
            if (queue.length < this.rotations.length) {
              const cm = this.facecentermass[cubies[cind][0]];
              for (const moverotation of moverotations) {
                const tq = this.facetocubie[this.findface(cm.rotatepoint(moverotation[0]))];
                if (!seen[tq]) {
                  queue.push(tq);
                  seen[tq] = true;
                }
              }
            }
          }
          cubiesetnum++;
        }
        if (this.setReidOrder && 4 <= this.stickersperface && this.stickersperface <= 9) {
          const reidorder = [
            [
              "UF",
              "UR",
              "UB",
              "UL",
              "DF",
              "DR",
              "DB",
              "DL",
              "FR",
              "FL",
              "BR",
              "BL"
            ],
            ["UFR", "URB", "UBL", "ULF", "DRF", "DFL", "DLB", "DBR"],
            ["U", "L", "F", "R", "B", "D"]
          ];
          const reidmap = {};
          for (const cubie of reidorder) {
            for (let j = 0; j < cubie.length; j++) {
              let mask = 0;
              for (let k = 0; k < cubie[j].length; k++) {
                mask |= 1 << cubie[j].charCodeAt(k) - 65;
              }
              reidmap[mask] = j;
            }
          }
          for (const cubieset of cubiesetcubies) {
            for (const cubienum of cubieset) {
              let mask = 0;
              for (const cubie of cubies[cubienum]) {
                mask |= 1 << this.facenames[this.getfaceindex(cubie)][1].charCodeAt(0) - 65;
              }
              cubieordnums[cubienum] = reidmap[mask];
            }
          }
        }
        this.cubiesetnums = cubiesetnums;
        this.cubieordnums = cubieordnums;
        this.cubiesetnames = cubiesetnames;
        this.cubieords = cubieords;
        this.orbitoris = orbitoris;
        this.cubievaluemap = cubievaluemap;
        this.cubiesetcubies = cubiesetcubies;
        if (this.options.fixedPieceType !== null) {
          for (let i2 = 0; i2 < cubies.length; i2++) {
            if (this.options.fixedPieceType === "v" && cubies[i2].length > 2 || this.options.fixedPieceType === "e" && cubies[i2].length === 2 || this.options.fixedPieceType === "f" && cubies[i2].length === 1) {
              this.fixedCubie = i2;
              break;
            }
          }
          if (this.fixedCubie < 0) {
            throw new Error("Could not find a cubie of type " + this.options.fixedPieceType + " to fix.");
          }
        }
        if (this.options.verbosity > 0) {
          console.log("# Cubie orbit sizes " + cubieords);
        }
        tend(t1);
      }
      unswizzle(mv) {
        const newmv = this.notationMapper.notationToInternal(mv);
        if (newmv === null) {
          return null;
        }
        return newmv.modified({ family: this.swizzler.unswizzle(newmv.family) });
      }
      stringToBlockMove(mv) {
        const re = RegExp("^(([0-9]+)-)?([0-9]+)?([^0-9]+)([0-9]+'?)?$");
        const p = mv.match(re);
        if (p === null) {
          throw new Error("Bad move passed " + mv);
        }
        const grip = p[4];
        let loslice = void 0;
        let hislice = void 0;
        if (p[2] !== void 0) {
          if (p[3] === void 0) {
            throw new Error("Missing second number in range");
          }
          loslice = parseInt(p[2], 10);
        }
        if (p[3] !== void 0) {
          hislice = parseInt(p[3], 10);
        }
        let amountstr = "1";
        let amount = 1;
        if (p[5] !== void 0) {
          amountstr = p[5];
          if (amountstr[0] === "'") {
            amountstr = "-" + amountstr.substring(1);
          }
          amount = parseInt(amountstr, 10);
        }
        return new Move(new QuantumMove(grip, hislice, loslice), amount);
      }
      parseMove(move) {
        const bm = this.notationMapper.notationToInternal(move);
        if (bm === null) {
          throw new Error("Bad move " + move.family);
        }
        move = bm;
        let grip = move.family;
        let fullrotation = false;
        if (grip.endsWith("v") && grip[0] <= "Z") {
          if (move.innerLayer !== void 0 || move.outerLayer !== void 0) {
            throw new Error("Cannot use a prefix with full cube rotations");
          }
          grip = grip.slice(0, -1);
          fullrotation = true;
        }
        if (grip.endsWith("w") && grip[0] <= "Z") {
          grip = grip.slice(0, -1).toLowerCase();
        }
        let geo;
        let msi = -1;
        const geoname = this.swizzler.unswizzle(grip);
        let firstgrip = false;
        for (let i2 = 0; i2 < this.movesetgeos.length; i2++) {
          const g = this.movesetgeos[i2];
          if (geoname === g[0]) {
            firstgrip = true;
            geo = g;
            msi = i2;
          }
          if (geoname === g[2]) {
            firstgrip = false;
            geo = g;
            msi = i2;
          }
        }
        let loslice = 1;
        let hislice = 1;
        if (grip.toUpperCase() !== grip) {
          hislice = 2;
        }
        if (geo === void 0) {
          throw new Error("Bad grip in move " + move.family);
        }
        if (move.outerLayer !== void 0) {
          loslice = move.outerLayer;
        }
        if (move.innerLayer !== void 0) {
          if (move.outerLayer === void 0) {
            hislice = move.innerLayer;
            if (grip <= "Z") {
              loslice = hislice;
            } else {
              loslice = 1;
            }
          } else {
            hislice = move.innerLayer;
          }
        }
        loslice--;
        hislice--;
        if (fullrotation) {
          loslice = 0;
          hislice = this.moveplanesets[msi].length;
        }
        if (loslice < 0 || loslice > this.moveplanesets[msi].length || hislice < 0 || hislice > this.moveplanesets[msi].length) {
          throw new Error("Bad slice spec " + loslice + " " + hislice + " vs " + this.moveplanesets[msi].length);
        }
        if (!permissivieMoveParsing && loslice === 0 && hislice === this.moveplanesets[msi].length && !fullrotation) {
          throw new Error("! full puzzle rotations must be specified with v suffix.");
        }
        return [void 0, msi, loslice, hislice, firstgrip, move.amount];
      }
      parsemove(mv) {
        const r3 = this.parseMove(this.stringToBlockMove(mv));
        r3[0] = mv;
        return r3;
      }
      genperms() {
        const t1 = tstart("genperms");
        if (this.cmovesbyslice.length > 0) {
          return;
        }
        const cmovesbyslice = [];
        if (this.options.orientCenters) {
          for (let k = 0; k < this.cubies.length; k++) {
            if (this.cubies[k].length === 1) {
              const kk = this.cubies[k][0];
              const i2 = this.getfaceindex(kk);
              if (this.basefaces[i2].centermass().dist(this.facecentermass[kk]) < eps3) {
                const o2 = this.basefaces[i2].length;
                for (let m = 1; m < o2; m++) {
                  this.cubies[k].push(this.cubies[k][m - 1]);
                }
                this.duplicatedFaces[kk] = o2;
                this.duplicatedCubies[k] = o2;
                this.orbitoris[this.cubiesetnums[k]] = o2;
              }
            }
          }
        }
        for (let k = 0; k < this.moveplanesets.length; k++) {
          const moveplaneset = this.moveplanesets[k];
          const slicenum = [];
          const slicecnts = [moveplaneset.length + 1, 0];
          let bhi = 1;
          while (bhi * 2 <= moveplaneset.length) {
            bhi *= 2;
          }
          for (let i2 = 0; i2 < this.faces.length; i2++) {
            let t2 = 0;
            if (moveplaneset.length > 0) {
              const dv = this.facecentermass[i2].dot(moveplaneset[0]);
              for (let b2 = bhi; b2 > 0; b2 >>= 1) {
                if (t2 + b2 <= moveplaneset.length && dv > moveplaneset[t2 + b2 - 1].a) {
                  t2 += b2;
                }
              }
              t2 = moveplaneset.length - t2;
            }
            slicenum.push(t2);
            while (slicecnts.length <= t2) {
              slicecnts.push(0);
            }
            slicecnts[t2]++;
          }
          const axiscmoves = new Array(slicecnts.length);
          for (let sc = 0; sc < slicecnts.length; sc++) {
            axiscmoves[sc] = [];
          }
          const cubiedone = [];
          for (let i2 = 0; i2 < this.faces.length; i2++) {
            if (slicenum[i2] < 0) {
              continue;
            }
            const b2 = [this.facetocubie[i2], this.facetoord[i2]];
            let cm = this.facecentermass[i2];
            const ocm = cm;
            let fi2 = i2;
            const sc = slicenum[fi2];
            for (; ; ) {
              slicenum[fi2] = -1;
              const cm2 = cm.rotatepoint(this.moverotations[k][0]);
              if (cm2.dist(ocm) < eps3) {
                break;
              }
              fi2 = this.findface(cm2);
              b2.push(this.facetocubie[fi2], this.facetoord[fi2]);
              cm = cm2;
            }
            if (b2.length > 2 && this.options.orientCenters && (this.cubies[b2[0]].length === 1 || this.duplicatedCubies[b2[0]] > 1)) {
              if (this.facecentermass[i2].dist(this.basefaces[this.getfaceindex(i2)].centermass()) < eps3) {
                let face1 = this.faces[this.cubies[b2[0]][0]];
                for (let ii = 0; ii < b2.length; ii += 2) {
                  const face0 = this.faces[this.cubies[b2[ii]][0]];
                  let o2 = -1;
                  for (let jj = 0; jj < face1.length; jj++) {
                    if (face0.get(jj).dist(face1.get(0)) < eps3) {
                      o2 = jj;
                      break;
                    }
                  }
                  if (o2 < 0) {
                    throw new Error("Couldn't find rotation of center faces; ignoring for now.");
                  } else {
                    b2[ii + 1] = o2;
                    face1 = face1.rotate(this.moverotations[k][0]);
                  }
                }
              }
            }
            if (b2.length === 2 && this.options.orientCenters) {
              for (let ii = 1; ii < this.movesetorders[k]; ii++) {
                if (sc === 0) {
                  b2.push(b2[0], ii);
                } else {
                  b2.push(b2[0], (this.movesetorders[k] - ii) % this.movesetorders[k]);
                }
              }
            }
            if (b2.length > 2 && !cubiedone[b2[0]]) {
              if (b2.length !== 2 * this.movesetorders[k]) {
                throw new Error("Bad length in perm gen");
              }
              for (const v of b2) {
                axiscmoves[sc].push(v);
              }
            }
            for (let j = 0; j < b2.length; j += 2) {
              cubiedone[b2[j]] = true;
            }
          }
          for (let kk = 0; kk < axiscmoves.length; kk++) {
            axiscmoves[kk] = axiscmoves[kk].slice();
          }
          cmovesbyslice.push(axiscmoves);
        }
        this.cmovesbyslice = cmovesbyslice;
        if (this.options.moveList) {
          const parsedmovelist = [];
          for (const moveString of this.options.moveList) {
            parsedmovelist.push(this.parsemove(moveString));
          }
          this.parsedmovelist = parsedmovelist;
        }
        this.facelisthash.clear();
        this.facecentermass = [];
        tend(t1);
      }
      getboundarygeometry() {
        return {
          baseplanes: this.baseplanes,
          facenames: this.facenames,
          faceplanes: this.faceplanes,
          vertexnames: this.vertexnames,
          edgenames: this.edgenames,
          geonormals: this.geonormals
        };
      }
      getmovesets(k) {
        const slices = this.moveplanesets[k].length;
        let r3 = [];
        if (this.parsedmovelist !== void 0) {
          for (const parsedmove of this.parsedmovelist) {
            if (parsedmove[1] !== k) {
              continue;
            }
            if (parsedmove[4]) {
              r3.push([parsedmove[2], parsedmove[3]]);
            } else {
              r3.push([slices - parsedmove[3], slices - parsedmove[2]]);
            }
            r3.push(parsedmove[5]);
          }
        } else if (this.options.vertexMoves && !this.options.allMoves) {
          const msg = this.movesetgeos[k];
          if (msg[1] !== msg[3]) {
            for (let i2 = 0; i2 < slices; i2++) {
              if (msg[1] !== "v") {
                if (this.options.outerBlockMoves) {
                  r3.push([i2 + 1, slices]);
                } else {
                  r3.push([i2 + 1]);
                }
                r3.push(1);
              } else {
                if (this.options.outerBlockMoves) {
                  r3.push([0, i2]);
                } else {
                  r3.push([i2, i2]);
                }
                r3.push(1);
              }
            }
          }
        } else {
          for (let i2 = 0; i2 <= slices; i2++) {
            if (!this.options.allMoves && i2 + i2 === slices) {
              continue;
            }
            if (this.options.outerBlockMoves) {
              if (i2 + i2 > slices) {
                r3.push([i2, slices]);
              } else {
                r3.push([0, i2]);
              }
            } else {
              r3.push([i2, i2]);
            }
            r3.push(1);
          }
        }
        if (this.fixedCubie >= 0) {
          const dep = this.keyface3(this.faces[this.cubies[this.fixedCubie][0]])[k];
          const newr = [];
          for (let i2 = 0; i2 < r3.length; i2 += 2) {
            let o2 = r3[i2];
            if (dep >= o2[0] && dep <= o2[1]) {
              if (o2[0] === 0) {
                o2 = [o2[1] + 1, slices];
              } else if (slices === o2[1]) {
                o2 = [0, o2[0] - 1];
              } else {
                throw Error("fixed cubie option would disconnect move");
              }
            }
            let found = false;
            for (let j = 0; j < newr.length; j += 2) {
              if (newr[j][0] === o2[0] && newr[j][1] === o2[1] && newr[j + 1] === r3[i2 + 1]) {
                found = true;
                break;
              }
            }
            if (!found) {
              newr.push(o2);
              newr.push(r3[i2 + 1]);
            }
          }
          r3 = newr;
        }
        return r3;
      }
      graybyori(cubie) {
        let ori = this.cubies[cubie].length;
        if (this.duplicatedCubies[cubie]) {
          ori = 1;
        }
        return ori === 1 && (this.options.grayCenters || !this.options.includeCenterOrbits) || ori === 2 && (this.options.grayEdges || !this.options.includeEdgeOrbits) || ori > 2 && (this.options.grayCorners || !this.options.includeCornerOrbits);
      }
      skipbyori(cubie) {
        let ori = this.cubies[cubie].length;
        if (this.duplicatedCubies[cubie]) {
          ori = 1;
        }
        return ori === 1 && !this.options.includeCenterOrbits || ori === 2 && !this.options.includeEdgeOrbits || ori > 2 && !this.options.includeCornerOrbits;
      }
      skipcubie(fi) {
        return this.skipbyori(fi);
      }
      header(comment) {
        return comment + copyright + "\n" + comment + "\n";
      }
      writegap() {
        const os = this.getOrbitsDef(false);
        const r3 = [];
        const mvs = [];
        for (let i2 = 0; i2 < os.moveops.length; i2++) {
          let movename = "M_" + externalName(this.notationMapper, os.movenames[i2]);
          let doinv = false;
          if (movename[movename.length - 1] === "'") {
            movename = movename.substring(0, movename.length - 1);
            doinv = true;
          }
          mvs.push(movename);
          if (doinv) {
            r3.push(movename + ":=" + os.moveops[i2].toPerm().inv().toGap() + ";");
          } else {
            r3.push(movename + ":=" + os.moveops[i2].toPerm().toGap() + ";");
          }
        }
        r3.push("Gen:=[");
        r3.push(mvs.join(","));
        r3.push("];");
        const ip = os.solved.identicalPieces();
        r3.push("ip:=[" + ip.map((_) => "[" + _.map((__) => __ + 1).join(",") + "]").join(",") + "];");
        r3.push("# Size(Group(Gen));");
        r3.push("# Size(Stabilizer(Group(Gen), ip, OnTuplesSets));");
        r3.push("");
        return this.header("# ") + r3.join("\n");
      }
      writeksolve(name = "PuzzleGeometryPuzzle") {
        const od = this.getOrbitsDef(false);
        return this.header("# ") + od.toKsolve(name, this.notationMapper).join("\n");
      }
      getKPuzzleDefinition(fortwisty = true, includemoves = true) {
        const od = this.getOrbitsDef(fortwisty, includemoves);
        const internalDefinition = od.toKPuzzleDefinition(includemoves);
        internalDefinition.experimentalPuzzleDescription = this.puzzleDescription;
        if (!internalDefinition) {
          throw new Error("Missing definition!");
        }
        return internalDefinition;
      }
      getMoveFromBits(moverange, amount, inverted, axiscmoves, setmoves, movesetorder) {
        const moveorbits = [];
        const perms = [];
        const oris = [];
        for (const len of this.cubieords) {
          perms.push(iota(len));
          oris.push(zeros(len));
        }
        for (let m = moverange[0]; m <= moverange[1]; m++) {
          const slicecmoves = axiscmoves[m];
          for (let j = 0; j < slicecmoves.length; j += 2 * movesetorder) {
            const mperm = slicecmoves.slice(j, j + 2 * movesetorder);
            const setnum = this.cubiesetnums[mperm[0]];
            for (let ii = 0; ii < mperm.length; ii += 2) {
              mperm[ii] = this.cubieordnums[mperm[ii]];
            }
            let inc = 2;
            let oinc = 3;
            if (inverted) {
              inc = mperm.length - 2;
              oinc = mperm.length - 1;
            }
            if (perms[setnum] === iota(this.cubieords[setnum])) {
              perms[setnum] = perms[setnum].slice();
              if (this.orbitoris[setnum] > 1 && !this.options.fixedOrientation) {
                oris[setnum] = oris[setnum].slice();
              }
            }
            for (let ii = 0; ii < mperm.length; ii += 2) {
              perms[setnum][mperm[(ii + inc) % mperm.length]] = mperm[ii];
              if (this.orbitoris[setnum] > 1 && !this.options.fixedOrientation) {
                oris[setnum][mperm[ii]] = (mperm[(ii + oinc) % mperm.length] - mperm[(ii + 1) % mperm.length] + 2 * this.orbitoris[setnum]) % this.orbitoris[setnum];
              }
            }
          }
        }
        let lastId = new PGOrbit(iota(24), zeros(24), 1);
        for (let ii = 0; ii < this.cubiesetnames.length; ii++) {
          if (setmoves && !setmoves[ii]) {
            continue;
          }
          if (this.orbitoris[ii] === 1 || this.options.fixedOrientation) {
            if (perms[ii] === iota(lastId.perm.length)) {
              if (perms[ii] !== lastId.perm) {
                lastId = new PGOrbit(perms[ii], oris[ii], 1);
              }
              moveorbits.push(lastId);
            } else {
              moveorbits.push(new PGOrbit(perms[ii], oris[ii], 1));
            }
          } else {
            const no = new Array(oris[ii].length);
            for (let jj = 0; jj < perms[ii].length; jj++) {
              no[jj] = oris[ii][perms[ii][jj]];
            }
            moveorbits.push(new PGOrbit(perms[ii], no, this.orbitoris[ii]));
          }
        }
        let mv = new PGTransform(moveorbits);
        if (amount !== 1) {
          mv = mv.mulScalar(amount);
        }
        return mv;
      }
      omitSet(name) {
        for (const excludedSet of this.options.excludeOrbits) {
          if (excludedSet === name) {
            return true;
          }
        }
        return false;
      }
      diffmvsets(a, b2, slices, neg) {
        for (let i2 = 0; i2 < a.length; i2 += 2) {
          let found = false;
          for (let j = 0; !found && j < b2.length; j += 2) {
            if (neg) {
              if (a[i2][0] + b2[j][1] === slices && a[i2][1] + b2[j][0] === slices && a[i2 + 1] === b2[j + 1]) {
                found = true;
              }
            } else {
              if (a[i2][0] === b2[j][0] && a[i2][1] === b2[j][1] && a[i2 + 1] === b2[j + 1]) {
                found = true;
              }
            }
          }
          if (!found) {
            return true;
          }
        }
        return false;
      }
      getOrbitsDef(fortwisty, includemoves = true) {
        const setmoves = [];
        if (fortwisty) {
          for (let i2 = 0; i2 < this.cubiesetnames.length; i2++) {
            setmoves.push(1);
          }
        }
        const setnames = [];
        const setdefs = [];
        const mps = [];
        const addrot = [];
        for (let k = 0; k < this.moveplanesets.length; k++) {
          const moveset = this.getmovesets(k);
          mps.push(moveset);
          if (this.options.addRotations) {
            addrot.push(1);
          } else {
            addrot.push(0);
          }
        }
        if (this.options.moveList && this.options.addRotations) {
          for (let i2 = 0; i2 < this.moverotations.length; i2++) {
            addrot[i2] = 0;
          }
          for (let k = 0; k < this.moveplanesets.length; k++) {
            for (let i2 = 0; i2 < this.moverotations.length; i2++) {
              let nn = this.moveplanenormals[k];
              for (let ii = 1; ii * 2 <= this.movesetorders[i2]; ii++) {
                nn = nn.rotatepoint(this.moverotations[i2][0]);
                if (addrot[i2] & ii) {
                  continue;
                }
                let found = -1;
                let neg = false;
                for (let j = 0; j < this.moveplanenormals.length; j++) {
                  if (nn.dist(this.moveplanenormals[j]) < eps3) {
                    found = j;
                    break;
                  } else if (nn.dist(this.moveplanenormals[j].smul(-1)) < eps3) {
                    found = j;
                    neg = true;
                    break;
                  }
                }
                if (found < 0) {
                  throw new Error("Could not find rotation");
                }
                const cmp = mps[found];
                if (cmp.length !== mps[k].length || this.moveplanesets[k].length !== this.moveplanesets[found].length || this.diffmvsets(cmp, mps[k], this.moveplanesets[found].length, neg)) {
                  addrot[i2] |= ii;
                }
              }
            }
          }
          for (let i2 = 0; i2 < this.moverotations.length; i2++) {
            if (addrot[i2] === 0) {
              addrot[i2] = 1;
            } else if (addrot[i2] === 1) {
              if (this.movesetorders[i2] > 3) {
                addrot[i2] = 2;
              } else {
                addrot[i2] = 0;
              }
            } else if (addrot[i2] === 3) {
              addrot[i2] = 0;
            } else {
              throw new Error("Impossible addrot val");
            }
          }
        }
        for (let k = 0; k < this.moveplanesets.length; k++) {
          if (addrot[k] !== 0) {
            mps[k].push([0, this.moveplanesets[k].length]);
            mps[k].push(addrot[k]);
          }
        }
        for (let k = 0; k < this.moveplanesets.length; k++) {
          const moveset = mps[k];
          const movesetorder = this.movesetorders[k];
          for (let i2 = 0; i2 < moveset.length; i2 += 2) {
            for (let j = 0; j < i2; j += 2) {
              if (moveset[i2] === moveset[j] && moveset[i2 + 1] === moveset[j + 1]) {
                throw new Error("Redundant moves in moveset.");
              }
            }
          }
          const allbits = [];
          for (let i2 = 0; i2 < moveset.length; i2 += 2) {
            for (let j = moveset[i2][0]; j <= moveset[i2][1]; j++) {
              allbits[j] = 1;
            }
          }
          const axiscmoves = this.cmovesbyslice[k];
          for (let i2 = 0; i2 < axiscmoves.length; i2++) {
            if (allbits[i2] !== 1) {
              continue;
            }
            const slicecmoves = axiscmoves[i2];
            for (let j = 0; j < slicecmoves.length; j += 2 * movesetorder) {
              if (this.skipcubie(slicecmoves[j])) {
                continue;
              }
              const ind = this.cubiesetnums[slicecmoves[j]];
              setmoves[ind] = 1;
            }
          }
        }
        for (let i2 = 0; i2 < this.cubiesetnames.length; i2++) {
          if (!setmoves[i2]) {
            continue;
          }
          if (this.omitSet(this.cubiesetnames[i2])) {
            setmoves[i2] = 0;
            continue;
          }
          setnames.push(this.cubiesetnames[i2]);
          setdefs.push(new PGOrbitDef(this.cubieords[i2], this.options.fixedOrientation ? 1 : this.orbitoris[i2]));
        }
        const solved = [];
        for (let i2 = 0; i2 < this.cubiesetnames.length; i2++) {
          if (!setmoves[i2]) {
            continue;
          }
          if (this.omitSet(this.cubiesetnames[i2])) {
            continue;
          }
          const p = [];
          const o2 = [];
          for (let j = 0; j < this.cubieords[i2]; j++) {
            if (fortwisty) {
              p.push(j);
            } else {
              const cubie = this.cubiesetcubies[i2][j];
              p.push(this.cubievaluemap[cubie]);
            }
            o2.push(0);
          }
          solved.push(new PGOrbit(p, o2, this.options.fixedOrientation ? 1 : this.orbitoris[i2]));
        }
        const movenames = [];
        const moves = [];
        if (includemoves) {
          for (let k = 0; k < this.moveplanesets.length; k++) {
            const moveplaneset = this.moveplanesets[k];
            const slices = moveplaneset.length;
            const moveset = mps[k];
            const movesetgeo = this.movesetgeos[k];
            for (let i2 = 0; i2 < moveset.length; i2 += 2) {
              const movebits = moveset[i2];
              const mna = getmovename(movesetgeo, movebits, slices);
              const movename = mna[0];
              const inverted = mna[1];
              if (moveset[i2 + 1] === 1) {
                movenames.push(movename);
              } else {
                movenames.push(movename + moveset[i2 + 1]);
              }
              const mv = this.getMoveFromBits(movebits, moveset[i2 + 1], inverted, this.cmovesbyslice[k], setmoves, this.movesetorders[k]);
              moves.push(mv);
            }
          }
        }
        let r3 = new PGOrbitsDef(setnames, setdefs, new VisibleState(solved), movenames, moves);
        if (this.options.optimizeOrbits) {
          r3 = r3.optimize();
        }
        if (this.options.scrambleAmount !== 0) {
          r3.scramble(this.options.scrambleAmount);
        }
        return r3;
      }
      getScramble(n = 0) {
        const od = this.getOrbitsDef(false);
        return od.transformToKTransformationData(od.getScrambleTransformation(n));
      }
      getMovesAsPerms() {
        return this.getOrbitsDef(false).moveops.map((_) => _.toPerm());
      }
      showcanon(disp) {
        showcanon(this.getOrbitsDef(false), disp);
      }
      getsolved() {
        const r3 = [];
        for (let i2 = 0; i2 < this.baseFaceCount; i2++) {
          for (let j = 0; j < this.stickersperface; j++) {
            r3.push(i2);
          }
        }
        return new Perm(r3);
      }
      getOrientationRotation(desiredRotation) {
        const [feature1name, [x1, y1, z1]] = desiredRotation[0];
        const direction1 = new Quat(0, x1, -y1, z1);
        const [feature2name, [x2, y2, z2]] = desiredRotation[1];
        const direction2 = new Quat(0, x2, -y2, z2);
        let feature1 = null;
        let feature2 = null;
        const feature1geoname = this.swizzler.unswizzle(feature1name);
        const feature2geoname = this.swizzler.unswizzle(feature2name);
        for (const gn of this.geonormals) {
          if (feature1geoname === gn[1]) {
            feature1 = gn[0];
          }
          if (feature2geoname === gn[1]) {
            feature2 = gn[0];
          }
        }
        if (!feature1) {
          throw new Error("Could not find feature " + feature1name);
        }
        if (!feature2) {
          throw new Error("Could not find feature " + feature2name);
        }
        const r1 = feature1.pointrotation(direction1);
        const feature2rot = feature2.rotatepoint(r1);
        const r22 = feature2rot.unproject(direction1).pointrotation(direction2.unproject(direction1));
        return r22.mul(r1);
      }
      getInitial3DRotation() {
        const basefacecount = this.baseFaceCount;
        let orientationDescription = null;
        if (this.options.puzzleOrientation) {
          orientationDescription = this.options.puzzleOrientation;
        } else if (this.options.puzzleOrientations) {
          orientationDescription = this.options.puzzleOrientations[basefacecount];
        }
        if (!orientationDescription) {
          orientationDescription = defaultOrientations()[basefacecount];
        }
        if (!orientationDescription) {
          throw new Error("No default orientation?");
        }
        return this.getOrientationRotation(orientationDescription);
      }
      generate2dmapping(w = 800, h = 500, trim = 10, threed = false, twodshrink = 0.92) {
        w -= 2 * trim;
        h -= 2 * trim;
        function extendedges(a, n) {
          let dx = a[1][0] - a[0][0];
          let dy = a[1][1] - a[0][1];
          const ang = 2 * Math.PI / n;
          const cosa = Math.cos(ang);
          const sina = Math.sin(ang);
          for (let i2 = 2; i2 < n; i2++) {
            const ndx = dx * cosa + dy * sina;
            dy = dy * cosa - dx * sina;
            dx = ndx;
            a.push([a[i2 - 1][0] + dx, a[i2 - 1][1] + dy]);
          }
        }
        this.genperms();
        const boundarygeo = this.getboundarygeometry();
        const face0 = boundarygeo.facenames[0][0];
        const polyn = face0.length;
        const net = this.net;
        if (net === null) {
          throw new Error("No net?");
        }
        const edges = {};
        let minx = 0;
        let miny = 0;
        let maxx = 1;
        let maxy = 0;
        edges[net[0][0]] = [
          [1, 0],
          [0, 0]
        ];
        extendedges(edges[net[0][0]], polyn);
        for (const neti of net) {
          const f0 = neti[0];
          if (!edges[f0]) {
            throw new Error("Bad edge description; first edge not connected.");
          }
          for (let j = 1; j < neti.length; j++) {
            const f1 = neti[j];
            if (f1 === "" || edges[f1]) {
              continue;
            }
            edges[f1] = [edges[f0][j % polyn], edges[f0][(j + polyn - 1) % polyn]];
            extendedges(edges[f1], polyn);
          }
        }
        for (const f in edges) {
          const es = edges[f];
          for (const esi of es) {
            minx = Math.min(minx, esi[0]);
            maxx = Math.max(maxx, esi[0]);
            miny = Math.min(miny, esi[1]);
            maxy = Math.max(maxy, esi[1]);
          }
        }
        const sc = Math.min(w / (maxx - minx), h / (maxy - miny));
        const xoff = 0.5 * (w - sc * (maxx + minx));
        const yoff = 0.5 * (h - sc * (maxy + miny));
        const geos = {};
        const bg = this.getboundarygeometry();
        const edges2 = {};
        const initv = [
          [sc + xoff, yoff],
          [xoff, yoff]
        ];
        edges2[net[0][0]] = initv;
        extendedges(edges2[net[0][0]], polyn);
        geos[this.facenames[0][1]] = this.project2d(0, 0, [
          new Quat(0, initv[0][0], initv[0][1], 0),
          new Quat(0, initv[1][0], initv[1][1], 0)
        ]);
        const connectat = [];
        connectat[0] = 0;
        for (const neti of net) {
          const f0 = neti[0];
          if (!edges2[f0]) {
            throw new Error("Bad edge description; first edge not connected.");
          }
          let gfi = -1;
          for (let j = 0; j < bg.facenames.length; j++) {
            if (f0 === bg.facenames[j][1]) {
              gfi = j;
              break;
            }
          }
          if (gfi < 0) {
            throw new Error("Could not find first face name " + f0);
          }
          const thisface = bg.facenames[gfi][0];
          for (let j = 1; j < neti.length; j++) {
            const f1 = neti[j];
            if (f1 === "" || edges2[f1]) {
              continue;
            }
            edges2[f1] = [
              edges2[f0][j % polyn],
              edges2[f0][(j + polyn - 1) % polyn]
            ];
            extendedges(edges2[f1], polyn);
            const caf0 = connectat[gfi];
            const mp = thisface[(caf0 + j) % polyn].sum(thisface[(caf0 + j + polyn - 1) % polyn]).smul(0.5);
            const epi = findelement(bg.edgenames, mp);
            const edgename = bg.edgenames[epi][1];
            const el = splitByFaceNames(edgename, this.facenames);
            const gf1 = el[f0 === el[0] ? 1 : 0];
            let gf1i = -1;
            for (let k = 0; k < bg.facenames.length; k++) {
              if (gf1 === bg.facenames[k][1]) {
                gf1i = k;
                break;
              }
            }
            if (gf1i < 0) {
              throw new Error("Could not find second face name");
            }
            const otherface = bg.facenames[gf1i][0];
            for (let k = 0; k < otherface.length; k++) {
              const mp2 = otherface[k].sum(otherface[(k + 1) % polyn]).smul(0.5);
              if (mp2.dist(mp) <= eps3) {
                const p1 = edges2[f0][(j + polyn - 1) % polyn];
                const p2 = edges2[f0][j % polyn];
                connectat[gf1i] = k;
                geos[gf1] = this.project2d(gf1i, k, [
                  new Quat(0, p2[0], p2[1], 0),
                  new Quat(0, p1[0], p1[1], 0)
                ]);
                break;
              }
            }
          }
        }
        let hix = 0;
        let hiy = 0;
        const rot = this.getInitial3DRotation();
        for (let face2 of this.faces) {
          if (threed) {
            face2 = face2.rotate(rot);
          }
          for (let j = 0; j < face2.length; j++) {
            hix = Math.max(hix, Math.abs(face2.get(j).b));
            hiy = Math.max(hiy, Math.abs(face2.get(j).c));
          }
        }
        const sc2 = Math.min(h / hiy / 2, (w - trim) / hix / 4);
        const mappt2d = (fn, q) => {
          if (threed) {
            q = q.rotatepoint(rot);
            const xoff2 = 0.5 * trim + 0.25 * w;
            const xmul = this.baseplanes[fn].rotateplane(rot).d < 0 ? 1 : -1;
            return [
              trim + w * 0.5 + xmul * (xoff2 - q.b * sc2),
              trim + h * 0.5 + q.c * sc2
            ];
          } else {
            const g = geos[this.facenames[fn][1]];
            return [
              trim + twodshrink * q.dot(g[0]) + g[2].b,
              trim + h - twodshrink * q.dot(g[1]) - g[2].c
            ];
          }
        };
        return mappt2d;
      }
      generatesvg(w = 800, h = 500, trim = 10, threed = false) {
        const mappt2d = this.generate2dmapping(w, h, trim, threed);
        function drawedges(id, pts, color) {
          return '<polygon id="' + id + '" class="sticker" style="fill: ' + color + '" points="' + pts.map((p) => p[0] + " " + p[1]).join(" ") + '"/>\n';
        }
        const pos = this.getsolved();
        const colormap = [];
        const facegeo = [];
        for (let i2 = 0; i2 < this.baseFaceCount; i2++) {
          colormap[i2] = this.colors[this.facenames[i2][1]];
        }
        for (let i2 = 0; i2 < this.faces.length; i2++) {
          const face2 = this.faces[i2];
          const facenum = Math.floor(i2 / this.stickersperface);
          const fg = [];
          for (let j = 0; j < face2.length; j++) {
            fg.push(mappt2d(facenum, face2.get(j)));
          }
          facegeo.push(fg);
        }
        const svg = [];
        for (let j = 0; j < this.baseFaceCount; j++) {
          svg.push("<g>");
          svg.push("<title>" + this.facenames[j][1] + "</title>\n");
          for (let ii = 0; ii < this.stickersperface; ii++) {
            const i2 = j * this.stickersperface + ii;
            const cubie = this.facetocubie[i2];
            const cubieori = this.facetoord[i2];
            const cubiesetnum = this.cubiesetnums[cubie];
            const cubieord = this.cubieordnums[cubie];
            const color = this.graybyori(cubie) ? "#808080" : colormap[pos.p[i2]];
            let id = this.cubiesetnames[cubiesetnum] + "-l" + cubieord + "-o" + cubieori;
            svg.push(drawedges(id, facegeo[i2], color));
            if (this.duplicatedFaces[i2]) {
              for (let jj = 1; jj < this.duplicatedFaces[i2]; jj++) {
                id = this.cubiesetnames[cubiesetnum] + "-l" + cubieord + "-o" + jj;
                svg.push(drawedges(id, facegeo[i2], color));
              }
            }
          }
          svg.push("</g>");
        }
        const html = '<svg id="svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 800 500">\n<style type="text/css"><![CDATA[.sticker { stroke: #000000; stroke-width: 1px; }]]></style>\n' + svg.join("") + "</svg>";
        return html;
      }
      get3d(options) {
        const stickers = [];
        const rot = this.getInitial3DRotation();
        const faces = [];
        const maxdist = 0.52 * this.basefaces[0].get(0).len();
        for (let i2 = 0; i2 < this.basefaces.length; i2++) {
          const coords = this.basefaces[i2].rotate(rot);
          const name = this.facenames[i2][1];
          faces.push({ coords: toFaceCoords(coords, maxdist), name });
        }
        for (let i2 = 0; i2 < this.faces.length; i2++) {
          const facenum = Math.floor(i2 / this.stickersperface);
          const cubie = this.facetocubie[i2];
          const cubieori = this.facetoord[i2];
          const cubiesetnum = this.cubiesetnums[cubie];
          const cubieord = this.cubieordnums[cubie];
          let color = this.graybyori(cubie) ? "#808080" : this.colors[this.facenames[facenum][1]];
          if (options?.stickerColors) {
            color = options.stickerColors[i2];
          }
          const coords = this.faces[i2].rotate(rot);
          stickers.push({
            coords: toFaceCoords(coords, maxdist),
            color,
            orbit: this.cubiesetnames[cubiesetnum],
            ord: cubieord,
            ori: cubieori,
            face: facenum
          });
          let fcoords = coords;
          if (this.duplicatedFaces[i2]) {
            const rotdist = fcoords.length / this.duplicatedFaces[i2];
            for (let jj = 1; jj < this.duplicatedFaces[i2]; jj++) {
              for (let k = 0; k < rotdist; k++) {
                fcoords = fcoords.rotateforward();
              }
              stickers.push({
                coords: toFaceCoords(fcoords, maxdist),
                color,
                orbit: this.cubiesetnames[cubiesetnum],
                ord: cubieord,
                ori: jj,
                face: facenum,
                isDup: true
              });
            }
          }
        }
        const grips = [];
        for (let i2 = 0; i2 < this.movesetgeos.length; i2++) {
          const msg = this.movesetgeos[i2];
          const order = this.movesetorders[i2];
          for (const gn of this.geonormals) {
            if (msg[0] === gn[1] && msg[1] === gn[2]) {
              grips.push({
                coordinates: toCoords(gn[0].rotatepoint(rot), 1),
                quantumMove: new Move(msg[0]),
                order
              });
              grips.push({
                coordinates: toCoords(gn[0].rotatepoint(rot).smul(-1), 1),
                quantumMove: new Move(msg[2]),
                order
              });
            }
          }
        }
        const twodmapper = this.generate2dmapping(2880, 2160, 0, false, 1);
        const g = function() {
          const irot = rot.invrot();
          return function(facenum, coords) {
            let q = new Quat(0, coords[0] * maxdist, -coords[1] * maxdist, coords[2] * maxdist);
            q = q.rotatepoint(irot);
            const x = twodmapper(facenum, q);
            x[0] /= 2880;
            x[1] = 1 - x[1] / 2160;
            return x;
          };
        }().bind(this);
        return {
          stickers,
          faces,
          axis: grips,
          unswizzle: this.unswizzle.bind(this),
          notationMapper: this.notationMapper,
          textureMapper: { getuv: g }
        };
      }
      getGeoNormal(geoname) {
        const rot = this.getInitial3DRotation();
        const grip = this.swizzler.unswizzle(geoname);
        for (const gn of this.geonormals) {
          if (grip === gn[1]) {
            const r3 = toCoords(gn[0].rotatepoint(rot), 1);
            if (Math.abs(r3[0]) < eps3 && Math.abs(r3[2]) < eps3) {
              r3[0] = 0;
              r3[2] = 1e-6;
            }
            return r3;
          }
        }
        return void 0;
      }
      getfaceindex(facenum) {
        const divid = this.stickersperface;
        return Math.floor(facenum / divid);
      }
      textForTwizzleExplorer() {
        return `Faces ${this.baseplanerot.length}
Stickers per face ${this.stickersperface}
Short edge ${this.shortedge}
Cubies ${this.cubies.length}
Edge distance ${this.edgedistance}
Vertex distance ${this.vertexdistance}`;
      }
      writeSchreierSims(tw) {
        const os = this.getOrbitsDef(false);
        const as = os.reassemblySize();
        tw(`Reassembly size is ${as}`);
        const ss = schreierSims(this.getMovesAsPerms(), tw);
        const r3 = as / ss;
        tw(`Ratio is ${r3}`);
      }
    };
    PGNotation = class {
      constructor(pg, od) {
        this.pg = pg;
        this.orbitNames = od.orbitnames;
      }
      lookupMove(move) {
        const mv = this.pg.parseMove(move);
        if (this.pg.parsedmovelist) {
          let found = false;
          for (const parsedmove of this.pg.parsedmovelist) {
            if (parsedmove[1] === mv[1] && parsedmove[2] === mv[2] && parsedmove[3] === mv[3] && parsedmove[4] === mv[4]) {
              found = true;
            }
          }
          if (!found) {
            return null;
          }
        }
        let bits = [mv[2], mv[3]];
        if (!mv[4]) {
          const slices = this.pg.moveplanesets[mv[1]].length;
          bits = [slices - mv[3], slices - mv[2]];
        }
        const pgmv = this.pg.getMoveFromBits(bits, mv[5], !mv[4], this.pg.cmovesbyslice[mv[1]], void 0, this.pg.movesetorders[mv[1]]);
        const r3 = PGOrbitsDef.transformToKTransformationData(this.orbitNames, pgmv);
        return r3;
      }
    };
  }
});

// src/cubing/puzzle-geometry/index.ts
var puzzle_geometry_exports = {};
__export(puzzle_geometry_exports, {
  ExperimentalPGNotation: () => PGNotation,
  PuzzleGeometry: () => PuzzleGeometry,
  Quat: () => Quat,
  getPG3DNamedPuzzles: () => getPG3DNamedPuzzles,
  getPuzzleDescriptionString: () => getPuzzleDescriptionString,
  getPuzzleGeometryByDesc: () => getPuzzleGeometryByDesc,
  getPuzzleGeometryByName: () => getPuzzleGeometryByName,
  parseOptions: () => parseOptions,
  parsePuzzleDescription: () => parsePuzzleDescription,
  schreierSims: () => schreierSims
});
var init_puzzle_geometry = __esm({
  "src/cubing/puzzle-geometry/index.ts"() {
    init_PuzzleGeometry();
    init_Options();
    init_Quat();
    init_SchreierSims();
    init_PuzzleGeometry();
  }
});

// src/cubing/puzzles/customPGPuzzleLoader.ts
async function descAsyncGetPuzzleGeometry(desc) {
  const puzzleGeometry = await Promise.resolve().then(() => (init_puzzle_geometry(), puzzle_geometry_exports));
  return puzzleGeometry.getPuzzleGeometryByDesc(desc, {
    allMoves: true,
    orientCenters: true,
    addRotations: true
  });
}
async function asyncGetKPuzzle(desc) {
  const pg = await descAsyncGetPuzzleGeometry(desc);
  const kpuzzleDefinition = pg.getKPuzzleDefinition(true);
  kpuzzleDefinition.name = `description: ${desc}`;
  const puzzleGeometry = await Promise.resolve().then(() => (init_puzzle_geometry(), puzzle_geometry_exports));
  const pgNotation = new puzzleGeometry.ExperimentalPGNotation(pg, pg.getOrbitsDef(true));
  return new KPuzzle(kpuzzleDefinition, {
    experimentalPGNotation: pgNotation
  });
}
function customPGPuzzleLoader(desc, info) {
  const customID = nextCustomID++;
  let cachedKPuzzle = null;
  const puzzleLoader = {
    id: `custom-${customID}`,
    fullName: info?.fullName ?? `Custom Puzzle (instance #${customID})`,
    kpuzzle: async () => {
      return cachedKPuzzle ?? (cachedKPuzzle = asyncGetKPuzzle(desc));
    },
    svg: async () => {
      const pg = await descAsyncGetPuzzleGeometry(desc);
      return pg.generatesvg();
    },
    pg: async () => {
      return descAsyncGetPuzzleGeometry(desc);
    }
  };
  if (info?.inventedBy) {
    puzzleLoader.inventedBy = info.inventedBy;
  }
  if (info?.inventionYear) {
    puzzleLoader.inventionYear = info.inventionYear;
  }
  return puzzleLoader;
}
var nextCustomID;
var init_customPGPuzzleLoader = __esm({
  "src/cubing/puzzles/customPGPuzzleLoader.ts"() {
    init_kpuzzle();
    nextCustomID = 1;
  }
});

// src/cubing/puzzles/events.ts
var wcaEvents, events;
var init_events = __esm({
  "src/cubing/puzzles/events.ts"() {
    wcaEvents = {
      "333": { puzzleID: "3x3x3", eventName: "3x3x3 Cube" },
      "222": { puzzleID: "2x2x2", eventName: "2x2x2 Cube" },
      "444": { puzzleID: "4x4x4", eventName: "4x4x4 Cube" },
      "555": { puzzleID: "5x5x5", eventName: "5x5x5 Cube" },
      "666": { puzzleID: "6x6x6", eventName: "6x6x6 Cube" },
      "777": { puzzleID: "7x7x7", eventName: "7x7x7 Cube" },
      "333bf": { puzzleID: "3x3x3", eventName: "3x3x3 Blindfolded" },
      "333fm": { puzzleID: "3x3x3", eventName: "3x3x3 Fewest Moves" },
      "333oh": { puzzleID: "3x3x3", eventName: "3x3x3 One-Handed" },
      "clock": { puzzleID: "clock", eventName: "Clock" },
      "minx": { puzzleID: "megaminx", eventName: "Megaminx" },
      "pyram": { puzzleID: "pyraminx", eventName: "Pyraminx" },
      "skewb": { puzzleID: "skewb", eventName: "Skewb" },
      "sq1": { puzzleID: "square1", eventName: "Square-1" },
      "444bf": { puzzleID: "4x4x4", eventName: "4x4x4 Blindfolded" },
      "555bf": { puzzleID: "5x5x5", eventName: "5x5x5 Blindfolded" },
      "333mb": { puzzleID: "3x3x3", eventName: "3x3x3 Multi-Blind" }
    };
    events = {
      ...wcaEvents,
      fto: { puzzleID: "fto", eventName: "Face-Turning Octahedron" },
      master_tetraminx: {
        puzzleID: "master_tetraminx",
        eventName: "Master Tetraminx"
      },
      kilominx: {
        puzzleID: "kilominx",
        eventName: "Kilominx"
      },
      redi_cube: {
        puzzleID: "redi_cube",
        eventName: "Redi Cube"
      }
    };
  }
});

// src/cubing/puzzles/stickerings/appearance.ts
function getFaceletAppearance(appearance, orbitName, pieceIdx, faceletIdx, hint) {
  const orbitAppearance = appearance.orbits[orbitName];
  const pieceAppearance = orbitAppearance.pieces[pieceIdx];
  if (pieceAppearance === null) {
    return regular;
  }
  const faceletAppearance = pieceAppearance.facelets[faceletIdx];
  if (faceletAppearance === null) {
    return regular;
  }
  if (typeof faceletAppearance === "string") {
    return faceletAppearance;
  }
  if (hint) {
    return faceletAppearance.hintAppearance ?? faceletAppearance.appearance;
  }
  return faceletAppearance.appearance;
}
function getPieceAppearance(pieceStickering) {
  switch (pieceStickering) {
    case "Regular" /* Regular */:
      return r;
    case "Dim" /* Dim */:
      return d;
    case "Ignored" /* Ignored */:
      return i;
    case "OrientationStickers" /* OrientationStickers */:
      return o;
    case "Invisible" /* Invisible */:
      return invisiblePiece;
    case "IgnoreNonPrimary" /* IgnoreNonPrimary */:
      return riiii;
    case "PermuteNonPrimary" /* PermuteNonPrimary */:
      return drrrr;
    case "Ignoriented" /* Ignoriented */:
      return diiii;
    case "OrientationWithoutPermutation" /* OrientationWithoutPermutation */:
      return oiiii;
  }
}
var PieceStickering, PieceAnnotation, regular, ignored, oriented, invisible, dim, r, i, o, invisiblePiece, riiii, drrrr, d, diiii, oiiii, PuzzleStickering, StickeringManager;
var init_appearance = __esm({
  "src/cubing/puzzles/stickerings/appearance.ts"() {
    PieceStickering = /* @__PURE__ */ ((PieceStickering2) => {
      PieceStickering2["Regular"] = "Regular";
      PieceStickering2["Dim"] = "Dim";
      PieceStickering2["Ignored"] = "Ignored";
      PieceStickering2["OrientationStickers"] = "OrientationStickers";
      PieceStickering2["Invisible"] = "Invisible";
      PieceStickering2["Ignoriented"] = "Ignoriented";
      PieceStickering2["IgnoreNonPrimary"] = "IgnoreNonPrimary";
      PieceStickering2["PermuteNonPrimary"] = "PermuteNonPrimary";
      PieceStickering2["OrientationWithoutPermutation"] = "OrientationWithoutPermutation";
      return PieceStickering2;
    })(PieceStickering || {});
    PieceAnnotation = class {
      constructor(kpuzzle, defaultValue) {
        this.stickerings = /* @__PURE__ */ new Map();
        for (const [orbitName, orbitDef] of Object.entries(kpuzzle.definition.orbits)) {
          this.stickerings.set(orbitName, new Array(orbitDef.numPieces).fill(defaultValue));
        }
      }
    };
    regular = "regular";
    ignored = "ignored";
    oriented = "oriented";
    invisible = "invisible";
    dim = "dim";
    r = {
      facelets: [regular, regular, regular, regular, regular]
    };
    i = {
      facelets: [ignored, ignored, ignored, ignored, ignored]
    };
    o = {
      facelets: [oriented, oriented, oriented, oriented, oriented]
    };
    invisiblePiece = {
      facelets: [invisible, invisible, invisible, invisible]
    };
    riiii = {
      facelets: [regular, ignored, ignored, ignored, ignored]
    };
    drrrr = {
      facelets: [dim, regular, regular, regular, regular]
    };
    d = {
      facelets: [dim, dim, dim, dim, dim]
    };
    diiii = {
      facelets: [dim, ignored, ignored, ignored, ignored]
    };
    oiiii = {
      facelets: [oriented, ignored, ignored, ignored, ignored]
    };
    PuzzleStickering = class extends PieceAnnotation {
      constructor(kpuzzle) {
        super(kpuzzle, "Regular" /* Regular */);
      }
      set(pieceSet, pieceStickering) {
        for (const [orbitName, pieces] of this.stickerings.entries()) {
          for (let i2 = 0; i2 < pieces.length; i2++) {
            if (pieceSet.stickerings.get(orbitName)[i2]) {
              pieces[i2] = pieceStickering;
            }
          }
        }
        return this;
      }
      toAppearance() {
        const appearance = { orbits: {} };
        for (const [orbitName, pieceStickerings] of this.stickerings.entries()) {
          const pieces = [];
          const orbitAppearance = {
            pieces
          };
          appearance.orbits[orbitName] = orbitAppearance;
          for (const pieceStickering of pieceStickerings) {
            pieces.push(getPieceAppearance(pieceStickering));
          }
        }
        return appearance;
      }
    };
    StickeringManager = class {
      constructor(kpuzzle) {
        this.kpuzzle = kpuzzle;
      }
      and(pieceSets) {
        const newPieceSet = new PieceAnnotation(this.kpuzzle, false);
        for (const [orbitName, orbitDef] of Object.entries(this.kpuzzle.definition.orbits)) {
          pieceLoop:
            for (let i2 = 0; i2 < orbitDef.numPieces; i2++) {
              newPieceSet.stickerings.get(orbitName)[i2] = true;
              for (const pieceSet of pieceSets) {
                if (!pieceSet.stickerings.get(orbitName)[i2]) {
                  newPieceSet.stickerings.get(orbitName)[i2] = false;
                  continue pieceLoop;
                }
              }
            }
        }
        return newPieceSet;
      }
      or(pieceSets) {
        const newPieceSet = new PieceAnnotation(this.kpuzzle, false);
        for (const [orbitName, orbitDef] of Object.entries(this.kpuzzle.definition.orbits)) {
          pieceLoop:
            for (let i2 = 0; i2 < orbitDef.numPieces; i2++) {
              newPieceSet.stickerings.get(orbitName)[i2] = false;
              for (const pieceSet of pieceSets) {
                if (pieceSet.stickerings.get(orbitName)[i2]) {
                  newPieceSet.stickerings.get(orbitName)[i2] = true;
                  continue pieceLoop;
                }
              }
            }
        }
        return newPieceSet;
      }
      not(pieceSet) {
        const newPieceSet = new PieceAnnotation(this.kpuzzle, false);
        for (const [orbitName, orbitDef] of Object.entries(this.kpuzzle.definition.orbits)) {
          for (let i2 = 0; i2 < orbitDef.numPieces; i2++) {
            newPieceSet.stickerings.get(orbitName)[i2] = !pieceSet.stickerings.get(orbitName)[i2];
          }
        }
        return newPieceSet;
      }
      all() {
        return this.and(this.moves([]));
      }
      move(moveSource) {
        const transformation = this.kpuzzle.moveToTransformation(moveSource);
        const newPieceSet = new PieceAnnotation(this.kpuzzle, false);
        for (const [orbitName, orbitDef] of Object.entries(this.kpuzzle.definition.orbits)) {
          for (let i2 = 0; i2 < orbitDef.numPieces; i2++) {
            if (transformation.transformationData[orbitName].permutation[i2] !== i2 || transformation.transformationData[orbitName].orientation[i2] !== 0) {
              newPieceSet.stickerings.get(orbitName)[i2] = true;
            }
          }
        }
        return newPieceSet;
      }
      moves(moveSources) {
        return moveSources.map((moveSource) => this.move(moveSource));
      }
    };
  }
});

// src/cubing/puzzles/stickerings/global-custom-stickering-hack.ts
function setGlobalCustomStickerer(stickerer) {
  (async () => {
    globalCustomStickerer = stickerer;
    const players = Array.from(document.body.querySelectorAll("twisty-player"));
    console.log(`Setting the custom stickering for ${players.length} players!`);
    const successPromises = [];
    for (const player of players) {
      successPromises.push((async () => {
        const stickering = await player.experimentalModel.twistySceneModel.stickering.get();
        player.experimentalStickering = stickering === "experimental-global-custom-1" ? "experimental-global-custom-2" : "experimental-global-custom-1";
      })());
    }
    await Promise.all(successPromises);
    console.log("Success!");
  })();
}
function useGlobalCustomStickerer(puzzleStickering, m) {
  globalCustomStickerer(puzzleStickering, m);
}
var globalCustomStickerer;
var init_global_custom_stickering_hack = __esm({
  "src/cubing/puzzles/stickerings/global-custom-stickering-hack.ts"() {
    init_appearance();
    globalCustomStickerer = () => {
    };
    if (globalThis.location && new URL(location.href).searchParams.get("global-custom-stickerer") === "true") {
      window.setGlobalCustomStickerer = setGlobalCustomStickerer;
      window.PieceStickering = PieceStickering;
      console.log("Global custom stickerer enabled! (using: global-custom-stickerer=true)");
      console.log("Look here for inspiration:", "https://github.com/cubing/cubing.js/blob/81b5cab3e27d8defb39dd1e0a10bc9e8ba894d26/src/cubing/puzzles/stickerings/cube-stickerings.ts#L67");
    }
  }
});

// src/cubing/puzzles/stickerings/cube-stickerings.ts
async function cubeAppearance(puzzleLoader, stickering) {
  const kpuzzle = await puzzleLoader.kpuzzle();
  const puzzleStickering = new PuzzleStickering(kpuzzle);
  const m = new StickeringManager(kpuzzle);
  const LL = () => m.move("U");
  const orUD = () => m.or(m.moves(["U", "D"]));
  const E = () => m.not(orUD());
  const orLR = () => m.or(m.moves(["L", "R"]));
  const M = () => m.not(orLR());
  const orFB = () => m.or(m.moves(["F", "B"]));
  const S = () => m.not(orFB());
  const F2L = () => m.not(LL());
  const centerU = () => m.and([LL(), M(), S()]);
  const edgeFR = () => m.and([m.and(m.moves(["F", "R"])), m.not(orUD())]);
  const cornerDFR = () => m.and(m.moves(["D", "R", "F"]));
  const slotFR = () => m.or([cornerDFR(), edgeFR()]);
  const CENTERS = () => m.or([m.and([M(), E()]), m.and([M(), S()]), m.and([E(), S()])]);
  const EDGES = () => m.or([
    m.and([M(), orUD(), orFB()]),
    m.and([E(), orLR(), orFB()]),
    m.and([S(), orUD(), orLR()])
  ]);
  const CORNERS = () => m.not(m.or([CENTERS(), EDGES()]));
  const L6E = () => m.or([M(), m.and([LL(), EDGES()])]);
  function dimF2L() {
    puzzleStickering.set(F2L(), "Dim" /* Dim */);
  }
  function setPLL() {
    puzzleStickering.set(LL(), "PermuteNonPrimary" /* PermuteNonPrimary */);
    puzzleStickering.set(centerU(), "Dim" /* Dim */);
  }
  function setOLL() {
    puzzleStickering.set(LL(), "IgnoreNonPrimary" /* IgnoreNonPrimary */);
    puzzleStickering.set(centerU(), "Regular" /* Regular */);
  }
  function dimOLL() {
    puzzleStickering.set(LL(), "Ignoriented" /* Ignoriented */);
    puzzleStickering.set(centerU(), "Dim" /* Dim */);
  }
  switch (stickering) {
    case "full":
      break;
    case "PLL":
      dimF2L();
      setPLL();
      break;
    case "CLS":
      dimF2L();
      puzzleStickering.set(m.and(m.moves(["D", "R", "F"])), "Regular" /* Regular */);
      puzzleStickering.set(LL(), "Ignoriented" /* Ignoriented */);
      puzzleStickering.set(m.and([LL(), M(), S()]), "Dim" /* Dim */);
      puzzleStickering.set(m.and([LL(), CORNERS()]), "IgnoreNonPrimary" /* IgnoreNonPrimary */);
      break;
    case "OLL":
      dimF2L();
      setOLL();
      break;
    case "COLL":
      dimF2L();
      setPLL();
      puzzleStickering.set(m.and([LL(), CORNERS()]), "Regular" /* Regular */);
      break;
    case "OCLL":
      dimF2L();
      dimOLL();
      puzzleStickering.set(m.and([LL(), CORNERS()]), "IgnoreNonPrimary" /* IgnoreNonPrimary */);
      break;
    case "CLL":
      dimF2L();
      puzzleStickering.set(m.not(m.and([CORNERS(), LL()])), "Dim" /* Dim */);
      break;
    case "ELL":
      dimF2L();
      puzzleStickering.set(LL(), "Dim" /* Dim */);
      puzzleStickering.set(m.and([LL(), EDGES()]), "Regular" /* Regular */);
      break;
    case "ELS":
      dimF2L();
      setOLL();
      puzzleStickering.set(m.and([LL(), CORNERS()]), "Ignored" /* Ignored */);
      puzzleStickering.set(edgeFR(), "Regular" /* Regular */);
      puzzleStickering.set(cornerDFR(), "Ignored" /* Ignored */);
      break;
    case "LL":
      dimF2L();
      break;
    case "F2L":
      puzzleStickering.set(LL(), "Ignored" /* Ignored */);
      break;
    case "ZBLL":
      dimF2L();
      puzzleStickering.set(LL(), "PermuteNonPrimary" /* PermuteNonPrimary */);
      puzzleStickering.set(centerU(), "Dim" /* Dim */);
      puzzleStickering.set(m.and([LL(), CORNERS()]), "Regular" /* Regular */);
      break;
    case "ZBLS":
      dimF2L();
      puzzleStickering.set(slotFR(), "Regular" /* Regular */);
      setOLL();
      puzzleStickering.set(m.and([LL(), CORNERS()]), "Ignored" /* Ignored */);
      break;
    case "WVLS":
    case "VLS":
      dimF2L();
      puzzleStickering.set(slotFR(), "Regular" /* Regular */);
      setOLL();
      break;
    case "LS":
      dimF2L();
      puzzleStickering.set(slotFR(), "Regular" /* Regular */);
      puzzleStickering.set(LL(), "Ignored" /* Ignored */);
      puzzleStickering.set(centerU(), "Dim" /* Dim */);
      break;
    case "EO":
      puzzleStickering.set(CORNERS(), "Ignored" /* Ignored */);
      puzzleStickering.set(EDGES(), "OrientationWithoutPermutation" /* OrientationWithoutPermutation */);
      break;
    case "EOline":
      puzzleStickering.set(CORNERS(), "Ignored" /* Ignored */);
      puzzleStickering.set(EDGES(), "OrientationWithoutPermutation" /* OrientationWithoutPermutation */);
      puzzleStickering.set(m.and(m.moves(["D", "M"])), "Regular" /* Regular */);
      break;
    case "EOcross":
      puzzleStickering.set(EDGES(), "OrientationWithoutPermutation" /* OrientationWithoutPermutation */);
      puzzleStickering.set(m.move("D"), "Regular" /* Regular */);
      puzzleStickering.set(CORNERS(), "Ignored" /* Ignored */);
      break;
    case "CMLL":
      puzzleStickering.set(F2L(), "Dim" /* Dim */);
      puzzleStickering.set(L6E(), "Ignored" /* Ignored */);
      puzzleStickering.set(m.and([LL(), CORNERS()]), "Regular" /* Regular */);
      break;
    case "L6E":
      puzzleStickering.set(m.not(L6E()), "Dim" /* Dim */);
      break;
    case "L6EO":
      puzzleStickering.set(m.not(L6E()), "Dim" /* Dim */);
      puzzleStickering.set(L6E(), "OrientationWithoutPermutation" /* OrientationWithoutPermutation */);
      puzzleStickering.set(m.and([CENTERS(), orUD()]), "OrientationStickers" /* OrientationStickers */);
      break;
    case "Daisy":
      puzzleStickering.set(m.all(), "Ignored" /* Ignored */);
      puzzleStickering.set(CENTERS(), "Dim" /* Dim */);
      puzzleStickering.set(m.and([m.move("D"), CENTERS()]), "Regular" /* Regular */);
      puzzleStickering.set(m.and([m.move("U"), EDGES()]), "IgnoreNonPrimary" /* IgnoreNonPrimary */);
      break;
    case "Cross":
      puzzleStickering.set(m.all(), "Ignored" /* Ignored */);
      puzzleStickering.set(CENTERS(), "Dim" /* Dim */);
      puzzleStickering.set(m.and([m.move("D"), CENTERS()]), "Regular" /* Regular */);
      puzzleStickering.set(m.and([m.move("D"), EDGES()]), "Regular" /* Regular */);
      break;
    case "2x2x2":
      puzzleStickering.set(m.or(m.moves(["U", "F", "R"])), "Ignored" /* Ignored */);
      puzzleStickering.set(m.and([m.or(m.moves(["U", "F", "R"])), CENTERS()]), "Dim" /* Dim */);
      break;
    case "2x2x3":
      puzzleStickering.set(m.all(), "Dim" /* Dim */);
      puzzleStickering.set(m.or(m.moves(["U", "F", "R"])), "Ignored" /* Ignored */);
      puzzleStickering.set(m.and([m.or(m.moves(["U", "F", "R"])), CENTERS()]), "Dim" /* Dim */);
      puzzleStickering.set(m.and([m.move("F"), m.not(m.or(m.moves(["U", "R"])))]), "Regular" /* Regular */);
      break;
    case "Void Cube":
      puzzleStickering.set(CENTERS(), "Invisible" /* Invisible */);
      break;
    case "picture":
    case "invisible":
      puzzleStickering.set(m.all(), "Invisible" /* Invisible */);
      break;
    case "centers-only":
      puzzleStickering.set(m.not(CENTERS()), "Ignored" /* Ignored */);
      break;
    case "experimental-global-custom-1":
    case "experimental-global-custom-2":
      useGlobalCustomStickerer(puzzleStickering, m);
      break;
    default:
      console.warn(`Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`);
      puzzleStickering.set(m.and(m.moves([])), "Dim" /* Dim */);
  }
  return puzzleStickering.toAppearance();
}
async function cubeStickerings() {
  return [
    "full",
    "PLL",
    "CLS",
    "OLL",
    "COLL",
    "OCLL",
    "ELL",
    "ELS",
    "LL",
    "F2L",
    "ZBLL",
    "ZBLS",
    "WVLS",
    "VLS",
    "LS",
    "EO",
    "EOline",
    "EOcross",
    "CMLL",
    "L6E",
    "L6EO",
    "Daisy",
    "Cross",
    "2x2x2",
    "2x2x3",
    "Void Cube",
    "picture",
    "invisible",
    "centers-only"
  ];
}
var init_cube_stickerings = __esm({
  "src/cubing/puzzles/stickerings/cube-stickerings.ts"() {
    init_appearance();
    init_global_custom_stickering_hack();
  }
});

// src/cubing/puzzles/async/lazy-cached.ts
function getCached(getValue) {
  let cachedPromise = null;
  return () => {
    return cachedPromise ?? (cachedPromise = getValue());
  };
}
var init_lazy_cached = __esm({
  "src/cubing/puzzles/async/lazy-cached.ts"() {
  }
});

// src/cubing/puzzles/async/async-pg3d.ts
async function asyncGetPuzzleGeometry(puzzleName) {
  const puzzleGeometry = await Promise.resolve().then(() => (init_puzzle_geometry(), puzzle_geometry_exports));
  return puzzleGeometry.getPuzzleGeometryByName(puzzleName, {
    allMoves: true,
    orientCenters: true,
    addRotations: true
  });
}
async function asyncGetKPuzzle2(pgPromise, puzzleName) {
  const pg = await pgPromise;
  const kpuzzleDefinition = pg.getKPuzzleDefinition(true);
  kpuzzleDefinition.name = puzzleName;
  const puzzleGeometry = await Promise.resolve().then(() => (init_puzzle_geometry(), puzzle_geometry_exports));
  const pgNotation = new puzzleGeometry.ExperimentalPGNotation(pg, pg.getOrbitsDef(true));
  return new KPuzzle(kpuzzleDefinition, {
    experimentalPGNotation: pgNotation
  });
}
var _cachedPG, _cachedKPuzzle, _cachedSVG, PGPuzzleLoader, CubePGPuzzleLoader;
var init_async_pg3d = __esm({
  "src/cubing/puzzles/async/async-pg3d.ts"() {
    init_kpuzzle();
    init_cube_stickerings();
    init_lazy_cached();
    PGPuzzleLoader = class {
      constructor(info) {
        __privateAdd(this, _cachedPG, void 0);
        __privateAdd(this, _cachedKPuzzle, void 0);
        __privateAdd(this, _cachedSVG, void 0);
        this.pgId = info.pgID;
        this.id = info.id;
        this.fullName = info.fullName;
        this.inventedBy = info.inventedBy;
        this.inventionYear = info.inventionYear;
      }
      pg() {
        return __privateGet(this, _cachedPG) ?? __privateSet(this, _cachedPG, asyncGetPuzzleGeometry(this.pgId ?? this.id));
      }
      kpuzzle() {
        return __privateGet(this, _cachedKPuzzle) ?? __privateSet(this, _cachedKPuzzle, asyncGetKPuzzle2(this.pg(), this.id));
      }
      svg() {
        return __privateGet(this, _cachedSVG) ?? __privateSet(this, _cachedSVG, (async () => (await this.pg()).generatesvg())());
      }
    };
    _cachedPG = new WeakMap();
    _cachedKPuzzle = new WeakMap();
    _cachedSVG = new WeakMap();
    CubePGPuzzleLoader = class extends PGPuzzleLoader {
      constructor() {
        super(...arguments);
        this.stickerings = cubeStickerings;
      }
      appearance(stickering) {
        return cubeAppearance(this, stickering);
      }
    };
  }
});

// src/cubing/puzzles/implementations/2x2x2/2x2x2.kpuzzle.json.ts
var x2x2_kpuzzle_json_exports = {};
__export(x2x2_kpuzzle_json_exports, {
  cube2x2x2KPuzzleDefinition: () => cube2x2x2KPuzzleDefinition
});
var cube2x2x2KPuzzleDefinition;
var init_x2x2_kpuzzle_json = __esm({
  "src/cubing/puzzles/implementations/2x2x2/2x2x2.kpuzzle.json.ts"() {
    cube2x2x2KPuzzleDefinition = {
      name: "2x2x2",
      orbits: {
        CORNERS: { numPieces: 8, numOrientations: 3 }
      },
      startStateData: {
        CORNERS: {
          pieces: [0, 1, 2, 3, 4, 5, 6, 7],
          orientation: [0, 0, 0, 0, 0, 0, 0, 0]
        }
      },
      moves: {
        U: {
          CORNERS: {
            permutation: [1, 2, 3, 0, 4, 5, 6, 7],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0]
          }
        },
        y: {
          CORNERS: {
            permutation: [1, 2, 3, 0, 7, 4, 5, 6],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0]
          }
        },
        x: {
          CORNERS: {
            permutation: [4, 0, 3, 5, 7, 6, 2, 1],
            orientation: [2, 1, 2, 1, 1, 2, 1, 2]
          }
        },
        L: {
          CORNERS: {
            permutation: [0, 1, 6, 2, 4, 3, 5, 7],
            orientation: [0, 0, 2, 1, 0, 2, 1, 0]
          }
        },
        F: {
          CORNERS: {
            permutation: [3, 1, 2, 5, 0, 4, 6, 7],
            orientation: [1, 0, 0, 2, 2, 1, 0, 0]
          }
        },
        R: {
          CORNERS: {
            permutation: [4, 0, 2, 3, 7, 5, 6, 1],
            orientation: [2, 1, 0, 0, 1, 0, 0, 2]
          }
        },
        B: {
          CORNERS: {
            permutation: [0, 7, 1, 3, 4, 5, 2, 6],
            orientation: [0, 2, 1, 0, 0, 0, 2, 1]
          }
        },
        D: {
          CORNERS: {
            permutation: [0, 1, 2, 3, 5, 6, 7, 4],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0]
          }
        },
        z: {
          CORNERS: {
            permutation: [3, 2, 6, 5, 0, 4, 7, 1],
            orientation: [1, 2, 1, 2, 2, 1, 2, 1]
          }
        }
      }
    };
    cube2x2x2KPuzzleDefinition.moves["Rv"] = cube2x2x2KPuzzleDefinition.moves["x"];
    cube2x2x2KPuzzleDefinition.moves["Uv"] = cube2x2x2KPuzzleDefinition.moves["y"];
    cube2x2x2KPuzzleDefinition.moves["Fv"] = cube2x2x2KPuzzleDefinition.moves["z"];
    cube2x2x2KPuzzleDefinition.moves["Lv"] = {
      CORNERS: {
        permutation: [1, 7, 6, 2, 0, 3, 5, 4],
        orientation: [2, 1, 2, 1, 1, 2, 1, 2]
      }
    };
    cube2x2x2KPuzzleDefinition.moves["Dv"] = {
      CORNERS: {
        permutation: [3, 0, 1, 2, 5, 6, 7, 4],
        orientation: [0, 0, 0, 0, 0, 0, 0, 0]
      }
    };
    cube2x2x2KPuzzleDefinition.moves["Bv"] = {
      CORNERS: {
        permutation: [4, 7, 1, 0, 5, 3, 2, 6],
        orientation: [1, 2, 1, 2, 2, 1, 2, 1]
      }
    };
  }
});

// src/cubing/puzzles/implementations/2x2x2/2x2x2.kpuzzle.svg.ts
var x2x2_kpuzzle_svg_exports = {};
__export(x2x2_kpuzzle_svg_exports, {
  default: () => x2x2_kpuzzle_svg_default
});
var x2x2_kpuzzle_svg_default;
var init_x2x2_kpuzzle_svg = __esm({
  "src/cubing/puzzles/implementations/2x2x2/2x2x2.kpuzzle.svg.ts"() {
    x2x2_kpuzzle_svg_default = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN"
       "http://www.w3.org/TR/2001/REC-SVG-20050904/DTD/svg11.dtd">
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 520 394" preserveAspectRatio="xMidYMid meet">
  <title>2x2x2</title>
  <defs>
    <g id="sticker">
        <rect x="0" y="0" width="1" height="1" stroke="black" stroke-width="0.04px" />
    </g>
  </defs>
  <g id="puzzle" transform="translate(5, 5) scale(60)">
    <use id="CORNERS-l0-o0" xlink:href="#sticker" transform="translate(3.2, 1)" style="fill: white"/>
    <use id="CORNERS-l0-o1" xlink:href="#sticker" transform="translate(4.4, 2.2)" style="fill: red"/>
    <use id="CORNERS-l0-o2" xlink:href="#sticker" transform="translate(3.2, 2.2)" style="fill: limegreen"/>

    <use id="CORNERS-l1-o0" xlink:href="#sticker" transform="translate(3.2, 0)" style="fill: white"/>
    <use id="CORNERS-l1-o1" xlink:href="#sticker" transform="translate(6.6, 2.2)" style="fill: #26f"/>
    <use id="CORNERS-l1-o2" xlink:href="#sticker" transform="translate(5.4, 2.2)" style="fill: red"/>

    <use id="CORNERS-l2-o0" xlink:href="#sticker" transform="translate(2.2, 0)" style="fill: white"/>
    <use id="CORNERS-l2-o1" xlink:href="#sticker" transform="translate(0, 2.2)" style="fill: orange"/>
    <use id="CORNERS-l2-o2" xlink:href="#sticker" transform="translate(7.6, 2.2)" style="fill: #26f"/>

    <use id="CORNERS-l3-o0" xlink:href="#sticker" transform="translate(2.2, 1)" style="fill: white"/>
    <use id="CORNERS-l3-o1" xlink:href="#sticker" transform="translate(2.2, 2.2)" style="fill: limegreen"/>
    <use id="CORNERS-l3-o2" xlink:href="#sticker" transform="translate(1, 2.2)" style="fill: orange"/>

    <use id="CORNERS-l4-o0" xlink:href="#sticker" transform="translate(3.2, 4.4)" style="fill: yellow"/>
    <use id="CORNERS-l4-o1" xlink:href="#sticker" transform="translate(3.2, 3.2)" style="fill: limegreen"/>
    <use id="CORNERS-l4-o2" xlink:href="#sticker" transform="translate(4.4, 3.2)" style="fill: red"/>

    <use id="CORNERS-l5-o0" xlink:href="#sticker" transform="translate(2.2, 4.4)" style="fill: yellow"/>
    <use id="CORNERS-l5-o1" xlink:href="#sticker" transform="translate(1, 3.2)" style="fill: orange"/>
    <use id="CORNERS-l5-o2" xlink:href="#sticker" transform="translate(2.2, 3.2)" style="fill: limegreen"/>

    <use id="CORNERS-l6-o0" xlink:href="#sticker" transform="translate(2.2, 5.4)" style="fill: yellow"/>
    <use id="CORNERS-l6-o1" xlink:href="#sticker" transform="translate(7.6, 3.2)" style="fill: #26f"/>
    <use id="CORNERS-l6-o2" xlink:href="#sticker" transform="translate(0, 3.2)"  style="fill: orange"/>

    <use id="CORNERS-l7-o0" xlink:href="#sticker" transform="translate(3.2, 5.4)" style="fill: yellow"/>
    <use id="CORNERS-l7-o1" xlink:href="#sticker" transform="translate(5.4, 3.2)" style="fill: red"/>
    <use id="CORNERS-l7-o2" xlink:href="#sticker" transform="translate(6.6, 3.2)" style="fill: #26f"/>
  </g>

</svg>`;
  }
});

// src/cubing/puzzles/implementations/2x2x2/index.ts
var cube2x2x2;
var init_x2x2 = __esm({
  "src/cubing/puzzles/implementations/2x2x2/index.ts"() {
    init_kpuzzle();
    init_async_pg3d();
    init_lazy_cached();
    init_cube_stickerings();
    cube2x2x2 = {
      id: "2x2x2",
      fullName: "2\xD72\xD72 Cube",
      kpuzzle: getCached(async () => new KPuzzle((await Promise.resolve().then(() => (init_x2x2_kpuzzle_json(), x2x2_kpuzzle_json_exports))).cube2x2x2KPuzzleDefinition)),
      svg: async () => {
        return (await Promise.resolve().then(() => (init_x2x2_kpuzzle_svg(), x2x2_kpuzzle_svg_exports))).default;
      },
      pg: getCached(async () => {
        return asyncGetPuzzleGeometry("2x2x2");
      }),
      appearance: (stickering) => cubeAppearance(cube2x2x2, stickering),
      stickerings: cubeStickerings
    };
  }
});

// src/cubing/puzzles/implementations/3x3x3/3x3x3.kpuzzle.svg.ts
var x3x3_kpuzzle_svg_exports = {};
__export(x3x3_kpuzzle_svg_exports, {
  default: () => x3x3_kpuzzle_svg_default
});
var x3x3_kpuzzle_svg_default;
var init_x3x3_kpuzzle_svg = __esm({
  "src/cubing/puzzles/implementations/3x3x3/3x3x3.kpuzzle.svg.ts"() {
    x3x3_kpuzzle_svg_default = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN"
       "http://www.w3.org/TR/2001/REC-SVG-20050904/DTD/svg11.dtd">
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 518 392" preserveAspectRatio="xMidYMid meet">
  <title>3x3x3</title>
  <defs>
    <g id="sticker">
        <rect x="0" y="0" width="1" height="1" stroke="black" stroke-width="0.04px" />
    </g>
  </defs>

<!--        0 1 2 3 4 5 6 7 8 9 10 11  -->
<!--        | | | | | | | | | | | |<-  -->
<!--    0 -       . . .                -->
<!--    1 -       . . .                -->
<!--    2 -       . . .                -->
<!--    3 - . . . . . . . . . . . .    -->
<!--    4 - . . . . . . . . . . . .    -->
<!--    5 - . . . . . . . . . . . .    -->
<!--    6 -       . . .                -->
<!--    7 -       . . .                -->
<!--    8 -       . . .                -->

  <g id="puzzle" transform="translate(5,5) scale(40)">
    <!-- CORNERS -->
    <use id="CORNERS-l0-o0" xlink:href="#sticker" transform="translate(5.3,2.1)" style="fill: white"/>
    <use id="CORNERS-l0-o1" xlink:href="#sticker" transform="translate(6.5,3.3)" style="fill: red"/>
    <use id="CORNERS-l0-o2" xlink:href="#sticker" transform="translate(5.3,3.3)" style="fill: limegreen"/>

    <use id="CORNERS-l1-o0" xlink:href="#sticker" transform="translate(5.3,0.1)" style="fill: white"/>
    <use id="CORNERS-l1-o1" xlink:href="#sticker" transform="translate(9.7,3.3)" style="fill: #26f"/>
    <use id="CORNERS-l1-o2" xlink:href="#sticker" transform="translate(8.5,3.3)" style="fill: red"/>

    <use id="CORNERS-l2-o0" xlink:href="#sticker" transform="translate(3.3,0.1)" style="fill: white"/>
    <use id="CORNERS-l2-o1" xlink:href="#sticker" transform="translate(0.1,3.3)" style="fill: orange"/>
    <use id="CORNERS-l2-o2" xlink:href="#sticker" transform="translate(11.7,3.3)" style="fill: #26f"/>

    <use id="CORNERS-l3-o0" xlink:href="#sticker" transform="translate(3.3,2.1)" style="fill: white"/>
    <use id="CORNERS-l3-o1" xlink:href="#sticker" transform="translate(3.3,3.3)" style="fill: limegreen"/>
    <use id="CORNERS-l3-o2" xlink:href="#sticker" transform="translate(2.1,3.3)" style="fill: orange"/>

    <use id="CORNERS-l4-o0" xlink:href="#sticker" transform="translate(5.3,6.5)" style="fill: yellow"/>
    <use id="CORNERS-l4-o1" xlink:href="#sticker" transform="translate(5.3,5.3)" style="fill: limegreen"/>
    <use id="CORNERS-l4-o2" xlink:href="#sticker" transform="translate(6.5,5.3)" style="fill: red"/>

    <use id="CORNERS-l5-o0" xlink:href="#sticker" transform="translate(3.3,6.5)" style="fill: yellow"/>
    <use id="CORNERS-l5-o1" xlink:href="#sticker" transform="translate(2.1,5.3)" style="fill: orange"/>
    <use id="CORNERS-l5-o2" xlink:href="#sticker" transform="translate(3.3,5.3)" style="fill: limegreen"/>

    <use id="CORNERS-l6-o0" xlink:href="#sticker" transform="translate(3.3,8.5)" style="fill: yellow"/>
    <use id="CORNERS-l6-o1" xlink:href="#sticker" transform="translate(11.7,5.3)" style="fill: #26f"/>
    <use id="CORNERS-l6-o2" xlink:href="#sticker" transform="translate(0.1,5.3)"  style="fill: orange"/>

    <use id="CORNERS-l7-o0" xlink:href="#sticker" transform="translate(5.3,8.5)" style="fill: yellow"/>
    <use id="CORNERS-l7-o1" xlink:href="#sticker" transform="translate(8.5,5.3)" style="fill: red"/>
    <use id="CORNERS-l7-o2" xlink:href="#sticker" transform="translate(9.7,5.3)" style="fill: #26f"/>

    <!-- EDGES -->
    <use id="EDGES-l0-o0"  xlink:href="#sticker" transform="translate(4.3,2.1)" style="fill: white"/>
    <use id="EDGES-l0-o1"  xlink:href="#sticker" transform="translate(4.3,3.3)" style="fill: limegreen"/>

    <use id="EDGES-l1-o0"  xlink:href="#sticker" transform="translate(5.3,1.1)" style="fill: white"/>
    <use id="EDGES-l1-o1"  xlink:href="#sticker" transform="translate(7.5,3.3)" style="fill: red"/>

    <use id="EDGES-l2-o0"  xlink:href="#sticker" transform="translate(4.3,0.1)" style="fill: white"/>
    <use id="EDGES-l2-o1"  xlink:href="#sticker" transform="translate(10.7,3.3)" style="fill: #26f"/>

    <use id="EDGES-l3-o0"  xlink:href="#sticker" transform="translate(3.3,1.1)" style="fill: white"/>
    <use id="EDGES-l3-o1"  xlink:href="#sticker" transform="translate(1.1,3.3)" style="fill: orange"/>

    <use id="EDGES-l4-o0"  xlink:href="#sticker" transform="translate(4.3,6.5)" style="fill: yellow"/>
    <use id="EDGES-l4-o1"  xlink:href="#sticker" transform="translate(4.3,5.3)" style="fill: limegreen"/>

    <use id="EDGES-l5-o0" xlink:href="#sticker" transform="translate(5.3,7.5)" style="fill: yellow"/>
    <use id="EDGES-l5-o1" xlink:href="#sticker" transform="translate(7.5,5.3)" style="fill: red"/>

    <use id="EDGES-l6-o0" xlink:href="#sticker" transform="translate(4.3,8.5)" style="fill: yellow"/>
    <use id="EDGES-l6-o1" xlink:href="#sticker" transform="translate(10.7,5.3)" style="fill: #26f"/>

    <use id="EDGES-l7-o0"  xlink:href="#sticker" transform="translate(3.3,7.5)" style="fill: yellow"/>
    <use id="EDGES-l7-o1"  xlink:href="#sticker" transform="translate(1.1,5.3)" style="fill: orange"/>

    <use id="EDGES-l8-o0"  xlink:href="#sticker" transform="translate(5.3,4.3)" style="fill: limegreen"/>
    <use id="EDGES-l8-o1"  xlink:href="#sticker" transform="translate(6.5,4.3)" style="fill: red"/>

    <use id="EDGES-l9-o0"  xlink:href="#sticker" transform="translate(3.3,4.3)" style="fill: limegreen"/>
    <use id="EDGES-l9-o1"  xlink:href="#sticker" transform="translate(2.1,4.3)" style="fill: orange"/>

    <use id="EDGES-l10-o0" xlink:href="#sticker" transform="translate(9.7,4.3)" style="fill: #26f"/>
    <use id="EDGES-l10-o1" xlink:href="#sticker" transform="translate(8.5,4.3)" style="fill: red"/>

    <use id="EDGES-l11-o0" xlink:href="#sticker" transform="translate(11.7,4.3)" style="fill: #26f"/>
    <use id="EDGES-l11-o1" xlink:href="#sticker" transform="translate(0.1,4.3)" style="fill: orange"/>

    <!-- CENTERS -->
    <!-- TODO: Allow the same sticker to be reused for multiple orientations -->
    <use id="CENTERS-l0-o0" xlink:href="#sticker" transform="translate(4.3,1.1)" style="fill: white"/>
    <use id="CENTERS-l0-o1" xlink:href="#sticker" transform="translate(4.3,1.1)" style="fill: white"/>
    <use id="CENTERS-l0-o2" xlink:href="#sticker" transform="translate(4.3,1.1)" style="fill: white"/>
    <use id="CENTERS-l0-o3" xlink:href="#sticker" transform="translate(4.3,1.1)" style="fill: white"/>

    <use id="CENTERS-l1-o0" xlink:href="#sticker" transform="translate(1.1,4.3)" style="fill: orange"/>
    <use id="CENTERS-l1-o1" xlink:href="#sticker" transform="translate(1.1,4.3)" style="fill: orange"/>
    <use id="CENTERS-l1-o2" xlink:href="#sticker" transform="translate(1.1,4.3)" style="fill: orange"/>
    <use id="CENTERS-l1-o3" xlink:href="#sticker" transform="translate(1.1,4.3)" style="fill: orange"/>

    <use id="CENTERS-l2-o0" xlink:href="#sticker" transform="translate(4.3,4.3)" style="fill: limegreen"/>
    <use id="CENTERS-l2-o1" xlink:href="#sticker" transform="translate(4.3,4.3)" style="fill: limegreen"/>
    <use id="CENTERS-l2-o2" xlink:href="#sticker" transform="translate(4.3,4.3)" style="fill: limegreen"/>
    <use id="CENTERS-l2-o3" xlink:href="#sticker" transform="translate(4.3,4.3)" style="fill: limegreen"/>

    <use id="CENTERS-l3-o0" xlink:href="#sticker" transform="translate(7.5,4.3)" style="fill: red"/>
    <use id="CENTERS-l3-o1" xlink:href="#sticker" transform="translate(7.5,4.3)" style="fill: red"/>
    <use id="CENTERS-l3-o2" xlink:href="#sticker" transform="translate(7.5,4.3)" style="fill: red"/>
    <use id="CENTERS-l3-o3" xlink:href="#sticker" transform="translate(7.5,4.3)" style="fill: red"/>

    <use id="CENTERS-l4-o0" xlink:href="#sticker" transform="translate(10.7,4.3)" style="fill: #26f"/>
    <use id="CENTERS-l4-o1" xlink:href="#sticker" transform="translate(10.7,4.3)" style="fill: #26f"/>
    <use id="CENTERS-l4-o2" xlink:href="#sticker" transform="translate(10.7,4.3)" style="fill: #26f"/>
    <use id="CENTERS-l4-o3" xlink:href="#sticker" transform="translate(10.7,4.3)" style="fill: #26f"/>

    <use id="CENTERS-l5-o0" xlink:href="#sticker" transform="translate(4.3,7.5)" style="fill: yellow"/>
    <use id="CENTERS-l5-o1" xlink:href="#sticker" transform="translate(4.3,7.5)" style="fill: yellow"/>
    <use id="CENTERS-l5-o2" xlink:href="#sticker" transform="translate(4.3,7.5)" style="fill: yellow"/>
    <use id="CENTERS-l5-o3" xlink:href="#sticker" transform="translate(4.3,7.5)" style="fill: yellow"/>
  </g>

</svg>`;
  }
});

// src/cubing/puzzles/implementations/3x3x3/3x3x3-ll.kpuzzle.svg.ts
var x3x3_ll_kpuzzle_svg_exports = {};
__export(x3x3_ll_kpuzzle_svg_exports, {
  default: () => x3x3_ll_kpuzzle_svg_default
});
var x3x3_ll_kpuzzle_svg_default;
var init_x3x3_ll_kpuzzle_svg = __esm({
  "src/cubing/puzzles/implementations/3x3x3/3x3x3-ll.kpuzzle.svg.ts"() {
    x3x3_ll_kpuzzle_svg_default = `<?xml version="1.0" encoding="UTF-8"?>
<svg width="288px" height="288px" viewBox="-16 -16 288 288" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>3x3x3 LL</title>
  <defs>
    <g id="sticker">
        <rect x="-10" y="-10" width="1" height="1" stroke="black" stroke-width="0.04px" />
    </g>
  </defs>
  <g id="3x3x3-LL" stroke="none" stroke-width="4" style="none" stroke-linejoin="round">
    <rect id="CENTERS-l0-o0" stroke="#000000" style="fill: white" x="96" y="96" width="64" height="64"></rect>
    <rect id="CENTERS-l0-o1" stroke="#000000" style="fill: white" x="96" y="96" width="64" height="64"></rect>
    <rect id="CENTERS-l0-o2" stroke="#000000" style="fill: white" x="96" y="96" width="64" height="64"></rect>
    <rect id="CENTERS-l0-o3" stroke="#000000" style="fill: white" x="96" y="96" width="64" height="64"></rect>

    <rect    id="CORNERS-l0-o0" stroke="#000000" style="fill: white" x="160" y="160" width="64" height="64"></rect>
    <polygon id="CORNERS-l0-o1" stroke="#000000" style="fill: red" points="224 160 252 160 252 252 224 224"></polygon>
    <polygon id="CORNERS-l0-o2" stroke="#000000" style="fill: limegreen" transform="translate(206, 238) scale(1, -1) rotate(-90) translate(-206, -238) " points="192 192 220 192 220 284 192 256"></polygon>
    <rect    id="CORNERS-l1-o0" stroke="#000000" style="fill: white" x="160" y="32" width="64" height="64"></rect>
    <polygon id="CORNERS-l1-o1" stroke="#000000" style="fill: #26f" transform="translate(206, 18) rotate(-90) translate(-206, -18) " points="192 -28 220 -28 220 64 192 36"></polygon>
    <polygon id="CORNERS-l1-o2" stroke="#000000" style="fill: red" transform="translate(238, 50) scale(1, -1) translate(-238, -50) " points="224 4 252 4 252 96 224 68"></polygon>
    <rect    id="CORNERS-l2-o0" stroke="#000000" style="fill: white" x="32" y="32" width="64" height="64"></rect>
    <polygon id="CORNERS-l2-o1" stroke="#000000" style="fill: orange" transform="translate(18, 50) scale(-1, -1) translate(-18, -50) " points="4 4 32 4 32 96 4 68"></polygon>
    <polygon id="CORNERS-l2-o2" stroke="#000000" style="fill: #26f" transform="translate(50, 18) scale(1, -1) rotate(90) translate(-50, -18) " points="36 -28 64 -28 64 64 36 36"></polygon>
    <rect    id="CORNERS-l3-o0" stroke="#000000" style="fill: white" x="32" y="160" width="64" height="64"></rect>
    <polygon id="CORNERS-l3-o1" stroke="#000000" style="fill: limegreen" transform="translate(50, 238) rotate(90) translate(-50, -238) " points="36 192 64 192 64 284 36 256"></polygon>
    <polygon id="CORNERS-l3-o2" stroke="#000000" style="fill: orange" transform="translate(18, 206) scale(-1, 1) translate(-18, -206) " points="4 160 32 160 32 252 4 224"></polygon>

    <rect id="EDGES-l0-o0" stroke="#000000" style="fill: white" x="96" y="160" width="64" height="64"></rect>
    <rect id="EDGES-l0-o1" stroke="#000000" style="fill: limegreen" transform="translate(128, 238) scale(1, -1) rotate(90) translate(-128, -238) " x="114" y="206" width="28" height="64"></rect>
    <rect id="EDGES-l1-o0" stroke="#000000" style="fill: white" x="160" y="96" width="64" height="64"></rect>
    <rect id="EDGES-l1-o1" stroke="#000000" style="fill: red" x="224" y="96" width="28" height="64"></rect>
    <rect id="EDGES-l2-o0" stroke="#000000" style="fill: white" x="96" y="32" width="64" height="64"></rect>
    <rect id="EDGES-l2-o1" stroke="#000000" style="fill: #26f" transform="translate(128, 18) scale(1, -1) rotate(90) translate(-128, -18) " x="114" y="-14" width="28" height="64"></rect>
    <rect id="EDGES-l3-o0" stroke="#000000" style="fill: white" x="32" y="96" width="64" height="64"></rect>
    <rect id="EDGES-l3-o1" stroke="#000000" style="fill: orange" x="4" y="96" width="28" height="64"></rect>

  </g>
  <g style="opacity: 0">
    <!-- CORNERS -->
    <use id="CORNERS-l4-o0" xlink:href="#sticker" style="fill: yellow"/>
    <use id="CORNERS-l4-o1" xlink:href="#sticker" style="fill: limegreen"/>
    <use id="CORNERS-l4-o2" xlink:href="#sticker" style="fill: red"/>

    <use id="CORNERS-l5-o0" xlink:href="#sticker" style="fill: yellow"/>
    <use id="CORNERS-l5-o1" xlink:href="#sticker" style="fill: orange"/>
    <use id="CORNERS-l5-o2" xlink:href="#sticker" style="fill: limegreen"/>

    <use id="CORNERS-l6-o0" xlink:href="#sticker" style="fill: yellow"/>
    <use id="CORNERS-l6-o1" xlink:href="#sticker" style="fill: #26f"/>
    <use id="CORNERS-l6-o2" xlink:href="#sticker"  style="fill: orange"/>

    <use id="CORNERS-l7-o0" xlink:href="#sticker" style="fill: yellow"/>
    <use id="CORNERS-l7-o1" xlink:href="#sticker" style="fill: red"/>
    <use id="CORNERS-l7-o2" xlink:href="#sticker" style="fill: #26f"/>

    <!-- EDGES -->
    <use id="EDGES-l4-o0"  xlink:href="#sticker" style="fill: yellow"/>
    <use id="EDGES-l4-o1"  xlink:href="#sticker" style="fill: limegreen"/>

    <use id="EDGES-l5-o0" xlink:href="#sticker" style="fill: yellow"/>
    <use id="EDGES-l5-o1" xlink:href="#sticker" style="fill: red"/>

    <use id="EDGES-l6-o0" xlink:href="#sticker" style="fill: yellow"/>
    <use id="EDGES-l6-o1" xlink:href="#sticker" style="fill: #26f"/>

    <use id="EDGES-l7-o0"  xlink:href="#sticker" style="fill: yellow"/>
    <use id="EDGES-l7-o1"  xlink:href="#sticker" style="fill: orange"/>

    <use id="EDGES-l8-o0"  xlink:href="#sticker" style="fill: limegreen"/>
    <use id="EDGES-l8-o1"  xlink:href="#sticker" style="fill: red"/>

    <use id="EDGES-l9-o0"  xlink:href="#sticker" style="fill: limegreen"/>
    <use id="EDGES-l9-o1"  xlink:href="#sticker" style="fill: orange"/>

    <use id="EDGES-l10-o0" xlink:href="#sticker" style="fill: #26f"/>
    <use id="EDGES-l10-o1" xlink:href="#sticker" style="fill: red"/>

    <use id="EDGES-l11-o0" xlink:href="#sticker" style="fill: #26f"/>
    <use id="EDGES-l11-o1" xlink:href="#sticker" style="fill: orange"/>

    <!-- CENTERS -->
    <!-- TODO: Allow the same sticker to be reused for multiple orientations -->
    <use id="CENTERS-l1-o0" xlink:href="#sticker" style="fill: orange"/>
    <use id="CENTERS-l1-o1" xlink:href="#sticker" style="fill: orange"/>
    <use id="CENTERS-l1-o2" xlink:href="#sticker" style="fill: orange"/>
    <use id="CENTERS-l1-o3" xlink:href="#sticker" style="fill: orange"/>

    <use id="CENTERS-l2-o0" xlink:href="#sticker" style="fill: limegreen"/>
    <use id="CENTERS-l2-o1" xlink:href="#sticker" style="fill: limegreen"/>
    <use id="CENTERS-l2-o2" xlink:href="#sticker" style="fill: limegreen"/>
    <use id="CENTERS-l2-o3" xlink:href="#sticker" style="fill: limegreen"/>

    <use id="CENTERS-l3-o0" xlink:href="#sticker" style="fill: red"/>
    <use id="CENTERS-l3-o1" xlink:href="#sticker" style="fill: red"/>
    <use id="CENTERS-l3-o2" xlink:href="#sticker" style="fill: red"/>
    <use id="CENTERS-l3-o3" xlink:href="#sticker" style="fill: red"/>

    <use id="CENTERS-l4-o0" xlink:href="#sticker" style="fill: #26f"/>
    <use id="CENTERS-l4-o1" xlink:href="#sticker" style="fill: #26f"/>
    <use id="CENTERS-l4-o2" xlink:href="#sticker" style="fill: #26f"/>
    <use id="CENTERS-l4-o3" xlink:href="#sticker" style="fill: #26f"/>

    <use id="CENTERS-l5-o0" xlink:href="#sticker" style="fill: yellow"/>
    <use id="CENTERS-l5-o1" xlink:href="#sticker" style="fill: yellow"/>
    <use id="CENTERS-l5-o2" xlink:href="#sticker" style="fill: yellow"/>
    <use id="CENTERS-l5-o3" xlink:href="#sticker" style="fill: yellow"/>
  </g>
</svg>`;
  }
});

// src/cubing/puzzles/implementations/3x3x3/index.ts
var cube3x3x3;
var init_x3x3 = __esm({
  "src/cubing/puzzles/implementations/3x3x3/index.ts"() {
    init_kpuzzle();
    init_async_pg3d();
    init_lazy_cached();
    init_cube_stickerings();
    cube3x3x3 = {
      id: "3x3x3",
      fullName: "3\xD73\xD73 Cube",
      inventedBy: ["Ern\u0151 Rubik"],
      inventionYear: 1974,
      kpuzzle: getCached(async () => {
        return experimental3x3x3KPuzzle;
      }),
      svg: getCached(async () => {
        return (await Promise.resolve().then(() => (init_x3x3_kpuzzle_svg(), x3x3_kpuzzle_svg_exports))).default;
      }),
      llSVG: getCached(async () => {
        return (await Promise.resolve().then(() => (init_x3x3_ll_kpuzzle_svg(), x3x3_ll_kpuzzle_svg_exports))).default;
      }),
      pg: getCached(async () => {
        return asyncGetPuzzleGeometry("3x3x3");
      }),
      appearance: (stickering) => cubeAppearance(cube3x3x3, stickering),
      stickerings: cubeStickerings
    };
  }
});

// src/cubing/puzzles/implementations/clock/clock.kpuzzle.json.ts
var clock_kpuzzle_json_exports = {};
__export(clock_kpuzzle_json_exports, {
  clockKPuzzleDefinition: () => clockKPuzzleDefinition
});
var clockKPuzzleDefinition;
var init_clock_kpuzzle_json = __esm({
  "src/cubing/puzzles/implementations/clock/clock.kpuzzle.json.ts"() {
    clockKPuzzleDefinition = {
      name: "Clock",
      orbits: {
        DIALS: { numPieces: 18, numOrientations: 12 },
        FACES: { numPieces: 18, numOrientations: 1 },
        FRAME: { numPieces: 1, numOrientations: 2 }
      },
      startStateData: {
        DIALS: {
          pieces: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17],
          orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        },
        FACES: {
          pieces: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17],
          orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        },
        FRAME: { pieces: [0], orientation: [0] }
      },
      moves: {
        UR_PLUS_: {
          DIALS: {
            permutation: [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12,
              13,
              14,
              15,
              16,
              17
            ],
            orientation: [0, 1, 1, 0, 1, 1, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0]
          },
          FACES: {
            permutation: [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12,
              13,
              14,
              15,
              16,
              17
            ],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
          },
          FRAME: { permutation: [0], orientation: [0] }
        },
        DR_PLUS_: {
          DIALS: {
            permutation: [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12,
              13,
              14,
              15,
              16,
              17
            ],
            orientation: [0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, -1, 0, 0]
          },
          FACES: {
            permutation: [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12,
              13,
              14,
              15,
              16,
              17
            ],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
          },
          FRAME: { permutation: [0], orientation: [0] }
        },
        DL_PLUS_: {
          DIALS: {
            permutation: [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12,
              13,
              14,
              15,
              16,
              17
            ],
            orientation: [0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1]
          },
          FACES: {
            permutation: [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12,
              13,
              14,
              15,
              16,
              17
            ],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
          },
          FRAME: { permutation: [0], orientation: [0] }
        },
        UL_PLUS_: {
          DIALS: {
            permutation: [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12,
              13,
              14,
              15,
              16,
              17
            ],
            orientation: [1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0]
          },
          FACES: {
            permutation: [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12,
              13,
              14,
              15,
              16,
              17
            ],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
          },
          FRAME: { permutation: [0], orientation: [0] }
        },
        U_PLUS_: {
          DIALS: {
            permutation: [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12,
              13,
              14,
              15,
              16,
              17
            ],
            orientation: [1, 1, 1, 1, 1, 1, 0, 0, 0, -1, 0, -1, 0, 0, 0, 0, 0, 0]
          },
          FACES: {
            permutation: [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12,
              13,
              14,
              15,
              16,
              17
            ],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
          },
          FRAME: { permutation: [0], orientation: [0] }
        },
        R_PLUS_: {
          DIALS: {
            permutation: [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12,
              13,
              14,
              15,
              16,
              17
            ],
            orientation: [0, 1, 1, 0, 1, 1, 0, 1, 1, -1, 0, 0, 0, 0, 0, -1, 0, 0]
          },
          FACES: {
            permutation: [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12,
              13,
              14,
              15,
              16,
              17
            ],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
          },
          FRAME: { permutation: [0], orientation: [0] }
        },
        D_PLUS_: {
          DIALS: {
            permutation: [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12,
              13,
              14,
              15,
              16,
              17
            ],
            orientation: [0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, -1, 0, -1]
          },
          FACES: {
            permutation: [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12,
              13,
              14,
              15,
              16,
              17
            ],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
          },
          FRAME: { permutation: [0], orientation: [0] }
        },
        L_PLUS_: {
          DIALS: {
            permutation: [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12,
              13,
              14,
              15,
              16,
              17
            ],
            orientation: [1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, -1, 0, 0, 0, 0, 0, -1]
          },
          FACES: {
            permutation: [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12,
              13,
              14,
              15,
              16,
              17
            ],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
          },
          FRAME: { permutation: [0], orientation: [0] }
        },
        ALL_PLUS_: {
          DIALS: {
            permutation: [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12,
              13,
              14,
              15,
              16,
              17
            ],
            orientation: [1, 1, 1, 1, 1, 1, 1, 1, 1, -1, 0, -1, 0, 0, 0, -1, 0, -1]
          },
          FACES: {
            permutation: [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12,
              13,
              14,
              15,
              16,
              17
            ],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
          },
          FRAME: { permutation: [0], orientation: [0] }
        },
        y2: {
          DIALS: {
            permutation: [
              9,
              10,
              11,
              12,
              13,
              14,
              15,
              16,
              17,
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8
            ],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
          },
          FACES: {
            permutation: [
              9,
              10,
              11,
              12,
              13,
              14,
              15,
              16,
              17,
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8
            ],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
          },
          FRAME: { permutation: [0], orientation: [1] }
        },
        UL: {
          DIALS: {
            permutation: [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12,
              13,
              14,
              15,
              16,
              17
            ],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
          },
          FACES: {
            permutation: [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12,
              13,
              14,
              15,
              16,
              17
            ],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
          },
          FRAME: { permutation: [0], orientation: [0] }
        },
        UR: {
          DIALS: {
            permutation: [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12,
              13,
              14,
              15,
              16,
              17
            ],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
          },
          FACES: {
            permutation: [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12,
              13,
              14,
              15,
              16,
              17
            ],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
          },
          FRAME: { permutation: [0], orientation: [0] }
        },
        DL: {
          DIALS: {
            permutation: [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12,
              13,
              14,
              15,
              16,
              17
            ],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
          },
          FACES: {
            permutation: [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12,
              13,
              14,
              15,
              16,
              17
            ],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
          },
          FRAME: { permutation: [0], orientation: [0] }
        },
        DR: {
          DIALS: {
            permutation: [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12,
              13,
              14,
              15,
              16,
              17
            ],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
          },
          FACES: {
            permutation: [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12,
              13,
              14,
              15,
              16,
              17
            ],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
          },
          FRAME: { permutation: [0], orientation: [0] }
        }
      }
    };
  }
});

// src/cubing/puzzles/implementations/clock/clock.kpuzzle.svg.ts
var clock_kpuzzle_svg_exports = {};
__export(clock_kpuzzle_svg_exports, {
  default: () => clock_kpuzzle_svg_default
});
var clock_kpuzzle_svg_default;
var init_clock_kpuzzle_svg = __esm({
  "src/cubing/puzzles/implementations/clock/clock.kpuzzle.svg.ts"() {
    clock_kpuzzle_svg_default = `<?xml version="1.0" encoding="UTF-8"?>
<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 480 240" preserveAspectRatio="xMidYMid meet">
  <title>clock</title>
  <defs>
    <g id="hand" transform="translate(-20, -20)">
      <path d="M19.9995197,2.22079449 L23.8791657,19.0203611 C23.9580836,19.3338406 24,19.6620253 24,20 C24,22.209139 22.209139,24 20,24 C17.790861,24 16,22.209139 16,20 C16,19.6620253 16.0419164,19.3338406 16.1208343,19.0203611 L19.9995197,2.22079449 Z"></path>
    </g>
    <g id="cardinal_hours" style="fill: #FFFFFF">
      <circle cx="0" cy="24" r="2"></circle>
      <circle cx="-24" cy="0" r="2"></circle>
      <circle cx="24" cy="0" r="2"></circle>
      <circle cx="0" cy="-24" r="2"></circle>
    </g>
    <g id="face_hours">
      <g>
        <use xlink:href="#cardinal_hours"/>
      </g>
      <g transform="rotate(30)">
        <use xlink:href="#cardinal_hours"/>
      </g>
      <g  transform="rotate(60)">
        <use xlink:href="#cardinal_hours"/>
      </g>
    </g>
    <g id="pegs" stroke="#000000" style="fill: #FFD000">
      <circle id="PEG4" cx="90" cy="90" r="10"></circle>
      <circle id="PEG3" cx="30" cy="90" r="10"></circle>
      <circle id="PEG2" cx="90" cy="30" r="10"></circle>
      <circle id="PEG1" cx="30" cy="30" r="10"></circle>
    </g>
    <g id="frame" transform="translate(-24, -24)">
      <path stroke="#000000" d="M120,20 C137.495665,20 153.941932,24.4930026 168.247913,32.3881183 C171.855881,30.8514056 175.828512,30 180,30 C196.568542,30 210,43.4314575 210,60 C210,64.1714878 209.148594,68.1441192 207.610077,71.7536009 C215.506997,86.0580678 220,102.504335 220,120 C220,137.495665 215.506997,153.941932 207.611882,168.247913 C209.148594,171.855881 210,175.828512 210,180 C210,196.568542 196.568542,210 180,210 C175.828512,210 171.855881,209.148594 168.246399,207.610077 C153.941932,215.506997 137.495665,220 120,220 C102.504335,220 86.0580678,215.506997 71.7520869,207.611882 C68.1441192,209.148594 64.1714878,210 60,210 C43.4314575,210 30,196.568542 30,180 C30,175.828512 30.8514056,171.855881 32.3899234,168.246399 C24.4930026,153.941932 20,137.495665 20,120 C20,102.504335 24.4930026,86.0580678 32.3881183,71.7520869 C30.8514056,68.1441192 30,64.1714878 30,60 C30,43.4314575 43.4314575,30 60,30 C64.1714878,30 68.1441192,30.8514056 71.7536009,32.3899234 C86.0580678,24.4930026 102.504335,20 120,20 Z"></path>
    </g>
  </defs>
  <g>
    <g transform="translate(24, 24)">
      <use xlink:href="#frame" id="FRAME-l0-o0" style="fill: #0C5093"/>
      <use xlink:href="#pegs" transform="translate(36, 36)"/>
      <g transform="translate(36, 36)">
        <circle id="FACES-l0-o0" stroke="#000000" style="fill: #90B8DF" r="20"></circle>
        <use xlink:href="#face_hours"/>
        <g>
          <use id="DIALS-l0-o0"  xlink:href="#hand" transform="rotate(0)" style="fill: #FFD000"/>
          <use id="DIALS-l0-o1"  xlink:href="#hand" transform="rotate(30)" style="fill: #0000"/>
          <use id="DIALS-l0-o2"  xlink:href="#hand" transform="rotate(60)" style="fill: #0000"/>
          <use id="DIALS-l0-o3"  xlink:href="#hand" transform="rotate(90)" style="fill: #0000"/>
          <use id="DIALS-l0-o4"  xlink:href="#hand" transform="rotate(120)" style="fill: #0000"/>
          <use id="DIALS-l0-o5"  xlink:href="#hand" transform="rotate(150)" style="fill: #0000"/>
          <use id="DIALS-l0-o6"  xlink:href="#hand" transform="rotate(180)" style="fill: #0000"/>
          <use id="DIALS-l0-o7"  xlink:href="#hand" transform="rotate(210)" style="fill: #0000"/>
          <use id="DIALS-l0-o8"  xlink:href="#hand" transform="rotate(240)" style="fill: #0000"/>
          <use id="DIALS-l0-o9"  xlink:href="#hand" transform="rotate(270)" style="fill: #0000"/>
          <use id="DIALS-l0-o10" xlink:href="#hand" transform="rotate(300)" style="fill: #0000"/>
          <use id="DIALS-l0-o11" xlink:href="#hand" transform="rotate(330)" style="fill: #0000"/>
        </g>
      </g>
      <g transform="translate(96, 36)">
        <circle id="FACES-l1-o0" stroke="#000000" style="fill: #90B8DF" r="20"></circle>
        <use xlink:href="#face_hours"/>
        <g>
          <use id="DIALS-l1-o0"  xlink:href="#hand" transform="rotate(0)" style="fill: #FFD000"/>
          <use id="DIALS-l1-o1"  xlink:href="#hand" transform="rotate(30)" style="fill: #0000"/>
          <use id="DIALS-l1-o2"  xlink:href="#hand" transform="rotate(60)" style="fill: #0000"/>
          <use id="DIALS-l1-o3"  xlink:href="#hand" transform="rotate(90)" style="fill: #0000"/>
          <use id="DIALS-l1-o4"  xlink:href="#hand" transform="rotate(120)" style="fill: #0000"/>
          <use id="DIALS-l1-o5"  xlink:href="#hand" transform="rotate(150)" style="fill: #0000"/>
          <use id="DIALS-l1-o6"  xlink:href="#hand" transform="rotate(180)" style="fill: #0000"/>
          <use id="DIALS-l1-o7"  xlink:href="#hand" transform="rotate(210)" style="fill: #0000"/>
          <use id="DIALS-l1-o8"  xlink:href="#hand" transform="rotate(240)" style="fill: #0000"/>
          <use id="DIALS-l1-o9"  xlink:href="#hand" transform="rotate(270)" style="fill: #0000"/>
          <use id="DIALS-l1-o10" xlink:href="#hand" transform="rotate(300)" style="fill: #0000"/>
          <use id="DIALS-l1-o11" xlink:href="#hand" transform="rotate(330)" style="fill: #0000"/>
        </g>
      </g>
      <g transform="translate(156, 36)">
        <circle id="FACES-l2-o0" stroke="#000000" style="fill: #90B8DF" r="20"></circle>
        <use xlink:href="#face_hours"/>
        <g>
          <use id="DIALS-l2-o0"  xlink:href="#hand" transform="rotate(0)" style="fill: #FFD000"/>
          <use id="DIALS-l2-o1"  xlink:href="#hand" transform="rotate(30)" style="fill: #0000"/>
          <use id="DIALS-l2-o2"  xlink:href="#hand" transform="rotate(60)" style="fill: #0000"/>
          <use id="DIALS-l2-o3"  xlink:href="#hand" transform="rotate(90)" style="fill: #0000"/>
          <use id="DIALS-l2-o4"  xlink:href="#hand" transform="rotate(120)" style="fill: #0000"/>
          <use id="DIALS-l2-o5"  xlink:href="#hand" transform="rotate(150)" style="fill: #0000"/>
          <use id="DIALS-l2-o6"  xlink:href="#hand" transform="rotate(180)" style="fill: #0000"/>
          <use id="DIALS-l2-o7"  xlink:href="#hand" transform="rotate(210)" style="fill: #0000"/>
          <use id="DIALS-l2-o8"  xlink:href="#hand" transform="rotate(240)" style="fill: #0000"/>
          <use id="DIALS-l2-o9"  xlink:href="#hand" transform="rotate(270)" style="fill: #0000"/>
          <use id="DIALS-l2-o10" xlink:href="#hand" transform="rotate(300)" style="fill: #0000"/>
          <use id="DIALS-l2-o11" xlink:href="#hand" transform="rotate(330)" style="fill: #0000"/>
        </g>
      </g>
      <g transform="translate(36, 96)">
        <circle id="FACES-l3-o0" stroke="#000000" style="fill: #90B8DF" r="20"></circle>
        <use xlink:href="#face_hours"/>
        <g>
          <use id="DIALS-l3-o0"  xlink:href="#hand" transform="rotate(0)" style="fill: #FFD000"/>
          <use id="DIALS-l3-o1"  xlink:href="#hand" transform="rotate(30)" style="fill: #0000"/>
          <use id="DIALS-l3-o2"  xlink:href="#hand" transform="rotate(60)" style="fill: #0000"/>
          <use id="DIALS-l3-o3"  xlink:href="#hand" transform="rotate(90)" style="fill: #0000"/>
          <use id="DIALS-l3-o4"  xlink:href="#hand" transform="rotate(120)" style="fill: #0000"/>
          <use id="DIALS-l3-o5"  xlink:href="#hand" transform="rotate(150)" style="fill: #0000"/>
          <use id="DIALS-l3-o6"  xlink:href="#hand" transform="rotate(180)" style="fill: #0000"/>
          <use id="DIALS-l3-o7"  xlink:href="#hand" transform="rotate(210)" style="fill: #0000"/>
          <use id="DIALS-l3-o8"  xlink:href="#hand" transform="rotate(240)" style="fill: #0000"/>
          <use id="DIALS-l3-o9"  xlink:href="#hand" transform="rotate(270)" style="fill: #0000"/>
          <use id="DIALS-l3-o10" xlink:href="#hand" transform="rotate(300)" style="fill: #0000"/>
          <use id="DIALS-l3-o11" xlink:href="#hand" transform="rotate(330)" style="fill: #0000"/>
        </g>
      </g>
      <g transform="translate(96, 96)">
        <circle id="FACES-l4-o0" stroke="#000000" style="fill: #90B8DF" r="20"></circle>
        <use xlink:href="#face_hours"/>
        <g>
          <use id="DIALS-l4-o0"  xlink:href="#hand" transform="rotate(0)" style="fill: #FFD000"/>
          <use id="DIALS-l4-o1"  xlink:href="#hand" transform="rotate(30)" style="fill: #0000"/>
          <use id="DIALS-l4-o2"  xlink:href="#hand" transform="rotate(60)" style="fill: #0000"/>
          <use id="DIALS-l4-o3"  xlink:href="#hand" transform="rotate(90)" style="fill: #0000"/>
          <use id="DIALS-l4-o4"  xlink:href="#hand" transform="rotate(120)" style="fill: #0000"/>
          <use id="DIALS-l4-o5"  xlink:href="#hand" transform="rotate(150)" style="fill: #0000"/>
          <use id="DIALS-l4-o6"  xlink:href="#hand" transform="rotate(180)" style="fill: #0000"/>
          <use id="DIALS-l4-o7"  xlink:href="#hand" transform="rotate(210)" style="fill: #0000"/>
          <use id="DIALS-l4-o8"  xlink:href="#hand" transform="rotate(240)" style="fill: #0000"/>
          <use id="DIALS-l4-o9"  xlink:href="#hand" transform="rotate(270)" style="fill: #0000"/>
          <use id="DIALS-l4-o10" xlink:href="#hand" transform="rotate(300)" style="fill: #0000"/>
          <use id="DIALS-l4-o11" xlink:href="#hand" transform="rotate(330)" style="fill: #0000"/>
        </g>
      </g>
      <g transform="translate(156, 96)">
        <circle id="FACES-l5-o0" stroke="#000000" style="fill: #90B8DF" r="20"></circle>
        <use xlink:href="#face_hours"/>
        <g>
          <use id="DIALS-l5-o0"  xlink:href="#hand" transform="rotate(0)" style="fill: #FFD000"/>
          <use id="DIALS-l5-o1"  xlink:href="#hand" transform="rotate(30)" style="fill: #0000"/>
          <use id="DIALS-l5-o2"  xlink:href="#hand" transform="rotate(60)" style="fill: #0000"/>
          <use id="DIALS-l5-o3"  xlink:href="#hand" transform="rotate(90)" style="fill: #0000"/>
          <use id="DIALS-l5-o4"  xlink:href="#hand" transform="rotate(120)" style="fill: #0000"/>
          <use id="DIALS-l5-o5"  xlink:href="#hand" transform="rotate(150)" style="fill: #0000"/>
          <use id="DIALS-l5-o6"  xlink:href="#hand" transform="rotate(180)" style="fill: #0000"/>
          <use id="DIALS-l5-o7"  xlink:href="#hand" transform="rotate(210)" style="fill: #0000"/>
          <use id="DIALS-l5-o8"  xlink:href="#hand" transform="rotate(240)" style="fill: #0000"/>
          <use id="DIALS-l5-o9"  xlink:href="#hand" transform="rotate(270)" style="fill: #0000"/>
          <use id="DIALS-l5-o10" xlink:href="#hand" transform="rotate(300)" style="fill: #0000"/>
          <use id="DIALS-l5-o11" xlink:href="#hand" transform="rotate(330)" style="fill: #0000"/>
        </g>
      </g>
      <g transform="translate(36, 156)">
        <circle id="FACES-l6-o0" stroke="#000000" style="fill: #90B8DF" r="20"></circle>
        <use xlink:href="#face_hours"/>
        <g>
          <use id="DIALS-l6-o0"  xlink:href="#hand" transform="rotate(0)" style="fill: #FFD000"/>
          <use id="DIALS-l6-o1"  xlink:href="#hand" transform="rotate(30)" style="fill: #0000"/>
          <use id="DIALS-l6-o2"  xlink:href="#hand" transform="rotate(60)" style="fill: #0000"/>
          <use id="DIALS-l6-o3"  xlink:href="#hand" transform="rotate(90)" style="fill: #0000"/>
          <use id="DIALS-l6-o4"  xlink:href="#hand" transform="rotate(120)" style="fill: #0000"/>
          <use id="DIALS-l6-o5"  xlink:href="#hand" transform="rotate(150)" style="fill: #0000"/>
          <use id="DIALS-l6-o6"  xlink:href="#hand" transform="rotate(180)" style="fill: #0000"/>
          <use id="DIALS-l6-o7"  xlink:href="#hand" transform="rotate(210)" style="fill: #0000"/>
          <use id="DIALS-l6-o8"  xlink:href="#hand" transform="rotate(240)" style="fill: #0000"/>
          <use id="DIALS-l6-o9"  xlink:href="#hand" transform="rotate(270)" style="fill: #0000"/>
          <use id="DIALS-l6-o10" xlink:href="#hand" transform="rotate(300)" style="fill: #0000"/>
          <use id="DIALS-l6-o11" xlink:href="#hand" transform="rotate(330)" style="fill: #0000"/>
        </g>
      </g>
      <g transform="translate(96, 156)">
        <circle id="FACES-l7-o0" stroke="#000000" style="fill: #90B8DF" r="20"></circle>
        <use xlink:href="#face_hours"/>
        <g>
          <use id="DIALS-l7-o0"  xlink:href="#hand" transform="rotate(0)" style="fill: #FFD000"/>
          <use id="DIALS-l7-o1"  xlink:href="#hand" transform="rotate(30)" style="fill: #0000"/>
          <use id="DIALS-l7-o2"  xlink:href="#hand" transform="rotate(60)" style="fill: #0000"/>
          <use id="DIALS-l7-o3"  xlink:href="#hand" transform="rotate(90)" style="fill: #0000"/>
          <use id="DIALS-l7-o4"  xlink:href="#hand" transform="rotate(120)" style="fill: #0000"/>
          <use id="DIALS-l7-o5"  xlink:href="#hand" transform="rotate(150)" style="fill: #0000"/>
          <use id="DIALS-l7-o6"  xlink:href="#hand" transform="rotate(180)" style="fill: #0000"/>
          <use id="DIALS-l7-o7"  xlink:href="#hand" transform="rotate(210)" style="fill: #0000"/>
          <use id="DIALS-l7-o8"  xlink:href="#hand" transform="rotate(240)" style="fill: #0000"/>
          <use id="DIALS-l7-o9"  xlink:href="#hand" transform="rotate(270)" style="fill: #0000"/>
          <use id="DIALS-l7-o10" xlink:href="#hand" transform="rotate(300)" style="fill: #0000"/>
          <use id="DIALS-l7-o11" xlink:href="#hand" transform="rotate(330)" style="fill: #0000"/>
        </g>
      </g>
      <g transform="translate(156, 156)">
        <circle id="FACES-l8-o0" stroke="#000000" style="fill: #90B8DF" r="20"></circle>
        <use xlink:href="#face_hours"/>
        <g>
          <use id="DIALS-l8-o0"  xlink:href="#hand" transform="rotate(0)" style="fill: #FFD000"/>
          <use id="DIALS-l8-o1"  xlink:href="#hand" transform="rotate(30)" style="fill: #0000"/>
          <use id="DIALS-l8-o2"  xlink:href="#hand" transform="rotate(60)" style="fill: #0000"/>
          <use id="DIALS-l8-o3"  xlink:href="#hand" transform="rotate(90)" style="fill: #0000"/>
          <use id="DIALS-l8-o4"  xlink:href="#hand" transform="rotate(120)" style="fill: #0000"/>
          <use id="DIALS-l8-o5"  xlink:href="#hand" transform="rotate(150)" style="fill: #0000"/>
          <use id="DIALS-l8-o6"  xlink:href="#hand" transform="rotate(180)" style="fill: #0000"/>
          <use id="DIALS-l8-o7"  xlink:href="#hand" transform="rotate(210)" style="fill: #0000"/>
          <use id="DIALS-l8-o8"  xlink:href="#hand" transform="rotate(240)" style="fill: #0000"/>
          <use id="DIALS-l8-o9"  xlink:href="#hand" transform="rotate(270)" style="fill: #0000"/>
          <use id="DIALS-l8-o10" xlink:href="#hand" transform="rotate(300)" style="fill: #0000"/>
          <use id="DIALS-l8-o11" xlink:href="#hand" transform="rotate(330)" style="fill: #0000"/>
        </g>
      </g>
    </g>
    <g transform="translate(264, 24)">
      <use xlink:href="#frame" id="FRAME-l0-o1" style="fill: #90B8DF"/>
      <use xlink:href="#pegs" transform="translate(36, 36)"/>
      <g transform="translate(36, 36)">
        <circle id="FACES-l9-o0" stroke="#000000" style="fill: #0C5093" r="20"></circle>
        <use xlink:href="#face_hours"/>
        <g>
          <use id="DIALS-l9-o0"  xlink:href="#hand" transform="rotate(0)" style="fill: #FFD000"/>
          <use id="DIALS-l9-o1"  xlink:href="#hand" transform="rotate(30)" style="fill: #0000"/>
          <use id="DIALS-l9-o2"  xlink:href="#hand" transform="rotate(60)" style="fill: #0000"/>
          <use id="DIALS-l9-o3"  xlink:href="#hand" transform="rotate(90)" style="fill: #0000"/>
          <use id="DIALS-l9-o4"  xlink:href="#hand" transform="rotate(120)" style="fill: #0000"/>
          <use id="DIALS-l9-o5"  xlink:href="#hand" transform="rotate(150)" style="fill: #0000"/>
          <use id="DIALS-l9-o6"  xlink:href="#hand" transform="rotate(180)" style="fill: #0000"/>
          <use id="DIALS-l9-o7"  xlink:href="#hand" transform="rotate(210)" style="fill: #0000"/>
          <use id="DIALS-l9-o8"  xlink:href="#hand" transform="rotate(240)" style="fill: #0000"/>
          <use id="DIALS-l9-o9"  xlink:href="#hand" transform="rotate(270)" style="fill: #0000"/>
          <use id="DIALS-l9-o10" xlink:href="#hand" transform="rotate(300)" style="fill: #0000"/>
          <use id="DIALS-l9-o11" xlink:href="#hand" transform="rotate(330)" style="fill: #0000"/>
        </g>
      </g>
      <g transform="translate(96, 36)">
        <circle id="FACES-l10-o0" stroke="#000000" style="fill: #0C5093" r="20"></circle>
        <use xlink:href="#face_hours"/>
        <g>
          <use id="DIALS-l10-o0"  xlink:href="#hand" transform="rotate(0)" style="fill: #FFD000"/>
          <use id="DIALS-l10-o1"  xlink:href="#hand" transform="rotate(30)" style="fill: #0000"/>
          <use id="DIALS-l10-o2"  xlink:href="#hand" transform="rotate(60)" style="fill: #0000"/>
          <use id="DIALS-l10-o3"  xlink:href="#hand" transform="rotate(90)" style="fill: #0000"/>
          <use id="DIALS-l10-o4"  xlink:href="#hand" transform="rotate(120)" style="fill: #0000"/>
          <use id="DIALS-l10-o5"  xlink:href="#hand" transform="rotate(150)" style="fill: #0000"/>
          <use id="DIALS-l10-o6"  xlink:href="#hand" transform="rotate(180)" style="fill: #0000"/>
          <use id="DIALS-l10-o7"  xlink:href="#hand" transform="rotate(210)" style="fill: #0000"/>
          <use id="DIALS-l10-o8"  xlink:href="#hand" transform="rotate(240)" style="fill: #0000"/>
          <use id="DIALS-l10-o9"  xlink:href="#hand" transform="rotate(270)" style="fill: #0000"/>
          <use id="DIALS-l10-o10" xlink:href="#hand" transform="rotate(300)" style="fill: #0000"/>
          <use id="DIALS-l10-o11" xlink:href="#hand" transform="rotate(330)" style="fill: #0000"/>
        </g>
      </g>
      <g transform="translate(156, 36)">
        <circle id="FACES-l11-o0" stroke="#000000" style="fill: #0C5093" r="20"></circle>
        <use xlink:href="#face_hours"/>
        <g>
          <use id="DIALS-l11-o0"  xlink:href="#hand" transform="rotate(0)" style="fill: #FFD000"/>
          <use id="DIALS-l11-o1"  xlink:href="#hand" transform="rotate(30)" style="fill: #0000"/>
          <use id="DIALS-l11-o2"  xlink:href="#hand" transform="rotate(60)" style="fill: #0000"/>
          <use id="DIALS-l11-o3"  xlink:href="#hand" transform="rotate(90)" style="fill: #0000"/>
          <use id="DIALS-l11-o4"  xlink:href="#hand" transform="rotate(120)" style="fill: #0000"/>
          <use id="DIALS-l11-o5"  xlink:href="#hand" transform="rotate(150)" style="fill: #0000"/>
          <use id="DIALS-l11-o6"  xlink:href="#hand" transform="rotate(180)" style="fill: #0000"/>
          <use id="DIALS-l11-o7"  xlink:href="#hand" transform="rotate(210)" style="fill: #0000"/>
          <use id="DIALS-l11-o8"  xlink:href="#hand" transform="rotate(240)" style="fill: #0000"/>
          <use id="DIALS-l11-o9"  xlink:href="#hand" transform="rotate(270)" style="fill: #0000"/>
          <use id="DIALS-l11-o10" xlink:href="#hand" transform="rotate(300)" style="fill: #0000"/>
          <use id="DIALS-l11-o11" xlink:href="#hand" transform="rotate(330)" style="fill: #0000"/>
        </g>
      </g>
      <g transform="translate(36, 96)">
        <circle id="FACES-l12-o0" stroke="#000000" style="fill: #0C5093" r="20"></circle>
        <use xlink:href="#face_hours"/>
        <g>
          <use id="DIALS-l12-o0"  xlink:href="#hand" transform="rotate(0)" style="fill: #FFD000"/>
          <use id="DIALS-l12-o1"  xlink:href="#hand" transform="rotate(30)" style="fill: #0000"/>
          <use id="DIALS-l12-o2"  xlink:href="#hand" transform="rotate(60)" style="fill: #0000"/>
          <use id="DIALS-l12-o3"  xlink:href="#hand" transform="rotate(90)" style="fill: #0000"/>
          <use id="DIALS-l12-o4"  xlink:href="#hand" transform="rotate(120)" style="fill: #0000"/>
          <use id="DIALS-l12-o5"  xlink:href="#hand" transform="rotate(150)" style="fill: #0000"/>
          <use id="DIALS-l12-o6"  xlink:href="#hand" transform="rotate(180)" style="fill: #0000"/>
          <use id="DIALS-l12-o7"  xlink:href="#hand" transform="rotate(210)" style="fill: #0000"/>
          <use id="DIALS-l12-o8"  xlink:href="#hand" transform="rotate(240)" style="fill: #0000"/>
          <use id="DIALS-l12-o9"  xlink:href="#hand" transform="rotate(270)" style="fill: #0000"/>
          <use id="DIALS-l12-o10" xlink:href="#hand" transform="rotate(300)" style="fill: #0000"/>
          <use id="DIALS-l12-o11" xlink:href="#hand" transform="rotate(330)" style="fill: #0000"/>
        </g>
      </g>
      <g transform="translate(96, 96)">
        <circle id="FACES-l13-o0" stroke="#000000" style="fill: #0C5093" r="20"></circle>
        <use xlink:href="#face_hours"/>
        <g>
          <use id="DIALS-l13-o0"  xlink:href="#hand" transform="rotate(0)" style="fill: #FFD000"/>
          <use id="DIALS-l13-o1"  xlink:href="#hand" transform="rotate(30)" style="fill: #0000"/>
          <use id="DIALS-l13-o2"  xlink:href="#hand" transform="rotate(60)" style="fill: #0000"/>
          <use id="DIALS-l13-o3"  xlink:href="#hand" transform="rotate(90)" style="fill: #0000"/>
          <use id="DIALS-l13-o4"  xlink:href="#hand" transform="rotate(120)" style="fill: #0000"/>
          <use id="DIALS-l13-o5"  xlink:href="#hand" transform="rotate(150)" style="fill: #0000"/>
          <use id="DIALS-l13-o6"  xlink:href="#hand" transform="rotate(180)" style="fill: #0000"/>
          <use id="DIALS-l13-o7"  xlink:href="#hand" transform="rotate(210)" style="fill: #0000"/>
          <use id="DIALS-l13-o8"  xlink:href="#hand" transform="rotate(240)" style="fill: #0000"/>
          <use id="DIALS-l13-o9"  xlink:href="#hand" transform="rotate(270)" style="fill: #0000"/>
          <use id="DIALS-l13-o10" xlink:href="#hand" transform="rotate(300)" style="fill: #0000"/>
          <use id="DIALS-l13-o11" xlink:href="#hand" transform="rotate(330)" style="fill: #0000"/>
        </g>
      </g>
      <g transform="translate(156, 96)">
        <circle id="FACES-l14-o0" stroke="#000000" style="fill: #0C5093" r="20"></circle>
        <use xlink:href="#face_hours"/>
        <g>
          <use id="DIALS-l14-o0"  xlink:href="#hand" transform="rotate(0)" style="fill: #FFD000"/>
          <use id="DIALS-l14-o1"  xlink:href="#hand" transform="rotate(30)" style="fill: #0000"/>
          <use id="DIALS-l14-o2"  xlink:href="#hand" transform="rotate(60)" style="fill: #0000"/>
          <use id="DIALS-l14-o3"  xlink:href="#hand" transform="rotate(90)" style="fill: #0000"/>
          <use id="DIALS-l14-o4"  xlink:href="#hand" transform="rotate(120)" style="fill: #0000"/>
          <use id="DIALS-l14-o5"  xlink:href="#hand" transform="rotate(150)" style="fill: #0000"/>
          <use id="DIALS-l14-o6"  xlink:href="#hand" transform="rotate(180)" style="fill: #0000"/>
          <use id="DIALS-l14-o7"  xlink:href="#hand" transform="rotate(210)" style="fill: #0000"/>
          <use id="DIALS-l14-o8"  xlink:href="#hand" transform="rotate(240)" style="fill: #0000"/>
          <use id="DIALS-l14-o9"  xlink:href="#hand" transform="rotate(270)" style="fill: #0000"/>
          <use id="DIALS-l14-o10" xlink:href="#hand" transform="rotate(300)" style="fill: #0000"/>
          <use id="DIALS-l14-o11" xlink:href="#hand" transform="rotate(330)" style="fill: #0000"/>
        </g>
      </g>
      <g transform="translate(36, 156)">
        <circle id="FACES-l15-o0" stroke="#000000" style="fill: #0C5093" r="20"></circle>
        <use xlink:href="#face_hours"/>
        <g>
          <use id="DIALS-l15-o0"  xlink:href="#hand" transform="rotate(0)" style="fill: #FFD000"/>
          <use id="DIALS-l15-o1"  xlink:href="#hand" transform="rotate(30)" style="fill: #0000"/>
          <use id="DIALS-l15-o2"  xlink:href="#hand" transform="rotate(60)" style="fill: #0000"/>
          <use id="DIALS-l15-o3"  xlink:href="#hand" transform="rotate(90)" style="fill: #0000"/>
          <use id="DIALS-l15-o4"  xlink:href="#hand" transform="rotate(120)" style="fill: #0000"/>
          <use id="DIALS-l15-o5"  xlink:href="#hand" transform="rotate(150)" style="fill: #0000"/>
          <use id="DIALS-l15-o6"  xlink:href="#hand" transform="rotate(180)" style="fill: #0000"/>
          <use id="DIALS-l15-o7"  xlink:href="#hand" transform="rotate(210)" style="fill: #0000"/>
          <use id="DIALS-l15-o8"  xlink:href="#hand" transform="rotate(240)" style="fill: #0000"/>
          <use id="DIALS-l15-o9"  xlink:href="#hand" transform="rotate(270)" style="fill: #0000"/>
          <use id="DIALS-l15-o10" xlink:href="#hand" transform="rotate(300)" style="fill: #0000"/>
          <use id="DIALS-l15-o11" xlink:href="#hand" transform="rotate(330)" style="fill: #0000"/>
        </g>
      </g>
      <g transform="translate(96, 156)">
        <circle id="FACES-l16-o0" stroke="#000000" style="fill: #0C5093" r="20"></circle>
        <use xlink:href="#face_hours"/>
        <g>
          <use id="DIALS-l16-o0"  xlink:href="#hand" transform="rotate(0)" style="fill: #FFD000"/>
          <use id="DIALS-l16-o1"  xlink:href="#hand" transform="rotate(30)" style="fill: #0000"/>
          <use id="DIALS-l16-o2"  xlink:href="#hand" transform="rotate(60)" style="fill: #0000"/>
          <use id="DIALS-l16-o3"  xlink:href="#hand" transform="rotate(90)" style="fill: #0000"/>
          <use id="DIALS-l16-o4"  xlink:href="#hand" transform="rotate(120)" style="fill: #0000"/>
          <use id="DIALS-l16-o5"  xlink:href="#hand" transform="rotate(150)" style="fill: #0000"/>
          <use id="DIALS-l16-o6"  xlink:href="#hand" transform="rotate(180)" style="fill: #0000"/>
          <use id="DIALS-l16-o7"  xlink:href="#hand" transform="rotate(210)" style="fill: #0000"/>
          <use id="DIALS-l16-o8"  xlink:href="#hand" transform="rotate(240)" style="fill: #0000"/>
          <use id="DIALS-l16-o9"  xlink:href="#hand" transform="rotate(270)" style="fill: #0000"/>
          <use id="DIALS-l16-o10" xlink:href="#hand" transform="rotate(300)" style="fill: #0000"/>
          <use id="DIALS-l16-o11" xlink:href="#hand" transform="rotate(330)" style="fill: #0000"/>
        </g>
      </g>
      <g transform="translate(156, 156)">
        <circle id="FACES-l17-o0" stroke="#000000" style="fill: #0C5093" r="20"></circle>
        <use xlink:href="#face_hours"/>
        <g>
          <use id="DIALS-l17-o0"  xlink:href="#hand" transform="rotate(0)" style="fill: #FFD000"/>
          <use id="DIALS-l17-o1"  xlink:href="#hand" transform="rotate(30)" style="fill: #0000"/>
          <use id="DIALS-l17-o2"  xlink:href="#hand" transform="rotate(60)" style="fill: #0000"/>
          <use id="DIALS-l17-o3"  xlink:href="#hand" transform="rotate(90)" style="fill: #0000"/>
          <use id="DIALS-l17-o4"  xlink:href="#hand" transform="rotate(120)" style="fill: #0000"/>
          <use id="DIALS-l17-o5"  xlink:href="#hand" transform="rotate(150)" style="fill: #0000"/>
          <use id="DIALS-l17-o6"  xlink:href="#hand" transform="rotate(180)" style="fill: #0000"/>
          <use id="DIALS-l17-o7"  xlink:href="#hand" transform="rotate(210)" style="fill: #0000"/>
          <use id="DIALS-l17-o8"  xlink:href="#hand" transform="rotate(240)" style="fill: #0000"/>
          <use id="DIALS-l17-o9"  xlink:href="#hand" transform="rotate(270)" style="fill: #0000"/>
          <use id="DIALS-l17-o10" xlink:href="#hand" transform="rotate(300)" style="fill: #0000"/>
          <use id="DIALS-l17-o11" xlink:href="#hand" transform="rotate(330)" style="fill: #0000"/>
        </g>
      </g>
    </g>
  </g>
</svg>`;
  }
});

// src/cubing/puzzles/implementations/clock/index.ts
var clock;
var init_clock = __esm({
  "src/cubing/puzzles/implementations/clock/index.ts"() {
    init_kpuzzle();
    init_lazy_cached();
    clock = {
      id: "clock",
      fullName: "Clock",
      inventedBy: ["Christopher C. Wiggs", "Christopher J. Taylor"],
      inventionYear: 1988,
      kpuzzle: getCached(async () => new KPuzzle((await Promise.resolve().then(() => (init_clock_kpuzzle_json(), clock_kpuzzle_json_exports))).clockKPuzzleDefinition)),
      svg: getCached(async () => {
        return (await Promise.resolve().then(() => (init_clock_kpuzzle_svg(), clock_kpuzzle_svg_exports))).default;
      })
    };
  }
});

// src/cubing/puzzles/stickerings/fto-stickerings.ts
async function ftoStickering(puzzleLoader, stickering) {
  const kpuzzle = await puzzleLoader.kpuzzle();
  const puzzleStickering = new PuzzleStickering(kpuzzle);
  const m = new StickeringManager(kpuzzle);
  const experimentalFTO_FC = () => m.and([m.move("U"), m.not(m.or(m.moves(["F", "BL", "BR"])))]);
  const experimentalFTO_F2T = () => m.and([m.move("U"), m.not(m.move("F"))]);
  const experimentalFTO_SC = () => m.or([
    experimentalFTO_F2T(),
    m.and([m.move("F"), m.not(m.or(m.moves(["U", "BL", "BR"])))])
  ]);
  const experimentalFTO_L2C = () => m.not(m.or([
    m.and([m.move("U"), m.move("F")]),
    m.and([m.move("F"), m.move("BL")]),
    m.and([m.move("F"), m.move("BR")]),
    m.and([m.move("BL"), m.move("BR")])
  ]));
  const experimentalFTO_LBT = () => m.not(m.or([
    m.and([m.move("F"), m.move("BL")]),
    m.and([m.move("F"), m.move("BR")]),
    m.and([m.move("BL"), m.move("BR")])
  ]));
  switch (stickering) {
    case "full":
      break;
    case "experimental-fto-fc":
      puzzleStickering.set(m.not(experimentalFTO_FC()), "Ignored" /* Ignored */);
      break;
    case "experimental-fto-f2t":
      puzzleStickering.set(m.not(experimentalFTO_F2T()), "Ignored" /* Ignored */);
      puzzleStickering.set(experimentalFTO_FC(), "Dim" /* Dim */);
      break;
    case "experimental-fto-sc":
      puzzleStickering.set(m.not(experimentalFTO_SC()), "Ignored" /* Ignored */);
      puzzleStickering.set(experimentalFTO_F2T(), "Dim" /* Dim */);
      break;
    case "experimental-fto-l2c":
      puzzleStickering.set(m.not(experimentalFTO_L2C()), "Ignored" /* Ignored */);
      puzzleStickering.set(experimentalFTO_SC(), "Dim" /* Dim */);
      break;
    case "experimental-fto-lbt":
      puzzleStickering.set(m.not(experimentalFTO_LBT()), "Ignored" /* Ignored */);
      puzzleStickering.set(experimentalFTO_L2C(), "Dim" /* Dim */);
      break;
    case "experimental-fto-l3t":
      puzzleStickering.set(experimentalFTO_LBT(), "Dim" /* Dim */);
      break;
    default:
      console.warn(`Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`);
      puzzleStickering.set(m.and(m.moves([])), "Dim" /* Dim */);
  }
  return puzzleStickering.toAppearance();
}
async function ftoStickerings() {
  return [
    "full",
    "experimental-fto-fc",
    "experimental-fto-f2t",
    "experimental-fto-sc",
    "experimental-fto-l2c",
    "experimental-fto-lbt",
    "experimental-fto-l3t"
  ];
}
var init_fto_stickerings = __esm({
  "src/cubing/puzzles/stickerings/fto-stickerings.ts"() {
    init_appearance();
  }
});

// src/cubing/puzzles/implementations/fto/fto.kpuzzle.svg.ts
var fto_kpuzzle_svg_exports = {};
__export(fto_kpuzzle_svg_exports, {
  ftoSVG: () => ftoSVG
});
var ftoSVG;
var init_fto_kpuzzle_svg = __esm({
  "src/cubing/puzzles/implementations/fto/fto.kpuzzle.svg.ts"() {
    ftoSVG = `<?xml version="1.0" encoding="UTF-8"?>
<svg width="2368px" height="1216px" viewBox="0 0 2368 1216" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <title>fto</title>
    <g id="fto" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" stroke-linejoin="round">
        <g id="BL" transform="translate(2040.000000, 608.000000) scale(-1, -1) rotate(90.000000) translate(-2040.000000, -608.000000) translate(1560.000000, 368.000000)" stroke="#000000" stroke-width="12">
            <polygon id="C4RNER-l4-o1" style="fill: #FF7F00;" points="480 0 640 160 320 160"></polygon>
            <polygon id="EDGES-l9-o1" style="fill: #FF7F00;" points="640 160 800 320 480 320"></polygon>
            <polygon id="CENTERS-l16-o0" style="fill: #FF7F00;" transform="translate(480.000000, 240.000000) scale(1, -1) translate(-480.000000, -240.000000) " points="480 160 640 320 320 320"></polygon>
            <polygon id="EDGES-l3-o1" style="fill: #FF7F00;" points="320 160 480 320 160 320"></polygon>
            <polygon id="C4RNER-l3-o3" style="fill: #FF7F00;" points="800 320 960 480 640 480"></polygon>
            <polygon id="CENTERS-l19-o0" style="fill: #FF7F00;" transform="translate(640.000000, 400.000000) scale(1, -1) translate(-640.000000, -400.000000) " points="640 320 800 480 480 480"></polygon>
            <polygon id="EDGES-l7-o1" style="fill: #FF7F00;" points="480 320 640 480 320 480"></polygon>
            <polygon id="CENTERS-l3-o0" style="fill: #FF7F00;" transform="translate(320.000000, 400.000000) scale(1, -1) translate(-320.000000, -400.000000) " points="320 320 480 480 160 480"></polygon>
            <polygon id="C4RNER-l0-o2" style="fill: #FF7F00;" points="160 320 320 480 0 480"></polygon>
        </g>
        <g id="D" transform="translate(1280.000000, 648.000000)" stroke="#000000" stroke-width="12">
            <polygon id="C4RNER-l4-o2" style="fill: #FFFF00;" points="480 0 640 160 320 160"></polygon>
            <polygon id="EDGES-l3-o0" style="fill: #FFFF00;" points="640 160 800 320 480 320"></polygon>
            <polygon id="CENTERS-l8-o0" style="fill: #FFFF00;" transform="translate(480.000000, 240.000000) scale(1, -1) translate(-480.000000, -240.000000) " points="480 160 640 320 320 320"></polygon>
            <polygon id="EDGES-l5-o0" style="fill: #FFFF00;" points="320 160 480 320 160 320"></polygon>
            <polygon id="C4RNER-l0-o1" style="fill: #FFFF00;" points="800 320 960 480 640 480"></polygon>
            <polygon id="CENTERS-l17-o0" style="fill: #FFFF00;" transform="translate(640.000000, 400.000000) scale(1, -1) translate(-640.000000, -400.000000) " points="640 320 800 480 480 480"></polygon>
            <polygon id="EDGES-l1-o1" style="fill: #FFFF00;" points="480 320 640 480 320 480"></polygon>
            <polygon id="CENTERS-l6-o0" style="fill: #FFFF00;" transform="translate(320.000000, 400.000000) scale(1, -1) translate(-320.000000, -400.000000) " points="320 320 480 480 160 480"></polygon>
            <polygon id="C4RNER-l2-o3" style="fill: #FFFF00;" points="160 320 320 480 0 480"></polygon>
        </g>
        <g id="BR" transform="translate(1480.000000, 608.000000) scale(1, -1) rotate(90.000000) translate(-1480.000000, -608.000000) translate(1000.000000, 368.000000)" stroke="#000000" stroke-width="12">
            <polygon id="C4RNER-l4-o3" style="fill: #7F7F7F;" points="480 0 640 160 320 160"></polygon>
            <polygon id="EDGES-l2-o1" style="fill: #7F7F7F;" points="640 160 800 320 480 320"></polygon>
            <polygon id="CENTERS-l15-o0" style="fill: #7F7F7F;" transform="translate(480.000000, 240.000000) scale(1, -1) translate(-480.000000, -240.000000) " points="480 160 640 320 320 320"></polygon>
            <polygon id="EDGES-l5-o1" style="fill: #7F7F7F;" points="320 160 480 320 160 320"></polygon>
            <polygon id="C4RNER-l5-o1" style="fill: #7F7F7F;" points="800 320 960 480 640 480"></polygon>
            <polygon id="CENTERS-l2-o0" style="fill: #7F7F7F;" transform="translate(640.000000, 400.000000) scale(1, -1) translate(-640.000000, -400.000000) " points="640 320 800 480 480 480"></polygon>
            <polygon id="EDGES-l4-o0" style="fill: #7F7F7F;" points="480 320 640 480 320 480"></polygon>
            <polygon id="CENTERS-l4-o0" style="fill: #7F7F7F;" transform="translate(320.000000, 400.000000) scale(1, -1) translate(-320.000000, -400.000000) " points="320 320 480 480 160 480"></polygon>
            <polygon id="C4RNER-l2-o2" style="fill: #7F7F7F;" points="160 320 320 480 0 480"></polygon>
        </g>
        <g id="B" transform="translate(1760.000000, 328.000000) scale(1, -1) translate(-1760.000000, -328.000000) translate(1280.000000, 88.000000)" stroke="#000000" stroke-width="12">
            <polygon id="C4RNER-l4-o0" style="fill: #0000FF;" points="480 0 640 160 320 160"></polygon>
            <polygon id="EDGES-l9-o0" style="fill: #0000FF;" points="640 160 800 320 480 320"></polygon>
            <polygon id="CENTERS-l13-o0" style="fill: #0000FF;" transform="translate(480.000000, 240.000000) scale(1, -1) translate(-480.000000, -240.000000) " points="480 160 640 320 320 320"></polygon>
            <polygon id="EDGES-l2-o0" style="fill: #0000FF;" points="320 160 480 320 160 320"></polygon>
            <polygon id="C4RNER-l3-o0" style="fill: #0000FF;" points="800 320 960 480 640 480"></polygon>
            <polygon id="CENTERS-l12-o0" style="fill: #0000FF;" transform="translate(640.000000, 400.000000) scale(1, -1) translate(-640.000000, -400.000000) " points="640 320 800 480 480 480"></polygon>
            <polygon id="EDGES-l8-o0" style="fill: #0000FF;" points="480 320 640 480 320 480"></polygon>
            <polygon id="CENTERS-l10-o0" style="fill: #0000FF;" transform="translate(320.000000, 400.000000) scale(1, -1) translate(-320.000000, -400.000000) " points="320 320 480 480 160 480"></polygon>
            <polygon id="C4RNER-l5-o0" style="fill: #0000FF;" points="160 320 320 480 0 480"></polygon>
        </g>
        <g id="R" transform="translate(888.000000, 608.000000) scale(-1, -1) rotate(90.000000) translate(-888.000000, -608.000000) translate(408.000000, 368.000000)" stroke="#000000" stroke-width="12">
            <polygon id="C4RNER-l1-o3" style="fill: #32CD32;" points="480 0 640 160 320 160"></polygon>
            <polygon id="EDGES-l6-o1" style="fill: #32CD32;" points="640 160 800 320 480 320"></polygon>
            <polygon id="CENTERS-l7-o0" style="fill: #32CD32;" transform="translate(480.000000, 240.000000) scale(1, -1) translate(-480.000000, -240.000000) " points="480 160 640 320 320 320"></polygon>
            <polygon id="EDGES-l0-o1" style="fill: #32CD32;" points="320 160 480 320 160 320"></polygon>
            <polygon id="C4RNER-l5-o2" style="fill: #32CD32;" points="800 320 960 480 640 480"></polygon>
            <polygon id="CENTERS-l5-o0" style="fill: #32CD32;" transform="translate(640.000000, 400.000000) scale(1, -1) translate(-640.000000, -400.000000) " points="640 320 800 480 480 480"></polygon>
            <polygon id="EDGES-l4-o1" style="fill: #32CD32;" points="480 320 640 480 320 480"></polygon>
            <polygon id="CENTERS-l11-o0" style="fill: #32CD32;" transform="translate(320.000000, 400.000000) scale(1, -1) translate(-320.000000, -400.000000) " points="320 320 480 480 160 480"></polygon>
            <polygon id="C4RNER-l2-o1" style="fill: #32CD32;" points="160 320 320 480 0 480"></polygon>
        </g>
        <g id="F" transform="translate(128.000000, 648.000000)" stroke="#000000" stroke-width="12">
            <polygon id="C4RNER-l1-o0" style="fill: #FF0000;" points="480 0 640 160 320 160"></polygon>
            <polygon id="EDGES-l0-o0" style="fill: #FF0000;" points="640 160 800 320 480 320"></polygon>
            <polygon id="CENTERS-l0-o0" style="fill: #FF0000;" transform="translate(480.000000, 240.000000) scale(1, -1) translate(-480.000000, -240.000000) " points="480 160 640 320 320 320"></polygon>
            <polygon id="EDGES-l10-o0" style="fill: #FF0000;" points="320 160 480 320 160 320"></polygon>
            <polygon id="C4RNER-l2-o0" style="fill: #FF0000;" points="800 320 960 480 640 480"></polygon>
            <polygon id="CENTERS-l1-o0" style="fill: #FF0000;" transform="translate(640.000000, 400.000000) scale(1, -1) translate(-640.000000, -400.000000) " points="640 320 800 480 480 480"></polygon>
            <polygon id="EDGES-l1-o0" style="fill: #FF0000;" points="480 320 640 480 320 480"></polygon>
            <polygon id="CENTERS-l14-o0" style="fill: #FF0000;" transform="translate(320.000000, 400.000000) scale(1, -1) translate(-320.000000, -400.000000) " points="320 320 480 480 160 480"></polygon>
            <polygon id="C4RNER-l0-o0" style="fill: #FF0000;" points="160 320 320 480 0 480"></polygon>
        </g>
        <g id="L" transform="translate(328.000000, 608.000000) scale(1, -1) rotate(90.000000) translate(-328.000000, -608.000000) translate(-152.000000, 368.000000)" stroke="#000000" stroke-width="12">
            <polygon id="C4RNER-l1-o1" style="fill: #7F007F;" points="480 0 640 160 320 160"></polygon>
            <polygon id="EDGES-l11-o1" style="fill: #7F007F;" points="640 160 800 320 480 320"></polygon>
            <polygon id="CENTERS-l21-o0" style="fill: #7F007F;" transform="translate(480.000000, 240.000000) scale(1, -1) translate(-480.000000, -240.000000) " points="480 160 640 320 320 320"></polygon>
            <polygon id="EDGES-l10-o1" style="fill: #7F007F;" points="320 160 480 320 160 320"></polygon>
            <polygon id="C4RNER-l3-o2" style="fill: #7F007F;" points="800 320 960 480 640 480"></polygon>
            <polygon id="CENTERS-l18-o0" style="fill: #7F007F;" transform="translate(640.000000, 400.000000) scale(1, -1) translate(-640.000000, -400.000000) " points="640 320 800 480 480 480"></polygon>
            <polygon id="EDGES-l7-o0" style="fill: #7F007F;" points="480 320 640 480 320 480"></polygon>
            <polygon id="CENTERS-l9-o0" style="fill: #7F007F;" transform="translate(320.000000, 400.000000) scale(1, -1) translate(-320.000000, -400.000000) " points="320 320 480 480 160 480"></polygon>
            <polygon id="C4RNER-l0-o3" style="fill: #7F007F;" points="160 320 320 480 0 480"></polygon>
        </g>
        <g id="U" transform="translate(608.000000, 328.000000) scale(1, -1) translate(-608.000000, -328.000000) translate(128.000000, 88.000000)" stroke="#000000" stroke-width="12">
            <polygon id="C4RNER-l1-o2" style="fill: #FFFFFF;" points="480 0 640 160 320 160"></polygon>
            <polygon id="EDGES-l6-o0" style="fill: #FFFFFF;" points="640 160 800 320 480 320"></polygon>
            <polygon id="CENTERS-l20-o0" style="fill: #FFFFFF;" transform="translate(480.000000, 240.000000) scale(1, -1) translate(-480.000000, -240.000000) " points="480 160 640 320 320 320"></polygon>
            <polygon id="EDGES-l11-o0" style="fill: #FFFFFF;" points="320 160 480 320 160 320"></polygon>
            <polygon id="C4RNER-l5-o3" style="fill: #FFFFFF;" points="800 320 960 480 640 480"></polygon>
            <polygon id="CENTERS-l23-o0" style="fill: #FFFFFF;" transform="translate(640.000000, 400.000000) scale(1, -1) translate(-640.000000, -400.000000) " points="640 320 800 480 480 480"></polygon>
            <polygon id="EDGES-l8-o1" style="fill: #FFFFFF;" points="480 320 640 480 320 480"></polygon>
            <polygon id="CENTERS-l22-o0" style="fill: #FFFFFF;" transform="translate(320.000000, 400.000000) scale(1, -1) translate(-320.000000, -400.000000) " points="320 320 480 480 160 480"></polygon>
            <polygon id="C4RNER-l3-o1" style="fill: #FFFFFF;" points="160 320 320 480 0 480"></polygon>
        </g>
    </g>
</svg>
`;
  }
});

// src/cubing/puzzles/implementations/fto/index.ts
var FTOPuzzleLoader, fto;
var init_fto = __esm({
  "src/cubing/puzzles/implementations/fto/index.ts"() {
    init_async_pg3d();
    init_lazy_cached();
    init_fto_stickerings();
    FTOPuzzleLoader = class extends PGPuzzleLoader {
      constructor() {
        super({
          pgID: "FTO",
          id: "fto",
          fullName: "Face-Turning Octahedron",
          inventedBy: ["Karl Rohrbach", "David Pitcher"],
          inventionYear: 1983
        });
        this.stickerings = ftoStickerings;
        this.svg = getCached(async () => {
          return (await Promise.resolve().then(() => (init_fto_kpuzzle_svg(), fto_kpuzzle_svg_exports))).ftoSVG;
        });
      }
      appearance(stickering) {
        return ftoStickering(this, stickering);
      }
    };
    fto = new FTOPuzzleLoader();
  }
});

// src/cubing/puzzles/stickerings/megaminx-stickerings.ts
async function megaminxAppearance(puzzleLoader, stickering) {
  switch (stickering) {
    case "full":
    case "F2L":
    case "LL":
      return cubeAppearance(puzzleLoader, stickering);
    default:
      console.warn(`Unsupported stickering for ${puzzleLoader.id}: ${stickering}. Setting all pieces to dim.`);
  }
  return cubeAppearance(puzzleLoader, "full");
}
async function megaminxStickerings() {
  return ["full", "F2L", "LL"];
}
var init_megaminx_stickerings = __esm({
  "src/cubing/puzzles/stickerings/megaminx-stickerings.ts"() {
    init_cube_stickerings();
  }
});

// src/cubing/puzzles/implementations/megaminx/index.ts
var MegaminxPuzzleLoader, megaminx;
var init_megaminx = __esm({
  "src/cubing/puzzles/implementations/megaminx/index.ts"() {
    init_async_pg3d();
    init_megaminx_stickerings();
    MegaminxPuzzleLoader = class extends PGPuzzleLoader {
      constructor() {
        super({
          id: "megaminx",
          fullName: "Megaminx",
          inventionYear: 1981
        });
        this.stickerings = megaminxStickerings;
      }
      appearance(stickering) {
        return megaminxAppearance(this, stickering);
      }
    };
    megaminx = new MegaminxPuzzleLoader();
  }
});

// src/cubing/puzzles/implementations/pyraminx/pyraminx.kpuzzle.svg.ts
var pyraminx_kpuzzle_svg_exports = {};
__export(pyraminx_kpuzzle_svg_exports, {
  default: () => pyraminx_kpuzzle_svg_default
});
var pyraminx_kpuzzle_svg_default;
var init_pyraminx_kpuzzle_svg = __esm({
  "src/cubing/puzzles/implementations/pyraminx/pyraminx.kpuzzle.svg.ts"() {
    pyraminx_kpuzzle_svg_default = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN"
       "http://www.w3.org/TR/2001/REC-SVG-20050904/DTD/svg11.dtd">
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="-20 -20 546 480" preserveAspectRatio="xMidYMid meet">
  <defs>
  </defs>
  <title>pyraminx</title>
  <defs>
    <g id="stickerA" transform="scale(1, 0.577350269)">
      <path
         d="m 0,1.732050808 1,-1.732050808 1,1.732050808 z"
         stroke="black" stroke-width="0.04px" stroke-linecap="butt" stroke-linejoin="round"
      />
    </g>
    <g id="stickerV" transform="scale(1, 0.577350269)">
      <path
         d="m 0,0 1,1.732050808 1,-1.732050808 z"
         stroke="black" stroke-width="0.04px" stroke-linecap="butt" stroke-linejoin="round"
      />
    </g>
  </defs>

<!--        0 1 2 3 4 5 6 7 8 9 10   -->
<!--        | | | | | | | | | | |    -->
<!--    0 - L L L L L F R R R R R    -->
<!--    1 -   L L L F F F R R R      -->
<!--    2 -     L F F F F F R        -->
<!--    3 -       D D D D D          -->
<!--    4 -         D D D            -->
<!--    5 -           D              -->

  <g id="puzzle" transform="translate(5, 5) scale(40, 69.28203232)">
    <!-- CORNERS -->
    <use id="CORNERS-l0-o0" xlink:href="#stickerV" transform="translate(5.2, 1.066666667)" style="fill: limegreen"/>
    <use id="CORNERS-l0-o1" xlink:href="#stickerA" transform="translate(3, 0)" style="fill: red"/>
    <use id="CORNERS-l0-o2" xlink:href="#stickerA" transform="translate(7.4, 0)" style="fill: blue"/>

    <use id="CORNERS-l3-o0" xlink:href="#stickerV" transform="translate(4.2, 2.066666667)" style="fill: limegreen"/>
    <use id="CORNERS-l3-o1" xlink:href="#stickerA" transform="translate(4.2, 3.2)" style="fill: yellow"/>
    <use id="CORNERS-l3-o2" xlink:href="#stickerA" transform="translate(2, 1)" style="fill: red"/>

    <use id="CORNERS-l2-o0" xlink:href="#stickerV" transform="translate(6.2, 2.066666667)" style="fill: limegreen"/>
    <use id="CORNERS-l2-o1" xlink:href="#stickerA" transform="translate(8.4, 1)" style="fill: blue"/>
    <use id="CORNERS-l2-o2" xlink:href="#stickerA" transform="translate(6.2, 3.2)" style="fill: yellow"/>

    <use id="CORNERS-l1-o1" xlink:href="#stickerA" transform="translate(9.4, 0)" style="fill: blue"/>
    <use id="CORNERS-l1-o2" xlink:href="#stickerA" transform="translate(1, 0)" style="fill: red"/>
    <use id="CORNERS-l1-o0" xlink:href="#stickerA" transform="translate(5.2, 4.2)" style="fill: yellow"/>

    <!-- "TIPS" -->
    <!-- CORNERS2 -->
    <use id="CORNERS2-l0-o0" xlink:href="#stickerA" transform="translate(5.2, 0.066666667)" style="fill: limegreen"/>
    <use id="CORNERS2-l0-o1" xlink:href="#stickerV" transform="translate(4, 0)" style="fill: red"/>
    <use id="CORNERS2-l0-o2" xlink:href="#stickerV" transform="translate(6.4, 0)" style="fill: blue"/>

    <use id="CORNERS2-l3-o0" xlink:href="#stickerA" transform="translate(3.2, 2.066666667)" style="fill: limegreen"/>
    <use id="CORNERS2-l3-o1" xlink:href="#stickerV" transform="translate(3.2, 3.2)" style="fill: yellow"/>
    <use id="CORNERS2-l3-o2" xlink:href="#stickerV" transform="translate(2, 2)" style="fill: red"/>

    <use id="CORNERS2-l2-o1" xlink:href="#stickerV" transform="translate(8.4, 2)" style="fill: blue"/>
    <use id="CORNERS2-l2-o2" xlink:href="#stickerV" transform="translate(7.2, 3.2)" style="fill: yellow"/>
    <use id="CORNERS2-l2-o0" xlink:href="#stickerA" transform="translate(7.2, 2.066666667)" style="fill: limegreen"/>

    <use id="CORNERS2-l1-o1" xlink:href="#stickerV" transform="translate(10.4,0)" style="fill: blue"/>
    <use id="CORNERS2-l1-o2" xlink:href="#stickerV" transform="translate(0, 0)" style="fill: red"/>
    <use id="CORNERS2-l1-o0" xlink:href="#stickerV" transform="translate(5.2, 5.2)" style="fill: yellow"/>

    <!-- EDGES -->
    <use id="EDGES-l0-o0" xlink:href="#stickerA" transform="translate(4.2, 1.066666667)" style="fill: limegreen"/>
    <use id="EDGES-l0-o1" xlink:href="#stickerV" transform="translate(3, 1)" style="fill: red"/>

    <use id="EDGES-l5-o0" xlink:href="#stickerA" transform="translate(6.2, 1.066666667)" style="fill: limegreen"/>
    <use id="EDGES-l5-o1" xlink:href="#stickerV" transform="translate(7.4, 1)" style="fill: blue"/>

    <use id="EDGES-l1-o1" xlink:href="#stickerV" transform="translate(8.4, 0)" style="fill: blue"/>
    <use id="EDGES-l1-o0" xlink:href="#stickerV" transform="translate(2, 0)" style="fill: red"/>

    <use id="EDGES-l2-o1" xlink:href="#stickerV" transform="translate(5.2, 3.2)" style="fill: yellow"/>
    <use id="EDGES-l2-o0" xlink:href="#stickerA" transform="translate(5.2, 2.066666667)" style="fill: limegreen"/>

    <use id="EDGES-l3-o0" xlink:href="#stickerV" transform="translate(6.2, 4.2)" style="fill: yellow"/>
    <use id="EDGES-l3-o1" xlink:href="#stickerV" transform="translate(9.4, 1)" style="fill: blue"/>

    <use id="EDGES-l4-o0" xlink:href="#stickerV" transform="translate(4.2, 4.2)" style="fill: yellow"/>
    <use id="EDGES-l4-o1" xlink:href="#stickerV" transform="translate(1, 1)" style="fill: red"/>
  </g>

</svg>`;
  }
});

// src/cubing/puzzles/implementations/pyraminx/index.ts
var PyraminxPuzzleLoader, pyraminx;
var init_pyraminx = __esm({
  "src/cubing/puzzles/implementations/pyraminx/index.ts"() {
    init_async_pg3d();
    init_lazy_cached();
    PyraminxPuzzleLoader = class extends PGPuzzleLoader {
      constructor() {
        super({
          id: "pyraminx",
          fullName: "Pyraminx",
          inventedBy: ["Uwe Meffert"]
        });
        this.svg = getCached(async () => {
          return (await Promise.resolve().then(() => (init_pyraminx_kpuzzle_svg(), pyraminx_kpuzzle_svg_exports))).default;
        });
      }
    };
    pyraminx = new PyraminxPuzzleLoader();
  }
});

// src/cubing/puzzles/implementations/square1/sq1-hyperorbit.kpuzzle.json.ts
var sq1_hyperorbit_kpuzzle_json_exports = {};
__export(sq1_hyperorbit_kpuzzle_json_exports, {
  sq1HyperOrbitKPuzzleDefinition: () => sq1HyperOrbitKPuzzleDefinition
});
var sq1HyperOrbitKPuzzleDefinition;
var init_sq1_hyperorbit_kpuzzle_json = __esm({
  "src/cubing/puzzles/implementations/square1/sq1-hyperorbit.kpuzzle.json.ts"() {
    sq1HyperOrbitKPuzzleDefinition = {
      name: "Square-1",
      orbits: {
        WEDGES: { numPieces: 24, numOrientations: 9 },
        EQUATOR: { numPieces: 2, numOrientations: 6 }
      },
      startStateData: {
        WEDGES: {
          pieces: [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23
          ],
          orientation: [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ]
        },
        EQUATOR: { pieces: [0, 1], orientation: [0, 0] }
      },
      moves: {
        U_SQ_: {
          WEDGES: {
            permutation: [
              11,
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              12,
              13,
              14,
              15,
              16,
              17,
              18,
              19,
              20,
              21,
              22,
              23
            ],
            orientation: [
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0
            ]
          },
          EQUATOR: { permutation: [0, 1], orientation: [0, 0] }
        },
        D_SQ_: {
          WEDGES: {
            permutation: [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              23,
              12,
              13,
              14,
              15,
              16,
              17,
              18,
              19,
              20,
              21,
              22
            ],
            orientation: [
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0
            ]
          },
          EQUATOR: { permutation: [0, 1], orientation: [0, 0] }
        },
        _SLASH_: {
          WEDGES: {
            permutation: [
              0,
              1,
              2,
              3,
              4,
              5,
              12,
              13,
              14,
              15,
              16,
              17,
              6,
              7,
              8,
              9,
              10,
              11,
              18,
              19,
              20,
              21,
              22,
              23
            ],
            orientation: [
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0
            ]
          },
          EQUATOR: { permutation: [0, 1], orientation: [0, 3] }
        }
      }
    };
  }
});

// src/cubing/puzzles/implementations/square1/sq1-hyperorbit.kpuzzle.svg.ts
var sq1_hyperorbit_kpuzzle_svg_exports = {};
__export(sq1_hyperorbit_kpuzzle_svg_exports, {
  default: () => sq1_hyperorbit_kpuzzle_svg_default
});
var sq1_hyperorbit_kpuzzle_svg_default;
var init_sq1_hyperorbit_kpuzzle_svg = __esm({
  "src/cubing/puzzles/implementations/square1/sq1-hyperorbit.kpuzzle.svg.ts"() {
    sq1_hyperorbit_kpuzzle_svg_default = `<?xml version="1.0" encoding="UTF-8"?>
<svg width="360px" height="552px" viewBox="0 0 360 552" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <!-- Generator: Sketch 59.1 (86144) - https://sketch.com -->
    <title>sq1-fancy</title>
    <desc>Created with Sketch.</desc>
    <!-- stroke="none" -->
    <g id="sq1-fancy" stroke="#888" stroke-width="0.25" fill="none" fill-rule="evenodd">
        <g id="EQUATOR" transform="translate(24.000000, 264.000000)">
            <rect id="EQUATOR-l1-o3" style="fill: red" x="168" y="0" width="24" height="24"></rect>
            <rect id="EQUATOR-l1-o4" style="fill: red" x="192" y="0" width="24" height="24"></rect>
            <rect id="EQUATOR-l1-o5" style="fill: limegreen" x="216" y="0" width="24" height="24"></rect>
            <rect id="EQUATOR-l1-o2" style="fill: limegreen" x="240" y="0" width="24" height="24"></rect>
            <rect id="EQUATOR-l1-o1" style="fill: limegreen" x="264" y="0" width="24" height="24"></rect>
            <rect id="EQUATOR-l1-o0" style="fill: orange" x="288" y="0" width="24" height="24"></rect>
            <rect id="EQUATOR-l0-o3" style="fill: orange" x="0" y="0" width="24" height="24"></rect>
            <rect id="EQUATOR-l0-o4" style="fill: orange" x="24" y="0" width="24" height="24"></rect>
            <rect id="EQUATOR-l0-o5" style="fill: limegreen" x="48" y="0" width="24" height="24"></rect>
            <rect id="EQUATOR-l0-o2" style="fill: limegreen" x="72" y="0" width="24" height="24"></rect>
            <rect id="EQUATOR-l0-o1" style="fill: limegreen" x="96" y="0" width="24" height="24"></rect>
            <rect id="EQUATOR-l0-o0" style="fill: red" x="120" y="0" width="24" height="24"></rect>
        </g>
        <g id="BOTTOM" transform="translate(41.000000, 257.000000)" stroke-linejoin="round">
            <g id="WEDGES-23" transform="translate(130.000000, 88.588457) rotate(120.000000) translate(-130.000000, -88.588457) translate(82.000000, 22.588457)">
                <polygon id="WEDGES-l23-o8" style="fill: #D8D8D8" points="25.723 70.277 40.574 95.999 -2.27373675e-13 96"></polygon>
                <polygon id="WEDGES-l23-o7" style="fill: red" points="70.2768775 96 60.8615612 131.138439 40.5741225 95.9988775"></polygon>
                <polygon id="WEDGES-l23-o6" style="fill: red" points="70.2768775 96 40.574 95.999 25.7231225 70.2768775"></polygon>
                <polygon id="WEDGES-l23-o5" style="fill: red" points="48.0001225 47.9995 68.287 47.9995 78.4307806 65.5692194"></polygon>
                <polygon id="WEDGES-l23-o4" style="fill: red" points="60.8615 35.1385 68.287 47.9995 48 48"></polygon>
                <polygon id="WEDGES-l23-o3" style="fill: white" points="83.1384388 48 78.4307806 65.5692194 68.2870612 47.9994388"></polygon>
                <polygon id="WEDGES-l23-o2" style="fill: white" points="83.1384388 48 68.287 47.9995 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l23-o1" style="fill: white" points="96 0 83.1384388 48 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l23-o0" style="fill: red" points="70.2768775 96 25.7231225 70.2768775 48.0001225 47.9995 78.4307806 65.5692194"></polygon>
            </g>
            <g id="WEDGES-22" transform="translate(97.157677, 115.157677) rotate(90.000000) translate(-97.157677, -115.157677) translate(49.157677, 49.157677)">
                <polygon id="WEDGES-l22-o8" style="fill: blue" points="25.723 70.277 40.574 95.999 -2.27373675e-13 96"></polygon>
                <polygon id="WEDGES-l22-o7" style="fill: #D8D8D8" points="70.2768775 96 60.8615612 131.138439 40.5741225 95.9988775"></polygon>
                <polygon id="WEDGES-l22-o6" style="fill: blue" points="70.2768775 96 40.574 95.999 25.7231225 70.2768775"></polygon>
                <polygon id="WEDGES-l22-o5" style="fill: blue" points="48.0001225 47.9995 68.287 47.9995 78.4307806 65.5692194"></polygon>
                <polygon id="WEDGES-l22-o4" style="fill: white" points="60.8615 35.1385 68.287 47.9995 48 48"></polygon>
                <polygon id="WEDGES-l22-o3" style="fill: blue" points="83.1384388 48 78.4307806 65.5692194 68.2870612 47.9994388"></polygon>
                <polygon id="WEDGES-l22-o2" style="fill: white" points="83.1384388 48 68.287 47.9995 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l22-o1" style="fill: white" points="96 0 83.1384388 48 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l22-o0" style="fill: blue" points="70.2768775 96 25.7231225 70.2768775 48.0001225 47.9995 78.4307806 65.5692194"></polygon>
            </g>
            <g id="WEDGES-21" transform="translate(82.000000, 154.588457) rotate(60.000000) translate(-82.000000, -154.588457) translate(34.000000, 88.588457)">
                <polygon id="WEDGES-l21-o8" style="fill: #D8D8D8" points="25.723 70.277 40.574 95.999 -2.27373675e-13 96"></polygon>
                <polygon id="WEDGES-l21-o7" style="fill: #D8D8D8" points="70.2768775 96 60.8615612 131.138439 40.5741225 95.9988775"></polygon>
                <polygon id="WEDGES-l21-o6" style="fill: #D8D8D8" points="70.2768775 96 40.574 95.999 25.7231225 70.2768775"></polygon>
                <polygon id="WEDGES-l21-o5" style="fill: blue" points="48.0001225 47.9995 68.287 47.9995 78.4307806 65.5692194"></polygon>
                <polygon id="WEDGES-l21-o4" style="fill: blue" points="60.8615 35.1385 68.287 47.9995 48 48"></polygon>
                <polygon id="WEDGES-l21-o3" style="fill: blue" points="83.1384388 48 78.4307806 65.5692194 68.2870612 47.9994388"></polygon>
                <polygon id="WEDGES-l21-o2" style="fill: blue" points="83.1384388 48 68.287 47.9995 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l21-o1" style="fill: white" points="96 0 83.1384388 48 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l21-o0" style="fill: blue" points="70.2768775 96 25.7231225 70.2768775 48.0001225 47.9995 78.4307806 65.5692194"></polygon>
            </g>
            <g id="WEDGES-20" transform="translate(88.588457, 196.315353) rotate(30.000000) translate(-88.588457, -196.315353) translate(40.588457, 130.315353)">
                <polygon id="WEDGES-l20-o8" style="fill: #D8D8D8" points="25.723 70.277 40.574 95.999 -2.27373675e-13 96"></polygon>
                <polygon id="WEDGES-l20-o7" style="fill: blue" points="70.2768775 96 60.8615612 131.138439 40.5741225 95.9988775"></polygon>
                <polygon id="WEDGES-l20-o6" style="fill: blue" points="70.2768775 96 40.574 95.999 25.7231225 70.2768775"></polygon>
                <polygon id="WEDGES-l20-o5" style="fill: blue" points="48.0001225 47.9995 68.287 47.9995 78.4307806 65.5692194"></polygon>
                <polygon id="WEDGES-l20-o4" style="fill: blue" points="60.8615 35.1385 68.287 47.9995 48 48"></polygon>
                <polygon id="WEDGES-l20-o3" style="fill: white" points="83.1384388 48 78.4307806 65.5692194 68.2870612 47.9994388"></polygon>
                <polygon id="WEDGES-l20-o2" style="fill: white" points="83.1384388 48 68.287 47.9995 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l20-o1" style="fill: white" points="96 0 83.1384388 48 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l20-o0" style="fill: blue" points="70.2768775 96 25.7231225 70.2768775 48.0001225 47.9995 78.4307806 65.5692194"></polygon>
            </g>
            <g id="WEDGES-19" transform="translate(67.157677, 163.157677)">
                <polygon id="WEDGES-l19-o8" style="fill: orange" points="25.723 70.277 40.574 95.999 -2.27373675e-13 96"></polygon>
                <polygon id="WEDGES-l19-o7" style="fill: #D8D8D8" points="70.2768775 96 60.8615612 131.138439 40.5741225 95.9988775"></polygon>
                <polygon id="WEDGES-l19-o6" style="fill: orange" points="70.2768775 96 40.574 95.999 25.7231225 70.2768775"></polygon>
                <polygon id="WEDGES-l19-o5" style="fill: orange" points="48.0001225 47.9995 68.287 47.9995 78.4307806 65.5692194"></polygon>
                <polygon id="WEDGES-l19-o4" style="fill: white" points="60.8615 35.1385 68.287 47.9995 48 48"></polygon>
                <polygon id="WEDGES-l19-o3" style="fill: orange" points="83.1384388 48 78.4307806 65.5692194 68.2870612 47.9994388"></polygon>
                <polygon id="WEDGES-l19-o2" style="fill: white" points="83.1384388 48 68.287 47.9995 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l19-o1" style="fill: white" points="96 0 83.1384388 48 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l19-o0" style="fill: orange" points="70.2768775 96 25.7231225 70.2768775 48.0001225 47.9995 78.4307806 65.5692194"></polygon>
            </g>
            <g id="WEDGES-18" transform="translate(154.588457, 244.315353) scale(-1, -1) rotate(150.000000) translate(-154.588457, -244.315353) translate(106.588457, 178.315353)">
                <polygon id="WEDGES-l18-o8" style="fill: #D8D8D8" points="25.723 70.277 40.574 95.999 -2.27373675e-13 96"></polygon>
                <polygon id="WEDGES-l18-o7" style="fill: #D8D8D8" points="70.2768775 96 60.8615612 131.138439 40.5741225 95.9988775"></polygon>
                <polygon id="WEDGES-l18-o6" style="fill: #D8D8D8" points="70.2768775 96 40.574 95.999 25.7231225 70.2768775"></polygon>
                <polygon id="WEDGES-l18-o5" style="fill: orange" points="48.0001225 47.9995 68.287 47.9995 78.4307806 65.5692194"></polygon>
                <polygon id="WEDGES-l18-o4" style="fill: orange" points="60.8615 35.1385 68.287 47.9995 48 48"></polygon>
                <polygon id="WEDGES-l18-o3" style="fill: orange" points="83.1384388 48 78.4307806 65.5692194 68.2870612 47.9994388"></polygon>
                <polygon id="WEDGES-l18-o2" style="fill: orange" points="83.1384388 48 68.287 47.9995 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l18-o1" style="fill: white" points="96 0 83.1384388 48 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l18-o0" style="fill: orange" points="70.2768775 96 25.7231225 70.2768775 48.0001225 47.9995 78.4307806 65.5692194"></polygon>
            </g>
            <g id="WEDGES-17" transform="translate(196.315353, 237.726896) scale(-1, -1) rotate(120.000000) translate(-196.315353, -237.726896) translate(148.315353, 171.726896)">
                <polygon id="WEDGES-l17-o8" style="fill: #D8D8D8" points="25.723 70.277 40.574 95.999 -2.27373675e-13 96"></polygon>
                <polygon id="WEDGES-l17-o7" style="fill: orange" points="70.2768775 96 60.8615612 131.138439 40.5741225 95.9988775"></polygon>
                <polygon id="WEDGES-l17-o6" style="fill: orange" points="70.2768775 96 40.574 95.999 25.7231225 70.2768775"></polygon>
                <polygon id="WEDGES-l17-o5" style="fill: orange" points="48.0001225 47.9995 68.287 47.9995 78.4307806 65.5692194"></polygon>
                <polygon id="WEDGES-l17-o4" style="fill: orange" points="60.8615 35.1385 68.287 47.9995 48 48"></polygon>
                <polygon id="WEDGES-l17-o3" style="fill: white" points="83.1384388 48 78.4307806 65.5692194 68.2870612 47.9994388"></polygon>
                <polygon id="WEDGES-l17-o2" style="fill: white" points="83.1384388 48 68.287 47.9995 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l17-o1" style="fill: white" points="96 0 83.1384388 48 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l17-o0" style="fill: orange" points="70.2768775 96 25.7231225 70.2768775 48.0001225 47.9995 78.4307806 65.5692194"></polygon>
            </g>
            <g id="WEDGES-16" transform="translate(229.157677, 211.157677) scale(-1, -1) rotate(90.000000) translate(-229.157677, -211.157677) translate(181.157677, 145.157677)">
                <polygon id="WEDGES-l16-o8" style="fill: limegreen" points="25.723 70.277 40.574 95.999 -2.27373675e-13 96"></polygon>
                <polygon id="WEDGES-l16-o7" style="fill: #D8D8D8" points="70.2768775 96 60.8615612 131.138439 40.5741225 95.9988775"></polygon>
                <polygon id="WEDGES-l16-o6" style="fill: limegreen" points="70.2768775 96 40.574 95.999 25.7231225 70.2768775"></polygon>
                <polygon id="WEDGES-l16-o5" style="fill: limegreen" points="48.0001225 47.9995 68.287 47.9995 78.4307806 65.5692194"></polygon>
                <polygon id="WEDGES-l16-o4" style="fill: white" points="60.8615 35.1385 68.287 47.9995 48 48"></polygon>
                <polygon id="WEDGES-l16-o3" style="fill: limegreen" points="83.1384388 48 78.4307806 65.5692194 68.2870612 47.9994388"></polygon>
                <polygon id="WEDGES-l16-o2" style="fill: white" points="83.1384388 48 68.287 47.9995 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l16-o1" style="fill: white" points="96 0 83.1384388 48 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l16-o0" style="fill: limegreen" points="70.2768775 96 25.7231225 70.2768775 48.0001225 47.9995 78.4307806 65.5692194"></polygon>
            </g>
            <g id="WEDGES-15" transform="translate(244.315353, 171.726896) scale(-1, -1) rotate(60.000000) translate(-244.315353, -171.726896) translate(196.315353, 105.726896)">
                <polygon id="WEDGES-l15-o8" style="fill: #D8D8D8" points="25.723 70.277 40.574 95.999 -2.27373675e-13 96"></polygon>
                <polygon id="WEDGES-l15-o7" style="fill: #D8D8D8" points="70.2768775 96 60.8615612 131.138439 40.5741225 95.9988775"></polygon>
                <polygon id="WEDGES-l15-o6" style="fill: #D8D8D8" points="70.2768775 96 40.574 95.999 25.7231225 70.2768775"></polygon>
                <polygon id="WEDGES-l15-o5" style="fill: limegreen" points="48.0001225 47.9995 68.287 47.9995 78.4307806 65.5692194"></polygon>
                <polygon id="WEDGES-l15-o4" style="fill: limegreen" points="60.8615 35.1385 68.287 47.9995 48 48"></polygon>
                <polygon id="WEDGES-l15-o3" style="fill: limegreen" points="83.1384388 48 78.4307806 65.5692194 68.2870612 47.9994388"></polygon>
                <polygon id="WEDGES-l15-o2" style="fill: limegreen" points="83.1384388 48 68.287 47.9995 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l15-o1" style="fill: white" points="96 0 83.1384388 48 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l15-o0" style="fill: limegreen" points="70.2768775 96 25.7231225 70.2768775 48.0001225 47.9995 78.4307806 65.5692194"></polygon>
            </g>
            <g id="WEDGES-14" transform="translate(237.726896, 130.000000) scale(-1, -1) rotate(30.000000) translate(-237.726896, -130.000000) translate(189.726896, 64.000000)">
                <polygon id="WEDGES-l14-o8" style="fill: #D8D8D8" points="25.723 70.277 40.574 95.999 -2.27373675e-13 96"></polygon>
                <polygon id="WEDGES-l14-o7" style="fill: limegreen" points="70.2768775 96 60.8615612 131.138439 40.5741225 95.9988775"></polygon>
                <polygon id="WEDGES-l14-o6" style="fill: limegreen" points="70.2768775 96 40.574 95.999 25.7231225 70.2768775"></polygon>
                <polygon id="WEDGES-l14-o5" style="fill: limegreen" points="48.0001225 47.9995 68.287 47.9995 78.4307806 65.5692194"></polygon>
                <polygon id="WEDGES-l14-o4" style="fill: limegreen" points="60.8615 35.1385 68.287 47.9995 48 48"></polygon>
                <polygon id="WEDGES-l14-o3" style="fill: white" points="83.1384388 48 78.4307806 65.5692194 68.2870612 47.9994388"></polygon>
                <polygon id="WEDGES-l14-o2" style="fill: white" points="83.1384388 48 68.287 47.9995 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l14-o1" style="fill: white" points="96 0 83.1384388 48 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l14-o0" style="fill: limegreen" points="70.2768775 96 25.7231225 70.2768775 48.0001225 47.9995 78.4307806 65.5692194"></polygon>
            </g>
            <g id="WEDGES-13" transform="translate(211.157677, 97.157677) scale(-1, -1) translate(-211.157677, -97.157677) translate(163.157677, 31.157677)">
                <polygon id="WEDGES-l13-o8" style="fill: red" points="25.723 70.277 40.574 95.999 -2.27373675e-13 96"></polygon>
                <polygon id="WEDGES-l13-o7" style="fill: #D8D8D8" points="70.2768775 96 60.8615612 131.138439 40.5741225 95.9988775"></polygon>
                <polygon id="WEDGES-l13-o6" style="fill: red" points="70.2768775 96 40.574 95.999 25.7231225 70.2768775"></polygon>
                <polygon id="WEDGES-l13-o5" style="fill: red" points="48.0001225 47.9995 68.287 47.9995 78.4307806 65.5692194"></polygon>
                <polygon id="WEDGES-l13-o4" style="fill: white" points="60.8615 35.1385 68.287 47.9995 48 48"></polygon>
                <polygon id="WEDGES-l13-o3" style="fill: red" points="83.1384388 48 78.4307806 65.5692194 68.2870612 47.9994388"></polygon>
                <polygon id="WEDGES-l13-o2" style="fill: white" points="83.1384388 48 68.287 47.9995 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l13-o1" style="fill: white" points="96 0 83.1384388 48 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l13-o0" style="fill: red" points="70.2768775 96 25.7231225 70.2768775 48.0001225 47.9995 78.4307806 65.5692194"></polygon>
            </g>
            <g id="WEDGES-12" transform="translate(171.726896, 82.000000) rotate(150.000000) translate(-171.726896, -82.000000) translate(123.726896, 16.000000)">
                <polygon id="WEDGES-l12-o8" style="fill: #D8D8D8" points="25.723 70.277 40.574 95.999 -2.27373675e-13 96"></polygon>
                <polygon id="WEDGES-l12-o7" style="fill: #D8D8D8" points="70.2768775 96 60.8615612 131.138439 40.5741225 95.9988775"></polygon>
                <polygon id="WEDGES-l12-o6" style="fill: #D8D8D8" points="70.2768775 96 40.574 95.999 25.7231225 70.2768775"></polygon>
                <polygon id="WEDGES-l12-o5" style="fill: red" points="48.0001225 47.9995 68.287 47.9995 78.4307806 65.5692194"></polygon>
                <polygon id="WEDGES-l12-o4" style="fill: red" points="60.8615 35.1385 68.287 47.9995 48 48"></polygon>
                <polygon id="WEDGES-l12-o3" style="fill: red" points="83.1384388 48 78.4307806 65.5692194 68.2870612 47.9994388"></polygon>
                <polygon id="WEDGES-l12-o2" style="fill: red" points="83.1384388 48 68.287 47.9995 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l12-o1" style="fill: white" points="96 0 83.1384388 48 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l12-o0" style="fill: red" points="70.2768775 96 25.7231225 70.2768775 48.0001225 47.9995 78.4307806 65.5692194"></polygon>
            </g>
        </g>
        <g id="TOP" transform="translate(41.000000, -31.000000)" stroke-linejoin="round">
            <g id="WEDGES-11" transform="translate(154.588457, 244.315353) scale(-1, -1) rotate(150.000000) translate(-154.588457, -244.315353) translate(106.588457, 178.315353)">
                <polygon id="WEDGES-l11-o8" style="fill: #D8D8D8" points="25.723 70.277 40.574 95.999 -2.27373675e-13 96"></polygon>
                <polygon id="WEDGES-l11-o7" style="fill: #D8D8D8" points="70.2768775 96 60.8615612 131.138439 40.5741225 95.9988775"></polygon>
                <polygon id="WEDGES-l11-o6" style="fill: #D8D8D8" points="70.2768775 96 40.574 95.999 25.7231225 70.2768775"></polygon>
                <polygon id="WEDGES-l11-o5" style="fill: red" points="48.0001225 47.9995 68.287 47.9995 78.4307806 65.5692194"></polygon>
                <polygon id="WEDGES-l11-o4" style="fill: red" points="60.8615 35.1385 68.287 47.9995 48 48"></polygon>
                <polygon id="WEDGES-l11-o3" style="fill: red" points="83.1384388 48 78.4307806 65.5692194 68.2870612 47.9994388"></polygon>
                <polygon id="WEDGES-l11-o2" style="fill: red" points="83.1384388 48 68.287 47.9995 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l11-o1" style="fill: yellow" points="96 0 83.1384388 48 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l11-o0" style="fill: red" points="70.2768775 96 25.7231225 70.2768775 48.0001225 47.9995 78.4307806 65.5692194"></polygon>
            </g>
            <g id="WEDGES-10" transform="translate(196.315353, 237.726896) scale(-1, -1) rotate(120.000000) translate(-196.315353, -237.726896) translate(148.315353, 171.726896)">
                <polygon id="WEDGES-l10-o8" style="fill: #D8D8D8" points="25.723 70.277 40.574 95.999 -2.27373675e-13 96"></polygon>
                <polygon id="WEDGES-l10-o7" style="fill: red" points="70.2768775 96 60.8615612 131.138439 40.5741225 95.9988775"></polygon>
                <polygon id="WEDGES-l10-o6" style="fill: red" points="70.2768775 96 40.574 95.999 25.7231225 70.2768775"></polygon>
                <polygon id="WEDGES-l10-o5" style="fill: red" points="48.0001225 47.9995 68.287 47.9995 78.4307806 65.5692194"></polygon>
                <polygon id="WEDGES-l10-o4" style="fill: red" points="60.8615 35.1385 68.287 47.9995 48 48"></polygon>
                <polygon id="WEDGES-l10-o3" style="fill: yellow" points="83.1384388 48 78.4307806 65.5692194 68.2870612 47.9994388"></polygon>
                <polygon id="WEDGES-l10-o2" style="fill: yellow" points="83.1384388 48 68.287 47.9995 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l10-o1" style="fill: yellow" points="96 0 83.1384388 48 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l10-o0" style="fill: red" points="70.2768775 96 25.7231225 70.2768775 48.0001225 47.9995 78.4307806 65.5692194"></polygon>
            </g>
            <g id="WEDGES-9" transform="translate(229.157677, 211.157677) scale(-1, -1) rotate(90.000000) translate(-229.157677, -211.157677) translate(181.157677, 145.157677)">
                <polygon id="WEDGES-l9-o8" style="fill: limegreen" points="25.723 70.277 40.574 95.999 -2.27373675e-13 96"></polygon>
                <polygon id="WEDGES-l9-o7" style="fill: #D8D8D8" points="70.2768775 96 60.8615612 131.138439 40.5741225 95.9988775"></polygon>
                <polygon id="WEDGES-l9-o6" style="fill: limegreen" points="70.2768775 96 40.574 95.999 25.7231225 70.2768775"></polygon>
                <polygon id="WEDGES-l9-o5" style="fill: limegreen" points="48.0001225 47.9995 68.287 47.9995 78.4307806 65.5692194"></polygon>
                <polygon id="WEDGES-l9-o4" style="fill: yellow" points="60.8615 35.1385 68.287 47.9995 48 48"></polygon>
                <polygon id="WEDGES-l9-o3" style="fill: limegreen" points="83.1384388 48 78.4307806 65.5692194 68.2870612 47.9994388"></polygon>
                <polygon id="WEDGES-l9-o2" style="fill: yellow" points="83.1384388 48 68.287 47.9995 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l9-o1" style="fill: yellow" points="96 0 83.1384388 48 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l9-o0" style="fill: limegreen" points="70.2768775 96 25.7231225 70.2768775 48.0001225 47.9995 78.4307806 65.5692194"></polygon>
            </g>
            <g id="WEDGES-8" transform="translate(244.315353, 171.726896) scale(-1, -1) rotate(60.000000) translate(-244.315353, -171.726896) translate(196.315353, 105.726896)">
                <polygon id="WEDGES-l8-o8" style="fill: #D8D8D8" points="25.723 70.277 40.574 95.999 -2.27373675e-13 96"></polygon>
                <polygon id="WEDGES-l8-o7" style="fill: #D8D8D8" points="70.2768775 96 60.8615612 131.138439 40.5741225 95.9988775"></polygon>
                <polygon id="WEDGES-l8-o6" style="fill: #D8D8D8" points="70.2768775 96 40.574 95.999 25.7231225 70.2768775"></polygon>
                <polygon id="WEDGES-l8-o5" style="fill: limegreen" points="48.0001225 47.9995 68.287 47.9995 78.4307806 65.5692194"></polygon>
                <polygon id="WEDGES-l8-o4" style="fill: limegreen" points="60.8615 35.1385 68.287 47.9995 48 48"></polygon>
                <polygon id="WEDGES-l8-o3" style="fill: limegreen" points="83.1384388 48 78.4307806 65.5692194 68.2870612 47.9994388"></polygon>
                <polygon id="WEDGES-l8-o2" style="fill: limegreen" points="83.1384388 48 68.287 47.9995 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l8-o1" style="fill: yellow" points="96 0 83.1384388 48 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l8-o0" style="fill: limegreen" points="70.2768775 96 25.7231225 70.2768775 48.0001225 47.9995 78.4307806 65.5692194"></polygon>
            </g>
            <g id="WEDGES-7" transform="translate(237.726896, 130.000000) scale(-1, -1) rotate(30.000000) translate(-237.726896, -130.000000) translate(189.726896, 64.000000)">
                <polygon id="WEDGES-l7-o8" style="fill: #D8D8D8" points="25.723 70.277 40.574 95.999 -2.27373675e-13 96"></polygon>
                <polygon id="WEDGES-l7-o7" style="fill: limegreen" points="70.2768775 96 60.8615612 131.138439 40.5741225 95.9988775"></polygon>
                <polygon id="WEDGES-l7-o6" style="fill: limegreen" points="70.2768775 96 40.574 95.999 25.7231225 70.2768775"></polygon>
                <polygon id="WEDGES-l7-o5" style="fill: limegreen" points="48.0001225 47.9995 68.287 47.9995 78.4307806 65.5692194"></polygon>
                <polygon id="WEDGES-l7-o4" style="fill: limegreen" points="60.8615 35.1385 68.287 47.9995 48 48"></polygon>
                <polygon id="WEDGES-l7-o3" style="fill: yellow" points="83.1384388 48 78.4307806 65.5692194 68.2870612 47.9994388"></polygon>
                <polygon id="WEDGES-l7-o2" style="fill: yellow" points="83.1384388 48 68.287 47.9995 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l7-o1" style="fill: yellow" points="96 0 83.1384388 48 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l7-o0" style="fill: limegreen" points="70.2768775 96 25.7231225 70.2768775 48.0001225 47.9995 78.4307806 65.5692194"></polygon>
            </g>
            <g id="WEDGES-6" transform="translate(211.157677, 97.157677) scale(-1, -1) translate(-211.157677, -97.157677) translate(163.157677, 31.157677)">
                <polygon id="WEDGES-l6-o8" style="fill: orange" points="25.723 70.277 40.574 95.999 -2.27373675e-13 96"></polygon>
                <polygon id="WEDGES-l6-o7" style="fill: #D8D8D8" points="70.2768775 96 60.8615612 131.138439 40.5741225 95.9988775"></polygon>
                <polygon id="WEDGES-l6-o6" style="fill: orange" points="70.2768775 96 40.574 95.999 25.7231225 70.2768775"></polygon>
                <polygon id="WEDGES-l6-o5" style="fill: orange" points="48.0001225 47.9995 68.287 47.9995 78.4307806 65.5692194"></polygon>
                <polygon id="WEDGES-l6-o4" style="fill: yellow" points="60.8615 35.1385 68.287 47.9995 48 48"></polygon>
                <polygon id="WEDGES-l6-o3" style="fill: orange" points="83.1384388 48 78.4307806 65.5692194 68.2870612 47.9994388"></polygon>
                <polygon id="WEDGES-l6-o2" style="fill: yellow" points="83.1384388 48 68.287 47.9995 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l6-o1" style="fill: yellow" points="96 0 83.1384388 48 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l6-o0" style="fill: orange" points="70.2768775 96 25.7231225 70.2768775 48.0001225 47.9995 78.4307806 65.5692194"></polygon>
            </g>
            <g id="WEDGES-5" transform="translate(171.726896, 82.000000) rotate(150.000000) translate(-171.726896, -82.000000) translate(123.726896, 16.000000)">
                <polygon id="WEDGES-l5-o8" style="fill: #D8D8D8" points="25.723 70.277 40.574 95.999 -2.27373675e-13 96"></polygon>
                <polygon id="WEDGES-l5-o7" style="fill: #D8D8D8" points="70.2768775 96 60.8615612 131.138439 40.5741225 95.9988775"></polygon>
                <polygon id="WEDGES-l5-o6" style="fill: #D8D8D8" points="70.2768775 96 40.574 95.999 25.7231225 70.2768775"></polygon>
                <polygon id="WEDGES-l5-o5" style="fill: orange" points="48.0001225 47.9995 68.287 47.9995 78.4307806 65.5692194"></polygon>
                <polygon id="WEDGES-l5-o4" style="fill: orange" points="60.8615 35.1385 68.287 47.9995 48 48"></polygon>
                <polygon id="WEDGES-l5-o3" style="fill: orange" points="83.1384388 48 78.4307806 65.5692194 68.2870612 47.9994388"></polygon>
                <polygon id="WEDGES-l5-o2" style="fill: orange" points="83.1384388 48 68.287 47.9995 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l5-o1" style="fill: yellow" points="96 0 83.1384388 48 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l5-o0" style="fill: orange" points="70.2768775 96 25.7231225 70.2768775 48.0001225 47.9995 78.4307806 65.5692194"></polygon>
            </g>
            <g id="WEDGES-4" transform="translate(130.000000, 88.588457) rotate(120.000000) translate(-130.000000, -88.588457) translate(82.000000, 22.588457)">
                <polygon id="WEDGES-l4-o8" style="fill: #D8D8D8" points="25.723 70.277 40.574 95.999 -2.27373675e-13 96"></polygon>
                <polygon id="WEDGES-l4-o7" style="fill: orange" points="70.2768775 96 60.8615612 131.138439 40.5741225 95.9988775"></polygon>
                <polygon id="WEDGES-l4-o6" style="fill: orange" points="70.2768775 96 40.574 95.999 25.7231225 70.2768775"></polygon>
                <polygon id="WEDGES-l4-o5" style="fill: orange" points="48.0001225 47.9995 68.287 47.9995 78.4307806 65.5692194"></polygon>
                <polygon id="WEDGES-l4-o4" style="fill: orange" points="60.8615 35.1385 68.287 47.9995 48 48"></polygon>
                <polygon id="WEDGES-l4-o3" style="fill: yellow" points="83.1384388 48 78.4307806 65.5692194 68.2870612 47.9994388"></polygon>
                <polygon id="WEDGES-l4-o2" style="fill: yellow" points="83.1384388 48 68.287 47.9995 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l4-o1" style="fill: yellow" points="96 0 83.1384388 48 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l4-o0" style="fill: orange" points="70.2768775 96 25.7231225 70.2768775 48.0001225 47.9995 78.4307806 65.5692194"></polygon>
            </g>
            <g id="WEDGES-3" transform="translate(97.157677, 115.157677) rotate(90.000000) translate(-97.157677, -115.157677) translate(49.157677, 49.157677)">
                <polygon id="WEDGES-l3-o8" style="fill: blue" points="25.723 70.277 40.574 95.999 -2.27373675e-13 96"></polygon>
                <polygon id="WEDGES-l3-o7" style="fill: #D8D8D8" points="70.2768775 96 60.8615612 131.138439 40.5741225 95.9988775"></polygon>
                <polygon id="WEDGES-l3-o6" style="fill: blue" points="70.2768775 96 40.574 95.999 25.7231225 70.2768775"></polygon>
                <polygon id="WEDGES-l3-o5" style="fill: blue" points="48.0001225 47.9995 68.287 47.9995 78.4307806 65.5692194"></polygon>
                <polygon id="WEDGES-l3-o4" style="fill: yellow" points="60.8615 35.1385 68.287 47.9995 48 48"></polygon>
                <polygon id="WEDGES-l3-o3" style="fill: blue" points="83.1384388 48 78.4307806 65.5692194 68.2870612 47.9994388"></polygon>
                <polygon id="WEDGES-l3-o2" style="fill: yellow" points="83.1384388 48 68.287 47.9995 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l3-o1" style="fill: yellow" points="96 0 83.1384388 48 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l3-o0" style="fill: blue" points="70.2768775 96 25.7231225 70.2768775 48.0001225 47.9995 78.4307806 65.5692194"></polygon>
            </g>
            <g id="WEDGES-2" transform="translate(82.000000, 154.588457) rotate(60.000000) translate(-82.000000, -154.588457) translate(34.000000, 88.588457)">
                <polygon id="WEDGES-l2-o8" style="fill: #D8D8D8" points="25.723 70.277 40.574 95.999 -2.27373675e-13 96"></polygon>
                <polygon id="WEDGES-l2-o7" style="fill: #D8D8D8" points="70.2768775 96 60.8615612 131.138439 40.5741225 95.9988775"></polygon>
                <polygon id="WEDGES-l2-o6" style="fill: #D8D8D8" points="70.2768775 96 40.574 95.999 25.7231225 70.2768775"></polygon>
                <polygon id="WEDGES-l2-o5" style="fill: blue" points="48.0001225 47.9995 68.287 47.9995 78.4307806 65.5692194"></polygon>
                <polygon id="WEDGES-l2-o4" style="fill: blue" points="60.8615 35.1385 68.287 47.9995 48 48"></polygon>
                <polygon id="WEDGES-l2-o3" style="fill: blue" points="83.1384388 48 78.4307806 65.5692194 68.2870612 47.9994388"></polygon>
                <polygon id="WEDGES-l2-o2" style="fill: blue" points="83.1384388 48 68.287 47.9995 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l2-o1" style="fill: yellow" points="96 0 83.1384388 48 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l2-o0" style="fill: blue" points="70.2768775 96 25.7231225 70.2768775 48.0001225 47.9995 78.4307806 65.5692194"></polygon>
            </g>
            <g id="WEDGES-1" transform="translate(88.588457, 196.315353) rotate(30.000000) translate(-88.588457, -196.315353) translate(40.588457, 130.315353)">
                <polygon id="WEDGES-l1-o8" style="fill: #D8D8D8" points="25.723 70.277 40.574 95.999 -2.27373675e-13 96"></polygon>
                <polygon id="WEDGES-l1-o7" style="fill: blue" points="70.2768775 96 60.8615612 131.138439 40.5741225 95.9988775"></polygon>
                <polygon id="WEDGES-l1-o6" style="fill: blue" points="70.2768775 96 40.574 95.999 25.7231225 70.2768775"></polygon>
                <polygon id="WEDGES-l1-o5" style="fill: blue" points="48.0001225 47.9995 68.287 47.9995 78.4307806 65.5692194"></polygon>
                <polygon id="WEDGES-l1-o4" style="fill: blue" points="60.8615 35.1385 68.287 47.9995 48 48"></polygon>
                <polygon id="WEDGES-l1-o3" style="fill: yellow" points="83.1384388 48 78.4307806 65.5692194 68.2870612 47.9994388"></polygon>
                <polygon id="WEDGES-l1-o2" style="fill: yellow" points="83.1384388 48 68.287 47.9995 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l1-o1" style="fill: yellow" points="96 0 83.1384388 48 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l1-o0" style="fill: blue" points="70.2768775 96 25.7231225 70.2768775 48.0001225 47.9995 78.4307806 65.5692194"></polygon>
            </g>
            <g id="WEDGES-0" transform="translate(67.157677, 163.157677)">
                <polygon id="WEDGES-l0-o8" style="fill: red" points="25.723 70.277 40.574 95.999 -2.27373675e-13 96"></polygon>
                <polygon id="WEDGES-l0-o7" style="fill: #D8D8D8" points="70.2768775 96 60.8615612 131.138439 40.5741225 95.9988775"></polygon>
                <polygon id="WEDGES-l0-o6" style="fill: red" points="70.2768775 96 40.574 95.999 25.7231225 70.2768775"></polygon>
                <polygon id="WEDGES-l0-o5" style="fill: red" points="48.0001225 47.9995 68.287 47.9995 78.4307806 65.5692194"></polygon>
                <polygon id="WEDGES-l0-o4" style="fill: yellow" points="60.8615 35.1385 68.287 47.9995 48 48"></polygon>
                <polygon id="WEDGES-l0-o3" style="fill: red" points="83.1384388 48 78.4307806 65.5692194 68.2870612 47.9994388"></polygon>
                <polygon id="WEDGES-l0-o2" style="fill: yellow" points="83.1384388 48 68.287 47.9995 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l0-o1" style="fill: yellow" points="96 0 83.1384388 48 60.8615612 35.1384388"></polygon>
                <polygon id="WEDGES-l0-o0" style="fill: red" points="70.2768775 96 25.7231225 70.2768775 48.0001225 47.9995 78.4307806 65.5692194"></polygon>
            </g>
        </g>
        <g id="DIAGONALS" transform="translate(168.861561, 1.019238)" stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2">
            <line x1="0" y1="287.842323" x2="70.2768775" y2="550.119201" id="BOTTOM"></line>
            <line x1="0.15767665" y1="262.276878" x2="70.4345542" y2="2.27488928e-16" id="TOP"></line>
        </g>
    </g>
</svg>`;
  }
});

// src/cubing/puzzles/implementations/square1/index.ts
var square1;
var init_square1 = __esm({
  "src/cubing/puzzles/implementations/square1/index.ts"() {
    init_kpuzzle();
    init_lazy_cached();
    square1 = {
      id: "square1",
      fullName: "Square-1",
      inventedBy: ["Karel Hr\u0161el", "Vojtech Kopsk\xFD"],
      inventionYear: 1990,
      kpuzzle: getCached(async () => new KPuzzle((await Promise.resolve().then(() => (init_sq1_hyperorbit_kpuzzle_json(), sq1_hyperorbit_kpuzzle_json_exports))).sq1HyperOrbitKPuzzleDefinition)),
      svg: getCached(async () => {
        return (await Promise.resolve().then(() => (init_sq1_hyperorbit_kpuzzle_svg(), sq1_hyperorbit_kpuzzle_svg_exports))).default;
      })
    };
  }
});

// src/cubing/puzzles/implementations/kilominx/kilominx.kpuzzle.svg.ts
var kilominx_kpuzzle_svg_exports = {};
__export(kilominx_kpuzzle_svg_exports, {
  kilominxSVG: () => kilominxSVG
});
var kilominxSVG;
var init_kilominx_kpuzzle_svg = __esm({
  "src/cubing/puzzles/implementations/kilominx/kilominx.kpuzzle.svg.ts"() {
    kilominxSVG = `<svg id="svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 800 500">
<style type="text/css"><![CDATA[.sticker { stroke: #000000; stroke-width: 1px; }]]></style>
<g><title>U</title>
<polygon id="CORNERS-l0-o1" class="sticker" style="fill: #ffffff" points="247.941 89.861 283.500 115.696 269.918 157.499 212.382 138.805"/>
<polygon id="CORNERS-l10-o2" class="sticker" style="fill: #ffffff" points="154.845 157.499 141.263 115.696 176.822 89.861 212.382 138.805"/>
<polygon id="CORNERS-l5-o0" class="sticker" style="fill: #ffffff" points="176.822 89.861 212.381 64.025 247.941 89.861 212.382 138.805"/>
<polygon id="CORNERS-l4-o1" class="sticker" style="fill: #ffffff" points="212.381 199.301 168.427 199.301 154.845 157.499 212.382 138.805"/>
<polygon id="CORNERS-l1-o1" class="sticker" style="fill: #ffffff" points="269.918 157.499 256.335 199.301 212.381 199.301 212.382 138.805"/>
</g><g><title>F</title>
<polygon id="CORNERS-l7-o0" class="sticker" style="fill: #006633" points="247.941 319.263 212.381 345.098 176.822 319.263 212.382 270.32"/>
<polygon id="CORNERS-l1-o0" class="sticker" style="fill: #006633" points="212.381 209.823 256.335 209.823 269.918 251.625 212.382 270.32"/>
<polygon id="CORNERS-l3-o0" class="sticker" style="fill: #006633" points="269.918 251.625 283.500 293.428 247.941 319.263 212.382 270.32"/>
<polygon id="CORNERS-l4-o2" class="sticker" style="fill: #006633" points="154.845 251.625 168.427 209.823 212.381 209.823 212.382 270.32"/>
<polygon id="CORNERS-l9-o1" class="sticker" style="fill: #006633" points="176.822 319.263 141.263 293.428 154.845 251.625 212.382 270.32"/>
</g><g><title>L</title>
<polygon id="CORNERS-l13-o0" class="sticker" style="fill: #660099" points="87.302 290.176 43.349 290.176 29.766 248.374 87.303 229.68"/>
<polygon id="CORNERS-l4-o0" class="sticker" style="fill: #660099" points="122.862 180.736 158.421 206.571 144.839 248.374 87.303 229.68"/>
<polygon id="CORNERS-l9-o0" class="sticker" style="fill: #660099" points="144.839 248.374 131.256 290.176 87.302 290.176 87.303 229.68"/>
<polygon id="CORNERS-l10-o0" class="sticker" style="fill: #660099" points="51.743 180.736 87.302 154.901 122.862 180.736 87.303 229.68"/>
<polygon id="CORNERS-l11-o0" class="sticker" style="fill: #660099" points="29.766 248.374 16.184 206.571 51.743 180.736 87.303 229.68"/>
</g><g><title>BL</title>
<polygon id="CORNERS-l15-o1" class="sticker" style="fill: #ffff00" points="700.480 172.224 664.921 198.059 629.361 172.224 664.921 123.281"/>
<polygon id="CORNERS-l10-o1" class="sticker" style="fill: #ffff00" points="664.921 62.784 708.874 62.784 722.457 104.586 664.921 123.281"/>
<polygon id="CORNERS-l11-o2" class="sticker" style="fill: #ffff00" points="722.457 104.586 736.039 146.389 700.480 172.224 664.921 123.281"/>
<polygon id="CORNERS-l5-o1" class="sticker" style="fill: #ffff00" points="607.384 104.586 620.967 62.784 664.921 62.784 664.921 123.281"/>
<polygon id="CORNERS-l19-o2" class="sticker" style="fill: #ffff00" points="629.361 172.224 593.802 146.389 607.384 104.586 664.921 123.281"/>
</g><g><title>BR</title>
<polygon id="CORNERS-l12-o1" class="sticker" style="fill: #0000ff" points="545.874 172.224 510.315 198.059 474.755 172.224 510.315 123.281"/>
<polygon id="CORNERS-l5-o2" class="sticker" style="fill: #0000ff" points="510.315 62.784 554.269 62.784 567.851 104.586 510.315 123.281"/>
<polygon id="CORNERS-l19-o1" class="sticker" style="fill: #0000ff" points="567.851 104.586 581.433 146.389 545.874 172.224 510.315 123.281"/>
<polygon id="CORNERS-l0-o2" class="sticker" style="fill: #0000ff" points="452.779 104.586 466.361 62.784 510.315 62.784 510.315 123.281"/>
<polygon id="CORNERS-l6-o2" class="sticker" style="fill: #0000ff" points="474.755 172.224 439.196 146.389 452.779 104.586 510.315 123.281"/>
</g><g><title>R</title>
<polygon id="CORNERS-l6-o1" class="sticker" style="fill: #ff0000" points="373.019 180.736 408.579 206.571 394.996 248.374 337.461 229.68"/>
<polygon id="CORNERS-l1-o2" class="sticker" style="fill: #ff0000" points="279.924 248.374 266.341 206.571 301.901 180.736 337.461 229.68"/>
<polygon id="CORNERS-l0-o0" class="sticker" style="fill: #ff0000" points="301.901 180.736 337.460 154.901 373.019 180.736 337.461 229.68"/>
<polygon id="CORNERS-l3-o1" class="sticker" style="fill: #ff0000" points="337.460 290.176 293.506 290.176 279.924 248.374 337.461 229.68"/>
<polygon id="CORNERS-l2-o2" class="sticker" style="fill: #ff0000" points="394.996 248.374 381.414 290.176 337.460 290.176 337.461 229.68"/>
</g><g><title>C</title>
<polygon id="CORNERS-l8-o2" class="sticker" style="fill: #ffffd0" points="347.220 395.413 333.638 437.215 289.684 437.215 289.685 376.719"/>
<polygon id="CORNERS-l3-o2" class="sticker" style="fill: #ffffd0" points="254.125 327.775 289.684 301.940 325.244 327.775 289.685 376.719"/>
<polygon id="CORNERS-l2-o1" class="sticker" style="fill: #ffffd0" points="325.244 327.775 360.803 353.610 347.220 395.413 289.685 376.719"/>
<polygon id="CORNERS-l7-o1" class="sticker" style="fill: #ffffd0" points="232.148 395.413 218.566 353.610 254.125 327.775 289.685 376.719"/>
<polygon id="CORNERS-l17-o2" class="sticker" style="fill: #ffffd0" points="289.684 437.215 245.730 437.215 232.148 395.413 289.685 376.719"/>
</g><g><title>A</title>
<polygon id="CORNERS-l17-o1" class="sticker" style="fill: #3399ff" points="192.615 395.413 179.032 437.215 135.078 437.215 135.079 376.719"/>
<polygon id="CORNERS-l9-o2" class="sticker" style="fill: #3399ff" points="99.519 327.775 135.078 301.940 170.638 327.775 135.079 376.719"/>
<polygon id="CORNERS-l7-o2" class="sticker" style="fill: #3399ff" points="170.638 327.775 206.197 353.610 192.615 395.413 135.079 376.719"/>
<polygon id="CORNERS-l13-o1" class="sticker" style="fill: #3399ff" points="77.542 395.413 63.960 353.610 99.519 327.775 135.079 376.719"/>
<polygon id="CORNERS-l14-o1" class="sticker" style="fill: #3399ff" points="135.078 437.215 91.125 437.215 77.542 395.413 135.079 376.719"/>
</g><g><title>I</title>
<polygon id="CORNERS-l18-o1" class="sticker" style="fill: #ff6633" points="677.137 319.263 641.578 293.428 655.160 251.625 712.697 270.32"/>
<polygon id="CORNERS-l13-o2" class="sticker" style="fill: #ff6633" points="770.233 251.625 783.815 293.428 748.256 319.263 712.697 270.32"/>
<polygon id="CORNERS-l14-o0" class="sticker" style="fill: #ff6633" points="748.256 319.263 712.697 345.098 677.137 319.263 712.697 270.32"/>
<polygon id="CORNERS-l11-o1" class="sticker" style="fill: #ff6633" points="712.697 209.823 756.650 209.823 770.233 251.625 712.697 270.32"/>
<polygon id="CORNERS-l15-o2" class="sticker" style="fill: #ff6633" points="655.160 251.625 668.743 209.823 712.697 209.823 712.697 270.32"/>
</g><g><title>BF</title>
<polygon id="CORNERS-l16-o1" class="sticker" style="fill: #99ff00" points="587.618 290.176 543.664 290.176 530.081 248.374 587.618 229.68"/>
<polygon id="CORNERS-l15-o0" class="sticker" style="fill: #99ff00" points="623.177 180.736 658.736 206.571 645.154 248.374 587.618 229.68"/>
<polygon id="CORNERS-l18-o0" class="sticker" style="fill: #99ff00" points="645.154 248.374 631.572 290.176 587.618 290.176 587.618 229.68"/>
<polygon id="CORNERS-l19-o0" class="sticker" style="fill: #99ff00" points="552.058 180.736 587.618 154.901 623.177 180.736 587.618 229.68"/>
<polygon id="CORNERS-l12-o2" class="sticker" style="fill: #99ff00" points="530.081 248.374 516.499 206.571 552.058 180.736 587.618 229.68"/>
</g><g><title>E</title>
<polygon id="CORNERS-l8-o0" class="sticker" style="fill: #ff66cc" points="498.098 319.263 462.539 345.098 426.980 319.263 462.539 270.32"/>
<polygon id="CORNERS-l12-o0" class="sticker" style="fill: #ff66cc" points="462.539 209.823 506.493 209.823 520.075 251.625 462.539 270.32"/>
<polygon id="CORNERS-l16-o0" class="sticker" style="fill: #ff66cc" points="520.075 251.625 533.658 293.428 498.098 319.263 462.539 270.32"/>
<polygon id="CORNERS-l6-o0" class="sticker" style="fill: #ff66cc" points="405.003 251.625 418.585 209.823 462.539 209.823 462.539 270.32"/>
<polygon id="CORNERS-l2-o0" class="sticker" style="fill: #ff66cc" points="426.980 319.263 391.420 293.428 405.003 251.625 462.539 270.32"/>
</g><g><title>D</title>
<polygon id="CORNERS-l18-o2" class="sticker" style="fill: #999999" points="587.618 300.698 631.572 300.698 645.154 342.500 587.618 361.195"/>
<polygon id="CORNERS-l8-o1" class="sticker" style="fill: #999999" points="552.058 410.138 516.499 384.303 530.081 342.500 587.618 361.195"/>
<polygon id="CORNERS-l16-o2" class="sticker" style="fill: #999999" points="530.081 342.500 543.664 300.698 587.618 300.698 587.618 361.195"/>
<polygon id="CORNERS-l17-o0" class="sticker" style="fill: #999999" points="623.177 410.138 587.618 435.974 552.058 410.138 587.618 361.195"/>
<polygon id="CORNERS-l14-o2" class="sticker" style="fill: #999999" points="645.154 342.500 658.736 384.303 623.177 410.138 587.618 361.195"/>
</g></svg>
`;
  }
});

// src/cubing/puzzles/implementations/kilominx/index.ts
var kilominx;
var init_kilominx = __esm({
  "src/cubing/puzzles/implementations/kilominx/index.ts"() {
    init_kpuzzle();
    init_async_pg3d();
    init_lazy_cached();
    kilominx = {
      id: "kilominx",
      fullName: "Kilominx",
      kpuzzle: getCached(async () => {
        const pg = await asyncGetPuzzleGeometry("megaminx + chopasaurus");
        const kpuzzleDefinition = JSON.parse(JSON.stringify(pg.getKPuzzleDefinition(true)));
        delete kpuzzleDefinition.orbits.CENTERS;
        delete kpuzzleDefinition.orbits.CENTERS2;
        delete kpuzzleDefinition.startStateData.CENTERS;
        delete kpuzzleDefinition.startStateData.CENTERS2;
        for (const moveDefinition of Object.values(kpuzzleDefinition.moves)) {
          delete moveDefinition.CENTERS;
          delete moveDefinition.CENTERS2;
        }
        kpuzzleDefinition.name = "kilominx";
        delete kpuzzleDefinition.experimentalPuzzleDescription;
        const puzzleGeometry = await Promise.resolve().then(() => (init_puzzle_geometry(), puzzle_geometry_exports));
        const pgNotation = new puzzleGeometry.ExperimentalPGNotation(pg, pg.getOrbitsDef(true));
        const kpuzzle = new KPuzzle(kpuzzleDefinition, {
          experimentalPGNotation: {
            lookupMove: (move) => {
              if (move.toString() === "x2" || move.toString() === "x2'") {
                return x2Transformation.transformationData;
              }
              return pgNotation.lookupMove(move);
            }
          }
        });
        const x2Transformation = kpuzzle.algToTransformation("Rv2 Fv Uv'");
        kpuzzleDefinition.moves["x2"] = x2Transformation;
        return kpuzzle;
      }),
      svg: getCached(async () => {
        return (await Promise.resolve().then(() => (init_kilominx_kpuzzle_svg(), kilominx_kpuzzle_svg_exports))).kilominxSVG;
      })
    };
  }
});

// src/cubing/puzzles/implementations/redi-cube/redi_cube.kpuzzle.json.ts
var redi_cube_kpuzzle_json_exports = {};
__export(redi_cube_kpuzzle_json_exports, {
  rediCubeKPuzzleDefinition: () => rediCubeKPuzzleDefinition
});
var rediCubeKPuzzleDefinition;
var init_redi_cube_kpuzzle_json = __esm({
  "src/cubing/puzzles/implementations/redi-cube/redi_cube.kpuzzle.json.ts"() {
    rediCubeKPuzzleDefinition = {
      name: "redi_cube",
      orbits: {
        EDGES: { numPieces: 12, numOrientations: 2 },
        CORNERS: { numPieces: 8, numOrientations: 3 }
      },
      startStateData: {
        EDGES: {
          pieces: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
          orientation: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        },
        CORNERS: {
          pieces: [0, 1, 2, 3, 4, 5, 6, 7],
          orientation: [0, 0, 0, 0, 0, 0, 0, 0]
        }
      },
      moves: {
        F: {
          EDGES: {
            permutation: [8, 0, 2, 3, 4, 5, 6, 7, 1, 9, 10, 11],
            orientation: [0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]
          },
          CORNERS: {
            permutation: [0, 1, 2, 3, 4, 5, 6, 7],
            orientation: [1, 0, 0, 0, 0, 0, 0, 0]
          }
        },
        x: {
          EDGES: {
            permutation: [4, 8, 0, 9, 6, 10, 2, 11, 5, 7, 1, 3],
            orientation: [1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0]
          },
          CORNERS: {
            permutation: [4, 0, 3, 5, 7, 6, 2, 1],
            orientation: [2, 1, 2, 1, 1, 2, 1, 2]
          }
        },
        y: {
          EDGES: {
            permutation: [1, 2, 3, 0, 5, 6, 7, 4, 10, 8, 11, 9],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1]
          },
          CORNERS: {
            permutation: [1, 2, 3, 0, 7, 4, 5, 6],
            orientation: [0, 0, 0, 0, 0, 0, 0, 0]
          }
        }
      },
      experimentalDerivedMoves: {
        z: "[x: y]",
        UR: "[y: F]",
        U: "[y2: F]",
        UL: "[y': F]",
        D: "[x: F]",
        L: "[z2: F]",
        R: "[x2: F]",
        B: "[y2 x: F]"
      }
    };
  }
});

// src/cubing/puzzles/implementations/redi-cube/redi_cube.kpuzzle.svg.ts
var redi_cube_kpuzzle_svg_exports = {};
__export(redi_cube_kpuzzle_svg_exports, {
  rediCubeSVG: () => rediCubeSVG
});
var rediCubeSVG;
var init_redi_cube_kpuzzle_svg = __esm({
  "src/cubing/puzzles/implementations/redi-cube/redi_cube.kpuzzle.svg.ts"() {
    rediCubeSVG = `<?xml version="1.0" encoding="UTF-8"?>
<svg width="546px" height="418px" viewBox="-20 -20 546 418" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<title>redi-cube</title>
<g istroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
  <g transform="translate(1.000000, 1.000000)" fill-rule="nonzero" stroke="#000000" stroke-width="1.6">
    <g id="CORNERS-l0-o0" transform="translate(208.000000, 80.000000)" style="fill: #FFFFFF;">
      <rect id="Rectangle" x="0" y="0" width="40" height="40"></rect>
    </g>
    <g id="CORNERS-l0-o1" transform="translate(256.000000, 128.000000)" style="fill: #FF0000;">
      <rect id="Rectangle" x="0" y="0" width="40" height="40"></rect>
    </g>
    <g id="CORNERS-l0-o2" transform="translate(208.000000, 128.000000)" style="fill: #32CD32;">
      <rect id="Rectangle" x="0" y="0" width="40" height="40"></rect>
    </g>
    <g id="CORNERS-l1-o0" transform="translate(208.000000, 0.000000)" style="fill: #FFFFFF;">
      <rect id="Rectangle" x="0" y="0" width="40" height="40"></rect>
    </g>
    <g id="CORNERS-l1-o1" transform="translate(384.000000, 128.000000)" style="fill: #2266FF;">
      <rect id="Rectangle" x="0" y="0" width="40" height="40"></rect>
    </g>
    <g id="CORNERS-l1-o2" transform="translate(336.000000, 128.000000)" style="fill: #FF0000;">
      <rect id="Rectangle" x="0" y="0" width="40" height="40"></rect>
    </g>
    <g id="CORNERS-l2-o0" transform="translate(128.000000, 0.000000)" style="fill: #FFFFFF;">
      <rect id="Rectangle" x="0" y="0" width="40" height="40"></rect>
    </g>
    <g id="CORNERS-l2-o1" transform="translate(0.000000, 128.000000)" style="fill: #FFA500;">
      <rect id="Rectangle" x="0" y="0" width="40" height="40"></rect>
    </g>
    <g id="CORNERS-l2-o2" transform="translate(464.000000, 128.000000)" style="fill: #2266FF;">
      <rect id="Rectangle" x="0" y="0" width="40" height="40"></rect>
    </g>
    <g id="CORNERS-l3-o0" transform="translate(128.000000, 80.000000)" style="fill: #FFFFFF;">
      <rect id="Rectangle" x="0" y="0" width="40" height="40"></rect>
    </g>
    <g id="CORNERS-l3-o1" transform="translate(128.000000, 128.000000)" style="fill: #32CD32;">
      <rect id="Rectangle" x="0" y="0" width="40" height="40"></rect>
    </g>
    <g id="CORNERS-l3-o2" transform="translate(80.000000, 128.000000)" style="fill: #FFA500;">
      <rect id="Rectangle" x="0" y="0" width="40" height="40"></rect>
    </g>
    <g id="CORNERS-l4-o0" transform="translate(208.000000, 256.000000)" style="fill: #FFFF00;">
      <rect id="Rectangle" x="0" y="0" width="40" height="40"></rect>
    </g>
    <g id="CORNERS-l4-o1" transform="translate(208.000000, 208.000000)" style="fill: #32CD32;">
      <rect id="Rectangle" x="0" y="0" width="40" height="40"></rect>
    </g>
    <g id="CORNERS-l4-o2" transform="translate(256.000000, 208.000000)" style="fill: #FF0000;">
      <rect id="Rectangle" x="0" y="0" width="40" height="40"></rect>
    </g>
    <g id="CORNERS-l5-o0" transform="translate(128.000000, 256.000000)" style="fill: #FFFF00;">
      <rect id="Rectangle" x="0" y="0" width="40" height="40"></rect>
    </g>
    <g id="CORNERS-l5-o1" transform="translate(80.000000, 208.000000)" style="fill: #FFA500;">
      <rect id="Rectangle" x="0" y="0" width="40" height="40"></rect>
    </g>
    <g id="CORNERS-l5-o2" transform="translate(128.000000, 208.000000)" style="fill: #32CD32;">
      <rect id="Rectangle" x="0" y="0" width="40" height="40"></rect>
    </g>
    <g id="CORNERS-l6-o0" transform="translate(128.000000, 336.000000)" style="fill: #FFFF00;">
      <rect id="Rectangle" x="0" y="0" width="40" height="40"></rect>
    </g>
    <g id="CORNERS-l6-o1" transform="translate(464.000000, 208.000000)" style="fill: #2266FF;">
      <rect id="Rectangle" x="0" y="0" width="40" height="40"></rect>
    </g>
    <g id="CORNERS-l6-o2" transform="translate(0.000000, 208.000000)" style="fill: #FFA500;">
      <rect id="Rectangle" x="0" y="0" width="40" height="40"></rect>
    </g>
    <g id="CORNERS-l7-o0" transform="translate(208.000000, 336.000000)" style="fill: #FFFF00;">
      <rect id="Rectangle" x="0" y="0" width="40" height="40"></rect>
    </g>
    <g id="CORNERS-l7-o1" transform="translate(336.000000, 208.000000)" style="fill: #FF0000;">
      <rect id="Rectangle" x="0" y="0" width="40" height="40"></rect>
    </g>
    <g id="CORNERS-l7-o2" transform="translate(384.000000, 208.000000)" style="fill: #2266FF;">
      <rect id="Rectangle" x="0" y="0" width="40" height="40"></rect>
    </g>
    <g id="EDGES-l0-o0" transform="translate(168.000000, 60.000000)" style="fill: #FFFFFF;">
      <polygon id="Rectangle" points="0 20 20 -8.8817842e-16 40 20 40 60 0 60"></polygon>
    </g>
    <g id="EDGES-l0-o1" transform="translate(168.000000, 128.000000)" style="fill: #32CD32;">
      <polygon id="Rectangle" points="0 0 40 0 40 40 20 60 0 40"></polygon>
    </g>
    <g id="EDGES-l1-o0" transform="translate(188.000000, 40.000000)" style="fill: #FFFFFF;">
      <polygon id="Rectangle" points="20 0 60 0 60 40 20 40 0 20"></polygon>
    </g>
    <g id="EDGES-l1-o1" transform="translate(296.000000, 128.000000)" style="fill: #FF0000;">
      <polygon id="Rectangle" points="0 0 40 0 40 40 20 60 0 40"></polygon>
    </g>
    <g id="EDGES-l2-o0" transform="translate(168.000000, 0.000000)" style="fill: #FFFFFF;">
      <polygon id="Rectangle" points="0 0 40 0 40 40 20 60 0 40"></polygon>
    </g>
    <g id="EDGES-l2-o1" transform="translate(424.000000, 128.000000)" style="fill: #2266FF;">
      <polygon id="Rectangle" points="0 0 40 0 40 40 20 60 0 40"></polygon>
    </g>
    <g id="EDGES-l3-o0" transform="translate(128.000000, 40.000000)" style="fill: #FFFFFF;">
      <polygon id="Rectangle" points="0 0 40 0 60 20 40 40 0 40"></polygon>
    </g>
    <g id="EDGES-l3-o1" transform="translate(40.000000, 128.000000)" style="fill: #FFA500;">
      <polygon id="Rectangle" points="0 0 40 0 40 40 20 60 0 40"></polygon>
    </g>
    <g id="EDGES-l4-o0" transform="translate(168.000000, 256.000000)" style="fill: #FFFF00;">
      <polygon id="Rectangle" points="0 0 40 0 40 40 20 60 0 40"></polygon>
    </g>
    <g id="EDGES-l4-o1" transform="translate(168.000000, 188.000000)" style="fill: #32CD32;">
      <polygon id="Rectangle" points="0 20 20 0 40 20 40 60 0 60"></polygon>
    </g>
    <g id="EDGES-l5-o0" transform="translate(188.000000, 296.000000)" style="fill: #FFFF00;">
      <polygon id="Rectangle" points="20 0 60 0 60 40 20 40 0 20"></polygon>
    </g>
    <g id="EDGES-l5-o1" transform="translate(296.000000, 188.000000)" style="fill: #FF0000;">
      <polygon id="Rectangle" points="0 20 20 0 40 20 40 60 0 60"></polygon>
    </g>
    <g id="EDGES-l6-o0" transform="translate(168.000000, 316.000000)" style="fill: #FFFF00;">
      <polygon id="Rectangle" points="0 20 20 -5.32907052e-14 40 20 40 60 0 60"></polygon>
    </g>
    <g id="EDGES-l6-o1" transform="translate(424.000000, 188.000000)" style="fill: #2266FF;">
      <polygon id="Rectangle" points="0 20 20 -1.77635684e-15 40 20 40 60 0 60"></polygon>
    </g>
    <g id="EDGES-l7-o0" transform="translate(128.000000, 296.000000)" style="fill: #FFFF00;">
      <polygon id="Rectangle" points="0 0 40 0 60 20 40 40 0 40"></polygon>
    </g>
    <g id="EDGES-l7-o1" transform="translate(40.000000, 188.000000)" style="fill: #FFA500;">
      <polygon id="Rectangle" points="0 20 20 0 40 20 40 60 0 60"></polygon>
    </g>
    <g id="EDGES-l8-o0" transform="translate(188.000000, 168.000000)" style="fill: #32CD32;">
      <polygon id="Rectangle" points="20 0 60 0 60 40 20 40 2.66453526e-14 20"></polygon>
    </g>
    <g id="EDGES-l8-o1" transform="translate(256.000000, 168.000000)" style="fill: #FF0000;">
      <polygon id="Rectangle" points="0 0 40 0 60 20 40 40 0 40"></polygon>
    </g>
    <g id="EDGES-l9-o0" transform="translate(128.000000, 168.000000)" style="fill: #32CD32;">
      <polygon id="Rectangle" points="0 0 40 0 60 20 40 40 0 40"></polygon>
    </g>
    <g id="EDGES-l9-o1" transform="translate(60.000000, 168.000000)" style="fill: #FFA500;">
      <polygon id="Rectangle" points="20 0 60 0 60 40 20 40 0 20"></polygon>
    </g>
    <g id="EDGES-l10-o0" transform="translate(384.000000, 168.000000)" style="fill: #2266FF;">
      <polygon id="Rectangle" points="0 0 40 0 60 20 40 40 0 40"></polygon>
    </g>
    <g id="EDGES-l10-o1" transform="translate(316.000000, 168.000000)" style="fill: #FF0000;">
      <polygon id="Rectangle" points="20 0 60 0 60 40 20 40 5.32907052e-14 20"></polygon>
    </g>
    <g id="EDGES-l11-o0" transform="translate(444.000000, 168.000000)" style="fill: #2266FF;">
      <polygon id="Rectangle" points="20 0 60 0 60 40 20 40 -3.55271368e-15 20"></polygon>
    </g>
    <g id="EDGES-l11-o1" transform="translate(0.000000, 168.000000)" style="fill: #FFA500;">
      <polygon id="Rectangle" points="0 0 40 0 60 20 40 40 0 40"></polygon>
    </g>
  </g>
</g>
</svg>
`;
  }
});

// src/cubing/puzzles/implementations/redi-cube/index.ts
var rediCube;
var init_redi_cube = __esm({
  "src/cubing/puzzles/implementations/redi-cube/index.ts"() {
    init_kpuzzle();
    init_lazy_cached();
    rediCube = {
      id: "redi_cube",
      fullName: "Redi Cube",
      inventedBy: ["Oskar van Deventer"],
      inventionYear: 2009,
      kpuzzle: getCached(async () => new KPuzzle((await Promise.resolve().then(() => (init_redi_cube_kpuzzle_json(), redi_cube_kpuzzle_json_exports))).rediCubeKPuzzleDefinition)),
      svg: async () => {
        return (await Promise.resolve().then(() => (init_redi_cube_kpuzzle_svg(), redi_cube_kpuzzle_svg_exports))).rediCubeSVG;
      }
    };
  }
});

// src/cubing/puzzles/index.ts
var puzzles;
var init_puzzles = __esm({
  "src/cubing/puzzles/index.ts"() {
    init_kpuzzle();
    init_customPGPuzzleLoader();
    init_events();
    init_appearance();
    init_cube_stickerings();
    init_async_pg3d();
    init_x2x2();
    init_x3x3();
    init_clock();
    init_fto();
    init_megaminx();
    init_pyraminx();
    init_square1();
    init_kilominx();
    init_redi_cube();
    puzzles = {
      "3x3x3": cube3x3x3,
      "2x2x2": cube2x2x2,
      "4x4x4": new CubePGPuzzleLoader({ id: "4x4x4", fullName: "4\xD74\xD74 Cube" }),
      "5x5x5": new CubePGPuzzleLoader({ id: "5x5x5", fullName: "5\xD75\xD75 Cube" }),
      "6x6x6": new CubePGPuzzleLoader({ id: "6x6x6", fullName: "6\xD76\xD76 Cube" }),
      "7x7x7": new CubePGPuzzleLoader({ id: "7x7x7", fullName: "7\xD77\xD77 Cube" }),
      "40x40x40": new CubePGPuzzleLoader({
        id: "40x40x40",
        fullName: "40\xD740\xD740 Cube"
      }),
      clock,
      "megaminx": megaminx,
      pyraminx,
      "skewb": new PGPuzzleLoader({
        id: "skewb",
        fullName: "Skewb",
        inventedBy: ["Tony Durham"]
      }),
      square1,
      "fto": fto,
      "gigaminx": new PGPuzzleLoader({
        id: "gigaminx",
        fullName: "Gigaminx",
        inventedBy: ["Tyler Fox"],
        inventionYear: 2006
      }),
      "master_tetraminx": new PGPuzzleLoader({
        pgID: "master tetraminx",
        id: "master_tetraminx",
        fullName: "Master Tetraminx",
        inventedBy: ["Katsuhiko Okamoto"],
        inventionYear: 2002
      }),
      kilominx,
      "redi_cube": rediCube
    };
  }
});

// node_modules/three/build/three.module.js
var three_module_exports = {};
__export(three_module_exports, {
  ACESFilmicToneMapping: () => ACESFilmicToneMapping,
  AddEquation: () => AddEquation,
  AddOperation: () => AddOperation,
  AdditiveAnimationBlendMode: () => AdditiveAnimationBlendMode,
  AdditiveBlending: () => AdditiveBlending,
  AlphaFormat: () => AlphaFormat,
  AlwaysDepth: () => AlwaysDepth,
  AlwaysStencilFunc: () => AlwaysStencilFunc,
  AmbientLight: () => AmbientLight,
  AmbientLightProbe: () => AmbientLightProbe,
  AnimationClip: () => AnimationClip,
  AnimationLoader: () => AnimationLoader,
  AnimationMixer: () => AnimationMixer,
  AnimationObjectGroup: () => AnimationObjectGroup,
  AnimationUtils: () => AnimationUtils,
  ArcCurve: () => ArcCurve,
  ArrayCamera: () => ArrayCamera,
  ArrowHelper: () => ArrowHelper,
  Audio: () => Audio,
  AudioAnalyser: () => AudioAnalyser,
  AudioContext: () => AudioContext,
  AudioListener: () => AudioListener,
  AudioLoader: () => AudioLoader,
  AxesHelper: () => AxesHelper,
  AxisHelper: () => AxisHelper,
  BackSide: () => BackSide,
  BasicDepthPacking: () => BasicDepthPacking,
  BasicShadowMap: () => BasicShadowMap,
  BinaryTextureLoader: () => BinaryTextureLoader,
  Bone: () => Bone,
  BooleanKeyframeTrack: () => BooleanKeyframeTrack,
  BoundingBoxHelper: () => BoundingBoxHelper,
  Box2: () => Box2,
  Box3: () => Box3,
  Box3Helper: () => Box3Helper,
  BoxBufferGeometry: () => BoxGeometry,
  BoxGeometry: () => BoxGeometry,
  BoxHelper: () => BoxHelper,
  BufferAttribute: () => BufferAttribute,
  BufferGeometry: () => BufferGeometry,
  BufferGeometryLoader: () => BufferGeometryLoader,
  ByteType: () => ByteType,
  Cache: () => Cache,
  Camera: () => Camera,
  CameraHelper: () => CameraHelper,
  CanvasRenderer: () => CanvasRenderer,
  CanvasTexture: () => CanvasTexture,
  CapsuleBufferGeometry: () => CapsuleGeometry,
  CapsuleGeometry: () => CapsuleGeometry,
  CatmullRomCurve3: () => CatmullRomCurve3,
  CineonToneMapping: () => CineonToneMapping,
  CircleBufferGeometry: () => CircleGeometry,
  CircleGeometry: () => CircleGeometry,
  ClampToEdgeWrapping: () => ClampToEdgeWrapping,
  Clock: () => Clock,
  Color: () => Color,
  ColorKeyframeTrack: () => ColorKeyframeTrack,
  ColorManagement: () => ColorManagement,
  CompressedTexture: () => CompressedTexture,
  CompressedTextureLoader: () => CompressedTextureLoader,
  ConeBufferGeometry: () => ConeGeometry,
  ConeGeometry: () => ConeGeometry,
  CubeCamera: () => CubeCamera,
  CubeReflectionMapping: () => CubeReflectionMapping,
  CubeRefractionMapping: () => CubeRefractionMapping,
  CubeTexture: () => CubeTexture,
  CubeTextureLoader: () => CubeTextureLoader,
  CubeUVReflectionMapping: () => CubeUVReflectionMapping,
  CubicBezierCurve: () => CubicBezierCurve,
  CubicBezierCurve3: () => CubicBezierCurve3,
  CubicInterpolant: () => CubicInterpolant,
  CullFaceBack: () => CullFaceBack,
  CullFaceFront: () => CullFaceFront,
  CullFaceFrontBack: () => CullFaceFrontBack,
  CullFaceNone: () => CullFaceNone,
  Curve: () => Curve,
  CurvePath: () => CurvePath,
  CustomBlending: () => CustomBlending,
  CustomToneMapping: () => CustomToneMapping,
  CylinderBufferGeometry: () => CylinderGeometry,
  CylinderGeometry: () => CylinderGeometry,
  Cylindrical: () => Cylindrical,
  Data3DTexture: () => Data3DTexture,
  DataArrayTexture: () => DataArrayTexture,
  DataTexture: () => DataTexture,
  DataTexture2DArray: () => DataTexture2DArray,
  DataTexture3D: () => DataTexture3D,
  DataTextureLoader: () => DataTextureLoader,
  DataUtils: () => DataUtils,
  DecrementStencilOp: () => DecrementStencilOp,
  DecrementWrapStencilOp: () => DecrementWrapStencilOp,
  DefaultLoadingManager: () => DefaultLoadingManager,
  DepthFormat: () => DepthFormat,
  DepthStencilFormat: () => DepthStencilFormat,
  DepthTexture: () => DepthTexture,
  DirectionalLight: () => DirectionalLight,
  DirectionalLightHelper: () => DirectionalLightHelper,
  DiscreteInterpolant: () => DiscreteInterpolant,
  DodecahedronBufferGeometry: () => DodecahedronGeometry,
  DodecahedronGeometry: () => DodecahedronGeometry,
  DoubleSide: () => DoubleSide,
  DstAlphaFactor: () => DstAlphaFactor,
  DstColorFactor: () => DstColorFactor,
  DynamicBufferAttribute: () => DynamicBufferAttribute,
  DynamicCopyUsage: () => DynamicCopyUsage,
  DynamicDrawUsage: () => DynamicDrawUsage,
  DynamicReadUsage: () => DynamicReadUsage,
  EdgesGeometry: () => EdgesGeometry,
  EdgesHelper: () => EdgesHelper,
  EllipseCurve: () => EllipseCurve,
  EqualDepth: () => EqualDepth,
  EqualStencilFunc: () => EqualStencilFunc,
  EquirectangularReflectionMapping: () => EquirectangularReflectionMapping,
  EquirectangularRefractionMapping: () => EquirectangularRefractionMapping,
  Euler: () => Euler,
  EventDispatcher: () => EventDispatcher,
  ExtrudeBufferGeometry: () => ExtrudeGeometry,
  ExtrudeGeometry: () => ExtrudeGeometry,
  FaceColors: () => FaceColors,
  FileLoader: () => FileLoader,
  FlatShading: () => FlatShading,
  Float16BufferAttribute: () => Float16BufferAttribute,
  Float32Attribute: () => Float32Attribute,
  Float32BufferAttribute: () => Float32BufferAttribute,
  Float64Attribute: () => Float64Attribute,
  Float64BufferAttribute: () => Float64BufferAttribute,
  FloatType: () => FloatType,
  Fog: () => Fog,
  FogExp2: () => FogExp2,
  Font: () => Font,
  FontLoader: () => FontLoader,
  FramebufferTexture: () => FramebufferTexture,
  FrontSide: () => FrontSide,
  Frustum: () => Frustum,
  GLBufferAttribute: () => GLBufferAttribute,
  GLSL1: () => GLSL1,
  GLSL3: () => GLSL3,
  GreaterDepth: () => GreaterDepth,
  GreaterEqualDepth: () => GreaterEqualDepth,
  GreaterEqualStencilFunc: () => GreaterEqualStencilFunc,
  GreaterStencilFunc: () => GreaterStencilFunc,
  GridHelper: () => GridHelper,
  Group: () => Group,
  HalfFloatType: () => HalfFloatType,
  HemisphereLight: () => HemisphereLight,
  HemisphereLightHelper: () => HemisphereLightHelper,
  HemisphereLightProbe: () => HemisphereLightProbe,
  IcosahedronBufferGeometry: () => IcosahedronGeometry,
  IcosahedronGeometry: () => IcosahedronGeometry,
  ImageBitmapLoader: () => ImageBitmapLoader,
  ImageLoader: () => ImageLoader,
  ImageUtils: () => ImageUtils,
  ImmediateRenderObject: () => ImmediateRenderObject,
  IncrementStencilOp: () => IncrementStencilOp,
  IncrementWrapStencilOp: () => IncrementWrapStencilOp,
  InstancedBufferAttribute: () => InstancedBufferAttribute,
  InstancedBufferGeometry: () => InstancedBufferGeometry,
  InstancedInterleavedBuffer: () => InstancedInterleavedBuffer,
  InstancedMesh: () => InstancedMesh,
  Int16Attribute: () => Int16Attribute,
  Int16BufferAttribute: () => Int16BufferAttribute,
  Int32Attribute: () => Int32Attribute,
  Int32BufferAttribute: () => Int32BufferAttribute,
  Int8Attribute: () => Int8Attribute,
  Int8BufferAttribute: () => Int8BufferAttribute,
  IntType: () => IntType,
  InterleavedBuffer: () => InterleavedBuffer,
  InterleavedBufferAttribute: () => InterleavedBufferAttribute,
  Interpolant: () => Interpolant,
  InterpolateDiscrete: () => InterpolateDiscrete,
  InterpolateLinear: () => InterpolateLinear,
  InterpolateSmooth: () => InterpolateSmooth,
  InvertStencilOp: () => InvertStencilOp,
  JSONLoader: () => JSONLoader,
  KeepStencilOp: () => KeepStencilOp,
  KeyframeTrack: () => KeyframeTrack,
  LOD: () => LOD,
  LatheBufferGeometry: () => LatheGeometry,
  LatheGeometry: () => LatheGeometry,
  Layers: () => Layers,
  LensFlare: () => LensFlare,
  LessDepth: () => LessDepth,
  LessEqualDepth: () => LessEqualDepth,
  LessEqualStencilFunc: () => LessEqualStencilFunc,
  LessStencilFunc: () => LessStencilFunc,
  Light: () => Light,
  LightProbe: () => LightProbe,
  Line: () => Line,
  Line3: () => Line3,
  LineBasicMaterial: () => LineBasicMaterial,
  LineCurve: () => LineCurve,
  LineCurve3: () => LineCurve3,
  LineDashedMaterial: () => LineDashedMaterial,
  LineLoop: () => LineLoop,
  LinePieces: () => LinePieces,
  LineSegments: () => LineSegments,
  LineStrip: () => LineStrip,
  LinearEncoding: () => LinearEncoding,
  LinearFilter: () => LinearFilter,
  LinearInterpolant: () => LinearInterpolant,
  LinearMipMapLinearFilter: () => LinearMipMapLinearFilter,
  LinearMipMapNearestFilter: () => LinearMipMapNearestFilter,
  LinearMipmapLinearFilter: () => LinearMipmapLinearFilter,
  LinearMipmapNearestFilter: () => LinearMipmapNearestFilter,
  LinearSRGBColorSpace: () => LinearSRGBColorSpace,
  LinearToneMapping: () => LinearToneMapping,
  Loader: () => Loader,
  LoaderUtils: () => LoaderUtils,
  LoadingManager: () => LoadingManager,
  LoopOnce: () => LoopOnce,
  LoopPingPong: () => LoopPingPong,
  LoopRepeat: () => LoopRepeat,
  LuminanceAlphaFormat: () => LuminanceAlphaFormat,
  LuminanceFormat: () => LuminanceFormat,
  MOUSE: () => MOUSE,
  Material: () => Material,
  MaterialLoader: () => MaterialLoader,
  Math: () => MathUtils,
  MathUtils: () => MathUtils,
  Matrix3: () => Matrix3,
  Matrix4: () => Matrix4,
  MaxEquation: () => MaxEquation,
  Mesh: () => Mesh,
  MeshBasicMaterial: () => MeshBasicMaterial,
  MeshDepthMaterial: () => MeshDepthMaterial,
  MeshDistanceMaterial: () => MeshDistanceMaterial,
  MeshFaceMaterial: () => MeshFaceMaterial,
  MeshLambertMaterial: () => MeshLambertMaterial,
  MeshMatcapMaterial: () => MeshMatcapMaterial,
  MeshNormalMaterial: () => MeshNormalMaterial,
  MeshPhongMaterial: () => MeshPhongMaterial,
  MeshPhysicalMaterial: () => MeshPhysicalMaterial,
  MeshStandardMaterial: () => MeshStandardMaterial,
  MeshToonMaterial: () => MeshToonMaterial,
  MinEquation: () => MinEquation,
  MirroredRepeatWrapping: () => MirroredRepeatWrapping,
  MixOperation: () => MixOperation,
  MultiMaterial: () => MultiMaterial,
  MultiplyBlending: () => MultiplyBlending,
  MultiplyOperation: () => MultiplyOperation,
  NearestFilter: () => NearestFilter,
  NearestMipMapLinearFilter: () => NearestMipMapLinearFilter,
  NearestMipMapNearestFilter: () => NearestMipMapNearestFilter,
  NearestMipmapLinearFilter: () => NearestMipmapLinearFilter,
  NearestMipmapNearestFilter: () => NearestMipmapNearestFilter,
  NeverDepth: () => NeverDepth,
  NeverStencilFunc: () => NeverStencilFunc,
  NoBlending: () => NoBlending,
  NoColorSpace: () => NoColorSpace,
  NoColors: () => NoColors,
  NoToneMapping: () => NoToneMapping,
  NormalAnimationBlendMode: () => NormalAnimationBlendMode,
  NormalBlending: () => NormalBlending,
  NotEqualDepth: () => NotEqualDepth,
  NotEqualStencilFunc: () => NotEqualStencilFunc,
  NumberKeyframeTrack: () => NumberKeyframeTrack,
  Object3D: () => Object3D,
  ObjectLoader: () => ObjectLoader,
  ObjectSpaceNormalMap: () => ObjectSpaceNormalMap,
  OctahedronBufferGeometry: () => OctahedronGeometry,
  OctahedronGeometry: () => OctahedronGeometry,
  OneFactor: () => OneFactor,
  OneMinusDstAlphaFactor: () => OneMinusDstAlphaFactor,
  OneMinusDstColorFactor: () => OneMinusDstColorFactor,
  OneMinusSrcAlphaFactor: () => OneMinusSrcAlphaFactor,
  OneMinusSrcColorFactor: () => OneMinusSrcColorFactor,
  OrthographicCamera: () => OrthographicCamera,
  PCFShadowMap: () => PCFShadowMap,
  PCFSoftShadowMap: () => PCFSoftShadowMap,
  PMREMGenerator: () => PMREMGenerator,
  ParametricGeometry: () => ParametricGeometry,
  Particle: () => Particle,
  ParticleBasicMaterial: () => ParticleBasicMaterial,
  ParticleSystem: () => ParticleSystem,
  ParticleSystemMaterial: () => ParticleSystemMaterial,
  Path: () => Path,
  PerspectiveCamera: () => PerspectiveCamera,
  Plane: () => Plane,
  PlaneBufferGeometry: () => PlaneGeometry,
  PlaneGeometry: () => PlaneGeometry,
  PlaneHelper: () => PlaneHelper,
  PointCloud: () => PointCloud,
  PointCloudMaterial: () => PointCloudMaterial,
  PointLight: () => PointLight,
  PointLightHelper: () => PointLightHelper,
  Points: () => Points,
  PointsMaterial: () => PointsMaterial,
  PolarGridHelper: () => PolarGridHelper,
  PolyhedronBufferGeometry: () => PolyhedronGeometry,
  PolyhedronGeometry: () => PolyhedronGeometry,
  PositionalAudio: () => PositionalAudio,
  PropertyBinding: () => PropertyBinding,
  PropertyMixer: () => PropertyMixer,
  QuadraticBezierCurve: () => QuadraticBezierCurve,
  QuadraticBezierCurve3: () => QuadraticBezierCurve3,
  Quaternion: () => Quaternion,
  QuaternionKeyframeTrack: () => QuaternionKeyframeTrack,
  QuaternionLinearInterpolant: () => QuaternionLinearInterpolant,
  REVISION: () => REVISION,
  RGBADepthPacking: () => RGBADepthPacking,
  RGBAFormat: () => RGBAFormat,
  RGBAIntegerFormat: () => RGBAIntegerFormat,
  RGBA_ASTC_10x10_Format: () => RGBA_ASTC_10x10_Format,
  RGBA_ASTC_10x5_Format: () => RGBA_ASTC_10x5_Format,
  RGBA_ASTC_10x6_Format: () => RGBA_ASTC_10x6_Format,
  RGBA_ASTC_10x8_Format: () => RGBA_ASTC_10x8_Format,
  RGBA_ASTC_12x10_Format: () => RGBA_ASTC_12x10_Format,
  RGBA_ASTC_12x12_Format: () => RGBA_ASTC_12x12_Format,
  RGBA_ASTC_4x4_Format: () => RGBA_ASTC_4x4_Format,
  RGBA_ASTC_5x4_Format: () => RGBA_ASTC_5x4_Format,
  RGBA_ASTC_5x5_Format: () => RGBA_ASTC_5x5_Format,
  RGBA_ASTC_6x5_Format: () => RGBA_ASTC_6x5_Format,
  RGBA_ASTC_6x6_Format: () => RGBA_ASTC_6x6_Format,
  RGBA_ASTC_8x5_Format: () => RGBA_ASTC_8x5_Format,
  RGBA_ASTC_8x6_Format: () => RGBA_ASTC_8x6_Format,
  RGBA_ASTC_8x8_Format: () => RGBA_ASTC_8x8_Format,
  RGBA_BPTC_Format: () => RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format: () => RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_2BPPV1_Format: () => RGBA_PVRTC_2BPPV1_Format,
  RGBA_PVRTC_4BPPV1_Format: () => RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT1_Format: () => RGBA_S3TC_DXT1_Format,
  RGBA_S3TC_DXT3_Format: () => RGBA_S3TC_DXT3_Format,
  RGBA_S3TC_DXT5_Format: () => RGBA_S3TC_DXT5_Format,
  RGBFormat: () => RGBFormat,
  RGB_ETC1_Format: () => RGB_ETC1_Format,
  RGB_ETC2_Format: () => RGB_ETC2_Format,
  RGB_PVRTC_2BPPV1_Format: () => RGB_PVRTC_2BPPV1_Format,
  RGB_PVRTC_4BPPV1_Format: () => RGB_PVRTC_4BPPV1_Format,
  RGB_S3TC_DXT1_Format: () => RGB_S3TC_DXT1_Format,
  RGFormat: () => RGFormat,
  RGIntegerFormat: () => RGIntegerFormat,
  RawShaderMaterial: () => RawShaderMaterial,
  Ray: () => Ray,
  Raycaster: () => Raycaster,
  RectAreaLight: () => RectAreaLight,
  RedFormat: () => RedFormat,
  RedIntegerFormat: () => RedIntegerFormat,
  ReinhardToneMapping: () => ReinhardToneMapping,
  RepeatWrapping: () => RepeatWrapping,
  ReplaceStencilOp: () => ReplaceStencilOp,
  ReverseSubtractEquation: () => ReverseSubtractEquation,
  RingBufferGeometry: () => RingGeometry,
  RingGeometry: () => RingGeometry,
  SRGBColorSpace: () => SRGBColorSpace,
  Scene: () => Scene,
  SceneUtils: () => SceneUtils,
  ShaderChunk: () => ShaderChunk,
  ShaderLib: () => ShaderLib,
  ShaderMaterial: () => ShaderMaterial,
  ShadowMaterial: () => ShadowMaterial,
  Shape: () => Shape,
  ShapeBufferGeometry: () => ShapeGeometry,
  ShapeGeometry: () => ShapeGeometry,
  ShapePath: () => ShapePath,
  ShapeUtils: () => ShapeUtils,
  ShortType: () => ShortType,
  Skeleton: () => Skeleton,
  SkeletonHelper: () => SkeletonHelper,
  SkinnedMesh: () => SkinnedMesh,
  SmoothShading: () => SmoothShading,
  Source: () => Source,
  Sphere: () => Sphere,
  SphereBufferGeometry: () => SphereGeometry,
  SphereGeometry: () => SphereGeometry,
  Spherical: () => Spherical,
  SphericalHarmonics3: () => SphericalHarmonics3,
  SplineCurve: () => SplineCurve,
  SpotLight: () => SpotLight,
  SpotLightHelper: () => SpotLightHelper,
  Sprite: () => Sprite,
  SpriteMaterial: () => SpriteMaterial,
  SrcAlphaFactor: () => SrcAlphaFactor,
  SrcAlphaSaturateFactor: () => SrcAlphaSaturateFactor,
  SrcColorFactor: () => SrcColorFactor,
  StaticCopyUsage: () => StaticCopyUsage,
  StaticDrawUsage: () => StaticDrawUsage,
  StaticReadUsage: () => StaticReadUsage,
  StereoCamera: () => StereoCamera,
  StreamCopyUsage: () => StreamCopyUsage,
  StreamDrawUsage: () => StreamDrawUsage,
  StreamReadUsage: () => StreamReadUsage,
  StringKeyframeTrack: () => StringKeyframeTrack,
  SubtractEquation: () => SubtractEquation,
  SubtractiveBlending: () => SubtractiveBlending,
  TOUCH: () => TOUCH,
  TangentSpaceNormalMap: () => TangentSpaceNormalMap,
  TetrahedronBufferGeometry: () => TetrahedronGeometry,
  TetrahedronGeometry: () => TetrahedronGeometry,
  TextGeometry: () => TextGeometry,
  Texture: () => Texture,
  TextureLoader: () => TextureLoader,
  TorusBufferGeometry: () => TorusGeometry,
  TorusGeometry: () => TorusGeometry,
  TorusKnotBufferGeometry: () => TorusKnotGeometry,
  TorusKnotGeometry: () => TorusKnotGeometry,
  Triangle: () => Triangle,
  TriangleFanDrawMode: () => TriangleFanDrawMode,
  TriangleStripDrawMode: () => TriangleStripDrawMode,
  TrianglesDrawMode: () => TrianglesDrawMode,
  TubeBufferGeometry: () => TubeGeometry,
  TubeGeometry: () => TubeGeometry,
  UVMapping: () => UVMapping,
  Uint16Attribute: () => Uint16Attribute,
  Uint16BufferAttribute: () => Uint16BufferAttribute,
  Uint32Attribute: () => Uint32Attribute,
  Uint32BufferAttribute: () => Uint32BufferAttribute,
  Uint8Attribute: () => Uint8Attribute,
  Uint8BufferAttribute: () => Uint8BufferAttribute,
  Uint8ClampedAttribute: () => Uint8ClampedAttribute,
  Uint8ClampedBufferAttribute: () => Uint8ClampedBufferAttribute,
  Uniform: () => Uniform,
  UniformsLib: () => UniformsLib,
  UniformsUtils: () => UniformsUtils,
  UnsignedByteType: () => UnsignedByteType,
  UnsignedInt248Type: () => UnsignedInt248Type,
  UnsignedIntType: () => UnsignedIntType,
  UnsignedShort4444Type: () => UnsignedShort4444Type,
  UnsignedShort5551Type: () => UnsignedShort5551Type,
  UnsignedShortType: () => UnsignedShortType,
  VSMShadowMap: () => VSMShadowMap,
  Vector2: () => Vector2,
  Vector3: () => Vector3,
  Vector4: () => Vector4,
  VectorKeyframeTrack: () => VectorKeyframeTrack,
  Vertex: () => Vertex,
  VertexColors: () => VertexColors,
  VideoTexture: () => VideoTexture,
  WebGL1Renderer: () => WebGL1Renderer,
  WebGL3DRenderTarget: () => WebGL3DRenderTarget,
  WebGLArrayRenderTarget: () => WebGLArrayRenderTarget,
  WebGLCubeRenderTarget: () => WebGLCubeRenderTarget,
  WebGLMultipleRenderTargets: () => WebGLMultipleRenderTargets,
  WebGLMultisampleRenderTarget: () => WebGLMultisampleRenderTarget,
  WebGLRenderTarget: () => WebGLRenderTarget,
  WebGLRenderTargetCube: () => WebGLRenderTargetCube,
  WebGLRenderer: () => WebGLRenderer,
  WebGLUtils: () => WebGLUtils,
  WireframeGeometry: () => WireframeGeometry,
  WireframeHelper: () => WireframeHelper,
  WrapAroundEnding: () => WrapAroundEnding,
  XHRLoader: () => XHRLoader,
  ZeroCurvatureEnding: () => ZeroCurvatureEnding,
  ZeroFactor: () => ZeroFactor,
  ZeroSlopeEnding: () => ZeroSlopeEnding,
  ZeroStencilOp: () => ZeroStencilOp,
  _SRGBAFormat: () => _SRGBAFormat,
  sRGBEncoding: () => sRGBEncoding
});
function generateUUID() {
  const d0 = Math.random() * 4294967295 | 0;
  const d1 = Math.random() * 4294967295 | 0;
  const d2 = Math.random() * 4294967295 | 0;
  const d3 = Math.random() * 4294967295 | 0;
  const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
  return uuid.toLowerCase();
}
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function euclideanModulo(n, m) {
  return (n % m + m) % m;
}
function mapLinear(x, a1, a2, b1, b2) {
  return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
}
function inverseLerp(x, y2, value) {
  if (x !== y2) {
    return (value - x) / (y2 - x);
  } else {
    return 0;
  }
}
function lerp(x, y2, t2) {
  return (1 - t2) * x + t2 * y2;
}
function damp(x, y2, lambda, dt) {
  return lerp(x, y2, 1 - Math.exp(-lambda * dt));
}
function pingpong(x, length = 1) {
  return length - Math.abs(euclideanModulo(x, length * 2) - length);
}
function smoothstep(x, min, max) {
  if (x <= min)
    return 0;
  if (x >= max)
    return 1;
  x = (x - min) / (max - min);
  return x * x * (3 - 2 * x);
}
function smootherstep(x, min, max) {
  if (x <= min)
    return 0;
  if (x >= max)
    return 1;
  x = (x - min) / (max - min);
  return x * x * x * (x * (x * 6 - 15) + 10);
}
function randInt(low, high) {
  return low + Math.floor(Math.random() * (high - low + 1));
}
function randFloat(low, high) {
  return low + Math.random() * (high - low);
}
function randFloatSpread(range) {
  return range * (0.5 - Math.random());
}
function seededRandom(s) {
  if (s !== void 0)
    _seed = s;
  let t2 = _seed += 1831565813;
  t2 = Math.imul(t2 ^ t2 >>> 15, t2 | 1);
  t2 ^= t2 + Math.imul(t2 ^ t2 >>> 7, t2 | 61);
  return ((t2 ^ t2 >>> 14) >>> 0) / 4294967296;
}
function degToRad(degrees) {
  return degrees * DEG2RAD;
}
function radToDeg(radians) {
  return radians * RAD2DEG;
}
function isPowerOfTwo(value) {
  return (value & value - 1) === 0 && value !== 0;
}
function ceilPowerOfTwo(value) {
  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
}
function floorPowerOfTwo(value) {
  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}
function setQuaternionFromProperEuler(q, a, b2, c, order) {
  const cos = Math.cos;
  const sin = Math.sin;
  const c2 = cos(b2 / 2);
  const s2 = sin(b2 / 2);
  const c13 = cos((a + c) / 2);
  const s13 = sin((a + c) / 2);
  const c1_3 = cos((a - c) / 2);
  const s1_3 = sin((a - c) / 2);
  const c3_1 = cos((c - a) / 2);
  const s3_1 = sin((c - a) / 2);
  switch (order) {
    case "XYX":
      q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
      break;
    case "YZY":
      q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
      break;
    case "ZXZ":
      q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
      break;
    case "XZX":
      q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
      break;
    case "YXY":
      q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
      break;
    case "ZYZ":
      q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
  }
}
function denormalize$1(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;
    case Uint16Array:
      return value / 65535;
    case Uint8Array:
      return value / 255;
    case Int16Array:
      return Math.max(value / 32767, -1);
    case Int8Array:
      return Math.max(value / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function normalize(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;
    case Uint16Array:
      return Math.round(value * 65535);
    case Uint8Array:
      return Math.round(value * 255);
    case Int16Array:
      return Math.round(value * 32767);
    case Int8Array:
      return Math.round(value * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
function arrayNeedsUint32(array) {
  for (let i2 = array.length - 1; i2 >= 0; --i2) {
    if (array[i2] > 65535)
      return true;
  }
  return false;
}
function getTypedArray(type, buffer) {
  return new TYPED_ARRAYS[type](buffer);
}
function createElementNS(name) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", name);
}
function SRGBToLinear(c) {
  return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c) {
  return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
}
function hue2rgb(p, q, t2) {
  if (t2 < 0)
    t2 += 1;
  if (t2 > 1)
    t2 -= 1;
  if (t2 < 1 / 6)
    return p + (q - p) * 6 * t2;
  if (t2 < 1 / 2)
    return q;
  if (t2 < 2 / 3)
    return p + (q - p) * 6 * (2 / 3 - t2);
  return p;
}
function toComponents(source, target) {
  target.r = source.r;
  target.g = source.g;
  target.b = source.b;
  return target;
}
function serializeImage(image) {
  if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
    return ImageUtils.getDataURL(image);
  } else {
    if (image.data) {
      return {
        data: Array.prototype.slice.call(image.data),
        width: image.width,
        height: image.height,
        type: image.data.constructor.name
      };
    } else {
      console.warn("THREE.Texture: Unable to serialize Texture.");
      return {};
    }
  }
}
function satForAxes(axes, v0, v1, v2, extents) {
  for (let i2 = 0, j = axes.length - 3; i2 <= j; i2 += 3) {
    _testAxis.fromArray(axes, i2);
    const r3 = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
    const p0 = v0.dot(_testAxis);
    const p1 = v1.dot(_testAxis);
    const p2 = v2.dot(_testAxis);
    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r3) {
      return false;
    }
  }
  return true;
}
function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
  let intersect;
  if (material.side === BackSide) {
    intersect = ray.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
  }
  if (intersect === null)
    return null;
  _intersectionPointWorld.copy(point);
  _intersectionPointWorld.applyMatrix4(object.matrixWorld);
  const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance < raycaster.near || distance > raycaster.far)
    return null;
  return {
    distance,
    point: _intersectionPointWorld.clone(),
    object
  };
}
function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b2, c) {
  _vA$1.fromBufferAttribute(position, a);
  _vB$1.fromBufferAttribute(position, b2);
  _vC$1.fromBufferAttribute(position, c);
  const morphInfluences = object.morphTargetInfluences;
  if (morphPosition && morphInfluences) {
    _morphA.set(0, 0, 0);
    _morphB.set(0, 0, 0);
    _morphC.set(0, 0, 0);
    for (let i2 = 0, il = morphPosition.length; i2 < il; i2++) {
      const influence = morphInfluences[i2];
      const morphAttribute = morphPosition[i2];
      if (influence === 0)
        continue;
      _tempA.fromBufferAttribute(morphAttribute, a);
      _tempB.fromBufferAttribute(morphAttribute, b2);
      _tempC.fromBufferAttribute(morphAttribute, c);
      if (morphTargetsRelative) {
        _morphA.addScaledVector(_tempA, influence);
        _morphB.addScaledVector(_tempB, influence);
        _morphC.addScaledVector(_tempC, influence);
      } else {
        _morphA.addScaledVector(_tempA.sub(_vA$1), influence);
        _morphB.addScaledVector(_tempB.sub(_vB$1), influence);
        _morphC.addScaledVector(_tempC.sub(_vC$1), influence);
      }
    }
    _vA$1.add(_morphA);
    _vB$1.add(_morphB);
    _vC$1.add(_morphC);
  }
  if (object.isSkinnedMesh) {
    object.boneTransform(a, _vA$1);
    object.boneTransform(b2, _vB$1);
    object.boneTransform(c, _vC$1);
  }
  const intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
  if (intersection) {
    if (uv) {
      _uvA$1.fromBufferAttribute(uv, a);
      _uvB$1.fromBufferAttribute(uv, b2);
      _uvC$1.fromBufferAttribute(uv, c);
      intersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
    }
    if (uv2) {
      _uvA$1.fromBufferAttribute(uv2, a);
      _uvB$1.fromBufferAttribute(uv2, b2);
      _uvC$1.fromBufferAttribute(uv2, c);
      intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
    }
    const face2 = {
      a,
      b: b2,
      c,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA$1, _vB$1, _vC$1, face2.normal);
    intersection.face = face2;
  }
  return intersection;
}
function cloneUniforms(src) {
  const dst = {};
  for (const u in src) {
    dst[u] = {};
    for (const p in src[u]) {
      const property = src[u][p];
      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
        dst[u][p] = property.clone();
      } else if (Array.isArray(property)) {
        dst[u][p] = property.slice();
      } else {
        dst[u][p] = property;
      }
    }
  }
  return dst;
}
function mergeUniforms(uniforms) {
  const merged = {};
  for (let u = 0; u < uniforms.length; u++) {
    const tmp2 = cloneUniforms(uniforms[u]);
    for (const p in tmp2) {
      merged[p] = tmp2[p];
    }
  }
  return merged;
}
function WebGLAnimation() {
  let context = null;
  let isAnimating = false;
  let animationLoop = null;
  let requestId = null;
  function onAnimationFrame(time, frame) {
    animationLoop(time, frame);
    requestId = context.requestAnimationFrame(onAnimationFrame);
  }
  return {
    start: function() {
      if (isAnimating === true)
        return;
      if (animationLoop === null)
        return;
      requestId = context.requestAnimationFrame(onAnimationFrame);
      isAnimating = true;
    },
    stop: function() {
      context.cancelAnimationFrame(requestId);
      isAnimating = false;
    },
    setAnimationLoop: function(callback) {
      animationLoop = callback;
    },
    setContext: function(value) {
      context = value;
    }
  };
}
function WebGLAttributes(gl, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  const buffers = /* @__PURE__ */ new WeakMap();
  function createBuffer(attribute, bufferType) {
    const array = attribute.array;
    const usage = attribute.usage;
    const buffer = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer);
    gl.bufferData(bufferType, array, usage);
    attribute.onUploadCallback();
    let type;
    if (array instanceof Float32Array) {
      type = 5126;
    } else if (array instanceof Uint16Array) {
      if (attribute.isFloat16BufferAttribute) {
        if (isWebGL2) {
          type = 5131;
        } else {
          throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
        }
      } else {
        type = 5123;
      }
    } else if (array instanceof Int16Array) {
      type = 5122;
    } else if (array instanceof Uint32Array) {
      type = 5125;
    } else if (array instanceof Int32Array) {
      type = 5124;
    } else if (array instanceof Int8Array) {
      type = 5120;
    } else if (array instanceof Uint8Array) {
      type = 5121;
    } else if (array instanceof Uint8ClampedArray) {
      type = 5121;
    } else {
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + array);
    }
    return {
      buffer,
      type,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute.version
    };
  }
  function updateBuffer(buffer, attribute, bufferType) {
    const array = attribute.array;
    const updateRange = attribute.updateRange;
    gl.bindBuffer(bufferType, buffer);
    if (updateRange.count === -1) {
      gl.bufferSubData(bufferType, 0, array);
    } else {
      if (isWebGL2) {
        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
      } else {
        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
      }
      updateRange.count = -1;
    }
  }
  function get(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    return buffers.get(attribute);
  }
  function remove(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data) {
      gl.deleteBuffer(data.buffer);
      buffers.delete(attribute);
    }
  }
  function update(attribute, bufferType) {
    if (attribute.isGLBufferAttribute) {
      const cached = buffers.get(attribute);
      if (!cached || cached.version < attribute.version) {
        buffers.set(attribute, {
          buffer: attribute.buffer,
          type: attribute.type,
          bytesPerElement: attribute.elementSize,
          version: attribute.version
        });
      }
      return;
    }
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data === void 0) {
      buffers.set(attribute, createBuffer(attribute, bufferType));
    } else if (data.version < attribute.version) {
      updateBuffer(data.buffer, attribute, bufferType);
      data.version = attribute.version;
    }
  }
  return {
    get,
    remove,
    update
  };
}
function WebGLBackground(renderer, cubemaps, state, objects, alpha, premultipliedAlpha) {
  const clearColor = new Color(0);
  let clearAlpha = alpha === true ? 0 : 1;
  let planeMesh;
  let boxMesh;
  let currentBackground = null;
  let currentBackgroundVersion = 0;
  let currentTonemapping = null;
  function render(renderList, scene) {
    let forceClear = false;
    let background = scene.isScene === true ? scene.background : null;
    if (background && background.isTexture) {
      background = cubemaps.get(background);
    }
    const xr = renderer.xr;
    const session = xr.getSession && xr.getSession();
    if (session && session.environmentBlendMode === "additive") {
      background = null;
    }
    if (background === null) {
      setClear(clearColor, clearAlpha);
    } else if (background && background.isColor) {
      setClear(background, 1);
      forceClear = true;
    }
    if (renderer.autoClear || forceClear) {
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    }
    if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
      if (boxMesh === void 0) {
        boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({
          name: "BackgroundCubeMaterial",
          uniforms: cloneUniforms(ShaderLib.cube.uniforms),
          vertexShader: ShaderLib.cube.vertexShader,
          fragmentShader: ShaderLib.cube.fragmentShader,
          side: BackSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        boxMesh.geometry.deleteAttribute("normal");
        boxMesh.geometry.deleteAttribute("uv");
        boxMesh.onBeforeRender = function(renderer2, scene2, camera) {
          this.matrixWorld.copyPosition(camera.matrixWorld);
        };
        Object.defineProperty(boxMesh.material, "envMap", {
          get: function() {
            return this.uniforms.envMap.value;
          }
        });
        objects.update(boxMesh);
      }
      boxMesh.material.uniforms.envMap.value = background;
      boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        boxMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
    } else if (background && background.isTexture) {
      if (planeMesh === void 0) {
        planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({
          name: "BackgroundMaterial",
          uniforms: cloneUniforms(ShaderLib.background.uniforms),
          vertexShader: ShaderLib.background.vertexShader,
          fragmentShader: ShaderLib.background.fragmentShader,
          side: FrontSide,
          depthTest: false,
          depthWrite: false,
          fog: false
        }));
        planeMesh.geometry.deleteAttribute("normal");
        Object.defineProperty(planeMesh.material, "map", {
          get: function() {
            return this.uniforms.t2D.value;
          }
        });
        objects.update(planeMesh);
      }
      planeMesh.material.uniforms.t2D.value = background;
      if (background.matrixAutoUpdate === true) {
        background.updateMatrix();
      }
      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        planeMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
    }
  }
  function setClear(color, alpha2) {
    state.buffers.color.setClear(color.r, color.g, color.b, alpha2, premultipliedAlpha);
  }
  return {
    getClearColor: function() {
      return clearColor;
    },
    setClearColor: function(color, alpha2 = 1) {
      clearColor.set(color);
      clearAlpha = alpha2;
      setClear(clearColor, clearAlpha);
    },
    getClearAlpha: function() {
      return clearAlpha;
    },
    setClearAlpha: function(alpha2) {
      clearAlpha = alpha2;
      setClear(clearColor, clearAlpha);
    },
    render
  };
}
function WebGLBindingStates(gl, extensions, attributes, capabilities) {
  const maxVertexAttributes = gl.getParameter(34921);
  const extension = capabilities.isWebGL2 ? null : extensions.get("OES_vertex_array_object");
  const vaoAvailable = capabilities.isWebGL2 || extension !== null;
  const bindingStates = {};
  const defaultState = createBindingState(null);
  let currentState = defaultState;
  let forceUpdate = false;
  function setup(object, material, program, geometry, index) {
    let updateBuffers = false;
    if (vaoAvailable) {
      const state = getBindingState(geometry, program, material);
      if (currentState !== state) {
        currentState = state;
        bindVertexArrayObject(currentState.object);
      }
      updateBuffers = needsUpdate(geometry, index);
      if (updateBuffers)
        saveCache(geometry, index);
    } else {
      const wireframe = material.wireframe === true;
      if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
        currentState.geometry = geometry.id;
        currentState.program = program.id;
        currentState.wireframe = wireframe;
        updateBuffers = true;
      }
    }
    if (object.isInstancedMesh === true) {
      updateBuffers = true;
    }
    if (index !== null) {
      attributes.update(index, 34963);
    }
    if (updateBuffers || forceUpdate) {
      forceUpdate = false;
      setupVertexAttributes(object, material, program, geometry);
      if (index !== null) {
        gl.bindBuffer(34963, attributes.get(index).buffer);
      }
    }
  }
  function createVertexArrayObject() {
    if (capabilities.isWebGL2)
      return gl.createVertexArray();
    return extension.createVertexArrayOES();
  }
  function bindVertexArrayObject(vao) {
    if (capabilities.isWebGL2)
      return gl.bindVertexArray(vao);
    return extension.bindVertexArrayOES(vao);
  }
  function deleteVertexArrayObject(vao) {
    if (capabilities.isWebGL2)
      return gl.deleteVertexArray(vao);
    return extension.deleteVertexArrayOES(vao);
  }
  function getBindingState(geometry, program, material) {
    const wireframe = material.wireframe === true;
    let programMap = bindingStates[geometry.id];
    if (programMap === void 0) {
      programMap = {};
      bindingStates[geometry.id] = programMap;
    }
    let stateMap = programMap[program.id];
    if (stateMap === void 0) {
      stateMap = {};
      programMap[program.id] = stateMap;
    }
    let state = stateMap[wireframe];
    if (state === void 0) {
      state = createBindingState(createVertexArrayObject());
      stateMap[wireframe] = state;
    }
    return state;
  }
  function createBindingState(vao) {
    const newAttributes = [];
    const enabledAttributes = [];
    const attributeDivisors = [];
    for (let i2 = 0; i2 < maxVertexAttributes; i2++) {
      newAttributes[i2] = 0;
      enabledAttributes[i2] = 0;
      attributeDivisors[i2] = 0;
    }
    return {
      geometry: null,
      program: null,
      wireframe: false,
      newAttributes,
      enabledAttributes,
      attributeDivisors,
      object: vao,
      attributes: {},
      index: null
    };
  }
  function needsUpdate(geometry, index) {
    const cachedAttributes = currentState.attributes;
    const geometryAttributes = geometry.attributes;
    let attributesNum = 0;
    for (const key in geometryAttributes) {
      const cachedAttribute = cachedAttributes[key];
      const geometryAttribute = geometryAttributes[key];
      if (cachedAttribute === void 0)
        return true;
      if (cachedAttribute.attribute !== geometryAttribute)
        return true;
      if (cachedAttribute.data !== geometryAttribute.data)
        return true;
      attributesNum++;
    }
    if (currentState.attributesNum !== attributesNum)
      return true;
    if (currentState.index !== index)
      return true;
    return false;
  }
  function saveCache(geometry, index) {
    const cache = {};
    const attributes2 = geometry.attributes;
    let attributesNum = 0;
    for (const key in attributes2) {
      const attribute = attributes2[key];
      const data = {};
      data.attribute = attribute;
      if (attribute.data) {
        data.data = attribute.data;
      }
      cache[key] = data;
      attributesNum++;
    }
    currentState.attributes = cache;
    currentState.attributesNum = attributesNum;
    currentState.index = index;
  }
  function initAttributes() {
    const newAttributes = currentState.newAttributes;
    for (let i2 = 0, il = newAttributes.length; i2 < il; i2++) {
      newAttributes[i2] = 0;
    }
  }
  function enableAttribute(attribute) {
    enableAttributeAndDivisor(attribute, 0);
  }
  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    const attributeDivisors = currentState.attributeDivisors;
    newAttributes[attribute] = 1;
    if (enabledAttributes[attribute] === 0) {
      gl.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }
    if (attributeDivisors[attribute] !== meshPerAttribute) {
      const extension2 = capabilities.isWebGL2 ? gl : extensions.get("ANGLE_instanced_arrays");
      extension2[capabilities.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
      attributeDivisors[attribute] = meshPerAttribute;
    }
  }
  function disableUnusedAttributes() {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    for (let i2 = 0, il = enabledAttributes.length; i2 < il; i2++) {
      if (enabledAttributes[i2] !== newAttributes[i2]) {
        gl.disableVertexAttribArray(i2);
        enabledAttributes[i2] = 0;
      }
    }
  }
  function vertexAttribPointer(index, size, type, normalized, stride, offset) {
    if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) {
      gl.vertexAttribIPointer(index, size, type, stride, offset);
    } else {
      gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
    }
  }
  function setupVertexAttributes(object, material, program, geometry) {
    if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
      if (extensions.get("ANGLE_instanced_arrays") === null)
        return;
    }
    initAttributes();
    const geometryAttributes = geometry.attributes;
    const programAttributes = program.getAttributes();
    const materialDefaultAttributeValues = material.defaultAttributeValues;
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        let geometryAttribute = geometryAttributes[name];
        if (geometryAttribute === void 0) {
          if (name === "instanceMatrix" && object.instanceMatrix)
            geometryAttribute = object.instanceMatrix;
          if (name === "instanceColor" && object.instanceColor)
            geometryAttribute = object.instanceColor;
        }
        if (geometryAttribute !== void 0) {
          const normalized = geometryAttribute.normalized;
          const size = geometryAttribute.itemSize;
          const attribute = attributes.get(geometryAttribute);
          if (attribute === void 0)
            continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          const bytesPerElement = attribute.bytesPerElement;
          if (geometryAttribute.isInterleavedBufferAttribute) {
            const data = geometryAttribute.data;
            const stride = data.stride;
            const offset = geometryAttribute.offset;
            if (data.isInstancedInterleavedBuffer) {
              for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                enableAttributeAndDivisor(programAttribute.location + i2, data.meshPerAttribute);
              }
              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = data.meshPerAttribute * data.count;
              }
            } else {
              for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                enableAttribute(programAttribute.location + i2);
              }
            }
            gl.bindBuffer(34962, buffer);
            for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
              vertexAttribPointer(programAttribute.location + i2, size / programAttribute.locationSize, type, normalized, stride * bytesPerElement, (offset + size / programAttribute.locationSize * i2) * bytesPerElement);
            }
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                enableAttributeAndDivisor(programAttribute.location + i2, geometryAttribute.meshPerAttribute);
              }
              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                enableAttribute(programAttribute.location + i2);
              }
            }
            gl.bindBuffer(34962, buffer);
            for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
              vertexAttribPointer(programAttribute.location + i2, size / programAttribute.locationSize, type, normalized, size * bytesPerElement, size / programAttribute.locationSize * i2 * bytesPerElement);
            }
          }
        } else if (materialDefaultAttributeValues !== void 0) {
          const value = materialDefaultAttributeValues[name];
          if (value !== void 0) {
            switch (value.length) {
              case 2:
                gl.vertexAttrib2fv(programAttribute.location, value);
                break;
              case 3:
                gl.vertexAttrib3fv(programAttribute.location, value);
                break;
              case 4:
                gl.vertexAttrib4fv(programAttribute.location, value);
                break;
              default:
                gl.vertexAttrib1fv(programAttribute.location, value);
            }
          }
        }
      }
    }
    disableUnusedAttributes();
  }
  function dispose() {
    reset();
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      for (const programId in programMap) {
        const stateMap = programMap[programId];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[programId];
      }
      delete bindingStates[geometryId];
    }
  }
  function releaseStatesOfGeometry(geometry) {
    if (bindingStates[geometry.id] === void 0)
      return;
    const programMap = bindingStates[geometry.id];
    for (const programId in programMap) {
      const stateMap = programMap[programId];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[programId];
    }
    delete bindingStates[geometry.id];
  }
  function releaseStatesOfProgram(program) {
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      if (programMap[program.id] === void 0)
        continue;
      const stateMap = programMap[program.id];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[program.id];
    }
  }
  function reset() {
    resetDefaultState();
    forceUpdate = true;
    if (currentState === defaultState)
      return;
    currentState = defaultState;
    bindVertexArrayObject(currentState.object);
  }
  function resetDefaultState() {
    defaultState.geometry = null;
    defaultState.program = null;
    defaultState.wireframe = false;
  }
  return {
    setup,
    reset,
    resetDefaultState,
    dispose,
    releaseStatesOfGeometry,
    releaseStatesOfProgram,
    initAttributes,
    enableAttribute,
    disableUnusedAttributes
  };
}
function WebGLBufferRenderer(gl, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  function render(start, count) {
    gl.drawArrays(mode, start, count);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0)
      return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl;
      methodName = "drawArraysInstanced";
    } else {
      extension = extensions.get("ANGLE_instanced_arrays");
      methodName = "drawArraysInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode, start, count, primcount);
    info.update(count, mode, primcount);
  }
  this.setMode = setMode;
  this.render = render;
  this.renderInstances = renderInstances;
}
function WebGLCapabilities(gl, extensions, parameters) {
  let maxAnisotropy;
  function getMaxAnisotropy() {
    if (maxAnisotropy !== void 0)
      return maxAnisotropy;
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }
    return maxAnisotropy;
  }
  function getMaxPrecision(precision2) {
    if (precision2 === "highp") {
      if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {
        return "highp";
      }
      precision2 = "mediump";
    }
    if (precision2 === "mediump") {
      if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {
        return "mediump";
      }
    }
    return "lowp";
  }
  const isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== "undefined" && gl instanceof WebGL2ComputeRenderingContext;
  let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
  const maxPrecision = getMaxPrecision(precision);
  if (maxPrecision !== precision) {
    console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
    precision = maxPrecision;
  }
  const drawBuffers = isWebGL2 || extensions.has("WEBGL_draw_buffers");
  const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  const maxTextures = gl.getParameter(34930);
  const maxVertexTextures = gl.getParameter(35660);
  const maxTextureSize = gl.getParameter(3379);
  const maxCubemapSize = gl.getParameter(34076);
  const maxAttributes = gl.getParameter(34921);
  const maxVertexUniforms = gl.getParameter(36347);
  const maxVaryings = gl.getParameter(36348);
  const maxFragmentUniforms = gl.getParameter(36349);
  const vertexTextures = maxVertexTextures > 0;
  const floatFragmentTextures = isWebGL2 || extensions.has("OES_texture_float");
  const floatVertexTextures = vertexTextures && floatFragmentTextures;
  const maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
  return {
    isWebGL2,
    drawBuffers,
    getMaxAnisotropy,
    getMaxPrecision,
    precision,
    logarithmicDepthBuffer,
    maxTextures,
    maxVertexTextures,
    maxTextureSize,
    maxCubemapSize,
    maxAttributes,
    maxVertexUniforms,
    maxVaryings,
    maxFragmentUniforms,
    vertexTextures,
    floatFragmentTextures,
    floatVertexTextures,
    maxSamples
  };
}
function WebGLClipping(properties) {
  const scope = this;
  let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
  const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = { value: null, needsUpdate: false };
  this.uniform = uniform;
  this.numPlanes = 0;
  this.numIntersection = 0;
  this.init = function(planes, enableLocalClipping, camera) {
    const enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    globalState = projectPlanes(planes, camera, 0);
    numGlobalPlanes = planes.length;
    return enabled;
  };
  this.beginShadows = function() {
    renderingShadows = true;
    projectPlanes(null);
  };
  this.endShadows = function() {
    renderingShadows = false;
    resetGlobalState();
  };
  this.setState = function(material, camera, useCache) {
    const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
    const materialProperties = properties.get(material);
    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
      if (renderingShadows) {
        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
      let dstArray = materialProperties.clippingState || null;
      uniform.value = dstArray;
      dstArray = projectPlanes(planes, camera, lGlobal, useCache);
      for (let i2 = 0; i2 !== lGlobal; ++i2) {
        dstArray[i2] = globalState[i2];
      }
      materialProperties.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };
  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState;
      uniform.needsUpdate = numGlobalPlanes > 0;
    }
    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }
  function projectPlanes(planes, camera, dstOffset, skipTransform) {
    const nPlanes = planes !== null ? planes.length : 0;
    let dstArray = null;
    if (nPlanes !== 0) {
      dstArray = uniform.value;
      if (skipTransform !== true || dstArray === null) {
        const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);
        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }
        for (let i2 = 0, i4 = dstOffset; i2 !== nPlanes; ++i2, i4 += 4) {
          plane.copy(planes[i2]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i4);
          dstArray[i4 + 3] = plane.constant;
        }
      }
      uniform.value = dstArray;
      uniform.needsUpdate = true;
    }
    scope.numPlanes = nPlanes;
    scope.numIntersection = 0;
    return dstArray;
  }
}
function WebGLCubeMaps(renderer) {
  let cubemaps = /* @__PURE__ */ new WeakMap();
  function mapTextureMapping(texture, mapping) {
    if (mapping === EquirectangularReflectionMapping) {
      texture.mapping = CubeReflectionMapping;
    } else if (mapping === EquirectangularRefractionMapping) {
      texture.mapping = CubeRefractionMapping;
    }
    return texture;
  }
  function get(texture) {
    if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
      const mapping = texture.mapping;
      if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
        if (cubemaps.has(texture)) {
          const cubemap = cubemaps.get(texture).texture;
          return mapTextureMapping(cubemap, texture.mapping);
        } else {
          const image = texture.image;
          if (image && image.height > 0) {
            const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
            renderTarget.fromEquirectangularTexture(renderer, texture);
            cubemaps.set(texture, renderTarget);
            texture.addEventListener("dispose", onTextureDispose);
            return mapTextureMapping(renderTarget.texture, texture.mapping);
          } else {
            return null;
          }
        }
      }
    }
    return texture;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemap = cubemaps.get(texture);
    if (cubemap !== void 0) {
      cubemaps.delete(texture);
      cubemap.dispose();
    }
  }
  function dispose() {
    cubemaps = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    dispose
  };
}
function _createPlanes(lodMax) {
  const lodPlanes = [];
  const sizeLods = [];
  const sigmas = [];
  let lod = lodMax;
  const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
  for (let i2 = 0; i2 < totalLods; i2++) {
    const sizeLod = Math.pow(2, lod);
    sizeLods.push(sizeLod);
    let sigma = 1 / sizeLod;
    if (i2 > lodMax - LOD_MIN) {
      sigma = EXTRA_LOD_SIGMA[i2 - lodMax + LOD_MIN - 1];
    } else if (i2 === 0) {
      sigma = 0;
    }
    sigmas.push(sigma);
    const texelSize = 1 / (sizeLod - 1);
    const min = -texelSize / 2;
    const max = 1 + texelSize / 2;
    const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
    const cubeFaces = 6;
    const vertices = 6;
    const positionSize = 3;
    const uvSize = 2;
    const faceIndexSize = 1;
    const position = new Float32Array(positionSize * vertices * cubeFaces);
    const uv = new Float32Array(uvSize * vertices * cubeFaces);
    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
    for (let face2 = 0; face2 < cubeFaces; face2++) {
      const x = face2 % 3 * 2 / 3 - 1;
      const y2 = face2 > 2 ? 0 : -1;
      const coordinates = [
        x,
        y2,
        0,
        x + 2 / 3,
        y2,
        0,
        x + 2 / 3,
        y2 + 1,
        0,
        x,
        y2,
        0,
        x + 2 / 3,
        y2 + 1,
        0,
        x,
        y2 + 1,
        0
      ];
      position.set(coordinates, positionSize * vertices * face2);
      uv.set(uv1, uvSize * vertices * face2);
      const fill = [face2, face2, face2, face2, face2, face2];
      faceIndex.set(fill, faceIndexSize * vertices * face2);
    }
    const planes = new BufferGeometry();
    planes.setAttribute("position", new BufferAttribute(position, positionSize));
    planes.setAttribute("uv", new BufferAttribute(uv, uvSize));
    planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize));
    lodPlanes.push(planes);
    if (lod > LOD_MIN) {
      lod--;
    }
  }
  return { lodPlanes, sizeLods, sigmas };
}
function _createRenderTarget(width, height, params) {
  const cubeUVRenderTarget = new WebGLRenderTarget(width, height, params);
  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
  cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
  cubeUVRenderTarget.scissorTest = true;
  return cubeUVRenderTarget;
}
function _setViewport(target, x, y2, width, height) {
  target.viewport.set(x, y2, width, height);
  target.scissor.set(x, y2, width, height);
}
function _getBlurShader(lodMax, width, height) {
  const weights = new Float32Array(MAX_SAMPLES);
  const poleAxis = new Vector3(0, 1, 0);
  const shaderMaterial = new ShaderMaterial({
    name: "SphericalGaussianBlur",
    defines: {
      "n": MAX_SAMPLES,
      "CUBEUV_TEXEL_WIDTH": 1 / width,
      "CUBEUV_TEXEL_HEIGHT": 1 / height,
      "CUBEUV_MAX_MIP": `${lodMax}.0`
    },
    uniforms: {
      "envMap": { value: null },
      "samples": { value: 1 },
      "weights": { value: weights },
      "latitudinal": { value: false },
      "dTheta": { value: 0 },
      "mipInt": { value: 0 },
      "poleAxis": { value: poleAxis }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}
function _getEquirectMaterial() {
  return new ShaderMaterial({
    name: "EquirectangularToCubeUV",
    uniforms: {
      "envMap": { value: null }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
}
function _getCubemapMaterial() {
  return new ShaderMaterial({
    name: "CubemapToCubeUV",
    uniforms: {
      "envMap": { value: null },
      "flipEnvMap": { value: -1 }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
}
function _getCommonVertexShader() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function WebGLCubeUVMaps(renderer) {
  let cubeUVmaps = /* @__PURE__ */ new WeakMap();
  let pmremGenerator = null;
  function get(texture) {
    if (texture && texture.isTexture) {
      const mapping = texture.mapping;
      const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
      const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;
      if (isEquirectMap || isCubeMap) {
        if (texture.isRenderTargetTexture && texture.needsPMREMUpdate === true) {
          texture.needsPMREMUpdate = false;
          let renderTarget = cubeUVmaps.get(texture);
          if (pmremGenerator === null)
            pmremGenerator = new PMREMGenerator(renderer);
          renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture, renderTarget) : pmremGenerator.fromCubemap(texture, renderTarget);
          cubeUVmaps.set(texture, renderTarget);
          return renderTarget.texture;
        } else {
          if (cubeUVmaps.has(texture)) {
            return cubeUVmaps.get(texture).texture;
          } else {
            const image = texture.image;
            if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {
              if (pmremGenerator === null)
                pmremGenerator = new PMREMGenerator(renderer);
              const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
              cubeUVmaps.set(texture, renderTarget);
              texture.addEventListener("dispose", onTextureDispose);
              return renderTarget.texture;
            } else {
              return null;
            }
          }
        }
      }
    }
    return texture;
  }
  function isCubeTextureComplete(image) {
    let count = 0;
    const length = 6;
    for (let i2 = 0; i2 < length; i2++) {
      if (image[i2] !== void 0)
        count++;
    }
    return count === length;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemapUV = cubeUVmaps.get(texture);
    if (cubemapUV !== void 0) {
      cubeUVmaps.delete(texture);
      cubemapUV.dispose();
    }
  }
  function dispose() {
    cubeUVmaps = /* @__PURE__ */ new WeakMap();
    if (pmremGenerator !== null) {
      pmremGenerator.dispose();
      pmremGenerator = null;
    }
  }
  return {
    get,
    dispose
  };
}
function WebGLExtensions(gl) {
  const extensions = {};
  function getExtension(name) {
    if (extensions[name] !== void 0) {
      return extensions[name];
    }
    let extension;
    switch (name) {
      case "WEBGL_depth_texture":
        extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        extension = gl.getExtension(name);
    }
    extensions[name] = extension;
    return extension;
  }
  return {
    has: function(name) {
      return getExtension(name) !== null;
    },
    init: function(capabilities) {
      if (capabilities.isWebGL2) {
        getExtension("EXT_color_buffer_float");
      } else {
        getExtension("WEBGL_depth_texture");
        getExtension("OES_texture_float");
        getExtension("OES_texture_half_float");
        getExtension("OES_texture_half_float_linear");
        getExtension("OES_standard_derivatives");
        getExtension("OES_element_index_uint");
        getExtension("OES_vertex_array_object");
        getExtension("ANGLE_instanced_arrays");
      }
      getExtension("OES_texture_float_linear");
      getExtension("EXT_color_buffer_half_float");
      getExtension("WEBGL_multisampled_render_to_texture");
    },
    get: function(name) {
      const extension = getExtension(name);
      if (extension === null) {
        console.warn("THREE.WebGLRenderer: " + name + " extension not supported.");
      }
      return extension;
    }
  };
}
function WebGLGeometries(gl, attributes, info, bindingStates) {
  const geometries = {};
  const wireframeAttributes = /* @__PURE__ */ new WeakMap();
  function onGeometryDispose(event) {
    const geometry = event.target;
    if (geometry.index !== null) {
      attributes.remove(geometry.index);
    }
    for (const name in geometry.attributes) {
      attributes.remove(geometry.attributes[name]);
    }
    geometry.removeEventListener("dispose", onGeometryDispose);
    delete geometries[geometry.id];
    const attribute = wireframeAttributes.get(geometry);
    if (attribute) {
      attributes.remove(attribute);
      wireframeAttributes.delete(geometry);
    }
    bindingStates.releaseStatesOfGeometry(geometry);
    if (geometry.isInstancedBufferGeometry === true) {
      delete geometry._maxInstanceCount;
    }
    info.memory.geometries--;
  }
  function get(object, geometry) {
    if (geometries[geometry.id] === true)
      return geometry;
    geometry.addEventListener("dispose", onGeometryDispose);
    geometries[geometry.id] = true;
    info.memory.geometries++;
    return geometry;
  }
  function update(geometry) {
    const geometryAttributes = geometry.attributes;
    for (const name in geometryAttributes) {
      attributes.update(geometryAttributes[name], 34962);
    }
    const morphAttributes = geometry.morphAttributes;
    for (const name in morphAttributes) {
      const array = morphAttributes[name];
      for (let i2 = 0, l = array.length; i2 < l; i2++) {
        attributes.update(array[i2], 34962);
      }
    }
  }
  function updateWireframeAttribute(geometry) {
    const indices = [];
    const geometryIndex = geometry.index;
    const geometryPosition = geometry.attributes.position;
    let version = 0;
    if (geometryIndex !== null) {
      const array = geometryIndex.array;
      version = geometryIndex.version;
      for (let i2 = 0, l = array.length; i2 < l; i2 += 3) {
        const a = array[i2 + 0];
        const b2 = array[i2 + 1];
        const c = array[i2 + 2];
        indices.push(a, b2, b2, c, c, a);
      }
    } else {
      const array = geometryPosition.array;
      version = geometryPosition.version;
      for (let i2 = 0, l = array.length / 3 - 1; i2 < l; i2 += 3) {
        const a = i2 + 0;
        const b2 = i2 + 1;
        const c = i2 + 2;
        indices.push(a, b2, b2, c, c, a);
      }
    }
    const attribute = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
    attribute.version = version;
    const previousAttribute = wireframeAttributes.get(geometry);
    if (previousAttribute)
      attributes.remove(previousAttribute);
    wireframeAttributes.set(geometry, attribute);
  }
  function getWireframeAttribute(geometry) {
    const currentAttribute = wireframeAttributes.get(geometry);
    if (currentAttribute) {
      const geometryIndex = geometry.index;
      if (geometryIndex !== null) {
        if (currentAttribute.version < geometryIndex.version) {
          updateWireframeAttribute(geometry);
        }
      }
    } else {
      updateWireframeAttribute(geometry);
    }
    return wireframeAttributes.get(geometry);
  }
  return {
    get,
    update,
    getWireframeAttribute
  };
}
function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  let type, bytesPerElement;
  function setIndex(value) {
    type = value.type;
    bytesPerElement = value.bytesPerElement;
  }
  function render(start, count) {
    gl.drawElements(mode, count, type, start * bytesPerElement);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0)
      return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl;
      methodName = "drawElementsInstanced";
    } else {
      extension = extensions.get("ANGLE_instanced_arrays");
      methodName = "drawElementsInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode, count, type, start * bytesPerElement, primcount);
    info.update(count, mode, primcount);
  }
  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render;
  this.renderInstances = renderInstances;
}
function WebGLInfo(gl) {
  const memory = {
    geometries: 0,
    textures: 0
  };
  const render = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function update(count, mode, instanceCount) {
    render.calls++;
    switch (mode) {
      case 4:
        render.triangles += instanceCount * (count / 3);
        break;
      case 1:
        render.lines += instanceCount * (count / 2);
        break;
      case 3:
        render.lines += instanceCount * (count - 1);
        break;
      case 2:
        render.lines += instanceCount * count;
        break;
      case 0:
        render.points += instanceCount * count;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
        break;
    }
  }
  function reset() {
    render.frame++;
    render.calls = 0;
    render.triangles = 0;
    render.points = 0;
    render.lines = 0;
  }
  return {
    memory,
    render,
    programs: null,
    autoReset: true,
    reset,
    update
  };
}
function numericalSort(a, b2) {
  return a[0] - b2[0];
}
function absNumericalSort(a, b2) {
  return Math.abs(b2[1]) - Math.abs(a[1]);
}
function denormalize(morph, attribute) {
  let denominator = 1;
  const array = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;
  if (array instanceof Int8Array)
    denominator = 127;
  else if (array instanceof Int16Array)
    denominator = 32767;
  else if (array instanceof Int32Array)
    denominator = 2147483647;
  else
    console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", array);
  morph.divideScalar(denominator);
}
function WebGLMorphtargets(gl, capabilities, textures) {
  const influencesList = {};
  const morphInfluences = new Float32Array(8);
  const morphTextures = /* @__PURE__ */ new WeakMap();
  const morph = new Vector4();
  const workInfluences = [];
  for (let i2 = 0; i2 < 8; i2++) {
    workInfluences[i2] = [i2, 0];
  }
  function update(object, geometry, material, program) {
    const objectInfluences = object.morphTargetInfluences;
    if (capabilities.isWebGL2 === true) {
      const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
      const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
      let entry = morphTextures.get(geometry);
      if (entry === void 0 || entry.count !== morphTargetsCount) {
        let disposeTexture = function() {
          texture.dispose();
          morphTextures.delete(geometry);
          geometry.removeEventListener("dispose", disposeTexture);
        };
        if (entry !== void 0)
          entry.texture.dispose();
        const hasMorphPosition = geometry.morphAttributes.position !== void 0;
        const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
        const hasMorphColors = geometry.morphAttributes.color !== void 0;
        const morphTargets = geometry.morphAttributes.position || [];
        const morphNormals = geometry.morphAttributes.normal || [];
        const morphColors = geometry.morphAttributes.color || [];
        let vertexDataCount = 0;
        if (hasMorphPosition === true)
          vertexDataCount = 1;
        if (hasMorphNormals === true)
          vertexDataCount = 2;
        if (hasMorphColors === true)
          vertexDataCount = 3;
        let width = geometry.attributes.position.count * vertexDataCount;
        let height = 1;
        if (width > capabilities.maxTextureSize) {
          height = Math.ceil(width / capabilities.maxTextureSize);
          width = capabilities.maxTextureSize;
        }
        const buffer = new Float32Array(width * height * 4 * morphTargetsCount);
        const texture = new DataArrayTexture(buffer, width, height, morphTargetsCount);
        texture.type = FloatType;
        texture.needsUpdate = true;
        const vertexDataStride = vertexDataCount * 4;
        for (let i2 = 0; i2 < morphTargetsCount; i2++) {
          const morphTarget = morphTargets[i2];
          const morphNormal = morphNormals[i2];
          const morphColor = morphColors[i2];
          const offset = width * height * 4 * i2;
          for (let j = 0; j < morphTarget.count; j++) {
            const stride = j * vertexDataStride;
            if (hasMorphPosition === true) {
              morph.fromBufferAttribute(morphTarget, j);
              if (morphTarget.normalized === true)
                denormalize(morph, morphTarget);
              buffer[offset + stride + 0] = morph.x;
              buffer[offset + stride + 1] = morph.y;
              buffer[offset + stride + 2] = morph.z;
              buffer[offset + stride + 3] = 0;
            }
            if (hasMorphNormals === true) {
              morph.fromBufferAttribute(morphNormal, j);
              if (morphNormal.normalized === true)
                denormalize(morph, morphNormal);
              buffer[offset + stride + 4] = morph.x;
              buffer[offset + stride + 5] = morph.y;
              buffer[offset + stride + 6] = morph.z;
              buffer[offset + stride + 7] = 0;
            }
            if (hasMorphColors === true) {
              morph.fromBufferAttribute(morphColor, j);
              if (morphColor.normalized === true)
                denormalize(morph, morphColor);
              buffer[offset + stride + 8] = morph.x;
              buffer[offset + stride + 9] = morph.y;
              buffer[offset + stride + 10] = morph.z;
              buffer[offset + stride + 11] = morphColor.itemSize === 4 ? morph.w : 1;
            }
          }
        }
        entry = {
          count: morphTargetsCount,
          texture,
          size: new Vector2(width, height)
        };
        morphTextures.set(geometry, entry);
        geometry.addEventListener("dispose", disposeTexture);
      }
      let morphInfluencesSum = 0;
      for (let i2 = 0; i2 < objectInfluences.length; i2++) {
        morphInfluencesSum += objectInfluences[i2];
      }
      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
      program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
      program.getUniforms().setValue(gl, "morphTargetInfluences", objectInfluences);
      program.getUniforms().setValue(gl, "morphTargetsTexture", entry.texture, textures);
      program.getUniforms().setValue(gl, "morphTargetsTextureSize", entry.size);
    } else {
      const length = objectInfluences === void 0 ? 0 : objectInfluences.length;
      let influences = influencesList[geometry.id];
      if (influences === void 0 || influences.length !== length) {
        influences = [];
        for (let i2 = 0; i2 < length; i2++) {
          influences[i2] = [i2, 0];
        }
        influencesList[geometry.id] = influences;
      }
      for (let i2 = 0; i2 < length; i2++) {
        const influence = influences[i2];
        influence[0] = i2;
        influence[1] = objectInfluences[i2];
      }
      influences.sort(absNumericalSort);
      for (let i2 = 0; i2 < 8; i2++) {
        if (i2 < length && influences[i2][1]) {
          workInfluences[i2][0] = influences[i2][0];
          workInfluences[i2][1] = influences[i2][1];
        } else {
          workInfluences[i2][0] = Number.MAX_SAFE_INTEGER;
          workInfluences[i2][1] = 0;
        }
      }
      workInfluences.sort(numericalSort);
      const morphTargets = geometry.morphAttributes.position;
      const morphNormals = geometry.morphAttributes.normal;
      let morphInfluencesSum = 0;
      for (let i2 = 0; i2 < 8; i2++) {
        const influence = workInfluences[i2];
        const index = influence[0];
        const value = influence[1];
        if (index !== Number.MAX_SAFE_INTEGER && value) {
          if (morphTargets && geometry.getAttribute("morphTarget" + i2) !== morphTargets[index]) {
            geometry.setAttribute("morphTarget" + i2, morphTargets[index]);
          }
          if (morphNormals && geometry.getAttribute("morphNormal" + i2) !== morphNormals[index]) {
            geometry.setAttribute("morphNormal" + i2, morphNormals[index]);
          }
          morphInfluences[i2] = value;
          morphInfluencesSum += value;
        } else {
          if (morphTargets && geometry.hasAttribute("morphTarget" + i2) === true) {
            geometry.deleteAttribute("morphTarget" + i2);
          }
          if (morphNormals && geometry.hasAttribute("morphNormal" + i2) === true) {
            geometry.deleteAttribute("morphNormal" + i2);
          }
          morphInfluences[i2] = 0;
        }
      }
      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
      program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
      program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences);
    }
  }
  return {
    update
  };
}
function WebGLObjects(gl, geometries, attributes, info) {
  let updateMap = /* @__PURE__ */ new WeakMap();
  function update(object) {
    const frame = info.render.frame;
    const geometry = object.geometry;
    const buffergeometry = geometries.get(object, geometry);
    if (updateMap.get(buffergeometry) !== frame) {
      geometries.update(buffergeometry);
      updateMap.set(buffergeometry, frame);
    }
    if (object.isInstancedMesh) {
      if (object.hasEventListener("dispose", onInstancedMeshDispose) === false) {
        object.addEventListener("dispose", onInstancedMeshDispose);
      }
      attributes.update(object.instanceMatrix, 34962);
      if (object.instanceColor !== null) {
        attributes.update(object.instanceColor, 34962);
      }
    }
    return buffergeometry;
  }
  function dispose() {
    updateMap = /* @__PURE__ */ new WeakMap();
  }
  function onInstancedMeshDispose(event) {
    const instancedMesh = event.target;
    instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
    attributes.remove(instancedMesh.instanceMatrix);
    if (instancedMesh.instanceColor !== null)
      attributes.remove(instancedMesh.instanceColor);
  }
  return {
    update,
    dispose
  };
}
function flatten(array, nBlocks, blockSize) {
  const firstElem = array[0];
  if (firstElem <= 0 || firstElem > 0)
    return array;
  const n = nBlocks * blockSize;
  let r3 = arrayCacheF32[n];
  if (r3 === void 0) {
    r3 = new Float32Array(n);
    arrayCacheF32[n] = r3;
  }
  if (nBlocks !== 0) {
    firstElem.toArray(r3, 0);
    for (let i2 = 1, offset = 0; i2 !== nBlocks; ++i2) {
      offset += blockSize;
      array[i2].toArray(r3, offset);
    }
  }
  return r3;
}
function arraysEqual(a, b2) {
  if (a.length !== b2.length)
    return false;
  for (let i2 = 0, l = a.length; i2 < l; i2++) {
    if (a[i2] !== b2[i2])
      return false;
  }
  return true;
}
function copyArray(a, b2) {
  for (let i2 = 0, l = b2.length; i2 < l; i2++) {
    a[i2] = b2[i2];
  }
}
function allocTexUnits(textures, n) {
  let r3 = arrayCacheI32[n];
  if (r3 === void 0) {
    r3 = new Int32Array(n);
    arrayCacheI32[n] = r3;
  }
  for (let i2 = 0; i2 !== n; ++i2) {
    r3[i2] = textures.allocateTextureUnit();
  }
  return r3;
}
function setValueV1f(gl, v) {
  const cache = this.cache;
  if (cache[0] === v)
    return;
  gl.uniform1f(this.addr, v);
  cache[0] = v;
}
function setValueV2f(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y) {
      gl.uniform2f(this.addr, v.x, v.y);
      cache[0] = v.x;
      cache[1] = v.y;
    }
  } else {
    if (arraysEqual(cache, v))
      return;
    gl.uniform2fv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV3f(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
      gl.uniform3f(this.addr, v.x, v.y, v.z);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
    }
  } else if (v.r !== void 0) {
    if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
      gl.uniform3f(this.addr, v.r, v.g, v.b);
      cache[0] = v.r;
      cache[1] = v.g;
      cache[2] = v.b;
    }
  } else {
    if (arraysEqual(cache, v))
      return;
    gl.uniform3fv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV4f(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
      gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
      cache[3] = v.w;
    }
  } else {
    if (arraysEqual(cache, v))
      return;
    gl.uniform4fv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueM2(gl, v) {
  const cache = this.cache;
  const elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v))
      return;
    gl.uniformMatrix2fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements))
      return;
    mat2array.set(elements);
    gl.uniformMatrix2fv(this.addr, false, mat2array);
    copyArray(cache, elements);
  }
}
function setValueM3(gl, v) {
  const cache = this.cache;
  const elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v))
      return;
    gl.uniformMatrix3fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements))
      return;
    mat3array.set(elements);
    gl.uniformMatrix3fv(this.addr, false, mat3array);
    copyArray(cache, elements);
  }
}
function setValueM4(gl, v) {
  const cache = this.cache;
  const elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v))
      return;
    gl.uniformMatrix4fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements))
      return;
    mat4array.set(elements);
    gl.uniformMatrix4fv(this.addr, false, mat4array);
    copyArray(cache, elements);
  }
}
function setValueV1i(gl, v) {
  const cache = this.cache;
  if (cache[0] === v)
    return;
  gl.uniform1i(this.addr, v);
  cache[0] = v;
}
function setValueV2i(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v))
    return;
  gl.uniform2iv(this.addr, v);
  copyArray(cache, v);
}
function setValueV3i(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v))
    return;
  gl.uniform3iv(this.addr, v);
  copyArray(cache, v);
}
function setValueV4i(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v))
    return;
  gl.uniform4iv(this.addr, v);
  copyArray(cache, v);
}
function setValueV1ui(gl, v) {
  const cache = this.cache;
  if (cache[0] === v)
    return;
  gl.uniform1ui(this.addr, v);
  cache[0] = v;
}
function setValueV2ui(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v))
    return;
  gl.uniform2uiv(this.addr, v);
  copyArray(cache, v);
}
function setValueV3ui(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v))
    return;
  gl.uniform3uiv(this.addr, v);
  copyArray(cache, v);
}
function setValueV4ui(gl, v) {
  const cache = this.cache;
  if (arraysEqual(cache, v))
    return;
  gl.uniform4uiv(this.addr, v);
  copyArray(cache, v);
}
function setValueT1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture2D(v || emptyTexture, unit);
}
function setValueT3D1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture3D(v || empty3dTexture, unit);
}
function setValueT6(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTextureCube(v || emptyCubeTexture, unit);
}
function setValueT2DArray1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture2DArray(v || emptyArrayTexture, unit);
}
function getSingularSetter(type) {
  switch (type) {
    case 5126:
      return setValueV1f;
    case 35664:
      return setValueV2f;
    case 35665:
      return setValueV3f;
    case 35666:
      return setValueV4f;
    case 35674:
      return setValueM2;
    case 35675:
      return setValueM3;
    case 35676:
      return setValueM4;
    case 5124:
    case 35670:
      return setValueV1i;
    case 35667:
    case 35671:
      return setValueV2i;
    case 35668:
    case 35672:
      return setValueV3i;
    case 35669:
    case 35673:
      return setValueV4i;
    case 5125:
      return setValueV1ui;
    case 36294:
      return setValueV2ui;
    case 36295:
      return setValueV3ui;
    case 36296:
      return setValueV4ui;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3D1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArray1;
  }
}
function setValueV1fArray(gl, v) {
  gl.uniform1fv(this.addr, v);
}
function setValueV2fArray(gl, v) {
  const data = flatten(v, this.size, 2);
  gl.uniform2fv(this.addr, data);
}
function setValueV3fArray(gl, v) {
  const data = flatten(v, this.size, 3);
  gl.uniform3fv(this.addr, data);
}
function setValueV4fArray(gl, v) {
  const data = flatten(v, this.size, 4);
  gl.uniform4fv(this.addr, data);
}
function setValueM2Array(gl, v) {
  const data = flatten(v, this.size, 4);
  gl.uniformMatrix2fv(this.addr, false, data);
}
function setValueM3Array(gl, v) {
  const data = flatten(v, this.size, 9);
  gl.uniformMatrix3fv(this.addr, false, data);
}
function setValueM4Array(gl, v) {
  const data = flatten(v, this.size, 16);
  gl.uniformMatrix4fv(this.addr, false, data);
}
function setValueV1iArray(gl, v) {
  gl.uniform1iv(this.addr, v);
}
function setValueV2iArray(gl, v) {
  gl.uniform2iv(this.addr, v);
}
function setValueV3iArray(gl, v) {
  gl.uniform3iv(this.addr, v);
}
function setValueV4iArray(gl, v) {
  gl.uniform4iv(this.addr, v);
}
function setValueV1uiArray(gl, v) {
  gl.uniform1uiv(this.addr, v);
}
function setValueV2uiArray(gl, v) {
  gl.uniform2uiv(this.addr, v);
}
function setValueV3uiArray(gl, v) {
  gl.uniform3uiv(this.addr, v);
}
function setValueV4uiArray(gl, v) {
  gl.uniform4uiv(this.addr, v);
}
function setValueT1Array(gl, v, textures) {
  const n = v.length;
  const units = allocTexUnits(textures, n);
  gl.uniform1iv(this.addr, units);
  for (let i2 = 0; i2 !== n; ++i2) {
    textures.setTexture2D(v[i2] || emptyTexture, units[i2]);
  }
}
function setValueT3DArray(gl, v, textures) {
  const n = v.length;
  const units = allocTexUnits(textures, n);
  gl.uniform1iv(this.addr, units);
  for (let i2 = 0; i2 !== n; ++i2) {
    textures.setTexture3D(v[i2] || empty3dTexture, units[i2]);
  }
}
function setValueT6Array(gl, v, textures) {
  const n = v.length;
  const units = allocTexUnits(textures, n);
  gl.uniform1iv(this.addr, units);
  for (let i2 = 0; i2 !== n; ++i2) {
    textures.setTextureCube(v[i2] || emptyCubeTexture, units[i2]);
  }
}
function setValueT2DArrayArray(gl, v, textures) {
  const n = v.length;
  const units = allocTexUnits(textures, n);
  gl.uniform1iv(this.addr, units);
  for (let i2 = 0; i2 !== n; ++i2) {
    textures.setTexture2DArray(v[i2] || emptyArrayTexture, units[i2]);
  }
}
function getPureArraySetter(type) {
  switch (type) {
    case 5126:
      return setValueV1fArray;
    case 35664:
      return setValueV2fArray;
    case 35665:
      return setValueV3fArray;
    case 35666:
      return setValueV4fArray;
    case 35674:
      return setValueM2Array;
    case 35675:
      return setValueM3Array;
    case 35676:
      return setValueM4Array;
    case 5124:
    case 35670:
      return setValueV1iArray;
    case 35667:
    case 35671:
      return setValueV2iArray;
    case 35668:
    case 35672:
      return setValueV3iArray;
    case 35669:
    case 35673:
      return setValueV4iArray;
    case 5125:
      return setValueV1uiArray;
    case 36294:
      return setValueV2uiArray;
    case 36295:
      return setValueV3uiArray;
    case 36296:
      return setValueV4uiArray;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1Array;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3DArray;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6Array;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArrayArray;
  }
}
function SingleUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.setValue = getSingularSetter(activeInfo.type);
}
function PureArrayUniform(id, activeInfo, addr) {
  this.id = id;
  this.addr = addr;
  this.cache = [];
  this.size = activeInfo.size;
  this.setValue = getPureArraySetter(activeInfo.type);
}
function StructuredUniform(id) {
  this.id = id;
  this.seq = [];
  this.map = {};
}
function addUniform(container, uniformObject) {
  container.seq.push(uniformObject);
  container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
  const path = activeInfo.name, pathLength = path.length;
  RePathPart.lastIndex = 0;
  while (true) {
    const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
    let id = match[1];
    const idIsIndex = match[2] === "]", subscript = match[3];
    if (idIsIndex)
      id = id | 0;
    if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
      addUniform(container, subscript === void 0 ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
      break;
    } else {
      const map = container.map;
      let next = map[id];
      if (next === void 0) {
        next = new StructuredUniform(id);
        addUniform(container, next);
      }
      container = next;
    }
  }
}
function WebGLUniforms(gl, program) {
  this.seq = [];
  this.map = {};
  const n = gl.getProgramParameter(program, 35718);
  for (let i2 = 0; i2 < n; ++i2) {
    const info = gl.getActiveUniform(program, i2), addr = gl.getUniformLocation(program, info.name);
    parseUniform(info, addr, this);
  }
}
function WebGLShader(gl, type, string) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, string);
  gl.compileShader(shader);
  return shader;
}
function handleSource(string, errorLine) {
  const lines = string.split("\n");
  const lines2 = [];
  const from2 = Math.max(errorLine - 6, 0);
  const to = Math.min(errorLine + 6, lines.length);
  for (let i2 = from2; i2 < to; i2++) {
    lines2.push(i2 + 1 + ": " + lines[i2]);
  }
  return lines2.join("\n");
}
function getEncodingComponents(encoding) {
  switch (encoding) {
    case LinearEncoding:
      return ["Linear", "( value )"];
    case sRGBEncoding:
      return ["sRGB", "( value )"];
    default:
      console.warn("THREE.WebGLProgram: Unsupported encoding:", encoding);
      return ["Linear", "( value )"];
  }
}
function getShaderErrors(gl, shader, type) {
  const status = gl.getShaderParameter(shader, 35713);
  const errors = gl.getShaderInfoLog(shader).trim();
  if (status && errors === "")
    return "";
  const errorLine = parseInt(/ERROR: 0:(\d+)/.exec(errors)[1]);
  return type.toUpperCase() + "\n\n" + errors + "\n\n" + handleSource(gl.getShaderSource(shader), errorLine);
}
function getTexelEncodingFunction(functionName, encoding) {
  const components = getEncodingComponents(encoding);
  return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
}
function getToneMappingFunction(functionName, toneMapping) {
  let toneMappingName;
  switch (toneMapping) {
    case LinearToneMapping:
      toneMappingName = "Linear";
      break;
    case ReinhardToneMapping:
      toneMappingName = "Reinhard";
      break;
    case CineonToneMapping:
      toneMappingName = "OptimizedCineon";
      break;
    case ACESFilmicToneMapping:
      toneMappingName = "ACESFilmic";
      break;
    case CustomToneMapping:
      toneMappingName = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
      toneMappingName = "Linear";
  }
  return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
}
function generateExtensions(parameters) {
  const chunks = [
    parameters.extensionDerivatives || !!parameters.envMapCubeUVHeight || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission) && parameters.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ];
  return chunks.filter(filterEmptyLine).join("\n");
}
function generateDefines(defines) {
  const chunks = [];
  for (const name in defines) {
    const value = defines[name];
    if (value === false)
      continue;
    chunks.push("#define " + name + " " + value);
  }
  return chunks.join("\n");
}
function fetchAttributeLocations(gl, program) {
  const attributes = {};
  const n = gl.getProgramParameter(program, 35721);
  for (let i2 = 0; i2 < n; i2++) {
    const info = gl.getActiveAttrib(program, i2);
    const name = info.name;
    let locationSize = 1;
    if (info.type === 35674)
      locationSize = 2;
    if (info.type === 35675)
      locationSize = 3;
    if (info.type === 35676)
      locationSize = 4;
    attributes[name] = {
      type: info.type,
      location: gl.getAttribLocation(program, name),
      locationSize
    };
  }
  return attributes;
}
function filterEmptyLine(string) {
  return string !== "";
}
function replaceLightNums(string, parameters) {
  return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}
function replaceClippingPlaneNums(string, parameters) {
  return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}
function resolveIncludes(string) {
  return string.replace(includePattern, includeReplacer);
}
function includeReplacer(match, include) {
  const string = ShaderChunk[include];
  if (string === void 0) {
    throw new Error("Can not resolve #include <" + include + ">");
  }
  return resolveIncludes(string);
}
function unrollLoops(string) {
  return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
}
function deprecatedLoopReplacer(match, start, end, snippet) {
  console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.");
  return loopReplacer(match, start, end, snippet);
}
function loopReplacer(match, start, end, snippet) {
  let string = "";
  for (let i2 = parseInt(start); i2 < parseInt(end); i2++) {
    string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i2 + " ]").replace(/UNROLLED_LOOP_INDEX/g, i2);
  }
  return string;
}
function generatePrecision(parameters) {
  let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
  if (parameters.precision === "highp") {
    precisionstring += "\n#define HIGH_PRECISION";
  } else if (parameters.precision === "mediump") {
    precisionstring += "\n#define MEDIUM_PRECISION";
  } else if (parameters.precision === "lowp") {
    precisionstring += "\n#define LOW_PRECISION";
  }
  return precisionstring;
}
function generateShadowMapTypeDefine(parameters) {
  let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
  if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
  } else if (parameters.shadowMapType === VSMShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
  }
  return shadowMapTypeDefine;
}
function generateEnvMapTypeDefine(parameters) {
  let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE";
        break;
      case CubeUVReflectionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  }
  return envMapTypeDefine;
}
function generateEnvMapModeDefine(parameters) {
  let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeRefractionMapping:
        envMapModeDefine = "ENVMAP_MODE_REFRACTION";
        break;
    }
  }
  return envMapModeDefine;
}
function generateEnvMapBlendingDefine(parameters) {
  let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
  if (parameters.envMap) {
    switch (parameters.combine) {
      case MultiplyOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case MixOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
        break;
      case AddOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
        break;
    }
  }
  return envMapBlendingDefine;
}
function generateCubeUVSize(parameters) {
  const imageHeight = parameters.envMapCubeUVHeight;
  if (imageHeight === null)
    return null;
  const maxMip = Math.log2(imageHeight / 32 + 1) + 3;
  const texelHeight = 1 / imageHeight;
  const texelWidth = 1 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
  return { texelWidth, texelHeight, maxMip };
}
function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
  const gl = renderer.getContext();
  const defines = parameters.defines;
  let vertexShader = parameters.vertexShader;
  let fragmentShader = parameters.fragmentShader;
  const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
  const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
  const envMapModeDefine = generateEnvMapModeDefine(parameters);
  const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
  const envMapCubeUVSize = generateCubeUVSize(parameters);
  const customExtensions = parameters.isWebGL2 ? "" : generateExtensions(parameters);
  const customDefines = generateDefines(defines);
  const program = gl.createProgram();
  let prefixVertex, prefixFragment;
  let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
  if (parameters.isRawShaderMaterial) {
    prefixVertex = [
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixVertex.length > 0) {
      prefixVertex += "\n";
    }
    prefixFragment = [
      customExtensions,
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixFragment.length > 0) {
      prefixFragment += "\n";
    }
  } else {
    prefixVertex = [
      generatePrecision(parameters),
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.instancing ? "#define USE_INSTANCING" : "",
      parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
      parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
      "#define MAX_BONES " + parameters.maxBones,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
      parameters.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
      parameters.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
      parameters.vertexTangents ? "#define USE_TANGENT" : "",
      parameters.vertexColors ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUvs ? "#define USE_UV" : "",
      parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.skinning ? "#define USE_SKINNING" : "",
      parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",
      parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
      parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
      parameters.morphColors && parameters.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
      parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
      parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + parameters.morphTextureStride : "",
      parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_COUNT " + parameters.morphTargetsCount : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      "#ifdef USE_INSTANCING",
      "	attribute mat4 instanceMatrix;",
      "#endif",
      "#ifdef USE_INSTANCING_COLOR",
      "	attribute vec3 instanceColor;",
      "#endif",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_TANGENT",
      "	attribute vec4 tangent;",
      "#endif",
      "#if defined( USE_COLOR_ALPHA )",
      "	attribute vec4 color;",
      "#elif defined( USE_COLOR )",
      "	attribute vec3 color;",
      "#endif",
      "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
      "	attribute vec3 morphTarget0;",
      "	attribute vec3 morphTarget1;",
      "	attribute vec3 morphTarget2;",
      "	attribute vec3 morphTarget3;",
      "	#ifdef USE_MORPHNORMALS",
      "		attribute vec3 morphNormal0;",
      "		attribute vec3 morphNormal1;",
      "		attribute vec3 morphNormal2;",
      "		attribute vec3 morphNormal3;",
      "	#else",
      "		attribute vec3 morphTarget4;",
      "		attribute vec3 morphTarget5;",
      "		attribute vec3 morphTarget6;",
      "		attribute vec3 morphTarget7;",
      "	#endif",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      "\n"
    ].filter(filterEmptyLine).join("\n");
    prefixFragment = [
      customExtensions,
      generatePrecision(parameters),
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.matcap ? "#define USE_MATCAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapTypeDefine : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.envMap ? "#define " + envMapBlendingDefine : "",
      envMapCubeUVSize ? "#define CUBEUV_TEXEL_WIDTH " + envMapCubeUVSize.texelWidth : "",
      envMapCubeUVSize ? "#define CUBEUV_TEXEL_HEIGHT " + envMapCubeUVSize.texelHeight : "",
      envMapCubeUVSize ? "#define CUBEUV_MAX_MIP " + envMapCubeUVSize.maxMip + ".0" : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
      parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "",
      parameters.clearcoat ? "#define USE_CLEARCOAT" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "",
      parameters.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.alphaTest ? "#define USE_ALPHATEST" : "",
      parameters.sheen ? "#define USE_SHEEN" : "",
      parameters.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "",
      parameters.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
      parameters.vertexTangents ? "#define USE_TANGENT" : "",
      parameters.vertexColors || parameters.instancingColor ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUvs ? "#define USE_UV" : "",
      parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
      parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
      parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      "uniform mat4 viewMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
      parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
      parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
      parameters.dithering ? "#define DITHERING" : "",
      parameters.opaque ? "#define OPAQUE" : "",
      ShaderChunk["encodings_pars_fragment"],
      getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding),
      parameters.depthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
      "\n"
    ].filter(filterEmptyLine).join("\n");
  }
  vertexShader = resolveIncludes(vertexShader);
  vertexShader = replaceLightNums(vertexShader, parameters);
  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
  fragmentShader = resolveIncludes(fragmentShader);
  fragmentShader = replaceLightNums(fragmentShader, parameters);
  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
  vertexShader = unrollLoops(vertexShader);
  fragmentShader = unrollLoops(fragmentShader);
  if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
    versionString = "#version 300 es\n";
    prefixVertex = [
      "precision mediump sampler2DArray;",
      "#define attribute in",
      "#define varying out",
      "#define texture2D texture"
    ].join("\n") + "\n" + prefixVertex;
    prefixFragment = [
      "#define varying in",
      parameters.glslVersion === GLSL3 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
      parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
      "#define gl_FragDepthEXT gl_FragDepth",
      "#define texture2D texture",
      "#define textureCube texture",
      "#define texture2DProj textureProj",
      "#define texture2DLodEXT textureLod",
      "#define texture2DProjLodEXT textureProjLod",
      "#define textureCubeLodEXT textureLod",
      "#define texture2DGradEXT textureGrad",
      "#define texture2DProjGradEXT textureProjGrad",
      "#define textureCubeGradEXT textureGrad"
    ].join("\n") + "\n" + prefixFragment;
  }
  const vertexGlsl = versionString + prefixVertex + vertexShader;
  const fragmentGlsl = versionString + prefixFragment + fragmentShader;
  const glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
  const glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);
  gl.attachShader(program, glVertexShader);
  gl.attachShader(program, glFragmentShader);
  if (parameters.index0AttributeName !== void 0) {
    gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
  } else if (parameters.morphTargets === true) {
    gl.bindAttribLocation(program, 0, "position");
  }
  gl.linkProgram(program);
  if (renderer.debug.checkShaderErrors) {
    const programLog = gl.getProgramInfoLog(program).trim();
    const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
    const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
    let runnable = true;
    let haveDiagnostics = true;
    if (gl.getProgramParameter(program, 35714) === false) {
      runnable = false;
      const vertexErrors = getShaderErrors(gl, glVertexShader, "vertex");
      const fragmentErrors = getShaderErrors(gl, glFragmentShader, "fragment");
      console.error("THREE.WebGLProgram: Shader Error " + gl.getError() + " - VALIDATE_STATUS " + gl.getProgramParameter(program, 35715) + "\n\nProgram Info Log: " + programLog + "\n" + vertexErrors + "\n" + fragmentErrors);
    } else if (programLog !== "") {
      console.warn("THREE.WebGLProgram: Program Info Log:", programLog);
    } else if (vertexLog === "" || fragmentLog === "") {
      haveDiagnostics = false;
    }
    if (haveDiagnostics) {
      this.diagnostics = {
        runnable,
        programLog,
        vertexShader: {
          log: vertexLog,
          prefix: prefixVertex
        },
        fragmentShader: {
          log: fragmentLog,
          prefix: prefixFragment
        }
      };
    }
  }
  gl.deleteShader(glVertexShader);
  gl.deleteShader(glFragmentShader);
  let cachedUniforms;
  this.getUniforms = function() {
    if (cachedUniforms === void 0) {
      cachedUniforms = new WebGLUniforms(gl, program);
    }
    return cachedUniforms;
  };
  let cachedAttributes;
  this.getAttributes = function() {
    if (cachedAttributes === void 0) {
      cachedAttributes = fetchAttributeLocations(gl, program);
    }
    return cachedAttributes;
  };
  this.destroy = function() {
    bindingStates.releaseStatesOfProgram(this);
    gl.deleteProgram(program);
    this.program = void 0;
  };
  this.name = parameters.shaderName;
  this.id = programIdCount++;
  this.cacheKey = cacheKey;
  this.usedTimes = 1;
  this.program = program;
  this.vertexShader = glVertexShader;
  this.fragmentShader = glFragmentShader;
  return this;
}
function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
  const _programLayers = new Layers();
  const _customShaders = new WebGLShaderCache();
  const programs = [];
  const isWebGL2 = capabilities.isWebGL2;
  const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
  const floatVertexTextures = capabilities.floatVertexTextures;
  const maxVertexUniforms = capabilities.maxVertexUniforms;
  const vertexTextures = capabilities.vertexTextures;
  let precision = capabilities.precision;
  const shaderIDs = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function getMaxBones(object) {
    const skeleton = object.skeleton;
    const bones = skeleton.bones;
    if (floatVertexTextures) {
      return 1024;
    } else {
      const nVertexUniforms = maxVertexUniforms;
      const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
      const maxBones = Math.min(nVertexMatrices, bones.length);
      if (maxBones < bones.length) {
        console.warn("THREE.WebGLRenderer: Skeleton has " + bones.length + " bones. This GPU supports " + maxBones + ".");
        return 0;
      }
      return maxBones;
    }
  }
  function getParameters(material, lights, shadows, scene, object) {
    const fog = scene.fog;
    const geometry = object.geometry;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
    const envMapCubeUVHeight = !!envMap && envMap.mapping === CubeUVReflectionMapping ? envMap.image.height : null;
    const shaderID = shaderIDs[material.type];
    const maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;
    if (material.precision !== null) {
      precision = capabilities.getMaxPrecision(material.precision);
      if (precision !== material.precision) {
        console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
      }
    }
    const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
    const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
    let morphTextureStride = 0;
    if (geometry.morphAttributes.position !== void 0)
      morphTextureStride = 1;
    if (geometry.morphAttributes.normal !== void 0)
      morphTextureStride = 2;
    if (geometry.morphAttributes.color !== void 0)
      morphTextureStride = 3;
    let vertexShader, fragmentShader;
    let customVertexShaderID, customFragmentShaderID;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      vertexShader = shader.vertexShader;
      fragmentShader = shader.fragmentShader;
    } else {
      vertexShader = material.vertexShader;
      fragmentShader = material.fragmentShader;
      _customShaders.update(material);
      customVertexShaderID = _customShaders.getVertexShaderID(material);
      customFragmentShaderID = _customShaders.getFragmentShaderID(material);
    }
    const currentRenderTarget = renderer.getRenderTarget();
    const useAlphaTest = material.alphaTest > 0;
    const useClearcoat = material.clearcoat > 0;
    const parameters = {
      isWebGL2,
      shaderID,
      shaderName: material.type,
      vertexShader,
      fragmentShader,
      defines: material.defines,
      customVertexShaderID,
      customFragmentShaderID,
      isRawShaderMaterial: material.isRawShaderMaterial === true,
      glslVersion: material.glslVersion,
      precision,
      instancing: object.isInstancedMesh === true,
      instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,
      supportsVertexTextures: vertexTextures,
      outputEncoding: currentRenderTarget === null ? renderer.outputEncoding : currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.encoding : LinearEncoding,
      map: !!material.map,
      matcap: !!material.matcap,
      envMap: !!envMap,
      envMapMode: envMap && envMap.mapping,
      envMapCubeUVHeight,
      lightMap: !!material.lightMap,
      aoMap: !!material.aoMap,
      emissiveMap: !!material.emissiveMap,
      bumpMap: !!material.bumpMap,
      normalMap: !!material.normalMap,
      objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
      tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
      decodeVideoTexture: !!material.map && material.map.isVideoTexture === true && material.map.encoding === sRGBEncoding,
      clearcoat: useClearcoat,
      clearcoatMap: useClearcoat && !!material.clearcoatMap,
      clearcoatRoughnessMap: useClearcoat && !!material.clearcoatRoughnessMap,
      clearcoatNormalMap: useClearcoat && !!material.clearcoatNormalMap,
      displacementMap: !!material.displacementMap,
      roughnessMap: !!material.roughnessMap,
      metalnessMap: !!material.metalnessMap,
      specularMap: !!material.specularMap,
      specularIntensityMap: !!material.specularIntensityMap,
      specularColorMap: !!material.specularColorMap,
      opaque: material.transparent === false && material.blending === NormalBlending,
      alphaMap: !!material.alphaMap,
      alphaTest: useAlphaTest,
      gradientMap: !!material.gradientMap,
      sheen: material.sheen > 0,
      sheenColorMap: !!material.sheenColorMap,
      sheenRoughnessMap: !!material.sheenRoughnessMap,
      transmission: material.transmission > 0,
      transmissionMap: !!material.transmissionMap,
      thicknessMap: !!material.thicknessMap,
      combine: material.combine,
      vertexTangents: !!material.normalMap && !!geometry.attributes.tangent,
      vertexColors: material.vertexColors,
      vertexAlphas: material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4,
      vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || !!material.sheenColorMap || !!material.sheenRoughnessMap,
      uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || material.transmission > 0 || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || material.sheen > 0 || !!material.sheenColorMap || !!material.sheenRoughnessMap) && !!material.displacementMap,
      fog: !!fog,
      useFog: material.fog,
      fogExp2: fog && fog.isFogExp2,
      flatShading: !!material.flatShading,
      sizeAttenuation: material.sizeAttenuation,
      logarithmicDepthBuffer,
      skinning: object.isSkinnedMesh === true && maxBones > 0,
      maxBones,
      useVertexTexture: floatVertexTextures,
      morphTargets: geometry.morphAttributes.position !== void 0,
      morphNormals: geometry.morphAttributes.normal !== void 0,
      morphColors: geometry.morphAttributes.color !== void 0,
      morphTargetsCount,
      morphTextureStride,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numDirLightShadows: lights.directionalShadowMap.length,
      numPointLightShadows: lights.pointShadowMap.length,
      numSpotLightShadows: lights.spotShadowMap.length,
      numClippingPlanes: clipping.numPlanes,
      numClipIntersection: clipping.numIntersection,
      dithering: material.dithering,
      shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
      shadowMapType: renderer.shadowMap.type,
      toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
      physicallyCorrectLights: renderer.physicallyCorrectLights,
      premultipliedAlpha: material.premultipliedAlpha,
      doubleSided: material.side === DoubleSide,
      flipSided: material.side === BackSide,
      depthPacking: material.depthPacking !== void 0 ? material.depthPacking : false,
      index0AttributeName: material.index0AttributeName,
      extensionDerivatives: material.extensions && material.extensions.derivatives,
      extensionFragDepth: material.extensions && material.extensions.fragDepth,
      extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
      extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: isWebGL2 || extensions.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: isWebGL2 || extensions.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: isWebGL2 || extensions.has("EXT_shader_texture_lod"),
      customProgramCacheKey: material.customProgramCacheKey()
    };
    return parameters;
  }
  function getProgramCacheKey(parameters) {
    const array = [];
    if (parameters.shaderID) {
      array.push(parameters.shaderID);
    } else {
      array.push(parameters.customVertexShaderID);
      array.push(parameters.customFragmentShaderID);
    }
    if (parameters.defines !== void 0) {
      for (const name in parameters.defines) {
        array.push(name);
        array.push(parameters.defines[name]);
      }
    }
    if (parameters.isRawShaderMaterial === false) {
      getProgramCacheKeyParameters(array, parameters);
      getProgramCacheKeyBooleans(array, parameters);
      array.push(renderer.outputEncoding);
    }
    array.push(parameters.customProgramCacheKey);
    return array.join();
  }
  function getProgramCacheKeyParameters(array, parameters) {
    array.push(parameters.precision);
    array.push(parameters.outputEncoding);
    array.push(parameters.envMapMode);
    array.push(parameters.envMapCubeUVHeight);
    array.push(parameters.combine);
    array.push(parameters.vertexUvs);
    array.push(parameters.fogExp2);
    array.push(parameters.sizeAttenuation);
    array.push(parameters.maxBones);
    array.push(parameters.morphTargetsCount);
    array.push(parameters.morphAttributeCount);
    array.push(parameters.numDirLights);
    array.push(parameters.numPointLights);
    array.push(parameters.numSpotLights);
    array.push(parameters.numHemiLights);
    array.push(parameters.numRectAreaLights);
    array.push(parameters.numDirLightShadows);
    array.push(parameters.numPointLightShadows);
    array.push(parameters.numSpotLightShadows);
    array.push(parameters.shadowMapType);
    array.push(parameters.toneMapping);
    array.push(parameters.numClippingPlanes);
    array.push(parameters.numClipIntersection);
  }
  function getProgramCacheKeyBooleans(array, parameters) {
    _programLayers.disableAll();
    if (parameters.isWebGL2)
      _programLayers.enable(0);
    if (parameters.supportsVertexTextures)
      _programLayers.enable(1);
    if (parameters.instancing)
      _programLayers.enable(2);
    if (parameters.instancingColor)
      _programLayers.enable(3);
    if (parameters.map)
      _programLayers.enable(4);
    if (parameters.matcap)
      _programLayers.enable(5);
    if (parameters.envMap)
      _programLayers.enable(6);
    if (parameters.lightMap)
      _programLayers.enable(7);
    if (parameters.aoMap)
      _programLayers.enable(8);
    if (parameters.emissiveMap)
      _programLayers.enable(9);
    if (parameters.bumpMap)
      _programLayers.enable(10);
    if (parameters.normalMap)
      _programLayers.enable(11);
    if (parameters.objectSpaceNormalMap)
      _programLayers.enable(12);
    if (parameters.tangentSpaceNormalMap)
      _programLayers.enable(13);
    if (parameters.clearcoat)
      _programLayers.enable(14);
    if (parameters.clearcoatMap)
      _programLayers.enable(15);
    if (parameters.clearcoatRoughnessMap)
      _programLayers.enable(16);
    if (parameters.clearcoatNormalMap)
      _programLayers.enable(17);
    if (parameters.displacementMap)
      _programLayers.enable(18);
    if (parameters.specularMap)
      _programLayers.enable(19);
    if (parameters.roughnessMap)
      _programLayers.enable(20);
    if (parameters.metalnessMap)
      _programLayers.enable(21);
    if (parameters.gradientMap)
      _programLayers.enable(22);
    if (parameters.alphaMap)
      _programLayers.enable(23);
    if (parameters.alphaTest)
      _programLayers.enable(24);
    if (parameters.vertexColors)
      _programLayers.enable(25);
    if (parameters.vertexAlphas)
      _programLayers.enable(26);
    if (parameters.vertexUvs)
      _programLayers.enable(27);
    if (parameters.vertexTangents)
      _programLayers.enable(28);
    if (parameters.uvsVertexOnly)
      _programLayers.enable(29);
    if (parameters.fog)
      _programLayers.enable(30);
    array.push(_programLayers.mask);
    _programLayers.disableAll();
    if (parameters.useFog)
      _programLayers.enable(0);
    if (parameters.flatShading)
      _programLayers.enable(1);
    if (parameters.logarithmicDepthBuffer)
      _programLayers.enable(2);
    if (parameters.skinning)
      _programLayers.enable(3);
    if (parameters.useVertexTexture)
      _programLayers.enable(4);
    if (parameters.morphTargets)
      _programLayers.enable(5);
    if (parameters.morphNormals)
      _programLayers.enable(6);
    if (parameters.morphColors)
      _programLayers.enable(7);
    if (parameters.premultipliedAlpha)
      _programLayers.enable(8);
    if (parameters.shadowMapEnabled)
      _programLayers.enable(9);
    if (parameters.physicallyCorrectLights)
      _programLayers.enable(10);
    if (parameters.doubleSided)
      _programLayers.enable(11);
    if (parameters.flipSided)
      _programLayers.enable(12);
    if (parameters.depthPacking)
      _programLayers.enable(13);
    if (parameters.dithering)
      _programLayers.enable(14);
    if (parameters.specularIntensityMap)
      _programLayers.enable(15);
    if (parameters.specularColorMap)
      _programLayers.enable(16);
    if (parameters.transmission)
      _programLayers.enable(17);
    if (parameters.transmissionMap)
      _programLayers.enable(18);
    if (parameters.thicknessMap)
      _programLayers.enable(19);
    if (parameters.sheen)
      _programLayers.enable(20);
    if (parameters.sheenColorMap)
      _programLayers.enable(21);
    if (parameters.sheenRoughnessMap)
      _programLayers.enable(22);
    if (parameters.decodeVideoTexture)
      _programLayers.enable(23);
    if (parameters.opaque)
      _programLayers.enable(24);
    array.push(_programLayers.mask);
  }
  function getUniforms(material) {
    const shaderID = shaderIDs[material.type];
    let uniforms;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      uniforms = UniformsUtils.clone(shader.uniforms);
    } else {
      uniforms = material.uniforms;
    }
    return uniforms;
  }
  function acquireProgram(parameters, cacheKey) {
    let program;
    for (let p = 0, pl = programs.length; p < pl; p++) {
      const preexistingProgram = programs[p];
      if (preexistingProgram.cacheKey === cacheKey) {
        program = preexistingProgram;
        ++program.usedTimes;
        break;
      }
    }
    if (program === void 0) {
      program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
      programs.push(program);
    }
    return program;
  }
  function releaseProgram(program) {
    if (--program.usedTimes === 0) {
      const i2 = programs.indexOf(program);
      programs[i2] = programs[programs.length - 1];
      programs.pop();
      program.destroy();
    }
  }
  function releaseShaderCache(material) {
    _customShaders.remove(material);
  }
  function dispose() {
    _customShaders.dispose();
  }
  return {
    getParameters,
    getProgramCacheKey,
    getUniforms,
    acquireProgram,
    releaseProgram,
    releaseShaderCache,
    programs,
    dispose
  };
}
function WebGLProperties() {
  let properties = /* @__PURE__ */ new WeakMap();
  function get(object) {
    let map = properties.get(object);
    if (map === void 0) {
      map = {};
      properties.set(object, map);
    }
    return map;
  }
  function remove(object) {
    properties.delete(object);
  }
  function update(object, key, value) {
    properties.get(object)[key] = value;
  }
  function dispose() {
    properties = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    remove,
    update,
    dispose
  };
}
function painterSortStable(a, b2) {
  if (a.groupOrder !== b2.groupOrder) {
    return a.groupOrder - b2.groupOrder;
  } else if (a.renderOrder !== b2.renderOrder) {
    return a.renderOrder - b2.renderOrder;
  } else if (a.material.id !== b2.material.id) {
    return a.material.id - b2.material.id;
  } else if (a.z !== b2.z) {
    return a.z - b2.z;
  } else {
    return a.id - b2.id;
  }
}
function reversePainterSortStable(a, b2) {
  if (a.groupOrder !== b2.groupOrder) {
    return a.groupOrder - b2.groupOrder;
  } else if (a.renderOrder !== b2.renderOrder) {
    return a.renderOrder - b2.renderOrder;
  } else if (a.z !== b2.z) {
    return b2.z - a.z;
  } else {
    return a.id - b2.id;
  }
}
function WebGLRenderList() {
  const renderItems = [];
  let renderItemsIndex = 0;
  const opaque = [];
  const transmissive = [];
  const transparent = [];
  function init() {
    renderItemsIndex = 0;
    opaque.length = 0;
    transmissive.length = 0;
    transparent.length = 0;
  }
  function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
    let renderItem = renderItems[renderItemsIndex];
    if (renderItem === void 0) {
      renderItem = {
        id: object.id,
        object,
        geometry,
        material,
        groupOrder,
        renderOrder: object.renderOrder,
        z,
        group
      };
      renderItems[renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z;
      renderItem.group = group;
    }
    renderItemsIndex++;
    return renderItem;
  }
  function push(object, geometry, material, groupOrder, z, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
    if (material.transmission > 0) {
      transmissive.push(renderItem);
    } else if (material.transparent === true) {
      transparent.push(renderItem);
    } else {
      opaque.push(renderItem);
    }
  }
  function unshift(object, geometry, material, groupOrder, z, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
    if (material.transmission > 0) {
      transmissive.unshift(renderItem);
    } else if (material.transparent === true) {
      transparent.unshift(renderItem);
    } else {
      opaque.unshift(renderItem);
    }
  }
  function sort(customOpaqueSort, customTransparentSort) {
    if (opaque.length > 1)
      opaque.sort(customOpaqueSort || painterSortStable);
    if (transmissive.length > 1)
      transmissive.sort(customTransparentSort || reversePainterSortStable);
    if (transparent.length > 1)
      transparent.sort(customTransparentSort || reversePainterSortStable);
  }
  function finish() {
    for (let i2 = renderItemsIndex, il = renderItems.length; i2 < il; i2++) {
      const renderItem = renderItems[i2];
      if (renderItem.id === null)
        break;
      renderItem.id = null;
      renderItem.object = null;
      renderItem.geometry = null;
      renderItem.material = null;
      renderItem.group = null;
    }
  }
  return {
    opaque,
    transmissive,
    transparent,
    init,
    push,
    unshift,
    finish,
    sort
  };
}
function WebGLRenderLists() {
  let lists = /* @__PURE__ */ new WeakMap();
  function get(scene, renderCallDepth) {
    let list;
    if (lists.has(scene) === false) {
      list = new WebGLRenderList();
      lists.set(scene, [list]);
    } else {
      if (renderCallDepth >= lists.get(scene).length) {
        list = new WebGLRenderList();
        lists.get(scene).push(list);
      } else {
        list = lists.get(scene)[renderCallDepth];
      }
    }
    return list;
  }
  function dispose() {
    lists = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    dispose
  };
}
function UniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            direction: new Vector3(),
            color: new Color()
          };
          break;
        case "SpotLight":
          uniforms = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          uniforms = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          uniforms = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color()
          };
          break;
        case "RectAreaLight":
          uniforms = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3()
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
function ShadowUniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "SpotLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "PointLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
function shadowCastingLightsFirst(lightA, lightB) {
  return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
}
function WebGLLights(extensions, capabilities) {
  const cache = new UniformsCache();
  const shadowCache = ShadowUniformsCache();
  const state = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadow: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: []
  };
  for (let i2 = 0; i2 < 9; i2++)
    state.probe.push(new Vector3());
  const vector3 = new Vector3();
  const matrix4 = new Matrix4();
  const matrix42 = new Matrix4();
  function setup(lights, physicallyCorrectLights) {
    let r3 = 0, g = 0, b2 = 0;
    for (let i2 = 0; i2 < 9; i2++)
      state.probe[i2].set(0, 0, 0);
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    let numDirectionalShadows = 0;
    let numPointShadows = 0;
    let numSpotShadows = 0;
    lights.sort(shadowCastingLightsFirst);
    const scaleFactor = physicallyCorrectLights !== true ? Math.PI : 1;
    for (let i2 = 0, l = lights.length; i2 < l; i2++) {
      const light = lights[i2];
      const color = light.color;
      const intensity = light.intensity;
      const distance = light.distance;
      const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
      if (light.isAmbientLight) {
        r3 += color.r * intensity * scaleFactor;
        g += color.g * intensity * scaleFactor;
        b2 += color.b * intensity * scaleFactor;
      } else if (light.isLightProbe) {
        for (let j = 0; j < 9; j++) {
          state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
        }
      } else if (light.isDirectionalLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.directionalShadow[directionalLength] = shadowUniforms;
          state.directionalShadowMap[directionalLength] = shadowMap;
          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
          numDirectionalShadows++;
        }
        state.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = cache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.color.copy(color).multiplyScalar(intensity * scaleFactor);
        uniforms.distance = distance;
        uniforms.coneCos = Math.cos(light.angle);
        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
        uniforms.decay = light.decay;
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.spotShadow[spotLength] = shadowUniforms;
          state.spotShadowMap[spotLength] = shadowMap;
          state.spotShadowMatrix[spotLength] = light.shadow.matrix;
          numSpotShadows++;
        }
        state.spot[spotLength] = uniforms;
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        state.rectArea[rectAreaLength] = uniforms;
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
        uniforms.distance = light.distance;
        uniforms.decay = light.decay;
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          shadowUniforms.shadowCameraNear = shadow.camera.near;
          shadowUniforms.shadowCameraFar = shadow.camera.far;
          state.pointShadow[pointLength] = shadowUniforms;
          state.pointShadowMap[pointLength] = shadowMap;
          state.pointShadowMatrix[pointLength] = light.shadow.matrix;
          numPointShadows++;
        }
        state.point[pointLength] = uniforms;
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = cache.get(light);
        uniforms.skyColor.copy(light.color).multiplyScalar(intensity * scaleFactor);
        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity * scaleFactor);
        state.hemi[hemiLength] = uniforms;
        hemiLength++;
      }
    }
    if (rectAreaLength > 0) {
      if (capabilities.isWebGL2) {
        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
      } else {
        if (extensions.has("OES_texture_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
        } else if (extensions.has("OES_texture_half_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
          state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
        } else {
          console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.");
        }
      }
    }
    state.ambient[0] = r3;
    state.ambient[1] = g;
    state.ambient[2] = b2;
    const hash = state.hash;
    if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
      state.directional.length = directionalLength;
      state.spot.length = spotLength;
      state.rectArea.length = rectAreaLength;
      state.point.length = pointLength;
      state.hemi.length = hemiLength;
      state.directionalShadow.length = numDirectionalShadows;
      state.directionalShadowMap.length = numDirectionalShadows;
      state.pointShadow.length = numPointShadows;
      state.pointShadowMap.length = numPointShadows;
      state.spotShadow.length = numSpotShadows;
      state.spotShadowMap.length = numSpotShadows;
      state.directionalShadowMatrix.length = numDirectionalShadows;
      state.pointShadowMatrix.length = numPointShadows;
      state.spotShadowMatrix.length = numSpotShadows;
      hash.directionalLength = directionalLength;
      hash.pointLength = pointLength;
      hash.spotLength = spotLength;
      hash.rectAreaLength = rectAreaLength;
      hash.hemiLength = hemiLength;
      hash.numDirectionalShadows = numDirectionalShadows;
      hash.numPointShadows = numPointShadows;
      hash.numSpotShadows = numSpotShadows;
      state.version = nextVersion++;
    }
  }
  function setupView(lights, camera) {
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    const viewMatrix = camera.matrixWorldInverse;
    for (let i2 = 0, l = lights.length; i2 < l; i2++) {
      const light = lights[i2];
      if (light.isDirectionalLight) {
        const uniforms = state.directional[directionalLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = state.spot[spotLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = state.rectArea[rectAreaLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        matrix42.identity();
        matrix4.copy(light.matrixWorld);
        matrix4.premultiply(viewMatrix);
        matrix42.extractRotation(matrix4);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        uniforms.halfWidth.applyMatrix4(matrix42);
        uniforms.halfHeight.applyMatrix4(matrix42);
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = state.point[pointLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = state.hemi[hemiLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        uniforms.direction.transformDirection(viewMatrix);
        uniforms.direction.normalize();
        hemiLength++;
      }
    }
  }
  return {
    setup,
    setupView,
    state
  };
}
function WebGLRenderState(extensions, capabilities) {
  const lights = new WebGLLights(extensions, capabilities);
  const lightsArray = [];
  const shadowsArray = [];
  function init() {
    lightsArray.length = 0;
    shadowsArray.length = 0;
  }
  function pushLight(light) {
    lightsArray.push(light);
  }
  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight);
  }
  function setupLights(physicallyCorrectLights) {
    lights.setup(lightsArray, physicallyCorrectLights);
  }
  function setupLightsView(camera) {
    lights.setupView(lightsArray, camera);
  }
  const state = {
    lightsArray,
    shadowsArray,
    lights
  };
  return {
    init,
    state,
    setupLights,
    setupLightsView,
    pushLight,
    pushShadow
  };
}
function WebGLRenderStates(extensions, capabilities) {
  let renderStates = /* @__PURE__ */ new WeakMap();
  function get(scene, renderCallDepth = 0) {
    let renderState;
    if (renderStates.has(scene) === false) {
      renderState = new WebGLRenderState(extensions, capabilities);
      renderStates.set(scene, [renderState]);
    } else {
      if (renderCallDepth >= renderStates.get(scene).length) {
        renderState = new WebGLRenderState(extensions, capabilities);
        renderStates.get(scene).push(renderState);
      } else {
        renderState = renderStates.get(scene)[renderCallDepth];
      }
    }
    return renderState;
  }
  function dispose() {
    renderStates = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    dispose
  };
}
function WebGLShadowMap(_renderer, _objects, _capabilities) {
  let _frustum = new Frustum();
  const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }), _distanceMaterial = new MeshDistanceMaterial(), _materialCache = {}, _maxTextureSize = _capabilities.maxTextureSize;
  const shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };
  const shadowMaterialVertical = new ShaderMaterial({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Vector2() },
      radius: { value: 4 }
    },
    vertexShader: vertex,
    fragmentShader: fragment
  });
  const shadowMaterialHorizontal = shadowMaterialVertical.clone();
  shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
  const fullScreenTri = new BufferGeometry();
  fullScreenTri.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
  const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
  const scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = PCFShadowMap;
  this.render = function(lights, scene, camera) {
    if (scope.enabled === false)
      return;
    if (scope.autoUpdate === false && scope.needsUpdate === false)
      return;
    if (lights.length === 0)
      return;
    const currentRenderTarget = _renderer.getRenderTarget();
    const activeCubeFace = _renderer.getActiveCubeFace();
    const activeMipmapLevel = _renderer.getActiveMipmapLevel();
    const _state = _renderer.state;
    _state.setBlending(NoBlending);
    _state.buffers.color.setClear(1, 1, 1, 1);
    _state.buffers.depth.setTest(true);
    _state.setScissorTest(false);
    for (let i2 = 0, il = lights.length; i2 < il; i2++) {
      const light = lights[i2];
      const shadow = light.shadow;
      if (shadow === void 0) {
        console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
        continue;
      }
      if (shadow.autoUpdate === false && shadow.needsUpdate === false)
        continue;
      _shadowMapSize.copy(shadow.mapSize);
      const shadowFrameExtents = shadow.getFrameExtents();
      _shadowMapSize.multiply(shadowFrameExtents);
      _viewportSize.copy(shadow.mapSize);
      if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
        if (_shadowMapSize.x > _maxTextureSize) {
          _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
          shadow.mapSize.x = _viewportSize.x;
        }
        if (_shadowMapSize.y > _maxTextureSize) {
          _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
          shadow.mapSize.y = _viewportSize.y;
        }
      }
      if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y);
        shadow.camera.updateProjectionMatrix();
      }
      if (shadow.map === null) {
        const pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.camera.updateProjectionMatrix();
      }
      _renderer.setRenderTarget(shadow.map);
      _renderer.clear();
      const viewportCount = shadow.getViewportCount();
      for (let vp = 0; vp < viewportCount; vp++) {
        const viewport = shadow.getViewport(vp);
        _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
        _state.viewport(_viewport);
        shadow.updateMatrices(light, vp);
        _frustum = shadow.getFrustum();
        renderObject(scene, camera, shadow.camera, light, this.type);
      }
      if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
        VSMPass(shadow, camera);
      }
      shadow.needsUpdate = false;
    }
    scope.needsUpdate = false;
    _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
  };
  function VSMPass(shadow, camera) {
    const geometry = _objects.update(fullScreenMesh);
    if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {
      shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
      shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;
      shadowMaterialVertical.needsUpdate = true;
      shadowMaterialHorizontal.needsUpdate = true;
    }
    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialVertical.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.mapPass);
    _renderer.clear();
    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
    shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
    shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.map);
    _renderer.clear();
    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
  }
  function getDepthMaterial(object, material, light, shadowCameraNear, shadowCameraFar, type) {
    let result = null;
    const customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;
    if (customMaterial !== void 0) {
      result = customMaterial;
    } else {
      result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
    }
    if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0) {
      const keyA = result.uuid, keyB = material.uuid;
      let materialsForVariant = _materialCache[keyA];
      if (materialsForVariant === void 0) {
        materialsForVariant = {};
        _materialCache[keyA] = materialsForVariant;
      }
      let cachedMaterial = materialsForVariant[keyB];
      if (cachedMaterial === void 0) {
        cachedMaterial = result.clone();
        materialsForVariant[keyB] = cachedMaterial;
      }
      result = cachedMaterial;
    }
    result.visible = material.visible;
    result.wireframe = material.wireframe;
    if (type === VSMShadowMap) {
      result.side = material.shadowSide !== null ? material.shadowSide : material.side;
    } else {
      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
    }
    result.alphaMap = material.alphaMap;
    result.alphaTest = material.alphaTest;
    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.clipIntersection = material.clipIntersection;
    result.displacementMap = material.displacementMap;
    result.displacementScale = material.displacementScale;
    result.displacementBias = material.displacementBias;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;
    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
      result.referencePosition.setFromMatrixPosition(light.matrixWorld);
      result.nearDistance = shadowCameraNear;
      result.farDistance = shadowCameraFar;
    }
    return result;
  }
  function renderObject(object, camera, shadowCamera, light, type) {
    if (object.visible === false)
      return;
    const visible = object.layers.test(camera.layers);
    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
      if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
        const geometry = _objects.update(object);
        const material = object.material;
        if (Array.isArray(material)) {
          const groups = geometry.groups;
          for (let k = 0, kl = groups.length; k < kl; k++) {
            const group = groups[k];
            const groupMaterial = material[group.materialIndex];
            if (groupMaterial && groupMaterial.visible) {
              const depthMaterial = getDepthMaterial(object, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
              _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
            }
          }
        } else if (material.visible) {
          const depthMaterial = getDepthMaterial(object, material, light, shadowCamera.near, shadowCamera.far, type);
          _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
        }
      }
    }
    const children = object.children;
    for (let i2 = 0, l = children.length; i2 < l; i2++) {
      renderObject(children[i2], camera, shadowCamera, light, type);
    }
  }
}
function WebGLState(gl, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function ColorBuffer() {
    let locked = false;
    const color = new Vector4();
    let currentColorMask = null;
    const currentColorClear = new Vector4(0, 0, 0, 0);
    return {
      setMask: function(colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl.colorMask(colorMask, colorMask, colorMask, colorMask);
          currentColorMask = colorMask;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(r3, g, b2, a, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r3 *= a;
          g *= a;
          b2 *= a;
        }
        color.set(r3, g, b2, a);
        if (currentColorClear.equals(color) === false) {
          gl.clearColor(r3, g, b2, a);
          currentColorClear.copy(color);
        }
      },
      reset: function() {
        locked = false;
        currentColorMask = null;
        currentColorClear.set(-1, 0, 0, 0);
      }
    };
  }
  function DepthBuffer() {
    let locked = false;
    let currentDepthMask = null;
    let currentDepthFunc = null;
    let currentDepthClear = null;
    return {
      setTest: function(depthTest) {
        if (depthTest) {
          enable(2929);
        } else {
          disable(2929);
        }
      },
      setMask: function(depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl.depthMask(depthMask);
          currentDepthMask = depthMask;
        }
      },
      setFunc: function(depthFunc) {
        if (currentDepthFunc !== depthFunc) {
          if (depthFunc) {
            switch (depthFunc) {
              case NeverDepth:
                gl.depthFunc(512);
                break;
              case AlwaysDepth:
                gl.depthFunc(519);
                break;
              case LessDepth:
                gl.depthFunc(513);
                break;
              case LessEqualDepth:
                gl.depthFunc(515);
                break;
              case EqualDepth:
                gl.depthFunc(514);
                break;
              case GreaterEqualDepth:
                gl.depthFunc(518);
                break;
              case GreaterDepth:
                gl.depthFunc(516);
                break;
              case NotEqualDepth:
                gl.depthFunc(517);
                break;
              default:
                gl.depthFunc(515);
            }
          } else {
            gl.depthFunc(515);
          }
          currentDepthFunc = depthFunc;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(depth) {
        if (currentDepthClear !== depth) {
          gl.clearDepth(depth);
          currentDepthClear = depth;
        }
      },
      reset: function() {
        locked = false;
        currentDepthMask = null;
        currentDepthFunc = null;
        currentDepthClear = null;
      }
    };
  }
  function StencilBuffer() {
    let locked = false;
    let currentStencilMask = null;
    let currentStencilFunc = null;
    let currentStencilRef = null;
    let currentStencilFuncMask = null;
    let currentStencilFail = null;
    let currentStencilZFail = null;
    let currentStencilZPass = null;
    let currentStencilClear = null;
    return {
      setTest: function(stencilTest) {
        if (!locked) {
          if (stencilTest) {
            enable(2960);
          } else {
            disable(2960);
          }
        }
      },
      setMask: function(stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl.stencilMask(stencilMask);
          currentStencilMask = stencilMask;
        }
      },
      setFunc: function(stencilFunc, stencilRef, stencilMask) {
        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
          currentStencilFunc = stencilFunc;
          currentStencilRef = stencilRef;
          currentStencilFuncMask = stencilMask;
        }
      },
      setOp: function(stencilFail, stencilZFail, stencilZPass) {
        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
          currentStencilFail = stencilFail;
          currentStencilZFail = stencilZFail;
          currentStencilZPass = stencilZPass;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(stencil) {
        if (currentStencilClear !== stencil) {
          gl.clearStencil(stencil);
          currentStencilClear = stencil;
        }
      },
      reset: function() {
        locked = false;
        currentStencilMask = null;
        currentStencilFunc = null;
        currentStencilRef = null;
        currentStencilFuncMask = null;
        currentStencilFail = null;
        currentStencilZFail = null;
        currentStencilZPass = null;
        currentStencilClear = null;
      }
    };
  }
  const colorBuffer = new ColorBuffer();
  const depthBuffer = new DepthBuffer();
  const stencilBuffer = new StencilBuffer();
  let enabledCapabilities = {};
  let currentBoundFramebuffers = {};
  let currentDrawbuffers = /* @__PURE__ */ new WeakMap();
  let defaultDrawbuffers = [];
  let currentProgram = null;
  let currentBlendingEnabled = false;
  let currentBlending = null;
  let currentBlendEquation = null;
  let currentBlendSrc = null;
  let currentBlendDst = null;
  let currentBlendEquationAlpha = null;
  let currentBlendSrcAlpha = null;
  let currentBlendDstAlpha = null;
  let currentPremultipledAlpha = false;
  let currentFlipSided = null;
  let currentCullFace = null;
  let currentLineWidth = null;
  let currentPolygonOffsetFactor = null;
  let currentPolygonOffsetUnits = null;
  const maxTextures = gl.getParameter(35661);
  let lineWidthAvailable = false;
  let version = 0;
  const glVersion = gl.getParameter(7938);
  if (glVersion.indexOf("WebGL") !== -1) {
    version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 1;
  } else if (glVersion.indexOf("OpenGL ES") !== -1) {
    version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 2;
  }
  let currentTextureSlot = null;
  let currentBoundTextures = {};
  const scissorParam = gl.getParameter(3088);
  const viewportParam = gl.getParameter(2978);
  const currentScissor = new Vector4().fromArray(scissorParam);
  const currentViewport = new Vector4().fromArray(viewportParam);
  function createTexture(type, target, count) {
    const data = new Uint8Array(4);
    const texture = gl.createTexture();
    gl.bindTexture(type, texture);
    gl.texParameteri(type, 10241, 9728);
    gl.texParameteri(type, 10240, 9728);
    for (let i2 = 0; i2 < count; i2++) {
      gl.texImage2D(target + i2, 0, 6408, 1, 1, 0, 6408, 5121, data);
    }
    return texture;
  }
  const emptyTextures = {};
  emptyTextures[3553] = createTexture(3553, 3553, 1);
  emptyTextures[34067] = createTexture(34067, 34069, 6);
  colorBuffer.setClear(0, 0, 0, 1);
  depthBuffer.setClear(1);
  stencilBuffer.setClear(0);
  enable(2929);
  depthBuffer.setFunc(LessEqualDepth);
  setFlipSided(false);
  setCullFace(CullFaceBack);
  enable(2884);
  setBlending(NoBlending);
  function enable(id) {
    if (enabledCapabilities[id] !== true) {
      gl.enable(id);
      enabledCapabilities[id] = true;
    }
  }
  function disable(id) {
    if (enabledCapabilities[id] !== false) {
      gl.disable(id);
      enabledCapabilities[id] = false;
    }
  }
  function bindFramebuffer(target, framebuffer) {
    if (currentBoundFramebuffers[target] !== framebuffer) {
      gl.bindFramebuffer(target, framebuffer);
      currentBoundFramebuffers[target] = framebuffer;
      if (isWebGL2) {
        if (target === 36009) {
          currentBoundFramebuffers[36160] = framebuffer;
        }
        if (target === 36160) {
          currentBoundFramebuffers[36009] = framebuffer;
        }
      }
      return true;
    }
    return false;
  }
  function drawBuffers(renderTarget, framebuffer) {
    let drawBuffers2 = defaultDrawbuffers;
    let needsUpdate = false;
    if (renderTarget) {
      drawBuffers2 = currentDrawbuffers.get(framebuffer);
      if (drawBuffers2 === void 0) {
        drawBuffers2 = [];
        currentDrawbuffers.set(framebuffer, drawBuffers2);
      }
      if (renderTarget.isWebGLMultipleRenderTargets) {
        const textures = renderTarget.texture;
        if (drawBuffers2.length !== textures.length || drawBuffers2[0] !== 36064) {
          for (let i2 = 0, il = textures.length; i2 < il; i2++) {
            drawBuffers2[i2] = 36064 + i2;
          }
          drawBuffers2.length = textures.length;
          needsUpdate = true;
        }
      } else {
        if (drawBuffers2[0] !== 36064) {
          drawBuffers2[0] = 36064;
          needsUpdate = true;
        }
      }
    } else {
      if (drawBuffers2[0] !== 1029) {
        drawBuffers2[0] = 1029;
        needsUpdate = true;
      }
    }
    if (needsUpdate) {
      if (capabilities.isWebGL2) {
        gl.drawBuffers(drawBuffers2);
      } else {
        extensions.get("WEBGL_draw_buffers").drawBuffersWEBGL(drawBuffers2);
      }
    }
  }
  function useProgram(program) {
    if (currentProgram !== program) {
      gl.useProgram(program);
      currentProgram = program;
      return true;
    }
    return false;
  }
  const equationToGL = {
    [AddEquation]: 32774,
    [SubtractEquation]: 32778,
    [ReverseSubtractEquation]: 32779
  };
  if (isWebGL2) {
    equationToGL[MinEquation] = 32775;
    equationToGL[MaxEquation] = 32776;
  } else {
    const extension = extensions.get("EXT_blend_minmax");
    if (extension !== null) {
      equationToGL[MinEquation] = extension.MIN_EXT;
      equationToGL[MaxEquation] = extension.MAX_EXT;
    }
  }
  const factorToGL = {
    [ZeroFactor]: 0,
    [OneFactor]: 1,
    [SrcColorFactor]: 768,
    [SrcAlphaFactor]: 770,
    [SrcAlphaSaturateFactor]: 776,
    [DstColorFactor]: 774,
    [DstAlphaFactor]: 772,
    [OneMinusSrcColorFactor]: 769,
    [OneMinusSrcAlphaFactor]: 771,
    [OneMinusDstColorFactor]: 775,
    [OneMinusDstAlphaFactor]: 773
  };
  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
    if (blending === NoBlending) {
      if (currentBlendingEnabled === true) {
        disable(3042);
        currentBlendingEnabled = false;
      }
      return;
    }
    if (currentBlendingEnabled === false) {
      enable(3042);
      currentBlendingEnabled = true;
    }
    if (blending !== CustomBlending) {
      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
          gl.blendEquation(32774);
          currentBlendEquation = AddEquation;
          currentBlendEquationAlpha = AddEquation;
        }
        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(1, 771, 1, 771);
              break;
            case AdditiveBlending:
              gl.blendFunc(1, 1);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(0, 769, 0, 1);
              break;
            case MultiplyBlending:
              gl.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(770, 771, 1, 771);
              break;
            case AdditiveBlending:
              gl.blendFunc(770, 1);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(0, 769, 0, 1);
              break;
            case MultiplyBlending:
              gl.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        }
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentBlending = blending;
        currentPremultipledAlpha = premultipliedAlpha;
      }
      return;
    }
    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;
    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
      currentBlendEquation = blendEquation;
      currentBlendEquationAlpha = blendEquationAlpha;
    }
    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
      currentBlendSrc = blendSrc;
      currentBlendDst = blendDst;
      currentBlendSrcAlpha = blendSrcAlpha;
      currentBlendDstAlpha = blendDstAlpha;
    }
    currentBlending = blending;
    currentPremultipledAlpha = null;
  }
  function setMaterial(material, frontFaceCW) {
    material.side === DoubleSide ? disable(2884) : enable(2884);
    let flipSided = material.side === BackSide;
    if (frontFaceCW)
      flipSided = !flipSided;
    setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
    depthBuffer.setFunc(material.depthFunc);
    depthBuffer.setTest(material.depthTest);
    depthBuffer.setMask(material.depthWrite);
    colorBuffer.setMask(material.colorWrite);
    const stencilWrite = material.stencilWrite;
    stencilBuffer.setTest(stencilWrite);
    if (stencilWrite) {
      stencilBuffer.setMask(material.stencilWriteMask);
      stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
      stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
    }
    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    material.alphaToCoverage === true ? enable(32926) : disable(32926);
  }
  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl.frontFace(2304);
      } else {
        gl.frontFace(2305);
      }
      currentFlipSided = flipSided;
    }
  }
  function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
      enable(2884);
      if (cullFace !== currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(1029);
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(1028);
        } else {
          gl.cullFace(1032);
        }
      }
    } else {
      disable(2884);
    }
    currentCullFace = cullFace;
  }
  function setLineWidth(width) {
    if (width !== currentLineWidth) {
      if (lineWidthAvailable)
        gl.lineWidth(width);
      currentLineWidth = width;
    }
  }
  function setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
      enable(32823);
      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
        gl.polygonOffset(factor, units);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units;
      }
    } else {
      disable(32823);
    }
  }
  function setScissorTest(scissorTest) {
    if (scissorTest) {
      enable(3089);
    } else {
      disable(3089);
    }
  }
  function activeTexture(webglSlot) {
    if (webglSlot === void 0)
      webglSlot = 33984 + maxTextures - 1;
    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  }
  function bindTexture(webglType, webglTexture) {
    if (currentTextureSlot === null) {
      activeTexture();
    }
    let boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture === void 0) {
      boundTexture = { type: void 0, texture: void 0 };
      currentBoundTextures[currentTextureSlot] = boundTexture;
    }
    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }
  function unbindTexture() {
    const boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture !== void 0 && boundTexture.type !== void 0) {
      gl.bindTexture(boundTexture.type, null);
      boundTexture.type = void 0;
      boundTexture.texture = void 0;
    }
  }
  function compressedTexImage2D() {
    try {
      gl.compressedTexImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texSubImage2D() {
    try {
      gl.texSubImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texSubImage3D() {
    try {
      gl.texSubImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function compressedTexSubImage2D() {
    try {
      gl.compressedTexSubImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texStorage2D() {
    try {
      gl.texStorage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texStorage3D() {
    try {
      gl.texStorage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage2D() {
    try {
      gl.texImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage3D() {
    try {
      gl.texImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function scissor(scissor2) {
    if (currentScissor.equals(scissor2) === false) {
      gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
      currentScissor.copy(scissor2);
    }
  }
  function viewport(viewport2) {
    if (currentViewport.equals(viewport2) === false) {
      gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
      currentViewport.copy(viewport2);
    }
  }
  function reset() {
    gl.disable(3042);
    gl.disable(2884);
    gl.disable(2929);
    gl.disable(32823);
    gl.disable(3089);
    gl.disable(2960);
    gl.disable(32926);
    gl.blendEquation(32774);
    gl.blendFunc(1, 0);
    gl.blendFuncSeparate(1, 0, 1, 0);
    gl.colorMask(true, true, true, true);
    gl.clearColor(0, 0, 0, 0);
    gl.depthMask(true);
    gl.depthFunc(513);
    gl.clearDepth(1);
    gl.stencilMask(4294967295);
    gl.stencilFunc(519, 0, 4294967295);
    gl.stencilOp(7680, 7680, 7680);
    gl.clearStencil(0);
    gl.cullFace(1029);
    gl.frontFace(2305);
    gl.polygonOffset(0, 0);
    gl.activeTexture(33984);
    gl.bindFramebuffer(36160, null);
    if (isWebGL2 === true) {
      gl.bindFramebuffer(36009, null);
      gl.bindFramebuffer(36008, null);
    }
    gl.useProgram(null);
    gl.lineWidth(1);
    gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    enabledCapabilities = {};
    currentTextureSlot = null;
    currentBoundTextures = {};
    currentBoundFramebuffers = {};
    currentDrawbuffers = /* @__PURE__ */ new WeakMap();
    defaultDrawbuffers = [];
    currentProgram = null;
    currentBlendingEnabled = false;
    currentBlending = null;
    currentBlendEquation = null;
    currentBlendSrc = null;
    currentBlendDst = null;
    currentBlendEquationAlpha = null;
    currentBlendSrcAlpha = null;
    currentBlendDstAlpha = null;
    currentPremultipledAlpha = false;
    currentFlipSided = null;
    currentCullFace = null;
    currentLineWidth = null;
    currentPolygonOffsetFactor = null;
    currentPolygonOffsetUnits = null;
    currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
    currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
  }
  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer
    },
    enable,
    disable,
    bindFramebuffer,
    drawBuffers,
    useProgram,
    setBlending,
    setMaterial,
    setFlipSided,
    setCullFace,
    setLineWidth,
    setPolygonOffset,
    setScissorTest,
    activeTexture,
    bindTexture,
    unbindTexture,
    compressedTexImage2D,
    texImage2D,
    texImage3D,
    texStorage2D,
    texStorage3D,
    texSubImage2D,
    texSubImage3D,
    compressedTexSubImage2D,
    scissor,
    viewport,
    reset
  };
}
function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
  const isWebGL2 = capabilities.isWebGL2;
  const maxTextures = capabilities.maxTextures;
  const maxCubemapSize = capabilities.maxCubemapSize;
  const maxTextureSize = capabilities.maxTextureSize;
  const maxSamples = capabilities.maxSamples;
  const multisampledRTTExt = extensions.has("WEBGL_multisampled_render_to_texture") ? extensions.get("WEBGL_multisampled_render_to_texture") : null;
  const supportsInvalidateFramebuffer = /OculusBrowser/g.test(navigator.userAgent);
  const _videoTextures = /* @__PURE__ */ new WeakMap();
  let _canvas2;
  const _sources = /* @__PURE__ */ new WeakMap();
  let useOffscreenCanvas = false;
  try {
    useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch (err2) {
  }
  function createCanvas(width, height) {
    return useOffscreenCanvas ? new OffscreenCanvas(width, height) : createElementNS("canvas");
  }
  function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
    let scale = 1;
    if (image.width > maxSize || image.height > maxSize) {
      scale = maxSize / Math.max(image.width, image.height);
    }
    if (scale < 1 || needsPowerOfTwo === true) {
      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
        const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;
        const width = floor(scale * image.width);
        const height = floor(scale * image.height);
        if (_canvas2 === void 0)
          _canvas2 = createCanvas(width, height);
        const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas2;
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext("2d");
        context.drawImage(image, 0, 0, width, height);
        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + width + "x" + height + ").");
        return canvas;
      } else {
        if ("data" in image) {
          console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ").");
        }
        return image;
      }
    }
    return image;
  }
  function isPowerOfTwo$1(image) {
    return isPowerOfTwo(image.width) && isPowerOfTwo(image.height);
  }
  function textureNeedsPowerOfTwo(texture) {
    if (isWebGL2)
      return false;
    return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function textureNeedsGenerateMipmaps(texture, supportsMips) {
    return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function generateMipmap(target) {
    _gl.generateMipmap(target);
  }
  function getInternalFormat(internalFormatName, glFormat, glType, encoding, isVideoTexture = false) {
    if (isWebGL2 === false)
      return glFormat;
    if (internalFormatName !== null) {
      if (_gl[internalFormatName] !== void 0)
        return _gl[internalFormatName];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
    }
    let internalFormat = glFormat;
    if (glFormat === 6403) {
      if (glType === 5126)
        internalFormat = 33326;
      if (glType === 5131)
        internalFormat = 33325;
      if (glType === 5121)
        internalFormat = 33321;
    }
    if (glFormat === 33319) {
      if (glType === 5126)
        internalFormat = 33328;
      if (glType === 5131)
        internalFormat = 33327;
      if (glType === 5121)
        internalFormat = 33323;
    }
    if (glFormat === 6408) {
      if (glType === 5126)
        internalFormat = 34836;
      if (glType === 5131)
        internalFormat = 34842;
      if (glType === 5121)
        internalFormat = encoding === sRGBEncoding && isVideoTexture === false ? 35907 : 32856;
      if (glType === 32819)
        internalFormat = 32854;
      if (glType === 32820)
        internalFormat = 32855;
    }
    if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 33327 || internalFormat === 33328 || internalFormat === 34842 || internalFormat === 34836) {
      extensions.get("EXT_color_buffer_float");
    }
    return internalFormat;
  }
  function getMipLevels(texture, image, supportsMips) {
    if (textureNeedsGenerateMipmaps(texture, supportsMips) === true || texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
      return Math.log2(Math.max(image.width, image.height)) + 1;
    } else if (texture.mipmaps !== void 0 && texture.mipmaps.length > 0) {
      return texture.mipmaps.length;
    } else if (texture.isCompressedTexture && Array.isArray(texture.image)) {
      return image.mipmaps.length;
    } else {
      return 1;
    }
  }
  function filterFallback(f) {
    if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
      return 9728;
    }
    return 9729;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    deallocateTexture(texture);
    if (texture.isVideoTexture) {
      _videoTextures.delete(texture);
    }
  }
  function onRenderTargetDispose(event) {
    const renderTarget = event.target;
    renderTarget.removeEventListener("dispose", onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
  }
  function deallocateTexture(texture) {
    const textureProperties = properties.get(texture);
    if (textureProperties.__webglInit === void 0)
      return;
    const source = texture.source;
    const webglTextures = _sources.get(source);
    if (webglTextures) {
      const webglTexture = webglTextures[textureProperties.__cacheKey];
      webglTexture.usedTimes--;
      if (webglTexture.usedTimes === 0) {
        deleteTexture(texture);
      }
      if (Object.keys(webglTextures).length === 0) {
        _sources.delete(source);
      }
    }
    properties.remove(texture);
  }
  function deleteTexture(texture) {
    const textureProperties = properties.get(texture);
    _gl.deleteTexture(textureProperties.__webglTexture);
    const source = texture.source;
    const webglTextures = _sources.get(source);
    delete webglTextures[textureProperties.__cacheKey];
    info.memory.textures--;
  }
  function deallocateRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    if (textureProperties.__webglTexture !== void 0) {
      _gl.deleteTexture(textureProperties.__webglTexture);
      info.memory.textures--;
    }
    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose();
    }
    if (renderTarget.isWebGLCubeRenderTarget) {
      for (let i2 = 0; i2 < 6; i2++) {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i2]);
        if (renderTargetProperties.__webglDepthbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i2]);
      }
    } else {
      _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
      if (renderTargetProperties.__webglDepthbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
      if (renderTargetProperties.__webglMultisampledFramebuffer)
        _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
      if (renderTargetProperties.__webglColorRenderbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
      if (renderTargetProperties.__webglDepthRenderbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
    }
    if (renderTarget.isWebGLMultipleRenderTargets) {
      for (let i2 = 0, il = texture.length; i2 < il; i2++) {
        const attachmentProperties = properties.get(texture[i2]);
        if (attachmentProperties.__webglTexture) {
          _gl.deleteTexture(attachmentProperties.__webglTexture);
          info.memory.textures--;
        }
        properties.remove(texture[i2]);
      }
    }
    properties.remove(texture);
    properties.remove(renderTarget);
  }
  let textureUnits = 0;
  function resetTextureUnits() {
    textureUnits = 0;
  }
  function allocateTextureUnit() {
    const textureUnit = textureUnits;
    if (textureUnit >= maxTextures) {
      console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + maxTextures);
    }
    textureUnits += 1;
    return textureUnit;
  }
  function getTextureCacheKey(texture) {
    const array = [];
    array.push(texture.wrapS);
    array.push(texture.wrapT);
    array.push(texture.magFilter);
    array.push(texture.minFilter);
    array.push(texture.anisotropy);
    array.push(texture.internalFormat);
    array.push(texture.format);
    array.push(texture.type);
    array.push(texture.generateMipmaps);
    array.push(texture.premultiplyAlpha);
    array.push(texture.flipY);
    array.push(texture.unpackAlignment);
    array.push(texture.encoding);
    return array.join();
  }
  function setTexture2D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.isVideoTexture)
      updateVideoTexture(texture);
    if (texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version) {
      const image = texture.image;
      if (image === null) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      } else if (image.complete === false) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      } else {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(3553, textureProperties.__webglTexture);
  }
  function setTexture2DArray(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(35866, textureProperties.__webglTexture);
  }
  function setTexture3D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(32879, textureProperties.__webglTexture);
  }
  function setTextureCube(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadCubeTexture(textureProperties, texture, slot);
      return;
    }
    state.activeTexture(33984 + slot);
    state.bindTexture(34067, textureProperties.__webglTexture);
  }
  const wrappingToGL = {
    [RepeatWrapping]: 10497,
    [ClampToEdgeWrapping]: 33071,
    [MirroredRepeatWrapping]: 33648
  };
  const filterToGL = {
    [NearestFilter]: 9728,
    [NearestMipmapNearestFilter]: 9984,
    [NearestMipmapLinearFilter]: 9986,
    [LinearFilter]: 9729,
    [LinearMipmapNearestFilter]: 9985,
    [LinearMipmapLinearFilter]: 9987
  };
  function setTextureParameters(textureType, texture, supportsMips) {
    if (supportsMips) {
      _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);
      _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);
      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);
      }
      _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);
      _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);
    } else {
      _gl.texParameteri(textureType, 10242, 33071);
      _gl.texParameteri(textureType, 10243, 33071);
      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, 33071);
      }
      if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
      }
      _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));
      _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));
      if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
      }
    }
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === false)
        return;
      if (isWebGL2 === false && (texture.type === HalfFloatType && extensions.has("OES_texture_half_float_linear") === false))
        return;
      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
        properties.get(texture).__currentAnisotropy = texture.anisotropy;
      }
    }
  }
  function initTexture(textureProperties, texture) {
    let forceUpload = false;
    if (textureProperties.__webglInit === void 0) {
      textureProperties.__webglInit = true;
      texture.addEventListener("dispose", onTextureDispose);
    }
    const source = texture.source;
    let webglTextures = _sources.get(source);
    if (webglTextures === void 0) {
      webglTextures = {};
      _sources.set(source, webglTextures);
    }
    const textureCacheKey = getTextureCacheKey(texture);
    if (textureCacheKey !== textureProperties.__cacheKey) {
      if (webglTextures[textureCacheKey] === void 0) {
        webglTextures[textureCacheKey] = {
          texture: _gl.createTexture(),
          usedTimes: 0
        };
        info.memory.textures++;
        forceUpload = true;
      }
      webglTextures[textureCacheKey].usedTimes++;
      const webglTexture = webglTextures[textureProperties.__cacheKey];
      if (webglTexture !== void 0) {
        webglTextures[textureProperties.__cacheKey].usedTimes--;
        if (webglTexture.usedTimes === 0) {
          deleteTexture(texture);
        }
      }
      textureProperties.__cacheKey = textureCacheKey;
      textureProperties.__webglTexture = webglTextures[textureCacheKey].texture;
    }
    return forceUpload;
  }
  function uploadTexture(textureProperties, texture, slot) {
    let textureType = 3553;
    if (texture.isDataArrayTexture)
      textureType = 35866;
    if (texture.isData3DTexture)
      textureType = 32879;
    const forceUpload = initTexture(textureProperties, texture);
    const source = texture.source;
    state.activeTexture(33984 + slot);
    state.bindTexture(textureType, textureProperties.__webglTexture);
    if (source.version !== source.__currentVersion || forceUpload === true) {
      _gl.pixelStorei(37440, texture.flipY);
      _gl.pixelStorei(37441, texture.premultiplyAlpha);
      _gl.pixelStorei(3317, texture.unpackAlignment);
      _gl.pixelStorei(37443, 0);
      const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;
      let image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
      image = verifyColorSpace(texture, image);
      const supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format, texture.encoding);
      let glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding, texture.isVideoTexture);
      setTextureParameters(textureType, texture, supportsMips);
      let mipmap;
      const mipmaps = texture.mipmaps;
      const useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
      const allocateMemory = textureProperties.__version === void 0;
      const levels = getMipLevels(texture, image, supportsMips);
      if (texture.isDepthTexture) {
        glInternalFormat = 6402;
        if (isWebGL2) {
          if (texture.type === FloatType) {
            glInternalFormat = 36012;
          } else if (texture.type === UnsignedIntType) {
            glInternalFormat = 33190;
          } else if (texture.type === UnsignedInt248Type) {
            glInternalFormat = 35056;
          } else {
            glInternalFormat = 33189;
          }
        } else {
          if (texture.type === FloatType) {
            console.error("WebGLRenderer: Floating point depth texture requires WebGL2.");
          }
        }
        if (texture.format === DepthFormat && glInternalFormat === 6402) {
          if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
            console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
            texture.type = UnsignedShortType;
            glType = utils.convert(texture.type);
          }
        }
        if (texture.format === DepthStencilFormat && glInternalFormat === 6402) {
          glInternalFormat = 34041;
          if (texture.type !== UnsignedInt248Type) {
            console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
            texture.type = UnsignedInt248Type;
            glType = utils.convert(texture.type);
          }
        }
        if (useTexStorage && allocateMemory) {
          state.texStorage2D(3553, 1, glInternalFormat, image.width, image.height);
        } else {
          state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
        }
      } else if (texture.isDataTexture) {
        if (mipmaps.length > 0 && supportsMips) {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(3553, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }
          for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
            mipmap = mipmaps[i2];
            if (useTexStorage) {
              state.texSubImage2D(3553, i2, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
            } else {
              state.texImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
          }
          texture.generateMipmaps = false;
        } else {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage2D(3553, levels, glInternalFormat, image.width, image.height);
            }
            state.texSubImage2D(3553, 0, 0, 0, image.width, image.height, glFormat, glType, image.data);
          } else {
            state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
          }
        }
      } else if (texture.isCompressedTexture) {
        if (useTexStorage && allocateMemory) {
          state.texStorage2D(3553, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
        }
        for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
          mipmap = mipmaps[i2];
          if (texture.format !== RGBAFormat) {
            if (glFormat !== null) {
              if (useTexStorage) {
                state.compressedTexSubImage2D(3553, i2, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
              } else {
                state.compressedTexImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
              }
            } else {
              console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
            }
          } else {
            if (useTexStorage) {
              state.texSubImage2D(3553, i2, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
            } else {
              state.texImage2D(3553, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
          }
        }
      } else if (texture.isDataArrayTexture) {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage3D(35866, levels, glInternalFormat, image.width, image.height, image.depth);
          }
          state.texSubImage3D(35866, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
        } else {
          state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        }
      } else if (texture.isData3DTexture) {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage3D(32879, levels, glInternalFormat, image.width, image.height, image.depth);
          }
          state.texSubImage3D(32879, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
        } else {
          state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        }
      } else if (texture.isFramebufferTexture) {
        if (useTexStorage && allocateMemory) {
          state.texStorage2D(3553, levels, glInternalFormat, image.width, image.height);
        } else {
          state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
        }
      } else {
        if (mipmaps.length > 0 && supportsMips) {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(3553, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }
          for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
            mipmap = mipmaps[i2];
            if (useTexStorage) {
              state.texSubImage2D(3553, i2, 0, 0, glFormat, glType, mipmap);
            } else {
              state.texImage2D(3553, i2, glInternalFormat, glFormat, glType, mipmap);
            }
          }
          texture.generateMipmaps = false;
        } else {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage2D(3553, levels, glInternalFormat, image.width, image.height);
            }
            state.texSubImage2D(3553, 0, 0, 0, glFormat, glType, image);
          } else {
            state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
          }
        }
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(textureType);
      }
      source.__currentVersion = source.version;
      if (texture.onUpdate)
        texture.onUpdate(texture);
    }
    textureProperties.__version = texture.version;
  }
  function uploadCubeTexture(textureProperties, texture, slot) {
    if (texture.image.length !== 6)
      return;
    const forceUpload = initTexture(textureProperties, texture);
    const source = texture.source;
    state.activeTexture(33984 + slot);
    state.bindTexture(34067, textureProperties.__webglTexture);
    if (source.version !== source.__currentVersion || forceUpload === true) {
      _gl.pixelStorei(37440, texture.flipY);
      _gl.pixelStorei(37441, texture.premultiplyAlpha);
      _gl.pixelStorei(3317, texture.unpackAlignment);
      _gl.pixelStorei(37443, 0);
      const isCompressed = texture.isCompressedTexture || texture.image[0].isCompressedTexture;
      const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
      const cubeImage = [];
      for (let i2 = 0; i2 < 6; i2++) {
        if (!isCompressed && !isDataTexture) {
          cubeImage[i2] = resizeImage(texture.image[i2], false, true, maxCubemapSize);
        } else {
          cubeImage[i2] = isDataTexture ? texture.image[i2].image : texture.image[i2];
        }
        cubeImage[i2] = verifyColorSpace(texture, cubeImage[i2]);
      }
      const image = cubeImage[0], supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format, texture.encoding), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
      const useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
      const allocateMemory = textureProperties.__version === void 0;
      let levels = getMipLevels(texture, image, supportsMips);
      setTextureParameters(34067, texture, supportsMips);
      let mipmaps;
      if (isCompressed) {
        if (useTexStorage && allocateMemory) {
          state.texStorage2D(34067, levels, glInternalFormat, image.width, image.height);
        }
        for (let i2 = 0; i2 < 6; i2++) {
          mipmaps = cubeImage[i2].mipmaps;
          for (let j = 0; j < mipmaps.length; j++) {
            const mipmap = mipmaps[j];
            if (texture.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  state.compressedTexSubImage2D(34069 + i2, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                } else {
                  state.compressedTexImage2D(34069 + i2, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                }
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
              }
            } else {
              if (useTexStorage) {
                state.texSubImage2D(34069 + i2, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
              } else {
                state.texImage2D(34069 + i2, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        }
      } else {
        mipmaps = texture.mipmaps;
        if (useTexStorage && allocateMemory) {
          if (mipmaps.length > 0)
            levels++;
          state.texStorage2D(34067, levels, glInternalFormat, cubeImage[0].width, cubeImage[0].height);
        }
        for (let i2 = 0; i2 < 6; i2++) {
          if (isDataTexture) {
            if (useTexStorage) {
              state.texSubImage2D(34069 + i2, 0, 0, 0, cubeImage[i2].width, cubeImage[i2].height, glFormat, glType, cubeImage[i2].data);
            } else {
              state.texImage2D(34069 + i2, 0, glInternalFormat, cubeImage[i2].width, cubeImage[i2].height, 0, glFormat, glType, cubeImage[i2].data);
            }
            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j];
              const mipmapImage = mipmap.image[i2].image;
              if (useTexStorage) {
                state.texSubImage2D(34069 + i2, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data);
              } else {
                state.texImage2D(34069 + i2, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
              }
            }
          } else {
            if (useTexStorage) {
              state.texSubImage2D(34069 + i2, 0, 0, 0, glFormat, glType, cubeImage[i2]);
            } else {
              state.texImage2D(34069 + i2, 0, glInternalFormat, glFormat, glType, cubeImage[i2]);
            }
            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j];
              if (useTexStorage) {
                state.texSubImage2D(34069 + i2, j + 1, 0, 0, glFormat, glType, mipmap.image[i2]);
              } else {
                state.texImage2D(34069 + i2, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i2]);
              }
            }
          }
        }
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(34067);
      }
      source.__currentVersion = source.version;
      if (texture.onUpdate)
        texture.onUpdate(texture);
    }
    textureProperties.__version = texture.version;
  }
  function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget) {
    const glFormat = utils.convert(texture.format, texture.encoding);
    const glType = utils.convert(texture.type);
    const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
    const renderTargetProperties = properties.get(renderTarget);
    if (!renderTargetProperties.__hasExternalTextures) {
      if (textureTarget === 32879 || textureTarget === 35866) {
        state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
      } else {
        state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
      }
    }
    state.bindFramebuffer(36160, framebuffer);
    if (useMultisampledRTT(renderTarget)) {
      multisampledRTTExt.framebufferTexture2DMultisampleEXT(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0, getRenderTargetSamples(renderTarget));
    } else {
      _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0);
    }
    state.bindFramebuffer(36160, null);
  }
  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
    _gl.bindRenderbuffer(36161, renderbuffer);
    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
      let glInternalFormat = 33189;
      if (isMultisample || useMultisampledRTT(renderTarget)) {
        const depthTexture = renderTarget.depthTexture;
        if (depthTexture && depthTexture.isDepthTexture) {
          if (depthTexture.type === FloatType) {
            glInternalFormat = 36012;
          } else if (depthTexture.type === UnsignedIntType) {
            glInternalFormat = 33190;
          }
        }
        const samples = getRenderTargetSamples(renderTarget);
        if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.renderbufferStorageMultisampleEXT(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        }
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
      const samples = getRenderTargetSamples(renderTarget);
      if (isMultisample && useMultisampledRTT(renderTarget) === false) {
        _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);
      } else if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.renderbufferStorageMultisampleEXT(36161, samples, 35056, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
    } else {
      const texture = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture[0] : renderTarget.texture;
      const glFormat = utils.convert(texture.format, texture.encoding);
      const glType = utils.convert(texture.type);
      const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
      const samples = getRenderTargetSamples(renderTarget);
      if (isMultisample && useMultisampledRTT(renderTarget) === false) {
        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.renderbufferStorageMultisampleEXT(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
      }
    }
    _gl.bindRenderbuffer(36161, null);
  }
  function setupDepthTexture(framebuffer, renderTarget) {
    const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
    if (isCube)
      throw new Error("Depth Texture with cube render targets is not supported");
    state.bindFramebuffer(36160, framebuffer);
    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    }
    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
      renderTarget.depthTexture.image.width = renderTarget.width;
      renderTarget.depthTexture.image.height = renderTarget.height;
      renderTarget.depthTexture.needsUpdate = true;
    }
    setTexture2D(renderTarget.depthTexture, 0);
    const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
    const samples = getRenderTargetSamples(renderTarget);
    if (renderTarget.depthTexture.format === DepthFormat) {
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, webglDepthTexture, 0, samples);
      } else {
        _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
      }
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, webglDepthTexture, 0, samples);
      } else {
        _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
      }
    } else {
      throw new Error("Unknown depthTexture format");
    }
  }
  function setupDepthRenderbuffer(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {
      if (isCube)
        throw new Error("target.depthTexture not supported in Cube render targets");
      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = [];
        for (let i2 = 0; i2 < 6; i2++) {
          state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i2]);
          renderTargetProperties.__webglDepthbuffer[i2] = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i2], renderTarget, false);
        }
      } else {
        state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
      }
    }
    state.bindFramebuffer(36160, null);
  }
  function rebindTextures(renderTarget, colorTexture, depthTexture) {
    const renderTargetProperties = properties.get(renderTarget);
    if (colorTexture !== void 0) {
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, 36064, 3553);
    }
    if (depthTexture !== void 0) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function setupRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    renderTarget.addEventListener("dispose", onRenderTargetDispose);
    if (renderTarget.isWebGLMultipleRenderTargets !== true) {
      if (textureProperties.__webglTexture === void 0) {
        textureProperties.__webglTexture = _gl.createTexture();
      }
      textureProperties.__version = texture.version;
      info.memory.textures++;
    }
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
    const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];
      for (let i2 = 0; i2 < 6; i2++) {
        renderTargetProperties.__webglFramebuffer[i2] = _gl.createFramebuffer();
      }
    } else {
      renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
      if (isMultipleRenderTargets) {
        if (capabilities.drawBuffers) {
          const textures = renderTarget.texture;
          for (let i2 = 0, il = textures.length; i2 < il; i2++) {
            const attachmentProperties = properties.get(textures[i2]);
            if (attachmentProperties.__webglTexture === void 0) {
              attachmentProperties.__webglTexture = _gl.createTexture();
              info.memory.textures++;
            }
          }
        } else {
          console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
        }
      } else if (isWebGL2 && renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
        renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
        renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
        _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);
        const glFormat = utils.convert(texture.format, texture.encoding);
        const glType = utils.convert(texture.type);
        const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);
        const samples = getRenderTargetSamples(renderTarget);
        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        state.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
        _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);
        _gl.bindRenderbuffer(36161, null);
        if (renderTarget.depthBuffer) {
          renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
        }
        state.bindFramebuffer(36160, null);
      }
    }
    if (isCube) {
      state.bindTexture(34067, textureProperties.__webglTexture);
      setTextureParameters(34067, texture, supportsMips);
      for (let i2 = 0; i2 < 6; i2++) {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i2], renderTarget, texture, 36064, 34069 + i2);
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(34067);
      }
      state.unbindTexture();
    } else if (isMultipleRenderTargets) {
      const textures = renderTarget.texture;
      for (let i2 = 0, il = textures.length; i2 < il; i2++) {
        const attachment = textures[i2];
        const attachmentProperties = properties.get(attachment);
        state.bindTexture(3553, attachmentProperties.__webglTexture);
        setTextureParameters(3553, attachment, supportsMips);
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, 36064 + i2, 3553);
        if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {
          generateMipmap(3553);
        }
      }
      state.unbindTexture();
    } else {
      let glTextureType = 3553;
      if (renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget) {
        if (isWebGL2) {
          glTextureType = renderTarget.isWebGL3DRenderTarget ? 32879 : 35866;
        } else {
          console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.");
        }
      }
      state.bindTexture(glTextureType, textureProperties.__webglTexture);
      setTextureParameters(glTextureType, texture, supportsMips);
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, 36064, glTextureType);
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(glTextureType);
      }
      state.unbindTexture();
    }
    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function updateRenderTargetMipmap(renderTarget) {
    const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
    const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];
    for (let i2 = 0, il = textures.length; i2 < il; i2++) {
      const texture = textures[i2];
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
        const webglTexture = properties.get(texture).__webglTexture;
        state.bindTexture(target, webglTexture);
        generateMipmap(target);
        state.unbindTexture();
      }
    }
  }
  function updateMultisampleRenderTarget(renderTarget) {
    if (isWebGL2 && renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
      const width = renderTarget.width;
      const height = renderTarget.height;
      let mask = 16384;
      const invalidationArray = [36064];
      const depthStyle = renderTarget.stencilBuffer ? 33306 : 36096;
      if (renderTarget.depthBuffer) {
        invalidationArray.push(depthStyle);
      }
      const renderTargetProperties = properties.get(renderTarget);
      const ignoreDepthValues = renderTargetProperties.__ignoreDepthValues !== void 0 ? renderTargetProperties.__ignoreDepthValues : false;
      if (ignoreDepthValues === false) {
        if (renderTarget.depthBuffer)
          mask |= 256;
        if (renderTarget.stencilBuffer)
          mask |= 1024;
      }
      state.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
      state.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);
      if (ignoreDepthValues === true) {
        _gl.invalidateFramebuffer(36008, [depthStyle]);
        _gl.invalidateFramebuffer(36009, [depthStyle]);
      }
      _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);
      if (supportsInvalidateFramebuffer) {
        _gl.invalidateFramebuffer(36008, invalidationArray);
      }
      state.bindFramebuffer(36008, null);
      state.bindFramebuffer(36009, renderTargetProperties.__webglMultisampledFramebuffer);
    }
  }
  function getRenderTargetSamples(renderTarget) {
    return Math.min(maxSamples, renderTarget.samples);
  }
  function useMultisampledRTT(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    return isWebGL2 && renderTarget.samples > 0 && extensions.has("WEBGL_multisampled_render_to_texture") === true && renderTargetProperties.__useRenderToTexture !== false;
  }
  function updateVideoTexture(texture) {
    const frame = info.render.frame;
    if (_videoTextures.get(texture) !== frame) {
      _videoTextures.set(texture, frame);
      texture.update();
    }
  }
  function verifyColorSpace(texture, image) {
    const encoding = texture.encoding;
    const format = texture.format;
    const type = texture.type;
    if (texture.isCompressedTexture === true || texture.isVideoTexture === true || texture.format === _SRGBAFormat)
      return image;
    if (encoding !== LinearEncoding) {
      if (encoding === sRGBEncoding) {
        if (isWebGL2 === false) {
          if (extensions.has("EXT_sRGB") === true && format === RGBAFormat) {
            texture.format = _SRGBAFormat;
            texture.minFilter = LinearFilter;
            texture.generateMipmaps = false;
          } else {
            image = ImageUtils.sRGBToLinear(image);
          }
        } else {
          if (format !== RGBAFormat || type !== UnsignedByteType) {
            console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.");
          }
        }
      } else {
        console.error("THREE.WebGLTextures: Unsupported texture encoding:", encoding);
      }
    }
    return image;
  }
  this.allocateTextureUnit = allocateTextureUnit;
  this.resetTextureUnits = resetTextureUnits;
  this.setTexture2D = setTexture2D;
  this.setTexture2DArray = setTexture2DArray;
  this.setTexture3D = setTexture3D;
  this.setTextureCube = setTextureCube;
  this.rebindTextures = rebindTextures;
  this.setupRenderTarget = setupRenderTarget;
  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
  this.setupDepthRenderbuffer = setupDepthRenderbuffer;
  this.setupFrameBufferTexture = setupFrameBufferTexture;
  this.useMultisampledRTT = useMultisampledRTT;
}
function WebGLUtils(gl, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function convert(p, encoding = null) {
    let extension;
    if (p === UnsignedByteType)
      return 5121;
    if (p === UnsignedShort4444Type)
      return 32819;
    if (p === UnsignedShort5551Type)
      return 32820;
    if (p === ByteType)
      return 5120;
    if (p === ShortType)
      return 5122;
    if (p === UnsignedShortType)
      return 5123;
    if (p === IntType)
      return 5124;
    if (p === UnsignedIntType)
      return 5125;
    if (p === FloatType)
      return 5126;
    if (p === HalfFloatType) {
      if (isWebGL2)
        return 5131;
      extension = extensions.get("OES_texture_half_float");
      if (extension !== null) {
        return extension.HALF_FLOAT_OES;
      } else {
        return null;
      }
    }
    if (p === AlphaFormat)
      return 6406;
    if (p === RGBAFormat)
      return 6408;
    if (p === LuminanceFormat)
      return 6409;
    if (p === LuminanceAlphaFormat)
      return 6410;
    if (p === DepthFormat)
      return 6402;
    if (p === DepthStencilFormat)
      return 34041;
    if (p === RedFormat)
      return 6403;
    if (p === RGBFormat) {
      console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228");
      return 6408;
    }
    if (p === _SRGBAFormat) {
      extension = extensions.get("EXT_sRGB");
      if (extension !== null) {
        return extension.SRGB_ALPHA_EXT;
      } else {
        return null;
      }
    }
    if (p === RedIntegerFormat)
      return 36244;
    if (p === RGFormat)
      return 33319;
    if (p === RGIntegerFormat)
      return 33320;
    if (p === RGBAIntegerFormat)
      return 36249;
    if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
      if (encoding === sRGBEncoding) {
        extension = extensions.get("WEBGL_compressed_texture_s3tc_srgb");
        if (extension !== null) {
          if (p === RGB_S3TC_DXT1_Format)
            return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT1_Format)
            return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT3_Format)
            return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (p === RGBA_S3TC_DXT5_Format)
            return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      } else {
        extension = extensions.get("WEBGL_compressed_texture_s3tc");
        if (extension !== null) {
          if (p === RGB_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT3_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (p === RGBA_S3TC_DXT5_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      }
    }
    if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_pvrtc");
      if (extension !== null) {
        if (p === RGB_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p === RGB_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p === RGBA_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p === RGBA_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else {
        return null;
      }
    }
    if (p === RGB_ETC1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc1");
      if (extension !== null) {
        return extension.COMPRESSED_RGB_ETC1_WEBGL;
      } else {
        return null;
      }
    }
    if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc");
      if (extension !== null) {
        if (p === RGB_ETC2_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
        if (p === RGBA_ETC2_EAC_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
      } else {
        return null;
      }
    }
    if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {
      extension = extensions.get("WEBGL_compressed_texture_astc");
      if (extension !== null) {
        if (p === RGBA_ASTC_4x4_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (p === RGBA_ASTC_5x4_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (p === RGBA_ASTC_5x5_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (p === RGBA_ASTC_6x5_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (p === RGBA_ASTC_6x6_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (p === RGBA_ASTC_8x5_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (p === RGBA_ASTC_8x6_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (p === RGBA_ASTC_8x8_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (p === RGBA_ASTC_10x5_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (p === RGBA_ASTC_10x6_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (p === RGBA_ASTC_10x8_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (p === RGBA_ASTC_10x10_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (p === RGBA_ASTC_12x10_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (p === RGBA_ASTC_12x12_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else {
        return null;
      }
    }
    if (p === RGBA_BPTC_Format) {
      extension = extensions.get("EXT_texture_compression_bptc");
      if (extension !== null) {
        if (p === RGBA_BPTC_Format)
          return encoding === sRGBEncoding ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      } else {
        return null;
      }
    }
    if (p === UnsignedInt248Type) {
      if (isWebGL2)
        return 34042;
      extension = extensions.get("WEBGL_depth_texture");
      if (extension !== null) {
        return extension.UNSIGNED_INT_24_8_WEBGL;
      } else {
        return null;
      }
    }
  }
  return { convert };
}
function WebGLMaterials(renderer, properties) {
  function refreshFogUniforms(uniforms, fog) {
    uniforms.fogColor.value.copy(fog.color);
    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }
  function refreshMaterialUniforms(uniforms, material, pixelRatio3, height, transmissionRenderTarget) {
    if (material.isMeshBasicMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshLambertMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshToonMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsToon(uniforms, material);
    } else if (material.isMeshPhongMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsPhong(uniforms, material);
    } else if (material.isMeshStandardMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsStandard(uniforms, material);
      if (material.isMeshPhysicalMaterial) {
        refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
      }
    } else if (material.isMeshMatcapMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsMatcap(uniforms, material);
    } else if (material.isMeshDepthMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshDistanceMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDistance(uniforms, material);
    } else if (material.isMeshNormalMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isLineBasicMaterial) {
      refreshUniformsLine(uniforms, material);
      if (material.isLineDashedMaterial) {
        refreshUniformsDash(uniforms, material);
      }
    } else if (material.isPointsMaterial) {
      refreshUniformsPoints(uniforms, material, pixelRatio3, height);
    } else if (material.isSpriteMaterial) {
      refreshUniformsSprites(uniforms, material);
    } else if (material.isShadowMaterial) {
      uniforms.color.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    } else if (material.isShaderMaterial) {
      material.uniformsNeedUpdate = false;
    }
  }
  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;
    if (material.color) {
      uniforms.diffuse.value.copy(material.color);
    }
    if (material.emissive) {
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide)
        uniforms.bumpScale.value *= -1;
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide)
        uniforms.normalScale.value.negate();
    }
    if (material.specularMap) {
      uniforms.specularMap.value = material.specularMap;
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
    const envMap = properties.get(material).envMap;
    if (envMap) {
      uniforms.envMap.value = envMap;
      uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.ior.value = material.ior;
      uniforms.refractionRatio.value = material.refractionRatio;
    }
    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      const scaleFactor = renderer.physicallyCorrectLights !== true ? Math.PI : 1;
      uniforms.lightMapIntensity.value = material.lightMapIntensity * scaleFactor;
    }
    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.specularMap) {
      uvScaleMap = material.specularMap;
    } else if (material.displacementMap) {
      uvScaleMap = material.displacementMap;
    } else if (material.normalMap) {
      uvScaleMap = material.normalMap;
    } else if (material.bumpMap) {
      uvScaleMap = material.bumpMap;
    } else if (material.roughnessMap) {
      uvScaleMap = material.roughnessMap;
    } else if (material.metalnessMap) {
      uvScaleMap = material.metalnessMap;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    } else if (material.emissiveMap) {
      uvScaleMap = material.emissiveMap;
    } else if (material.clearcoatMap) {
      uvScaleMap = material.clearcoatMap;
    } else if (material.clearcoatNormalMap) {
      uvScaleMap = material.clearcoatNormalMap;
    } else if (material.clearcoatRoughnessMap) {
      uvScaleMap = material.clearcoatRoughnessMap;
    } else if (material.specularIntensityMap) {
      uvScaleMap = material.specularIntensityMap;
    } else if (material.specularColorMap) {
      uvScaleMap = material.specularColorMap;
    } else if (material.transmissionMap) {
      uvScaleMap = material.transmissionMap;
    } else if (material.thicknessMap) {
      uvScaleMap = material.thicknessMap;
    } else if (material.sheenColorMap) {
      uvScaleMap = material.sheenColorMap;
    } else if (material.sheenRoughnessMap) {
      uvScaleMap = material.sheenRoughnessMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.isWebGLRenderTarget) {
        uvScaleMap = uvScaleMap.texture;
      }
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
    let uv2ScaleMap;
    if (material.aoMap) {
      uv2ScaleMap = material.aoMap;
    } else if (material.lightMap) {
      uv2ScaleMap = material.lightMap;
    }
    if (uv2ScaleMap !== void 0) {
      if (uv2ScaleMap.isWebGLRenderTarget) {
        uv2ScaleMap = uv2ScaleMap.texture;
      }
      if (uv2ScaleMap.matrixAutoUpdate === true) {
        uv2ScaleMap.updateMatrix();
      }
      uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
    }
  }
  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
  }
  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }
  function refreshUniformsPoints(uniforms, material, pixelRatio3, height) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * pixelRatio3;
    uniforms.scale.value = height * 0.5;
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }
  function refreshUniformsSprites(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.rotation.value = material.rotation;
    if (material.map) {
      uniforms.map.value = material.map;
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
    let uvScaleMap;
    if (material.map) {
      uvScaleMap = material.map;
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap;
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix();
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
    }
  }
  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value.copy(material.specular);
    uniforms.shininess.value = Math.max(material.shininess, 1e-4);
  }
  function refreshUniformsToon(uniforms, material) {
    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap;
    }
  }
  function refreshUniformsStandard(uniforms, material) {
    uniforms.roughness.value = material.roughness;
    uniforms.metalness.value = material.metalness;
    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
    }
    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
    }
    const envMap = properties.get(material).envMap;
    if (envMap) {
      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }
  function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
    uniforms.ior.value = material.ior;
    if (material.sheen > 0) {
      uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);
      uniforms.sheenRoughness.value = material.sheenRoughness;
      if (material.sheenColorMap) {
        uniforms.sheenColorMap.value = material.sheenColorMap;
      }
      if (material.sheenRoughnessMap) {
        uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
      }
    }
    if (material.clearcoat > 0) {
      uniforms.clearcoat.value = material.clearcoat;
      uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
      if (material.clearcoatMap) {
        uniforms.clearcoatMap.value = material.clearcoatMap;
      }
      if (material.clearcoatRoughnessMap) {
        uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
      }
      if (material.clearcoatNormalMap) {
        uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
        uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
        if (material.side === BackSide) {
          uniforms.clearcoatNormalScale.value.negate();
        }
      }
    }
    if (material.transmission > 0) {
      uniforms.transmission.value = material.transmission;
      uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
      uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
      if (material.transmissionMap) {
        uniforms.transmissionMap.value = material.transmissionMap;
      }
      uniforms.thickness.value = material.thickness;
      if (material.thicknessMap) {
        uniforms.thicknessMap.value = material.thicknessMap;
      }
      uniforms.attenuationDistance.value = material.attenuationDistance;
      uniforms.attenuationColor.value.copy(material.attenuationColor);
    }
    uniforms.specularIntensity.value = material.specularIntensity;
    uniforms.specularColor.value.copy(material.specularColor);
    if (material.specularIntensityMap) {
      uniforms.specularIntensityMap.value = material.specularIntensityMap;
    }
    if (material.specularColorMap) {
      uniforms.specularColorMap.value = material.specularColorMap;
    }
  }
  function refreshUniformsMatcap(uniforms, material) {
    if (material.matcap) {
      uniforms.matcap.value = material.matcap;
    }
  }
  function refreshUniformsDistance(uniforms, material) {
    uniforms.referencePosition.value.copy(material.referencePosition);
    uniforms.nearDistance.value = material.nearDistance;
    uniforms.farDistance.value = material.farDistance;
  }
  return {
    refreshFogUniforms,
    refreshMaterialUniforms
  };
}
function createCanvasElement() {
  const canvas = createElementNS("canvas");
  canvas.style.display = "block";
  return canvas;
}
function WebGLRenderer(parameters = {}) {
  const _canvas2 = parameters.canvas !== void 0 ? parameters.canvas : createCanvasElement(), _context2 = parameters.context !== void 0 ? parameters.context : null, _depth = parameters.depth !== void 0 ? parameters.depth : true, _stencil = parameters.stencil !== void 0 ? parameters.stencil : true, _antialias = parameters.antialias !== void 0 ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== void 0 ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== void 0 ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== void 0 ? parameters.powerPreference : "default", _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== void 0 ? parameters.failIfMajorPerformanceCaveat : false;
  let _alpha;
  if (parameters.context !== void 0) {
    _alpha = _context2.getContextAttributes().alpha;
  } else {
    _alpha = parameters.alpha !== void 0 ? parameters.alpha : false;
  }
  let currentRenderList = null;
  let currentRenderState = null;
  const renderListStack = [];
  const renderStateStack = [];
  this.domElement = _canvas2;
  this.debug = {
    checkShaderErrors: true
  };
  this.autoClear = true;
  this.autoClearColor = true;
  this.autoClearDepth = true;
  this.autoClearStencil = true;
  this.sortObjects = true;
  this.clippingPlanes = [];
  this.localClippingEnabled = false;
  this.outputEncoding = LinearEncoding;
  this.physicallyCorrectLights = false;
  this.toneMapping = NoToneMapping;
  this.toneMappingExposure = 1;
  const _this = this;
  let _isContextLost = false;
  let _currentActiveCubeFace = 0;
  let _currentActiveMipmapLevel = 0;
  let _currentRenderTarget = null;
  let _currentMaterialId = -1;
  let _currentCamera = null;
  const _currentViewport = new Vector4();
  const _currentScissor = new Vector4();
  let _currentScissorTest = null;
  let _width2 = _canvas2.width;
  let _height2 = _canvas2.height;
  let _pixelRatio = 1;
  let _opaqueSort = null;
  let _transparentSort = null;
  const _viewport = new Vector4(0, 0, _width2, _height2);
  const _scissor = new Vector4(0, 0, _width2, _height2);
  let _scissorTest = false;
  const _frustum = new Frustum();
  let _clippingEnabled = false;
  let _localClippingEnabled = false;
  let _transmissionRenderTarget = null;
  const _projScreenMatrix2 = new Matrix4();
  const _vector22 = new Vector2();
  const _vector3 = new Vector3();
  const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
  function getTargetPixelRatio() {
    return _currentRenderTarget === null ? _pixelRatio : 1;
  }
  let _gl = _context2;
  function getContext(contextNames, contextAttributes) {
    for (let i2 = 0; i2 < contextNames.length; i2++) {
      const contextName = contextNames[i2];
      const context = _canvas2.getContext(contextName, contextAttributes);
      if (context !== null)
        return context;
    }
    return null;
  }
  try {
    const contextAttributes = {
      alpha: true,
      depth: _depth,
      stencil: _stencil,
      antialias: _antialias,
      premultipliedAlpha: _premultipliedAlpha,
      preserveDrawingBuffer: _preserveDrawingBuffer,
      powerPreference: _powerPreference,
      failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
    };
    if ("setAttribute" in _canvas2)
      _canvas2.setAttribute("data-engine", `three.js r${REVISION}`);
    _canvas2.addEventListener("webglcontextlost", onContextLost, false);
    _canvas2.addEventListener("webglcontextrestored", onContextRestore, false);
    if (_gl === null) {
      const contextNames = ["webgl2", "webgl", "experimental-webgl"];
      if (_this.isWebGL1Renderer === true) {
        contextNames.shift();
      }
      _gl = getContext(contextNames, contextAttributes);
      if (_gl === null) {
        if (getContext(contextNames)) {
          throw new Error("Error creating WebGL context with your selected attributes.");
        } else {
          throw new Error("Error creating WebGL context.");
        }
      }
    }
    if (_gl.getShaderPrecisionFormat === void 0) {
      _gl.getShaderPrecisionFormat = function() {
        return { "rangeMin": 1, "rangeMax": 1, "precision": 1 };
      };
    }
  } catch (error) {
    console.error("THREE.WebGLRenderer: " + error.message);
    throw error;
  }
  let extensions, capabilities, state, info;
  let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
  let programCache, materials, renderLists, renderStates, clipping, shadowMap;
  let background, morphtargets, bufferRenderer, indexedBufferRenderer;
  let utils, bindingStates;
  function initGLContext() {
    extensions = new WebGLExtensions(_gl);
    capabilities = new WebGLCapabilities(_gl, extensions, parameters);
    extensions.init(capabilities);
    utils = new WebGLUtils(_gl, extensions, capabilities);
    state = new WebGLState(_gl, extensions, capabilities);
    info = new WebGLInfo(_gl);
    properties = new WebGLProperties();
    textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
    cubemaps = new WebGLCubeMaps(_this);
    cubeuvmaps = new WebGLCubeUVMaps(_this);
    attributes = new WebGLAttributes(_gl, capabilities);
    bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
    geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
    objects = new WebGLObjects(_gl, geometries, attributes, info);
    morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);
    clipping = new WebGLClipping(properties);
    programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
    materials = new WebGLMaterials(_this, properties);
    renderLists = new WebGLRenderLists();
    renderStates = new WebGLRenderStates(extensions, capabilities);
    background = new WebGLBackground(_this, cubemaps, state, objects, _alpha, _premultipliedAlpha);
    shadowMap = new WebGLShadowMap(_this, objects, capabilities);
    bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
    indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
    info.programs = programCache.programs;
    _this.capabilities = capabilities;
    _this.extensions = extensions;
    _this.properties = properties;
    _this.renderLists = renderLists;
    _this.shadowMap = shadowMap;
    _this.state = state;
    _this.info = info;
  }
  initGLContext();
  const xr = new WebXRManager(_this, _gl);
  this.xr = xr;
  this.getContext = function() {
    return _gl;
  };
  this.getContextAttributes = function() {
    return _gl.getContextAttributes();
  };
  this.forceContextLoss = function() {
    const extension = extensions.get("WEBGL_lose_context");
    if (extension)
      extension.loseContext();
  };
  this.forceContextRestore = function() {
    const extension = extensions.get("WEBGL_lose_context");
    if (extension)
      extension.restoreContext();
  };
  this.getPixelRatio = function() {
    return _pixelRatio;
  };
  this.setPixelRatio = function(value) {
    if (value === void 0)
      return;
    _pixelRatio = value;
    this.setSize(_width2, _height2, false);
  };
  this.getSize = function(target) {
    return target.set(_width2, _height2);
  };
  this.setSize = function(width, height, updateStyle) {
    if (xr.isPresenting) {
      console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
      return;
    }
    _width2 = width;
    _height2 = height;
    _canvas2.width = Math.floor(width * _pixelRatio);
    _canvas2.height = Math.floor(height * _pixelRatio);
    if (updateStyle !== false) {
      _canvas2.style.width = width + "px";
      _canvas2.style.height = height + "px";
    }
    this.setViewport(0, 0, width, height);
  };
  this.getDrawingBufferSize = function(target) {
    return target.set(_width2 * _pixelRatio, _height2 * _pixelRatio).floor();
  };
  this.setDrawingBufferSize = function(width, height, pixelRatio3) {
    _width2 = width;
    _height2 = height;
    _pixelRatio = pixelRatio3;
    _canvas2.width = Math.floor(width * pixelRatio3);
    _canvas2.height = Math.floor(height * pixelRatio3);
    this.setViewport(0, 0, width, height);
  };
  this.getCurrentViewport = function(target) {
    return target.copy(_currentViewport);
  };
  this.getViewport = function(target) {
    return target.copy(_viewport);
  };
  this.setViewport = function(x, y2, width, height) {
    if (x.isVector4) {
      _viewport.set(x.x, x.y, x.z, x.w);
    } else {
      _viewport.set(x, y2, width, height);
    }
    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
  };
  this.getScissor = function(target) {
    return target.copy(_scissor);
  };
  this.setScissor = function(x, y2, width, height) {
    if (x.isVector4) {
      _scissor.set(x.x, x.y, x.z, x.w);
    } else {
      _scissor.set(x, y2, width, height);
    }
    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
  };
  this.getScissorTest = function() {
    return _scissorTest;
  };
  this.setScissorTest = function(boolean) {
    state.setScissorTest(_scissorTest = boolean);
  };
  this.setOpaqueSort = function(method) {
    _opaqueSort = method;
  };
  this.setTransparentSort = function(method) {
    _transparentSort = method;
  };
  this.getClearColor = function(target) {
    return target.copy(background.getClearColor());
  };
  this.setClearColor = function() {
    background.setClearColor.apply(background, arguments);
  };
  this.getClearAlpha = function() {
    return background.getClearAlpha();
  };
  this.setClearAlpha = function() {
    background.setClearAlpha.apply(background, arguments);
  };
  this.clear = function(color = true, depth = true, stencil = true) {
    let bits = 0;
    if (color)
      bits |= 16384;
    if (depth)
      bits |= 256;
    if (stencil)
      bits |= 1024;
    _gl.clear(bits);
  };
  this.clearColor = function() {
    this.clear(true, false, false);
  };
  this.clearDepth = function() {
    this.clear(false, true, false);
  };
  this.clearStencil = function() {
    this.clear(false, false, true);
  };
  this.dispose = function() {
    _canvas2.removeEventListener("webglcontextlost", onContextLost, false);
    _canvas2.removeEventListener("webglcontextrestored", onContextRestore, false);
    renderLists.dispose();
    renderStates.dispose();
    properties.dispose();
    cubemaps.dispose();
    cubeuvmaps.dispose();
    objects.dispose();
    bindingStates.dispose();
    programCache.dispose();
    xr.dispose();
    xr.removeEventListener("sessionstart", onXRSessionStart);
    xr.removeEventListener("sessionend", onXRSessionEnd);
    if (_transmissionRenderTarget) {
      _transmissionRenderTarget.dispose();
      _transmissionRenderTarget = null;
    }
    animation.stop();
  };
  function onContextLost(event) {
    event.preventDefault();
    console.log("THREE.WebGLRenderer: Context Lost.");
    _isContextLost = true;
  }
  function onContextRestore() {
    console.log("THREE.WebGLRenderer: Context Restored.");
    _isContextLost = false;
    const infoAutoReset = info.autoReset;
    const shadowMapEnabled = shadowMap.enabled;
    const shadowMapAutoUpdate = shadowMap.autoUpdate;
    const shadowMapNeedsUpdate = shadowMap.needsUpdate;
    const shadowMapType = shadowMap.type;
    initGLContext();
    info.autoReset = infoAutoReset;
    shadowMap.enabled = shadowMapEnabled;
    shadowMap.autoUpdate = shadowMapAutoUpdate;
    shadowMap.needsUpdate = shadowMapNeedsUpdate;
    shadowMap.type = shadowMapType;
  }
  function onMaterialDispose(event) {
    const material = event.target;
    material.removeEventListener("dispose", onMaterialDispose);
    deallocateMaterial(material);
  }
  function deallocateMaterial(material) {
    releaseMaterialProgramReferences(material);
    properties.remove(material);
  }
  function releaseMaterialProgramReferences(material) {
    const programs = properties.get(material).programs;
    if (programs !== void 0) {
      programs.forEach(function(program) {
        programCache.releaseProgram(program);
      });
      if (material.isShaderMaterial) {
        programCache.releaseShaderCache(material);
      }
    }
  }
  this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
    if (scene === null)
      scene = _emptyScene;
    const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
    const program = setProgram(camera, scene, geometry, material, object);
    state.setMaterial(material, frontFaceCW);
    let index = geometry.index;
    const position = geometry.attributes.position;
    if (index === null) {
      if (position === void 0 || position.count === 0)
        return;
    } else if (index.count === 0) {
      return;
    }
    let rangeFactor = 1;
    if (material.wireframe === true) {
      index = geometries.getWireframeAttribute(geometry);
      rangeFactor = 2;
    }
    bindingStates.setup(object, material, program, geometry, index);
    let attribute;
    let renderer = bufferRenderer;
    if (index !== null) {
      attribute = attributes.get(index);
      renderer = indexedBufferRenderer;
      renderer.setIndex(attribute);
    }
    const dataCount = index !== null ? index.count : position.count;
    const rangeStart = geometry.drawRange.start * rangeFactor;
    const rangeCount = geometry.drawRange.count * rangeFactor;
    const groupStart = group !== null ? group.start * rangeFactor : 0;
    const groupCount = group !== null ? group.count * rangeFactor : Infinity;
    const drawStart = Math.max(rangeStart, groupStart);
    const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
    const drawCount = Math.max(0, drawEnd - drawStart + 1);
    if (drawCount === 0)
      return;
    if (object.isMesh) {
      if (material.wireframe === true) {
        state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
        renderer.setMode(1);
      } else {
        renderer.setMode(4);
      }
    } else if (object.isLine) {
      let lineWidth = material.linewidth;
      if (lineWidth === void 0)
        lineWidth = 1;
      state.setLineWidth(lineWidth * getTargetPixelRatio());
      if (object.isLineSegments) {
        renderer.setMode(1);
      } else if (object.isLineLoop) {
        renderer.setMode(2);
      } else {
        renderer.setMode(3);
      }
    } else if (object.isPoints) {
      renderer.setMode(0);
    } else if (object.isSprite) {
      renderer.setMode(4);
    }
    if (object.isInstancedMesh) {
      renderer.renderInstances(drawStart, drawCount, object.count);
    } else if (geometry.isInstancedBufferGeometry) {
      const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);
      renderer.renderInstances(drawStart, drawCount, instanceCount);
    } else {
      renderer.render(drawStart, drawCount);
    }
  };
  this.compile = function(scene, camera) {
    currentRenderState = renderStates.get(scene);
    currentRenderState.init();
    renderStateStack.push(currentRenderState);
    scene.traverseVisible(function(object) {
      if (object.isLight && object.layers.test(camera.layers)) {
        currentRenderState.pushLight(object);
        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      }
    });
    currentRenderState.setupLights(_this.physicallyCorrectLights);
    scene.traverse(function(object) {
      const material = object.material;
      if (material) {
        if (Array.isArray(material)) {
          for (let i2 = 0; i2 < material.length; i2++) {
            const material2 = material[i2];
            getProgram(material2, scene, object);
          }
        } else {
          getProgram(material, scene, object);
        }
      }
    });
    renderStateStack.pop();
    currentRenderState = null;
  };
  let onAnimationFrameCallback = null;
  function onAnimationFrame(time) {
    if (onAnimationFrameCallback)
      onAnimationFrameCallback(time);
  }
  function onXRSessionStart() {
    animation.stop();
  }
  function onXRSessionEnd() {
    animation.start();
  }
  const animation = new WebGLAnimation();
  animation.setAnimationLoop(onAnimationFrame);
  if (typeof self !== "undefined")
    animation.setContext(self);
  this.setAnimationLoop = function(callback) {
    onAnimationFrameCallback = callback;
    xr.setAnimationLoop(callback);
    callback === null ? animation.stop() : animation.start();
  };
  xr.addEventListener("sessionstart", onXRSessionStart);
  xr.addEventListener("sessionend", onXRSessionEnd);
  this.render = function(scene, camera) {
    if (camera !== void 0 && camera.isCamera !== true) {
      console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
      return;
    }
    if (_isContextLost === true)
      return;
    if (scene.autoUpdate === true)
      scene.updateMatrixWorld();
    if (camera.parent === null)
      camera.updateMatrixWorld();
    if (xr.enabled === true && xr.isPresenting === true) {
      if (xr.cameraAutoUpdate === true)
        xr.updateCamera(camera);
      camera = xr.getCamera();
    }
    if (scene.isScene === true)
      scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
    currentRenderState = renderStates.get(scene, renderStateStack.length);
    currentRenderState.init();
    renderStateStack.push(currentRenderState);
    _projScreenMatrix2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    _frustum.setFromProjectionMatrix(_projScreenMatrix2);
    _localClippingEnabled = this.localClippingEnabled;
    _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
    currentRenderList = renderLists.get(scene, renderListStack.length);
    currentRenderList.init();
    renderListStack.push(currentRenderList);
    projectObject(scene, camera, 0, _this.sortObjects);
    currentRenderList.finish();
    if (_this.sortObjects === true) {
      currentRenderList.sort(_opaqueSort, _transparentSort);
    }
    if (_clippingEnabled === true)
      clipping.beginShadows();
    const shadowsArray = currentRenderState.state.shadowsArray;
    shadowMap.render(shadowsArray, scene, camera);
    if (_clippingEnabled === true)
      clipping.endShadows();
    if (this.info.autoReset === true)
      this.info.reset();
    background.render(currentRenderList, scene);
    currentRenderState.setupLights(_this.physicallyCorrectLights);
    if (camera.isArrayCamera) {
      const cameras = camera.cameras;
      for (let i2 = 0, l = cameras.length; i2 < l; i2++) {
        const camera2 = cameras[i2];
        renderScene(currentRenderList, scene, camera2, camera2.viewport);
      }
    } else {
      renderScene(currentRenderList, scene, camera);
    }
    if (_currentRenderTarget !== null) {
      textures.updateMultisampleRenderTarget(_currentRenderTarget);
      textures.updateRenderTargetMipmap(_currentRenderTarget);
    }
    if (scene.isScene === true)
      scene.onAfterRender(_this, scene, camera);
    bindingStates.resetDefaultState();
    _currentMaterialId = -1;
    _currentCamera = null;
    renderStateStack.pop();
    if (renderStateStack.length > 0) {
      currentRenderState = renderStateStack[renderStateStack.length - 1];
    } else {
      currentRenderState = null;
    }
    renderListStack.pop();
    if (renderListStack.length > 0) {
      currentRenderList = renderListStack[renderListStack.length - 1];
    } else {
      currentRenderList = null;
    }
  };
  function projectObject(object, camera, groupOrder, sortObjects) {
    if (object.visible === false)
      return;
    const visible = object.layers.test(camera.layers);
    if (visible) {
      if (object.isGroup) {
        groupOrder = object.renderOrder;
      } else if (object.isLOD) {
        if (object.autoUpdate === true)
          object.update(camera);
      } else if (object.isLight) {
        currentRenderState.pushLight(object);
        if (object.castShadow) {
          currentRenderState.pushShadow(object);
        }
      } else if (object.isSprite) {
        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
          }
          const geometry = objects.update(object);
          const material = object.material;
          if (material.visible) {
            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      } else if (object.isMesh || object.isLine || object.isPoints) {
        if (object.isSkinnedMesh) {
          if (object.skeleton.frame !== info.render.frame) {
            object.skeleton.update();
            object.skeleton.frame = info.render.frame;
          }
        }
        if (!object.frustumCulled || _frustum.intersectsObject(object)) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
          }
          const geometry = objects.update(object);
          const material = object.material;
          if (Array.isArray(material)) {
            const groups = geometry.groups;
            for (let i2 = 0, l = groups.length; i2 < l; i2++) {
              const group = groups[i2];
              const groupMaterial = material[group.materialIndex];
              if (groupMaterial && groupMaterial.visible) {
                currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
              }
            }
          } else if (material.visible) {
            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
          }
        }
      }
    }
    const children = object.children;
    for (let i2 = 0, l = children.length; i2 < l; i2++) {
      projectObject(children[i2], camera, groupOrder, sortObjects);
    }
  }
  function renderScene(currentRenderList2, scene, camera, viewport) {
    const opaqueObjects = currentRenderList2.opaque;
    const transmissiveObjects = currentRenderList2.transmissive;
    const transparentObjects = currentRenderList2.transparent;
    currentRenderState.setupLightsView(camera);
    if (transmissiveObjects.length > 0)
      renderTransmissionPass(opaqueObjects, scene, camera);
    if (viewport)
      state.viewport(_currentViewport.copy(viewport));
    if (opaqueObjects.length > 0)
      renderObjects(opaqueObjects, scene, camera);
    if (transmissiveObjects.length > 0)
      renderObjects(transmissiveObjects, scene, camera);
    if (transparentObjects.length > 0)
      renderObjects(transparentObjects, scene, camera);
    state.buffers.depth.setTest(true);
    state.buffers.depth.setMask(true);
    state.buffers.color.setMask(true);
    state.setPolygonOffset(false);
  }
  function renderTransmissionPass(opaqueObjects, scene, camera) {
    const isWebGL2 = capabilities.isWebGL2;
    if (_transmissionRenderTarget === null) {
      _transmissionRenderTarget = new WebGLRenderTarget(1, 1, {
        generateMipmaps: true,
        type: utils.convert(HalfFloatType) !== null ? HalfFloatType : UnsignedByteType,
        minFilter: LinearMipmapLinearFilter,
        samples: isWebGL2 && _antialias === true ? 4 : 0
      });
    }
    _this.getDrawingBufferSize(_vector22);
    if (isWebGL2) {
      _transmissionRenderTarget.setSize(_vector22.x, _vector22.y);
    } else {
      _transmissionRenderTarget.setSize(floorPowerOfTwo(_vector22.x), floorPowerOfTwo(_vector22.y));
    }
    const currentRenderTarget = _this.getRenderTarget();
    _this.setRenderTarget(_transmissionRenderTarget);
    _this.clear();
    const currentToneMapping = _this.toneMapping;
    _this.toneMapping = NoToneMapping;
    renderObjects(opaqueObjects, scene, camera);
    _this.toneMapping = currentToneMapping;
    textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
    textures.updateRenderTargetMipmap(_transmissionRenderTarget);
    _this.setRenderTarget(currentRenderTarget);
  }
  function renderObjects(renderList, scene, camera) {
    const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
    for (let i2 = 0, l = renderList.length; i2 < l; i2++) {
      const renderItem = renderList[i2];
      const object = renderItem.object;
      const geometry = renderItem.geometry;
      const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
      const group = renderItem.group;
      if (object.layers.test(camera.layers)) {
        renderObject(object, scene, camera, geometry, material, group);
      }
    }
  }
  function renderObject(object, scene, camera, geometry, material, group) {
    object.onBeforeRender(_this, scene, camera, geometry, material, group);
    object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
    object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
    material.onBeforeRender(_this, scene, camera, geometry, object, group);
    if (material.transparent === true && material.side === DoubleSide) {
      material.side = BackSide;
      material.needsUpdate = true;
      _this.renderBufferDirect(camera, scene, geometry, material, object, group);
      material.side = FrontSide;
      material.needsUpdate = true;
      _this.renderBufferDirect(camera, scene, geometry, material, object, group);
      material.side = DoubleSide;
    } else {
      _this.renderBufferDirect(camera, scene, geometry, material, object, group);
    }
    object.onAfterRender(_this, scene, camera, geometry, material, group);
  }
  function getProgram(material, scene, object) {
    if (scene.isScene !== true)
      scene = _emptyScene;
    const materialProperties = properties.get(material);
    const lights = currentRenderState.state.lights;
    const shadowsArray = currentRenderState.state.shadowsArray;
    const lightsStateVersion = lights.state.version;
    const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
    const programCacheKey = programCache.getProgramCacheKey(parameters2);
    let programs = materialProperties.programs;
    materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
    materialProperties.fog = scene.fog;
    materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);
    if (programs === void 0) {
      material.addEventListener("dispose", onMaterialDispose);
      programs = /* @__PURE__ */ new Map();
      materialProperties.programs = programs;
    }
    let program = programs.get(programCacheKey);
    if (program !== void 0) {
      if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
        updateCommonMaterialProperties(material, parameters2);
        return program;
      }
    } else {
      parameters2.uniforms = programCache.getUniforms(material);
      material.onBuild(object, parameters2, _this);
      material.onBeforeCompile(parameters2, _this);
      program = programCache.acquireProgram(parameters2, programCacheKey);
      programs.set(programCacheKey, program);
      materialProperties.uniforms = parameters2.uniforms;
    }
    const uniforms = materialProperties.uniforms;
    if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
      uniforms.clippingPlanes = clipping.uniform;
    }
    updateCommonMaterialProperties(material, parameters2);
    materialProperties.needsLights = materialNeedsLights(material);
    materialProperties.lightsStateVersion = lightsStateVersion;
    if (materialProperties.needsLights) {
      uniforms.ambientLightColor.value = lights.state.ambient;
      uniforms.lightProbe.value = lights.state.probe;
      uniforms.directionalLights.value = lights.state.directional;
      uniforms.directionalLightShadows.value = lights.state.directionalShadow;
      uniforms.spotLights.value = lights.state.spot;
      uniforms.spotLightShadows.value = lights.state.spotShadow;
      uniforms.rectAreaLights.value = lights.state.rectArea;
      uniforms.ltc_1.value = lights.state.rectAreaLTC1;
      uniforms.ltc_2.value = lights.state.rectAreaLTC2;
      uniforms.pointLights.value = lights.state.point;
      uniforms.pointLightShadows.value = lights.state.pointShadow;
      uniforms.hemisphereLights.value = lights.state.hemi;
      uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
      uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
      uniforms.spotShadowMap.value = lights.state.spotShadowMap;
      uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
      uniforms.pointShadowMap.value = lights.state.pointShadowMap;
      uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
    }
    const progUniforms = program.getUniforms();
    const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
    materialProperties.currentProgram = program;
    materialProperties.uniformsList = uniformsList;
    return program;
  }
  function updateCommonMaterialProperties(material, parameters2) {
    const materialProperties = properties.get(material);
    materialProperties.outputEncoding = parameters2.outputEncoding;
    materialProperties.instancing = parameters2.instancing;
    materialProperties.skinning = parameters2.skinning;
    materialProperties.morphTargets = parameters2.morphTargets;
    materialProperties.morphNormals = parameters2.morphNormals;
    materialProperties.morphColors = parameters2.morphColors;
    materialProperties.morphTargetsCount = parameters2.morphTargetsCount;
    materialProperties.numClippingPlanes = parameters2.numClippingPlanes;
    materialProperties.numIntersection = parameters2.numClipIntersection;
    materialProperties.vertexAlphas = parameters2.vertexAlphas;
    materialProperties.vertexTangents = parameters2.vertexTangents;
    materialProperties.toneMapping = parameters2.toneMapping;
  }
  function setProgram(camera, scene, geometry, material, object) {
    if (scene.isScene !== true)
      scene = _emptyScene;
    textures.resetTextureUnits();
    const fog = scene.fog;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.encoding : LinearEncoding;
    const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
    const vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
    const vertexTangents = !!material.normalMap && !!geometry.attributes.tangent;
    const morphTargets = !!geometry.morphAttributes.position;
    const morphNormals = !!geometry.morphAttributes.normal;
    const morphColors = !!geometry.morphAttributes.color;
    const toneMapping = material.toneMapped ? _this.toneMapping : NoToneMapping;
    const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
    const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
    const materialProperties = properties.get(material);
    const lights = currentRenderState.state.lights;
    if (_clippingEnabled === true) {
      if (_localClippingEnabled === true || camera !== _currentCamera) {
        const useCache = camera === _currentCamera && material.id === _currentMaterialId;
        clipping.setState(material, camera, useCache);
      }
    }
    let needsProgramChange = false;
    if (material.version === materialProperties.__version) {
      if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
        needsProgramChange = true;
      } else if (materialProperties.outputEncoding !== encoding) {
        needsProgramChange = true;
      } else if (object.isInstancedMesh && materialProperties.instancing === false) {
        needsProgramChange = true;
      } else if (!object.isInstancedMesh && materialProperties.instancing === true) {
        needsProgramChange = true;
      } else if (object.isSkinnedMesh && materialProperties.skinning === false) {
        needsProgramChange = true;
      } else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
        needsProgramChange = true;
      } else if (materialProperties.envMap !== envMap) {
        needsProgramChange = true;
      } else if (material.fog && materialProperties.fog !== fog) {
        needsProgramChange = true;
      } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
        needsProgramChange = true;
      } else if (materialProperties.vertexAlphas !== vertexAlphas) {
        needsProgramChange = true;
      } else if (materialProperties.vertexTangents !== vertexTangents) {
        needsProgramChange = true;
      } else if (materialProperties.morphTargets !== morphTargets) {
        needsProgramChange = true;
      } else if (materialProperties.morphNormals !== morphNormals) {
        needsProgramChange = true;
      } else if (materialProperties.morphColors !== morphColors) {
        needsProgramChange = true;
      } else if (materialProperties.toneMapping !== toneMapping) {
        needsProgramChange = true;
      } else if (capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount) {
        needsProgramChange = true;
      }
    } else {
      needsProgramChange = true;
      materialProperties.__version = material.version;
    }
    let program = materialProperties.currentProgram;
    if (needsProgramChange === true) {
      program = getProgram(material, scene, object);
    }
    let refreshProgram = false;
    let refreshMaterial = false;
    let refreshLights = false;
    const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
    if (state.useProgram(program.program)) {
      refreshProgram = true;
      refreshMaterial = true;
      refreshLights = true;
    }
    if (material.id !== _currentMaterialId) {
      _currentMaterialId = material.id;
      refreshMaterial = true;
    }
    if (refreshProgram || _currentCamera !== camera) {
      p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
      if (capabilities.logarithmicDepthBuffer) {
        p_uniforms.setValue(_gl, "logDepthBufFC", 2 / (Math.log(camera.far + 1) / Math.LN2));
      }
      if (_currentCamera !== camera) {
        _currentCamera = camera;
        refreshMaterial = true;
        refreshLights = true;
      }
      if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
        const uCamPos = p_uniforms.map.cameraPosition;
        if (uCamPos !== void 0) {
          uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
        }
      }
      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
        p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
      }
      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || object.isSkinnedMesh) {
        p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
      }
    }
    if (object.isSkinnedMesh) {
      p_uniforms.setOptional(_gl, object, "bindMatrix");
      p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
      const skeleton = object.skeleton;
      if (skeleton) {
        if (capabilities.floatVertexTextures) {
          if (skeleton.boneTexture === null)
            skeleton.computeBoneTexture();
          p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
          p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
        } else {
          p_uniforms.setOptional(_gl, skeleton, "boneMatrices");
        }
      }
    }
    const morphAttributes = geometry.morphAttributes;
    if (morphAttributes.position !== void 0 || morphAttributes.normal !== void 0 || morphAttributes.color !== void 0 && capabilities.isWebGL2 === true) {
      morphtargets.update(object, geometry, material, program);
    }
    if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
      materialProperties.receiveShadow = object.receiveShadow;
      p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
    }
    if (refreshMaterial) {
      p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
      if (materialProperties.needsLights) {
        markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
      }
      if (fog && material.fog) {
        materials.refreshFogUniforms(m_uniforms, fog);
      }
      materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height2, _transmissionRenderTarget);
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
    }
    if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
      material.uniformsNeedUpdate = false;
    }
    if (material.isSpriteMaterial) {
      p_uniforms.setValue(_gl, "center", object.center);
    }
    p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
    p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
    p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
    return program;
  }
  function markUniformsLightsNeedsUpdate(uniforms, value) {
    uniforms.ambientLightColor.needsUpdate = value;
    uniforms.lightProbe.needsUpdate = value;
    uniforms.directionalLights.needsUpdate = value;
    uniforms.directionalLightShadows.needsUpdate = value;
    uniforms.pointLights.needsUpdate = value;
    uniforms.pointLightShadows.needsUpdate = value;
    uniforms.spotLights.needsUpdate = value;
    uniforms.spotLightShadows.needsUpdate = value;
    uniforms.rectAreaLights.needsUpdate = value;
    uniforms.hemisphereLights.needsUpdate = value;
  }
  function materialNeedsLights(material) {
    return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
  }
  this.getActiveCubeFace = function() {
    return _currentActiveCubeFace;
  };
  this.getActiveMipmapLevel = function() {
    return _currentActiveMipmapLevel;
  };
  this.getRenderTarget = function() {
    return _currentRenderTarget;
  };
  this.setRenderTargetTextures = function(renderTarget, colorTexture, depthTexture) {
    properties.get(renderTarget.texture).__webglTexture = colorTexture;
    properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;
    const renderTargetProperties = properties.get(renderTarget);
    renderTargetProperties.__hasExternalTextures = true;
    if (renderTargetProperties.__hasExternalTextures) {
      renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === void 0;
      if (!renderTargetProperties.__autoAllocateDepthBuffer) {
        if (extensions.has("WEBGL_multisampled_render_to_texture") === true) {
          console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided");
          renderTargetProperties.__useRenderToTexture = false;
        }
      }
    }
  };
  this.setRenderTargetFramebuffer = function(renderTarget, defaultFramebuffer) {
    const renderTargetProperties = properties.get(renderTarget);
    renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
    renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === void 0;
  };
  this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
    _currentRenderTarget = renderTarget;
    _currentActiveCubeFace = activeCubeFace;
    _currentActiveMipmapLevel = activeMipmapLevel;
    let useDefaultFramebuffer = true;
    if (renderTarget) {
      const renderTargetProperties = properties.get(renderTarget);
      if (renderTargetProperties.__useDefaultFramebuffer !== void 0) {
        state.bindFramebuffer(36160, null);
        useDefaultFramebuffer = false;
      } else if (renderTargetProperties.__webglFramebuffer === void 0) {
        textures.setupRenderTarget(renderTarget);
      } else if (renderTargetProperties.__hasExternalTextures) {
        textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);
      }
    }
    let framebuffer = null;
    let isCube = false;
    let isRenderTarget3D = false;
    if (renderTarget) {
      const texture = renderTarget.texture;
      if (texture.isData3DTexture || texture.isDataArrayTexture) {
        isRenderTarget3D = true;
      }
      const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLCubeRenderTarget) {
        framebuffer = __webglFramebuffer[activeCubeFace];
        isCube = true;
      } else if (capabilities.isWebGL2 && renderTarget.samples > 0 && textures.useMultisampledRTT(renderTarget) === false) {
        framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
      } else {
        framebuffer = __webglFramebuffer;
      }
      _currentViewport.copy(renderTarget.viewport);
      _currentScissor.copy(renderTarget.scissor);
      _currentScissorTest = renderTarget.scissorTest;
    } else {
      _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
      _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
      _currentScissorTest = _scissorTest;
    }
    const framebufferBound = state.bindFramebuffer(36160, framebuffer);
    if (framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer) {
      state.drawBuffers(renderTarget, framebuffer);
    }
    state.viewport(_currentViewport);
    state.scissor(_currentScissor);
    state.setScissorTest(_currentScissorTest);
    if (isCube) {
      const textureProperties = properties.get(renderTarget.texture);
      _gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
    } else if (isRenderTarget3D) {
      const textureProperties = properties.get(renderTarget.texture);
      const layer = activeCubeFace || 0;
      _gl.framebufferTextureLayer(36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
    }
    _currentMaterialId = -1;
  };
  this.readRenderTargetPixels = function(renderTarget, x, y2, width, height, buffer, activeCubeFaceIndex) {
    if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
      console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      return;
    }
    let framebuffer = properties.get(renderTarget).__webglFramebuffer;
    if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
      framebuffer = framebuffer[activeCubeFaceIndex];
    }
    if (framebuffer) {
      state.bindFramebuffer(36160, framebuffer);
      try {
        const texture = renderTarget.texture;
        const textureFormat = texture.format;
        const textureType = texture.type;
        if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
          return;
        }
        const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has("EXT_color_buffer_half_float") || capabilities.isWebGL2 && extensions.has("EXT_color_buffer_float"));
        if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && !(textureType === FloatType && (capabilities.isWebGL2 || extensions.has("OES_texture_float") || extensions.has("WEBGL_color_buffer_float"))) && !halfFloatSupportedByExt) {
          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
          return;
        }
        if (x >= 0 && x <= renderTarget.width - width && (y2 >= 0 && y2 <= renderTarget.height - height)) {
          _gl.readPixels(x, y2, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
        }
      } finally {
        const framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
        state.bindFramebuffer(36160, framebuffer2);
      }
    }
  };
  this.copyFramebufferToTexture = function(position, texture, level = 0) {
    if (texture.isFramebufferTexture !== true) {
      console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.");
      return;
    }
    const levelScale = Math.pow(2, -level);
    const width = Math.floor(texture.image.width * levelScale);
    const height = Math.floor(texture.image.height * levelScale);
    textures.setTexture2D(texture, 0);
    _gl.copyTexSubImage2D(3553, level, 0, 0, position.x, position.y, width, height);
    state.unbindTexture();
  };
  this.copyTextureToTexture = function(position, srcTexture, dstTexture, level = 0) {
    const width = srcTexture.image.width;
    const height = srcTexture.image.height;
    const glFormat = utils.convert(dstTexture.format);
    const glType = utils.convert(dstTexture.type);
    textures.setTexture2D(dstTexture, 0);
    _gl.pixelStorei(37440, dstTexture.flipY);
    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
    _gl.pixelStorei(3317, dstTexture.unpackAlignment);
    if (srcTexture.isDataTexture) {
      _gl.texSubImage2D(3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
    } else {
      if (srcTexture.isCompressedTexture) {
        _gl.compressedTexSubImage2D(3553, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
      } else {
        _gl.texSubImage2D(3553, level, position.x, position.y, glFormat, glType, srcTexture.image);
      }
    }
    if (level === 0 && dstTexture.generateMipmaps)
      _gl.generateMipmap(3553);
    state.unbindTexture();
  };
  this.copyTextureToTexture3D = function(sourceBox, position, srcTexture, dstTexture, level = 0) {
    if (_this.isWebGL1Renderer) {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
      return;
    }
    const width = sourceBox.max.x - sourceBox.min.x + 1;
    const height = sourceBox.max.y - sourceBox.min.y + 1;
    const depth = sourceBox.max.z - sourceBox.min.z + 1;
    const glFormat = utils.convert(dstTexture.format);
    const glType = utils.convert(dstTexture.type);
    let glTarget;
    if (dstTexture.isData3DTexture) {
      textures.setTexture3D(dstTexture, 0);
      glTarget = 32879;
    } else if (dstTexture.isDataArrayTexture) {
      textures.setTexture2DArray(dstTexture, 0);
      glTarget = 35866;
    } else {
      console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
      return;
    }
    _gl.pixelStorei(37440, dstTexture.flipY);
    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);
    _gl.pixelStorei(3317, dstTexture.unpackAlignment);
    const unpackRowLen = _gl.getParameter(3314);
    const unpackImageHeight = _gl.getParameter(32878);
    const unpackSkipPixels = _gl.getParameter(3316);
    const unpackSkipRows = _gl.getParameter(3315);
    const unpackSkipImages = _gl.getParameter(32877);
    const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;
    _gl.pixelStorei(3314, image.width);
    _gl.pixelStorei(32878, image.height);
    _gl.pixelStorei(3316, sourceBox.min.x);
    _gl.pixelStorei(3315, sourceBox.min.y);
    _gl.pixelStorei(32877, sourceBox.min.z);
    if (srcTexture.isDataTexture || srcTexture.isData3DTexture) {
      _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image.data);
    } else {
      if (srcTexture.isCompressedTexture) {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.");
        _gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, image.data);
      } else {
        _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth, glFormat, glType, image);
      }
    }
    _gl.pixelStorei(3314, unpackRowLen);
    _gl.pixelStorei(32878, unpackImageHeight);
    _gl.pixelStorei(3316, unpackSkipPixels);
    _gl.pixelStorei(3315, unpackSkipRows);
    _gl.pixelStorei(32877, unpackSkipImages);
    if (level === 0 && dstTexture.generateMipmaps)
      _gl.generateMipmap(glTarget);
    state.unbindTexture();
  };
  this.initTexture = function(texture) {
    textures.setTexture2D(texture, 0);
    state.unbindTexture();
  };
  this.resetState = function() {
    _currentActiveCubeFace = 0;
    _currentActiveMipmapLevel = 0;
    _currentRenderTarget = null;
    state.reset();
    bindingStates.reset();
  };
  if (typeof __THREE_DEVTOOLS__ !== "undefined") {
    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
}
function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
  _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);
  if (sin !== void 0) {
    _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
    _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
  } else {
    _rotatedPosition.copy(_alignedPosition);
  }
  vertexPosition.copy(mvPosition);
  vertexPosition.x += _rotatedPosition.x;
  vertexPosition.y += _rotatedPosition.y;
  vertexPosition.applyMatrix4(_viewWorldMatrix);
}
function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects2, object) {
  const rayPointDistanceSq = _ray.distanceSqToPoint(point);
  if (rayPointDistanceSq < localThresholdSq) {
    const intersectPoint = new Vector3();
    _ray.closestPointToPoint(point, intersectPoint);
    intersectPoint.applyMatrix4(matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far)
      return;
    intersects2.push({
      distance,
      distanceToRay: Math.sqrt(rayPointDistanceSq),
      point: intersectPoint,
      index,
      face: null,
      object
    });
  }
}
function CubicPoly() {
  let c0 = 0, c1 = 0, c2 = 0, c3 = 0;
  function init(x0, x1, t0, t1) {
    c0 = x0;
    c1 = t0;
    c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
    c3 = 2 * x0 - 2 * x1 + t0 + t1;
  }
  return {
    initCatmullRom: function(x0, x1, x2, x3, tension) {
      init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
    },
    initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
      let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
      let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
      t1 *= dt1;
      t2 *= dt1;
      init(x1, x2, t1, t2);
    },
    calc: function(t2) {
      const t22 = t2 * t2;
      const t3 = t22 * t2;
      return c0 + c1 * t2 + c2 * t22 + c3 * t3;
    }
  };
}
function CatmullRom(t2, p0, p1, p2, p3) {
  const v0 = (p2 - p0) * 0.5;
  const v1 = (p3 - p1) * 0.5;
  const t22 = t2 * t2;
  const t3 = t2 * t22;
  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t22 + v0 * t2 + p1;
}
function QuadraticBezierP0(t2, p) {
  const k = 1 - t2;
  return k * k * p;
}
function QuadraticBezierP1(t2, p) {
  return 2 * (1 - t2) * t2 * p;
}
function QuadraticBezierP2(t2, p) {
  return t2 * t2 * p;
}
function QuadraticBezier(t2, p0, p1, p2) {
  return QuadraticBezierP0(t2, p0) + QuadraticBezierP1(t2, p1) + QuadraticBezierP2(t2, p2);
}
function CubicBezierP0(t2, p) {
  const k = 1 - t2;
  return k * k * k * p;
}
function CubicBezierP1(t2, p) {
  const k = 1 - t2;
  return 3 * k * k * t2 * p;
}
function CubicBezierP2(t2, p) {
  return 3 * (1 - t2) * t2 * t2 * p;
}
function CubicBezierP3(t2, p) {
  return t2 * t2 * t2 * p;
}
function CubicBezier(t2, p0, p1, p2, p3) {
  return CubicBezierP0(t2, p0) + CubicBezierP1(t2, p1) + CubicBezierP2(t2, p2) + CubicBezierP3(t2, p3);
}
function linkedList(data, start, end, dim2, clockwise) {
  let i2, last;
  if (clockwise === signedArea(data, start, end, dim2) > 0) {
    for (i2 = start; i2 < end; i2 += dim2)
      last = insertNode(i2, data[i2], data[i2 + 1], last);
  } else {
    for (i2 = end - dim2; i2 >= start; i2 -= dim2)
      last = insertNode(i2, data[i2], data[i2 + 1], last);
  }
  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}
function filterPoints(start, end) {
  if (!start)
    return start;
  if (!end)
    end = start;
  let p = start, again;
  do {
    again = false;
    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
      removeNode(p);
      p = end = p.prev;
      if (p === p.next)
        break;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end);
  return end;
}
function earcutLinked(ear, triangles, dim2, minX, minY, invSize, pass) {
  if (!ear)
    return;
  if (!pass && invSize)
    indexCurve(ear, minX, minY, invSize);
  let stop = ear, prev, next;
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i / dim2);
      triangles.push(ear.i / dim2);
      triangles.push(next.i / dim2);
      removeNode(ear);
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim2, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim2);
        earcutLinked(ear, triangles, dim2, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim2, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  const a = ear.prev, b2 = ear, c = ear.next;
  if (area(a, b2, c) >= 0)
    return false;
  let p = ear.next.next;
  while (p !== ear.prev) {
    if (pointInTriangle(a.x, a.y, b2.x, b2.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  const a = ear.prev, b2 = ear, c = ear.next;
  if (area(a, b2, c) >= 0)
    return false;
  const minTX = a.x < b2.x ? a.x < c.x ? a.x : c.x : b2.x < c.x ? b2.x : c.x, minTY = a.y < b2.y ? a.y < c.y ? a.y : c.y : b2.y < c.y ? b2.y : c.y, maxTX = a.x > b2.x ? a.x > c.x ? a.x : c.x : b2.x > c.x ? b2.x : c.x, maxTY = a.y > b2.y ? a.y > c.y ? a.y : c.y : b2.y > c.y ? b2.y : c.y;
  const minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
  let p = ear.prevZ, n = ear.nextZ;
  while (p && p.z >= minZ && n && n.z <= maxZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b2.x, b2.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.prevZ;
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b2.x, b2.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
      return false;
    n = n.nextZ;
  }
  while (p && p.z >= minZ) {
    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b2.x, b2.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.prevZ;
  }
  while (n && n.z <= maxZ) {
    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b2.x, b2.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)
      return false;
    n = n.nextZ;
  }
  return true;
}
function cureLocalIntersections(start, triangles, dim2) {
  let p = start;
  do {
    const a = p.prev, b2 = p.next.next;
    if (!equals(a, b2) && intersects(a, p, p.next, b2) && locallyInside(a, b2) && locallyInside(b2, a)) {
      triangles.push(a.i / dim2);
      triangles.push(p.i / dim2);
      triangles.push(b2.i / dim2);
      removeNode(p);
      removeNode(p.next);
      p = start = b2;
    }
    p = p.next;
  } while (p !== start);
  return filterPoints(p);
}
function splitEarcut(start, triangles, dim2, minX, minY, invSize) {
  let a = start;
  do {
    let b2 = a.next.next;
    while (b2 !== a.prev) {
      if (a.i !== b2.i && isValidDiagonal(a, b2)) {
        let c = splitPolygon(a, b2);
        a = filterPoints(a, a.next);
        c = filterPoints(c, c.next);
        earcutLinked(a, triangles, dim2, minX, minY, invSize);
        earcutLinked(c, triangles, dim2, minX, minY, invSize);
        return;
      }
      b2 = b2.next;
    }
    a = a.next;
  } while (a !== start);
}
function eliminateHoles(data, holeIndices, outerNode, dim2) {
  const queue = [];
  let i2, len, start, end, list;
  for (i2 = 0, len = holeIndices.length; i2 < len; i2++) {
    start = holeIndices[i2] * dim2;
    end = i2 < len - 1 ? holeIndices[i2 + 1] * dim2 : data.length;
    list = linkedList(data, start, end, dim2, false);
    if (list === list.next)
      list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);
  for (i2 = 0; i2 < queue.length; i2++) {
    eliminateHole(queue[i2], outerNode);
    outerNode = filterPoints(outerNode, outerNode.next);
  }
  return outerNode;
}
function compareX(a, b2) {
  return a.x - b2.x;
}
function eliminateHole(hole, outerNode) {
  outerNode = findHoleBridge(hole, outerNode);
  if (outerNode) {
    const b2 = splitPolygon(outerNode, hole);
    filterPoints(outerNode, outerNode.next);
    filterPoints(b2, b2.next);
  }
}
function findHoleBridge(hole, outerNode) {
  let p = outerNode;
  const hx = hole.x;
  const hy = hole.y;
  let qx = -Infinity, m;
  do {
    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
      if (x <= hx && x > qx) {
        qx = x;
        if (x === hx) {
          if (hy === p.y)
            return p;
          if (hy === p.next.y)
            return p.next;
        }
        m = p.x < p.next.x ? p : p.next;
      }
    }
    p = p.next;
  } while (p !== outerNode);
  if (!m)
    return null;
  if (hx === qx)
    return m;
  const stop = m, mx = m.x, my = m.y;
  let tanMin = Infinity, tan;
  p = m;
  do {
    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
      tan = Math.abs(hy - p.y) / (hx - p.x);
      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
        m = p;
        tanMin = tan;
      }
    }
    p = p.next;
  } while (p !== stop);
  return m;
}
function sectorContainsSector(m, p) {
  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}
function indexCurve(start, minX, minY, invSize) {
  let p = start;
  do {
    if (p.z === null)
      p.z = zOrder(p.x, p.y, minX, minY, invSize);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start);
  p.prevZ.nextZ = null;
  p.prevZ = null;
  sortLinked(p);
}
function sortLinked(list) {
  let i2, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
  do {
    p = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p) {
      numMerges++;
      q = p;
      pSize = 0;
      for (i2 = 0; i2 < inSize; i2++) {
        pSize++;
        q = q.nextZ;
        if (!q)
          break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
          e = p;
          p = p.nextZ;
          pSize--;
        } else {
          e = q;
          q = q.nextZ;
          qSize--;
        }
        if (tail)
          tail.nextZ = e;
        else
          list = e;
        e.prevZ = tail;
        tail = e;
      }
      p = q;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x, y2, minX, minY, invSize) {
  x = 32767 * (x - minX) * invSize;
  y2 = 32767 * (y2 - minY) * invSize;
  x = (x | x << 8) & 16711935;
  x = (x | x << 4) & 252645135;
  x = (x | x << 2) & 858993459;
  x = (x | x << 1) & 1431655765;
  y2 = (y2 | y2 << 8) & 16711935;
  y2 = (y2 | y2 << 4) & 252645135;
  y2 = (y2 | y2 << 2) & 858993459;
  y2 = (y2 | y2 << 1) & 1431655765;
  return x | y2 << 1;
}
function getLeftmost(start) {
  let p = start, leftmost = start;
  do {
    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
      leftmost = p;
    p = p.next;
  } while (p !== start);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px2, py2) {
  return (cx - px2) * (ay - py2) - (ax - px2) * (cy - py2) >= 0 && (ax - px2) * (by - py2) - (bx - px2) * (ay - py2) >= 0 && (bx - px2) * (cy - py2) - (cx - px2) * (by - py2) >= 0;
}
function isValidDiagonal(a, b2) {
  return a.next.i !== b2.i && a.prev.i !== b2.i && !intersectsPolygon(a, b2) && (locallyInside(a, b2) && locallyInside(b2, a) && middleInside(a, b2) && (area(a.prev, a, b2.prev) || area(a, b2.prev, b2)) || equals(a, b2) && area(a.prev, a, a.next) > 0 && area(b2.prev, b2, b2.next) > 0);
}
function area(p, q, r3) {
  return (q.y - p.y) * (r3.x - q.x) - (q.x - p.x) * (r3.y - q.y);
}
function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
function intersects(p1, q1, p2, q2) {
  const o1 = sign(area(p1, q1, p2));
  const o2 = sign(area(p1, q1, q2));
  const o3 = sign(area(p2, q2, p1));
  const o4 = sign(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4)
    return true;
  if (o1 === 0 && onSegment(p1, p2, q1))
    return true;
  if (o2 === 0 && onSegment(p1, q2, q1))
    return true;
  if (o3 === 0 && onSegment(p2, p1, q2))
    return true;
  if (o4 === 0 && onSegment(p2, q1, q2))
    return true;
  return false;
}
function onSegment(p, q, r3) {
  return q.x <= Math.max(p.x, r3.x) && q.x >= Math.min(p.x, r3.x) && q.y <= Math.max(p.y, r3.y) && q.y >= Math.min(p.y, r3.y);
}
function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a, b2) {
  let p = a;
  do {
    if (p.i !== a.i && p.next.i !== a.i && p.i !== b2.i && p.next.i !== b2.i && intersects(p, p.next, a, b2))
      return true;
    p = p.next;
  } while (p !== a);
  return false;
}
function locallyInside(a, b2) {
  return area(a.prev, a, a.next) < 0 ? area(a, b2, a.next) >= 0 && area(a, a.prev, b2) >= 0 : area(a, b2, a.prev) < 0 || area(a, a.next, b2) < 0;
}
function middleInside(a, b2) {
  let p = a, inside = false;
  const px2 = (a.x + b2.x) / 2, py2 = (a.y + b2.y) / 2;
  do {
    if (p.y > py2 !== p.next.y > py2 && p.next.y !== p.y && px2 < (p.next.x - p.x) * (py2 - p.y) / (p.next.y - p.y) + p.x)
      inside = !inside;
    p = p.next;
  } while (p !== a);
  return inside;
}
function splitPolygon(a, b2) {
  const a2 = new Node(a.i, a.x, a.y), b22 = new Node(b2.i, b2.x, b2.y), an = a.next, bp = b2.prev;
  a.next = b2;
  b2.prev = a;
  a2.next = an;
  an.prev = a2;
  b22.next = a2;
  a2.prev = b22;
  bp.next = b22;
  b22.prev = bp;
  return b22;
}
function insertNode(i2, x, y2, last) {
  const p = new Node(i2, x, y2);
  if (!last) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last.next;
    p.prev = last;
    last.next.prev = p;
    last.next = p;
  }
  return p;
}
function removeNode(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ)
    p.prevZ.nextZ = p.nextZ;
  if (p.nextZ)
    p.nextZ.prevZ = p.prevZ;
}
function Node(i2, x, y2) {
  this.i = i2;
  this.x = x;
  this.y = y2;
  this.prev = null;
  this.next = null;
  this.z = null;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
function signedArea(data, start, end, dim2) {
  let sum = 0;
  for (let i2 = start, j = end - dim2; i2 < end; i2 += dim2) {
    sum += (data[j] - data[i2]) * (data[i2 + 1] + data[j + 1]);
    j = i2;
  }
  return sum;
}
function removeDupEndPts(points) {
  const l = points.length;
  if (l > 2 && points[l - 1].equals(points[0])) {
    points.pop();
  }
}
function addContour(vertices, contour) {
  for (let i2 = 0; i2 < contour.length; i2++) {
    vertices.push(contour[i2].x);
    vertices.push(contour[i2].y);
  }
}
function toJSON$1(shapes, options, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i2 = 0, l = shapes.length; i2 < l; i2++) {
      const shape = shapes[i2];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  if (options.extrudePath !== void 0)
    data.options.extrudePath = options.extrudePath.toJSON();
  return data;
}
function toJSON(shapes, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i2 = 0, l = shapes.length; i2 < l; i2++) {
      const shape = shapes[i2];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  return data;
}
function isUniqueEdge(start, end, edges) {
  const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;
  const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`;
  if (edges.has(hash1) === true || edges.has(hash2) === true) {
    return false;
  } else {
    edges.add(hash1);
    edges.add(hash2);
    return true;
  }
}
function getTrackTypeForValueTypeName(typeName) {
  switch (typeName.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return NumberKeyframeTrack;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return VectorKeyframeTrack;
    case "color":
      return ColorKeyframeTrack;
    case "quaternion":
      return QuaternionKeyframeTrack;
    case "bool":
    case "boolean":
      return BooleanKeyframeTrack;
    case "string":
      return StringKeyframeTrack;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
}
function parseKeyframeTrack(json) {
  if (json.type === void 0) {
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  }
  const trackType = getTrackTypeForValueTypeName(json.type);
  if (json.times === void 0) {
    const times = [], values = [];
    AnimationUtils.flattenJSON(json.keys, times, values, "value");
    json.times = times;
    json.values = values;
  }
  if (trackType.parse !== void 0) {
    return trackType.parse(json);
  } else {
    return new trackType(json.name, json.times, json.values, json.interpolation);
  }
}
function now() {
  return (typeof performance === "undefined" ? Date : performance).now();
}
function ascSort(a, b2) {
  return a.distance - b2.distance;
}
function intersectObject(object, raycaster, intersects2, recursive) {
  if (object.layers.test(raycaster.layers)) {
    object.raycast(raycaster, intersects2);
  }
  if (recursive === true) {
    const children = object.children;
    for (let i2 = 0, l = children.length; i2 < l; i2++) {
      intersectObject(children[i2], raycaster, intersects2, true);
    }
  }
}
function getBoneList(object) {
  const boneList = [];
  if (object.isBone === true) {
    boneList.push(object);
  }
  for (let i2 = 0; i2 < object.children.length; i2++) {
    boneList.push.apply(boneList, getBoneList(object.children[i2]));
  }
  return boneList;
}
function setPoint(point, pointMap, geometry, camera, x, y2, z) {
  _vector.set(x, y2, z).unproject(camera);
  const points = pointMap[point];
  if (points !== void 0) {
    const position = geometry.getAttribute("position");
    for (let i2 = 0, l = points.length; i2 < l; i2++) {
      position.setXYZ(points[i2], _vector.x, _vector.y, _vector.z);
    }
  }
}
function MeshFaceMaterial(materials) {
  console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead.");
  return materials;
}
function MultiMaterial(materials = []) {
  console.warn("THREE.MultiMaterial has been removed. Use an Array instead.");
  materials.isMultiMaterial = true;
  materials.materials = materials;
  materials.clone = function() {
    return materials.slice();
  };
  return materials;
}
function CanvasRenderer() {
  console.error("THREE.CanvasRenderer has been removed");
}
function JSONLoader() {
  console.error("THREE.JSONLoader has been removed.");
}
function LensFlare() {
  console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js");
}
function FontLoader() {
  console.error("THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js");
}
function Font() {
  console.error("THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js");
}
function ImmediateRenderObject() {
  console.error("THREE.ImmediateRenderObject has been removed.");
}
var REVISION, MOUSE, TOUCH, CullFaceNone, CullFaceBack, CullFaceFront, CullFaceFrontBack, BasicShadowMap, PCFShadowMap, PCFSoftShadowMap, VSMShadowMap, FrontSide, BackSide, DoubleSide, FlatShading, SmoothShading, NoBlending, NormalBlending, AdditiveBlending, SubtractiveBlending, MultiplyBlending, CustomBlending, AddEquation, SubtractEquation, ReverseSubtractEquation, MinEquation, MaxEquation, ZeroFactor, OneFactor, SrcColorFactor, OneMinusSrcColorFactor, SrcAlphaFactor, OneMinusSrcAlphaFactor, DstAlphaFactor, OneMinusDstAlphaFactor, DstColorFactor, OneMinusDstColorFactor, SrcAlphaSaturateFactor, NeverDepth, AlwaysDepth, LessDepth, LessEqualDepth, EqualDepth, GreaterEqualDepth, GreaterDepth, NotEqualDepth, MultiplyOperation, MixOperation, AddOperation, NoToneMapping, LinearToneMapping, ReinhardToneMapping, CineonToneMapping, ACESFilmicToneMapping, CustomToneMapping, UVMapping, CubeReflectionMapping, CubeRefractionMapping, EquirectangularReflectionMapping, EquirectangularRefractionMapping, CubeUVReflectionMapping, RepeatWrapping, ClampToEdgeWrapping, MirroredRepeatWrapping, NearestFilter, NearestMipmapNearestFilter, NearestMipMapNearestFilter, NearestMipmapLinearFilter, NearestMipMapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipMapNearestFilter, LinearMipmapLinearFilter, LinearMipMapLinearFilter, UnsignedByteType, ByteType, ShortType, UnsignedShortType, IntType, UnsignedIntType, FloatType, HalfFloatType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedInt248Type, AlphaFormat, RGBFormat, RGBAFormat, LuminanceFormat, LuminanceAlphaFormat, DepthFormat, DepthStencilFormat, RedFormat, RedIntegerFormat, RGFormat, RGIntegerFormat, RGBAIntegerFormat, RGB_S3TC_DXT1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGB_PVRTC_4BPPV1_Format, RGB_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_PVRTC_2BPPV1_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGBA_ETC2_EAC_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_10x10_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_BPTC_Format, LoopOnce, LoopRepeat, LoopPingPong, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, ZeroCurvatureEnding, ZeroSlopeEnding, WrapAroundEnding, NormalAnimationBlendMode, AdditiveAnimationBlendMode, TrianglesDrawMode, TriangleStripDrawMode, TriangleFanDrawMode, LinearEncoding, sRGBEncoding, BasicDepthPacking, RGBADepthPacking, TangentSpaceNormalMap, ObjectSpaceNormalMap, NoColorSpace, SRGBColorSpace, LinearSRGBColorSpace, ZeroStencilOp, KeepStencilOp, ReplaceStencilOp, IncrementStencilOp, DecrementStencilOp, IncrementWrapStencilOp, DecrementWrapStencilOp, InvertStencilOp, NeverStencilFunc, LessStencilFunc, EqualStencilFunc, LessEqualStencilFunc, GreaterStencilFunc, NotEqualStencilFunc, GreaterEqualStencilFunc, AlwaysStencilFunc, StaticDrawUsage, DynamicDrawUsage, StreamDrawUsage, StaticReadUsage, DynamicReadUsage, StreamReadUsage, StaticCopyUsage, DynamicCopyUsage, StreamCopyUsage, GLSL1, GLSL3, _SRGBAFormat, EventDispatcher, _lut, _seed, DEG2RAD, RAD2DEG, MathUtils, Vector2, Matrix3, TYPED_ARRAYS, FN, ColorManagement, _colorKeywords, _rgb, _hslA, _hslB, Color, _canvas, ImageUtils, Source, textureId, Texture, Vector4, WebGLRenderTarget, DataArrayTexture, WebGLArrayRenderTarget, Data3DTexture, WebGL3DRenderTarget, WebGLMultipleRenderTargets, Quaternion, Vector3, _vector$c, _quaternion$4, Box3, _points, _vector$b, _box$3, _v0$2, _v1$7, _v2$3, _f0, _f1, _f2, _center, _extents, _triangleNormal, _testAxis, _box$2, _v1$6, _toFarthestPoint, _toPoint, Sphere, _vector$a, _segCenter, _segDir, _diff, _edge1, _edge2, _normal$1, Ray, Matrix4, _v1$5, _m1$2, _zero, _one, _x, _y, _z, _matrix$1, _quaternion$3, Euler, Layers, _object3DId, _v1$4, _q1, _m1$1, _target, _position$3, _scale$2, _quaternion$2, _xAxis, _yAxis, _zAxis, _addedEvent, _removedEvent, Object3D, _v0$1, _v1$3, _v2$2, _v3$1, _vab, _vac, _vbc, _vap, _vbp, _vcp, Triangle, materialId, Material, MeshBasicMaterial, _vector$9, _vector2$1, BufferAttribute, Int8BufferAttribute, Uint8BufferAttribute, Uint8ClampedBufferAttribute, Int16BufferAttribute, Uint16BufferAttribute, Int32BufferAttribute, Uint32BufferAttribute, Float16BufferAttribute, Float32BufferAttribute, Float64BufferAttribute, _id$1, _m1, _obj, _offset, _box$1, _boxMorphTargets, _vector$8, BufferGeometry, _inverseMatrix$2, _ray$2, _sphere$3, _vA$1, _vB$1, _vC$1, _tempA, _tempB, _tempC, _morphA, _morphB, _morphC, _uvA$1, _uvB$1, _uvC$1, _intersectionPoint, _intersectionPointWorld, Mesh, BoxGeometry, UniformsUtils, default_vertex, default_fragment, ShaderMaterial, Camera, PerspectiveCamera, fov, aspect, CubeCamera, CubeTexture, WebGLCubeRenderTarget, _vector1, _vector2, _normalMatrix, Plane, _sphere$2, _vector$7, Frustum, PlaneGeometry, alphamap_fragment, alphamap_pars_fragment, alphatest_fragment, alphatest_pars_fragment, aomap_fragment, aomap_pars_fragment, begin_vertex, beginnormal_vertex, bsdfs, bumpmap_pars_fragment, clipping_planes_fragment, clipping_planes_pars_fragment, clipping_planes_pars_vertex, clipping_planes_vertex, color_fragment, color_pars_fragment, color_pars_vertex, color_vertex, common, cube_uv_reflection_fragment, defaultnormal_vertex, displacementmap_pars_vertex, displacementmap_vertex, emissivemap_fragment, emissivemap_pars_fragment, encodings_fragment, encodings_pars_fragment, envmap_fragment, envmap_common_pars_fragment, envmap_pars_fragment, envmap_pars_vertex, envmap_vertex, fog_vertex, fog_pars_vertex, fog_fragment, fog_pars_fragment, gradientmap_pars_fragment, lightmap_fragment, lightmap_pars_fragment, lights_lambert_vertex, lights_pars_begin, envmap_physical_pars_fragment, lights_toon_fragment, lights_toon_pars_fragment, lights_phong_fragment, lights_phong_pars_fragment, lights_physical_fragment, lights_physical_pars_fragment, lights_fragment_begin, lights_fragment_maps, lights_fragment_end, logdepthbuf_fragment, logdepthbuf_pars_fragment, logdepthbuf_pars_vertex, logdepthbuf_vertex, map_fragment, map_pars_fragment, map_particle_fragment, map_particle_pars_fragment, metalnessmap_fragment, metalnessmap_pars_fragment, morphcolor_vertex, morphnormal_vertex, morphtarget_pars_vertex, morphtarget_vertex, normal_fragment_begin, normal_fragment_maps, normal_pars_fragment, normal_pars_vertex, normal_vertex, normalmap_pars_fragment, clearcoat_normal_fragment_begin, clearcoat_normal_fragment_maps, clearcoat_pars_fragment, output_fragment, packing, premultiplied_alpha_fragment, project_vertex, dithering_fragment, dithering_pars_fragment, roughnessmap_fragment, roughnessmap_pars_fragment, shadowmap_pars_fragment, shadowmap_pars_vertex, shadowmap_vertex, shadowmask_pars_fragment, skinbase_vertex, skinning_pars_vertex, skinning_vertex, skinnormal_vertex, specularmap_fragment, specularmap_pars_fragment, tonemapping_fragment, tonemapping_pars_fragment, transmission_fragment, transmission_pars_fragment, uv_pars_fragment, uv_pars_vertex, uv_vertex, uv2_pars_fragment, uv2_pars_vertex, uv2_vertex, worldpos_vertex, vertex$g, fragment$g, vertex$f, fragment$f, vertex$e, fragment$e, vertex$d, fragment$d, vertex$c, fragment$c, vertex$b, fragment$b, vertex$a, fragment$a, vertex$9, fragment$9, vertex$8, fragment$8, vertex$7, fragment$7, vertex$6, fragment$6, vertex$5, fragment$5, vertex$4, fragment$4, vertex$3, fragment$3, vertex$2, fragment$2, vertex$1, fragment$1, ShaderChunk, UniformsLib, ShaderLib, OrthographicCamera, LOD_MIN, EXTRA_LOD_SIGMA, MAX_SAMPLES, _flatCamera, _clearColor, _oldTarget, PHI, INV_PHI, _axisDirections, PMREMGenerator, emptyTexture, emptyArrayTexture, empty3dTexture, emptyCubeTexture, arrayCacheF32, arrayCacheI32, mat4array, mat3array, mat2array, RePathPart, programIdCount, includePattern, deprecatedUnrollLoopPattern, unrollLoopPattern, _id, WebGLShaderCache, WebGLShaderStage, nextVersion, MeshDepthMaterial, MeshDistanceMaterial, vertex, fragment, ArrayCamera, Group, _moveEvent, WebXRController, DepthTexture, WebXRManager, WebGL1Renderer, FogExp2, Fog, Scene, InterleavedBuffer, _vector$6, InterleavedBufferAttribute, SpriteMaterial, _geometry, _intersectPoint, _worldScale, _mvPosition, _alignedPosition, _rotatedPosition, _viewWorldMatrix, _vA, _vB, _vC, _uvA, _uvB, _uvC, Sprite, _v1$2, _v2$1, LOD, _basePosition, _skinIndex, _skinWeight, _vector$5, _matrix, SkinnedMesh, Bone, DataTexture, _offsetMatrix, _identityMatrix, Skeleton, InstancedBufferAttribute, _instanceLocalMatrix, _instanceWorldMatrix, _instanceIntersects, _mesh, InstancedMesh, LineBasicMaterial, _start$1, _end$1, _inverseMatrix$1, _ray$1, _sphere$1, Line, _start, _end, LineSegments, LineLoop, PointsMaterial, _inverseMatrix, _ray, _sphere, _position$2, Points, VideoTexture, FramebufferTexture, CompressedTexture, CanvasTexture, Curve, EllipseCurve, ArcCurve, tmp, px, py, pz, CatmullRomCurve3, CubicBezierCurve, CubicBezierCurve3, LineCurve, LineCurve3, QuadraticBezierCurve, QuadraticBezierCurve3, SplineCurve, Curves, CurvePath, Path, LatheGeometry, CapsuleGeometry, CircleGeometry, CylinderGeometry, ConeGeometry, PolyhedronGeometry, DodecahedronGeometry, _v0, _v1$1, _normal, _triangle, EdgesGeometry, Shape, Earcut, ShapeUtils, ExtrudeGeometry, WorldUVGenerator, IcosahedronGeometry, OctahedronGeometry, RingGeometry, ShapeGeometry, SphereGeometry, TetrahedronGeometry, TorusGeometry, TorusKnotGeometry, TubeGeometry, WireframeGeometry, Geometries, ShadowMaterial, RawShaderMaterial, MeshStandardMaterial, MeshPhysicalMaterial, MeshPhongMaterial, MeshToonMaterial, MeshNormalMaterial, MeshLambertMaterial, MeshMatcapMaterial, LineDashedMaterial, materialLib, AnimationUtils, Interpolant, CubicInterpolant, LinearInterpolant, DiscreteInterpolant, KeyframeTrack, BooleanKeyframeTrack, ColorKeyframeTrack, NumberKeyframeTrack, QuaternionLinearInterpolant, QuaternionKeyframeTrack, StringKeyframeTrack, VectorKeyframeTrack, AnimationClip, Cache, LoadingManager, DefaultLoadingManager, Loader, loading, FileLoader, AnimationLoader, CompressedTextureLoader, ImageLoader, CubeTextureLoader, DataTextureLoader, TextureLoader, Light, HemisphereLight, _projScreenMatrix$1, _lightPositionWorld$1, _lookTarget$1, LightShadow, SpotLightShadow, SpotLight, _projScreenMatrix, _lightPositionWorld, _lookTarget, PointLightShadow, PointLight, DirectionalLightShadow, DirectionalLight, AmbientLight, RectAreaLight, SphericalHarmonics3, LightProbe, MaterialLoader, LoaderUtils, InstancedBufferGeometry, BufferGeometryLoader, ObjectLoader, TEXTURE_MAPPING, TEXTURE_WRAPPING, TEXTURE_FILTER, ImageBitmapLoader, _context, AudioContext, AudioLoader, HemisphereLightProbe, AmbientLightProbe, _eyeRight, _eyeLeft, _projectionMatrix, StereoCamera, Clock, _position$1, _quaternion$1, _scale$1, _orientation$1, AudioListener, Audio, _position, _quaternion, _scale, _orientation, PositionalAudio, AudioAnalyser, PropertyMixer, _RESERVED_CHARS_RE, _reservedRe, _wordChar, _wordCharOrDot, _directoryRe, _nodeRe, _objectRe, _propertyRe, _trackRe, _supportedObjectNames, Composite, PropertyBinding, AnimationObjectGroup, AnimationAction, AnimationMixer, Uniform, InstancedInterleavedBuffer, GLBufferAttribute, Raycaster, Spherical, Cylindrical, _vector$4, Box2, _startP, _startEnd, Line3, _vector$3, SpotLightHelper, _vector$2, _boneMatrix, _matrixWorldInv, SkeletonHelper, PointLightHelper, _vector$1, _color1, _color2, HemisphereLightHelper, GridHelper, PolarGridHelper, _v1, _v2, _v3, DirectionalLightHelper, _vector, _camera, CameraHelper, _box, BoxHelper, Box3Helper, PlaneHelper, _axis, _lineGeometry, _coneGeometry, ArrowHelper, AxesHelper, ShapePath, DataUtils, _buffer, _floatView, _uint32View, _baseTable, _shiftTable, _mantissaTable, _exponentTable, _offsetTable, LineStrip, LinePieces, NoColors, FaceColors, VertexColors, PointCloud, Particle, ParticleSystem, PointCloudMaterial, ParticleBasicMaterial, ParticleSystemMaterial, Vertex, DynamicBufferAttribute, Int8Attribute, Uint8Attribute, Uint8ClampedAttribute, Int16Attribute, Uint16Attribute, Int32Attribute, Uint32Attribute, Float32Attribute, Float64Attribute, AxisHelper, BoundingBoxHelper, EdgesHelper, WireframeHelper, XHRLoader, BinaryTextureLoader, WebGLRenderTargetCube, SceneUtils, ParametricGeometry, TextGeometry, WebGLMultisampleRenderTarget, DataTexture2DArray, DataTexture3D;
var init_three_module = __esm({
  "node_modules/three/build/three.module.js"() {
    REVISION = "139";
    MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
    TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
    CullFaceNone = 0;
    CullFaceBack = 1;
    CullFaceFront = 2;
    CullFaceFrontBack = 3;
    BasicShadowMap = 0;
    PCFShadowMap = 1;
    PCFSoftShadowMap = 2;
    VSMShadowMap = 3;
    FrontSide = 0;
    BackSide = 1;
    DoubleSide = 2;
    FlatShading = 1;
    SmoothShading = 2;
    NoBlending = 0;
    NormalBlending = 1;
    AdditiveBlending = 2;
    SubtractiveBlending = 3;
    MultiplyBlending = 4;
    CustomBlending = 5;
    AddEquation = 100;
    SubtractEquation = 101;
    ReverseSubtractEquation = 102;
    MinEquation = 103;
    MaxEquation = 104;
    ZeroFactor = 200;
    OneFactor = 201;
    SrcColorFactor = 202;
    OneMinusSrcColorFactor = 203;
    SrcAlphaFactor = 204;
    OneMinusSrcAlphaFactor = 205;
    DstAlphaFactor = 206;
    OneMinusDstAlphaFactor = 207;
    DstColorFactor = 208;
    OneMinusDstColorFactor = 209;
    SrcAlphaSaturateFactor = 210;
    NeverDepth = 0;
    AlwaysDepth = 1;
    LessDepth = 2;
    LessEqualDepth = 3;
    EqualDepth = 4;
    GreaterEqualDepth = 5;
    GreaterDepth = 6;
    NotEqualDepth = 7;
    MultiplyOperation = 0;
    MixOperation = 1;
    AddOperation = 2;
    NoToneMapping = 0;
    LinearToneMapping = 1;
    ReinhardToneMapping = 2;
    CineonToneMapping = 3;
    ACESFilmicToneMapping = 4;
    CustomToneMapping = 5;
    UVMapping = 300;
    CubeReflectionMapping = 301;
    CubeRefractionMapping = 302;
    EquirectangularReflectionMapping = 303;
    EquirectangularRefractionMapping = 304;
    CubeUVReflectionMapping = 306;
    RepeatWrapping = 1e3;
    ClampToEdgeWrapping = 1001;
    MirroredRepeatWrapping = 1002;
    NearestFilter = 1003;
    NearestMipmapNearestFilter = 1004;
    NearestMipMapNearestFilter = 1004;
    NearestMipmapLinearFilter = 1005;
    NearestMipMapLinearFilter = 1005;
    LinearFilter = 1006;
    LinearMipmapNearestFilter = 1007;
    LinearMipMapNearestFilter = 1007;
    LinearMipmapLinearFilter = 1008;
    LinearMipMapLinearFilter = 1008;
    UnsignedByteType = 1009;
    ByteType = 1010;
    ShortType = 1011;
    UnsignedShortType = 1012;
    IntType = 1013;
    UnsignedIntType = 1014;
    FloatType = 1015;
    HalfFloatType = 1016;
    UnsignedShort4444Type = 1017;
    UnsignedShort5551Type = 1018;
    UnsignedInt248Type = 1020;
    AlphaFormat = 1021;
    RGBFormat = 1022;
    RGBAFormat = 1023;
    LuminanceFormat = 1024;
    LuminanceAlphaFormat = 1025;
    DepthFormat = 1026;
    DepthStencilFormat = 1027;
    RedFormat = 1028;
    RedIntegerFormat = 1029;
    RGFormat = 1030;
    RGIntegerFormat = 1031;
    RGBAIntegerFormat = 1033;
    RGB_S3TC_DXT1_Format = 33776;
    RGBA_S3TC_DXT1_Format = 33777;
    RGBA_S3TC_DXT3_Format = 33778;
    RGBA_S3TC_DXT5_Format = 33779;
    RGB_PVRTC_4BPPV1_Format = 35840;
    RGB_PVRTC_2BPPV1_Format = 35841;
    RGBA_PVRTC_4BPPV1_Format = 35842;
    RGBA_PVRTC_2BPPV1_Format = 35843;
    RGB_ETC1_Format = 36196;
    RGB_ETC2_Format = 37492;
    RGBA_ETC2_EAC_Format = 37496;
    RGBA_ASTC_4x4_Format = 37808;
    RGBA_ASTC_5x4_Format = 37809;
    RGBA_ASTC_5x5_Format = 37810;
    RGBA_ASTC_6x5_Format = 37811;
    RGBA_ASTC_6x6_Format = 37812;
    RGBA_ASTC_8x5_Format = 37813;
    RGBA_ASTC_8x6_Format = 37814;
    RGBA_ASTC_8x8_Format = 37815;
    RGBA_ASTC_10x5_Format = 37816;
    RGBA_ASTC_10x6_Format = 37817;
    RGBA_ASTC_10x8_Format = 37818;
    RGBA_ASTC_10x10_Format = 37819;
    RGBA_ASTC_12x10_Format = 37820;
    RGBA_ASTC_12x12_Format = 37821;
    RGBA_BPTC_Format = 36492;
    LoopOnce = 2200;
    LoopRepeat = 2201;
    LoopPingPong = 2202;
    InterpolateDiscrete = 2300;
    InterpolateLinear = 2301;
    InterpolateSmooth = 2302;
    ZeroCurvatureEnding = 2400;
    ZeroSlopeEnding = 2401;
    WrapAroundEnding = 2402;
    NormalAnimationBlendMode = 2500;
    AdditiveAnimationBlendMode = 2501;
    TrianglesDrawMode = 0;
    TriangleStripDrawMode = 1;
    TriangleFanDrawMode = 2;
    LinearEncoding = 3e3;
    sRGBEncoding = 3001;
    BasicDepthPacking = 3200;
    RGBADepthPacking = 3201;
    TangentSpaceNormalMap = 0;
    ObjectSpaceNormalMap = 1;
    NoColorSpace = "";
    SRGBColorSpace = "srgb";
    LinearSRGBColorSpace = "srgb-linear";
    ZeroStencilOp = 0;
    KeepStencilOp = 7680;
    ReplaceStencilOp = 7681;
    IncrementStencilOp = 7682;
    DecrementStencilOp = 7683;
    IncrementWrapStencilOp = 34055;
    DecrementWrapStencilOp = 34056;
    InvertStencilOp = 5386;
    NeverStencilFunc = 512;
    LessStencilFunc = 513;
    EqualStencilFunc = 514;
    LessEqualStencilFunc = 515;
    GreaterStencilFunc = 516;
    NotEqualStencilFunc = 517;
    GreaterEqualStencilFunc = 518;
    AlwaysStencilFunc = 519;
    StaticDrawUsage = 35044;
    DynamicDrawUsage = 35048;
    StreamDrawUsage = 35040;
    StaticReadUsage = 35045;
    DynamicReadUsage = 35049;
    StreamReadUsage = 35041;
    StaticCopyUsage = 35046;
    DynamicCopyUsage = 35050;
    StreamCopyUsage = 35042;
    GLSL1 = "100";
    GLSL3 = "300 es";
    _SRGBAFormat = 1035;
    EventDispatcher = class {
      addEventListener(type, listener) {
        if (this._listeners === void 0)
          this._listeners = {};
        const listeners = this._listeners;
        if (listeners[type] === void 0) {
          listeners[type] = [];
        }
        if (listeners[type].indexOf(listener) === -1) {
          listeners[type].push(listener);
        }
      }
      hasEventListener(type, listener) {
        if (this._listeners === void 0)
          return false;
        const listeners = this._listeners;
        return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
      }
      removeEventListener(type, listener) {
        if (this._listeners === void 0)
          return;
        const listeners = this._listeners;
        const listenerArray = listeners[type];
        if (listenerArray !== void 0) {
          const index = listenerArray.indexOf(listener);
          if (index !== -1) {
            listenerArray.splice(index, 1);
          }
        }
      }
      dispatchEvent(event) {
        if (this._listeners === void 0)
          return;
        const listeners = this._listeners;
        const listenerArray = listeners[event.type];
        if (listenerArray !== void 0) {
          event.target = this;
          const array = listenerArray.slice(0);
          for (let i2 = 0, l = array.length; i2 < l; i2++) {
            array[i2].call(this, event);
          }
          event.target = null;
        }
      }
    };
    _lut = [];
    for (let i2 = 0; i2 < 256; i2++) {
      _lut[i2] = (i2 < 16 ? "0" : "") + i2.toString(16);
    }
    _seed = 1234567;
    DEG2RAD = Math.PI / 180;
    RAD2DEG = 180 / Math.PI;
    MathUtils = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      DEG2RAD,
      RAD2DEG,
      generateUUID,
      clamp,
      euclideanModulo,
      mapLinear,
      inverseLerp,
      lerp,
      damp,
      pingpong,
      smoothstep,
      smootherstep,
      randInt,
      randFloat,
      randFloatSpread,
      seededRandom,
      degToRad,
      radToDeg,
      isPowerOfTwo,
      ceilPowerOfTwo,
      floorPowerOfTwo,
      setQuaternionFromProperEuler,
      normalize,
      denormalize: denormalize$1
    });
    Vector2 = class {
      constructor(x = 0, y2 = 0) {
        this.x = x;
        this.y = y2;
      }
      get width() {
        return this.x;
      }
      set width(value) {
        this.x = value;
      }
      get height() {
        return this.y;
      }
      set height(value) {
        this.y = value;
      }
      set(x, y2) {
        this.x = x;
        this.y = y2;
        return this;
      }
      setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        return this;
      }
      setX(x) {
        this.x = x;
        return this;
      }
      setY(y2) {
        this.y = y2;
        return this;
      }
      setComponent(index, value) {
        switch (index) {
          case 0:
            this.x = value;
            break;
          case 1:
            this.y = value;
            break;
          default:
            throw new Error("index is out of range: " + index);
        }
        return this;
      }
      getComponent(index) {
        switch (index) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          default:
            throw new Error("index is out of range: " + index);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y);
      }
      copy(v) {
        this.x = v.x;
        this.y = v.y;
        return this;
      }
      add(v, w) {
        if (w !== void 0) {
          console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
          return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        return this;
      }
      addScalar(s) {
        this.x += s;
        this.y += s;
        return this;
      }
      addVectors(a, b2) {
        this.x = a.x + b2.x;
        this.y = a.y + b2.y;
        return this;
      }
      addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        return this;
      }
      sub(v, w) {
        if (w !== void 0) {
          console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
          return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        return this;
      }
      subScalar(s) {
        this.x -= s;
        this.y -= s;
        return this;
      }
      subVectors(a, b2) {
        this.x = a.x - b2.x;
        this.y = a.y - b2.y;
        return this;
      }
      multiply(v) {
        this.x *= v.x;
        this.y *= v.y;
        return this;
      }
      multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        return this;
      }
      divide(v) {
        this.x /= v.x;
        this.y /= v.y;
        return this;
      }
      divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
      }
      applyMatrix3(m) {
        const x = this.x, y2 = this.y;
        const e = m.elements;
        this.x = e[0] * x + e[3] * y2 + e[6];
        this.y = e[1] * x + e[4] * y2 + e[7];
        return this;
      }
      min(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        return this;
      }
      max(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        return this;
      }
      clamp(min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        return this;
      }
      clampScalar(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        return this;
      }
      clampLength(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
      }
      floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
      }
      ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
      }
      round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
      }
      roundToZero() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        return this;
      }
      negate() {
        this.x = -this.x;
        this.y = -this.y;
        return this;
      }
      dot(v) {
        return this.x * v.x + this.y * v.y;
      }
      cross(v) {
        return this.x * v.y - this.y * v.x;
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y);
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      angle() {
        const angle = Math.atan2(-this.y, -this.x) + Math.PI;
        return angle;
      }
      distanceTo(v) {
        return Math.sqrt(this.distanceToSquared(v));
      }
      distanceToSquared(v) {
        const dx = this.x - v.x, dy = this.y - v.y;
        return dx * dx + dy * dy;
      }
      manhattanDistanceTo(v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
      }
      setLength(length) {
        return this.normalize().multiplyScalar(length);
      }
      lerp(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        return this;
      }
      lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        return this;
      }
      equals(v) {
        return v.x === this.x && v.y === this.y;
      }
      fromArray(array, offset = 0) {
        this.x = array[offset];
        this.y = array[offset + 1];
        return this;
      }
      toArray(array = [], offset = 0) {
        array[offset] = this.x;
        array[offset + 1] = this.y;
        return array;
      }
      fromBufferAttribute(attribute, index, offset) {
        if (offset !== void 0) {
          console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
        }
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        return this;
      }
      rotateAround(center, angle) {
        const c = Math.cos(angle), s = Math.sin(angle);
        const x = this.x - center.x;
        const y2 = this.y - center.y;
        this.x = x * c - y2 * s + center.x;
        this.y = x * s + y2 * c + center.y;
        return this;
      }
      random() {
        this.x = Math.random();
        this.y = Math.random();
        return this;
      }
      *[Symbol.iterator]() {
        yield this.x;
        yield this.y;
      }
    };
    Vector2.prototype.isVector2 = true;
    Matrix3 = class {
      constructor() {
        this.elements = [
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ];
        if (arguments.length > 0) {
          console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
        }
      }
      set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
        const te = this.elements;
        te[0] = n11;
        te[1] = n21;
        te[2] = n31;
        te[3] = n12;
        te[4] = n22;
        te[5] = n32;
        te[6] = n13;
        te[7] = n23;
        te[8] = n33;
        return this;
      }
      identity() {
        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
        return this;
      }
      copy(m) {
        const te = this.elements;
        const me = m.elements;
        te[0] = me[0];
        te[1] = me[1];
        te[2] = me[2];
        te[3] = me[3];
        te[4] = me[4];
        te[5] = me[5];
        te[6] = me[6];
        te[7] = me[7];
        te[8] = me[8];
        return this;
      }
      extractBasis(xAxis, yAxis, zAxis) {
        xAxis.setFromMatrix3Column(this, 0);
        yAxis.setFromMatrix3Column(this, 1);
        zAxis.setFromMatrix3Column(this, 2);
        return this;
      }
      setFromMatrix4(m) {
        const me = m.elements;
        this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
        return this;
      }
      multiply(m) {
        return this.multiplyMatrices(this, m);
      }
      premultiply(m) {
        return this.multiplyMatrices(m, this);
      }
      multiplyMatrices(a, b2) {
        const ae = a.elements;
        const be = b2.elements;
        const te = this.elements;
        const a11 = ae[0], a12 = ae[3], a13 = ae[6];
        const a21 = ae[1], a22 = ae[4], a23 = ae[7];
        const a31 = ae[2], a32 = ae[5], a33 = ae[8];
        const b11 = be[0], b12 = be[3], b13 = be[6];
        const b21 = be[1], b22 = be[4], b23 = be[7];
        const b31 = be[2], b32 = be[5], b33 = be[8];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31;
        te[3] = a11 * b12 + a12 * b22 + a13 * b32;
        te[6] = a11 * b13 + a12 * b23 + a13 * b33;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31;
        te[4] = a21 * b12 + a22 * b22 + a23 * b32;
        te[7] = a21 * b13 + a22 * b23 + a23 * b33;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31;
        te[5] = a31 * b12 + a32 * b22 + a33 * b32;
        te[8] = a31 * b13 + a32 * b23 + a33 * b33;
        return this;
      }
      multiplyScalar(s) {
        const te = this.elements;
        te[0] *= s;
        te[3] *= s;
        te[6] *= s;
        te[1] *= s;
        te[4] *= s;
        te[7] *= s;
        te[2] *= s;
        te[5] *= s;
        te[8] *= s;
        return this;
      }
      determinant() {
        const te = this.elements;
        const a = te[0], b2 = te[1], c = te[2], d2 = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i2 = te[8];
        return a * e * i2 - a * f * h - b2 * d2 * i2 + b2 * f * g + c * d2 * h - c * e * g;
      }
      invert() {
        const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
        if (det === 0)
          return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n31 * n23 - n33 * n21) * detInv;
        te[2] = (n32 * n21 - n31 * n22) * detInv;
        te[3] = t12 * detInv;
        te[4] = (n33 * n11 - n31 * n13) * detInv;
        te[5] = (n31 * n12 - n32 * n11) * detInv;
        te[6] = t13 * detInv;
        te[7] = (n21 * n13 - n23 * n11) * detInv;
        te[8] = (n22 * n11 - n21 * n12) * detInv;
        return this;
      }
      transpose() {
        let tmp2;
        const m = this.elements;
        tmp2 = m[1];
        m[1] = m[3];
        m[3] = tmp2;
        tmp2 = m[2];
        m[2] = m[6];
        m[6] = tmp2;
        tmp2 = m[5];
        m[5] = m[7];
        m[7] = tmp2;
        return this;
      }
      getNormalMatrix(matrix4) {
        return this.setFromMatrix4(matrix4).invert().transpose();
      }
      transposeIntoArray(r3) {
        const m = this.elements;
        r3[0] = m[0];
        r3[1] = m[3];
        r3[2] = m[6];
        r3[3] = m[1];
        r3[4] = m[4];
        r3[5] = m[7];
        r3[6] = m[2];
        r3[7] = m[5];
        r3[8] = m[8];
        return this;
      }
      setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
        const c = Math.cos(rotation);
        const s = Math.sin(rotation);
        this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
        return this;
      }
      scale(sx, sy) {
        const te = this.elements;
        te[0] *= sx;
        te[3] *= sx;
        te[6] *= sx;
        te[1] *= sy;
        te[4] *= sy;
        te[7] *= sy;
        return this;
      }
      rotate(theta) {
        const c = Math.cos(theta);
        const s = Math.sin(theta);
        const te = this.elements;
        const a11 = te[0], a12 = te[3], a13 = te[6];
        const a21 = te[1], a22 = te[4], a23 = te[7];
        te[0] = c * a11 + s * a21;
        te[3] = c * a12 + s * a22;
        te[6] = c * a13 + s * a23;
        te[1] = -s * a11 + c * a21;
        te[4] = -s * a12 + c * a22;
        te[7] = -s * a13 + c * a23;
        return this;
      }
      translate(tx, ty) {
        const te = this.elements;
        te[0] += tx * te[2];
        te[3] += tx * te[5];
        te[6] += tx * te[8];
        te[1] += ty * te[2];
        te[4] += ty * te[5];
        te[7] += ty * te[8];
        return this;
      }
      equals(matrix) {
        const te = this.elements;
        const me = matrix.elements;
        for (let i2 = 0; i2 < 9; i2++) {
          if (te[i2] !== me[i2])
            return false;
        }
        return true;
      }
      fromArray(array, offset = 0) {
        for (let i2 = 0; i2 < 9; i2++) {
          this.elements[i2] = array[i2 + offset];
        }
        return this;
      }
      toArray(array = [], offset = 0) {
        const te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        return array;
      }
      clone() {
        return new this.constructor().fromArray(this.elements);
      }
    };
    Matrix3.prototype.isMatrix3 = true;
    TYPED_ARRAYS = {
      Int8Array,
      Uint8Array,
      Uint8ClampedArray,
      Int16Array,
      Uint16Array,
      Int32Array,
      Uint32Array,
      Float32Array,
      Float64Array
    };
    FN = {
      [SRGBColorSpace]: { [LinearSRGBColorSpace]: SRGBToLinear },
      [LinearSRGBColorSpace]: { [SRGBColorSpace]: LinearToSRGB }
    };
    ColorManagement = {
      legacyMode: true,
      get workingColorSpace() {
        return LinearSRGBColorSpace;
      },
      set workingColorSpace(colorSpace) {
        console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
      },
      convert: function(color, sourceColorSpace, targetColorSpace) {
        if (this.legacyMode || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {
          return color;
        }
        if (FN[sourceColorSpace] && FN[sourceColorSpace][targetColorSpace] !== void 0) {
          const fn = FN[sourceColorSpace][targetColorSpace];
          color.r = fn(color.r);
          color.g = fn(color.g);
          color.b = fn(color.b);
          return color;
        }
        throw new Error("Unsupported color space conversion.");
      },
      fromWorkingColorSpace: function(color, targetColorSpace) {
        return this.convert(color, this.workingColorSpace, targetColorSpace);
      },
      toWorkingColorSpace: function(color, sourceColorSpace) {
        return this.convert(color, sourceColorSpace, this.workingColorSpace);
      }
    };
    _colorKeywords = {
      "aliceblue": 15792383,
      "antiquewhite": 16444375,
      "aqua": 65535,
      "aquamarine": 8388564,
      "azure": 15794175,
      "beige": 16119260,
      "bisque": 16770244,
      "black": 0,
      "blanchedalmond": 16772045,
      "blue": 255,
      "blueviolet": 9055202,
      "brown": 10824234,
      "burlywood": 14596231,
      "cadetblue": 6266528,
      "chartreuse": 8388352,
      "chocolate": 13789470,
      "coral": 16744272,
      "cornflowerblue": 6591981,
      "cornsilk": 16775388,
      "crimson": 14423100,
      "cyan": 65535,
      "darkblue": 139,
      "darkcyan": 35723,
      "darkgoldenrod": 12092939,
      "darkgray": 11119017,
      "darkgreen": 25600,
      "darkgrey": 11119017,
      "darkkhaki": 12433259,
      "darkmagenta": 9109643,
      "darkolivegreen": 5597999,
      "darkorange": 16747520,
      "darkorchid": 10040012,
      "darkred": 9109504,
      "darksalmon": 15308410,
      "darkseagreen": 9419919,
      "darkslateblue": 4734347,
      "darkslategray": 3100495,
      "darkslategrey": 3100495,
      "darkturquoise": 52945,
      "darkviolet": 9699539,
      "deeppink": 16716947,
      "deepskyblue": 49151,
      "dimgray": 6908265,
      "dimgrey": 6908265,
      "dodgerblue": 2003199,
      "firebrick": 11674146,
      "floralwhite": 16775920,
      "forestgreen": 2263842,
      "fuchsia": 16711935,
      "gainsboro": 14474460,
      "ghostwhite": 16316671,
      "gold": 16766720,
      "goldenrod": 14329120,
      "gray": 8421504,
      "green": 32768,
      "greenyellow": 11403055,
      "grey": 8421504,
      "honeydew": 15794160,
      "hotpink": 16738740,
      "indianred": 13458524,
      "indigo": 4915330,
      "ivory": 16777200,
      "khaki": 15787660,
      "lavender": 15132410,
      "lavenderblush": 16773365,
      "lawngreen": 8190976,
      "lemonchiffon": 16775885,
      "lightblue": 11393254,
      "lightcoral": 15761536,
      "lightcyan": 14745599,
      "lightgoldenrodyellow": 16448210,
      "lightgray": 13882323,
      "lightgreen": 9498256,
      "lightgrey": 13882323,
      "lightpink": 16758465,
      "lightsalmon": 16752762,
      "lightseagreen": 2142890,
      "lightskyblue": 8900346,
      "lightslategray": 7833753,
      "lightslategrey": 7833753,
      "lightsteelblue": 11584734,
      "lightyellow": 16777184,
      "lime": 65280,
      "limegreen": 3329330,
      "linen": 16445670,
      "magenta": 16711935,
      "maroon": 8388608,
      "mediumaquamarine": 6737322,
      "mediumblue": 205,
      "mediumorchid": 12211667,
      "mediumpurple": 9662683,
      "mediumseagreen": 3978097,
      "mediumslateblue": 8087790,
      "mediumspringgreen": 64154,
      "mediumturquoise": 4772300,
      "mediumvioletred": 13047173,
      "midnightblue": 1644912,
      "mintcream": 16121850,
      "mistyrose": 16770273,
      "moccasin": 16770229,
      "navajowhite": 16768685,
      "navy": 128,
      "oldlace": 16643558,
      "olive": 8421376,
      "olivedrab": 7048739,
      "orange": 16753920,
      "orangered": 16729344,
      "orchid": 14315734,
      "palegoldenrod": 15657130,
      "palegreen": 10025880,
      "paleturquoise": 11529966,
      "palevioletred": 14381203,
      "papayawhip": 16773077,
      "peachpuff": 16767673,
      "peru": 13468991,
      "pink": 16761035,
      "plum": 14524637,
      "powderblue": 11591910,
      "purple": 8388736,
      "rebeccapurple": 6697881,
      "red": 16711680,
      "rosybrown": 12357519,
      "royalblue": 4286945,
      "saddlebrown": 9127187,
      "salmon": 16416882,
      "sandybrown": 16032864,
      "seagreen": 3050327,
      "seashell": 16774638,
      "sienna": 10506797,
      "silver": 12632256,
      "skyblue": 8900331,
      "slateblue": 6970061,
      "slategray": 7372944,
      "slategrey": 7372944,
      "snow": 16775930,
      "springgreen": 65407,
      "steelblue": 4620980,
      "tan": 13808780,
      "teal": 32896,
      "thistle": 14204888,
      "tomato": 16737095,
      "turquoise": 4251856,
      "violet": 15631086,
      "wheat": 16113331,
      "white": 16777215,
      "whitesmoke": 16119285,
      "yellow": 16776960,
      "yellowgreen": 10145074
    };
    _rgb = { r: 0, g: 0, b: 0 };
    _hslA = { h: 0, s: 0, l: 0 };
    _hslB = { h: 0, s: 0, l: 0 };
    Color = class {
      constructor(r3, g, b2) {
        if (g === void 0 && b2 === void 0) {
          return this.set(r3);
        }
        return this.setRGB(r3, g, b2);
      }
      set(value) {
        if (value && value.isColor) {
          this.copy(value);
        } else if (typeof value === "number") {
          this.setHex(value);
        } else if (typeof value === "string") {
          this.setStyle(value);
        }
        return this;
      }
      setScalar(scalar) {
        this.r = scalar;
        this.g = scalar;
        this.b = scalar;
        return this;
      }
      setHex(hex, colorSpace = SRGBColorSpace) {
        hex = Math.floor(hex);
        this.r = (hex >> 16 & 255) / 255;
        this.g = (hex >> 8 & 255) / 255;
        this.b = (hex & 255) / 255;
        ColorManagement.toWorkingColorSpace(this, colorSpace);
        return this;
      }
      setRGB(r3, g, b2, colorSpace = LinearSRGBColorSpace) {
        this.r = r3;
        this.g = g;
        this.b = b2;
        ColorManagement.toWorkingColorSpace(this, colorSpace);
        return this;
      }
      setHSL(h, s, l, colorSpace = LinearSRGBColorSpace) {
        h = euclideanModulo(h, 1);
        s = clamp(s, 0, 1);
        l = clamp(l, 0, 1);
        if (s === 0) {
          this.r = this.g = this.b = l;
        } else {
          const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
          const q = 2 * l - p;
          this.r = hue2rgb(q, p, h + 1 / 3);
          this.g = hue2rgb(q, p, h);
          this.b = hue2rgb(q, p, h - 1 / 3);
        }
        ColorManagement.toWorkingColorSpace(this, colorSpace);
        return this;
      }
      setStyle(style, colorSpace = SRGBColorSpace) {
        function handleAlpha(string) {
          if (string === void 0)
            return;
          if (parseFloat(string) < 1) {
            console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
          }
        }
        let m;
        if (m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
          let color;
          const name = m[1];
          const components = m[2];
          switch (name) {
            case "rgb":
            case "rgba":
              if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                this.r = Math.min(255, parseInt(color[1], 10)) / 255;
                this.g = Math.min(255, parseInt(color[2], 10)) / 255;
                this.b = Math.min(255, parseInt(color[3], 10)) / 255;
                ColorManagement.toWorkingColorSpace(this, colorSpace);
                handleAlpha(color[4]);
                return this;
              }
              if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                this.r = Math.min(100, parseInt(color[1], 10)) / 100;
                this.g = Math.min(100, parseInt(color[2], 10)) / 100;
                this.b = Math.min(100, parseInt(color[3], 10)) / 100;
                ColorManagement.toWorkingColorSpace(this, colorSpace);
                handleAlpha(color[4]);
                return this;
              }
              break;
            case "hsl":
            case "hsla":
              if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                const h = parseFloat(color[1]) / 360;
                const s = parseInt(color[2], 10) / 100;
                const l = parseInt(color[3], 10) / 100;
                handleAlpha(color[4]);
                return this.setHSL(h, s, l, colorSpace);
              }
              break;
          }
        } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
          const hex = m[1];
          const size = hex.length;
          if (size === 3) {
            this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
            this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
            this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
            ColorManagement.toWorkingColorSpace(this, colorSpace);
            return this;
          } else if (size === 6) {
            this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
            this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
            this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
            ColorManagement.toWorkingColorSpace(this, colorSpace);
            return this;
          }
        }
        if (style && style.length > 0) {
          return this.setColorName(style, colorSpace);
        }
        return this;
      }
      setColorName(style, colorSpace = SRGBColorSpace) {
        const hex = _colorKeywords[style.toLowerCase()];
        if (hex !== void 0) {
          this.setHex(hex, colorSpace);
        } else {
          console.warn("THREE.Color: Unknown color " + style);
        }
        return this;
      }
      clone() {
        return new this.constructor(this.r, this.g, this.b);
      }
      copy(color) {
        this.r = color.r;
        this.g = color.g;
        this.b = color.b;
        return this;
      }
      copySRGBToLinear(color) {
        this.r = SRGBToLinear(color.r);
        this.g = SRGBToLinear(color.g);
        this.b = SRGBToLinear(color.b);
        return this;
      }
      copyLinearToSRGB(color) {
        this.r = LinearToSRGB(color.r);
        this.g = LinearToSRGB(color.g);
        this.b = LinearToSRGB(color.b);
        return this;
      }
      convertSRGBToLinear() {
        this.copySRGBToLinear(this);
        return this;
      }
      convertLinearToSRGB() {
        this.copyLinearToSRGB(this);
        return this;
      }
      getHex(colorSpace = SRGBColorSpace) {
        ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
        return clamp(_rgb.r * 255, 0, 255) << 16 ^ clamp(_rgb.g * 255, 0, 255) << 8 ^ clamp(_rgb.b * 255, 0, 255) << 0;
      }
      getHexString(colorSpace = SRGBColorSpace) {
        return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);
      }
      getHSL(target, colorSpace = LinearSRGBColorSpace) {
        ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
        const r3 = _rgb.r, g = _rgb.g, b2 = _rgb.b;
        const max = Math.max(r3, g, b2);
        const min = Math.min(r3, g, b2);
        let hue, saturation;
        const lightness = (min + max) / 2;
        if (min === max) {
          hue = 0;
          saturation = 0;
        } else {
          const delta = max - min;
          saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
          switch (max) {
            case r3:
              hue = (g - b2) / delta + (g < b2 ? 6 : 0);
              break;
            case g:
              hue = (b2 - r3) / delta + 2;
              break;
            case b2:
              hue = (r3 - g) / delta + 4;
              break;
          }
          hue /= 6;
        }
        target.h = hue;
        target.s = saturation;
        target.l = lightness;
        return target;
      }
      getRGB(target, colorSpace = LinearSRGBColorSpace) {
        ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
        target.r = _rgb.r;
        target.g = _rgb.g;
        target.b = _rgb.b;
        return target;
      }
      getStyle(colorSpace = SRGBColorSpace) {
        ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace);
        if (colorSpace !== SRGBColorSpace) {
          return `color(${colorSpace} ${_rgb.r} ${_rgb.g} ${_rgb.b})`;
        }
        return `rgb(${_rgb.r * 255 | 0},${_rgb.g * 255 | 0},${_rgb.b * 255 | 0})`;
      }
      offsetHSL(h, s, l) {
        this.getHSL(_hslA);
        _hslA.h += h;
        _hslA.s += s;
        _hslA.l += l;
        this.setHSL(_hslA.h, _hslA.s, _hslA.l);
        return this;
      }
      add(color) {
        this.r += color.r;
        this.g += color.g;
        this.b += color.b;
        return this;
      }
      addColors(color1, color2) {
        this.r = color1.r + color2.r;
        this.g = color1.g + color2.g;
        this.b = color1.b + color2.b;
        return this;
      }
      addScalar(s) {
        this.r += s;
        this.g += s;
        this.b += s;
        return this;
      }
      sub(color) {
        this.r = Math.max(0, this.r - color.r);
        this.g = Math.max(0, this.g - color.g);
        this.b = Math.max(0, this.b - color.b);
        return this;
      }
      multiply(color) {
        this.r *= color.r;
        this.g *= color.g;
        this.b *= color.b;
        return this;
      }
      multiplyScalar(s) {
        this.r *= s;
        this.g *= s;
        this.b *= s;
        return this;
      }
      lerp(color, alpha) {
        this.r += (color.r - this.r) * alpha;
        this.g += (color.g - this.g) * alpha;
        this.b += (color.b - this.b) * alpha;
        return this;
      }
      lerpColors(color1, color2, alpha) {
        this.r = color1.r + (color2.r - color1.r) * alpha;
        this.g = color1.g + (color2.g - color1.g) * alpha;
        this.b = color1.b + (color2.b - color1.b) * alpha;
        return this;
      }
      lerpHSL(color, alpha) {
        this.getHSL(_hslA);
        color.getHSL(_hslB);
        const h = lerp(_hslA.h, _hslB.h, alpha);
        const s = lerp(_hslA.s, _hslB.s, alpha);
        const l = lerp(_hslA.l, _hslB.l, alpha);
        this.setHSL(h, s, l);
        return this;
      }
      equals(c) {
        return c.r === this.r && c.g === this.g && c.b === this.b;
      }
      fromArray(array, offset = 0) {
        this.r = array[offset];
        this.g = array[offset + 1];
        this.b = array[offset + 2];
        return this;
      }
      toArray(array = [], offset = 0) {
        array[offset] = this.r;
        array[offset + 1] = this.g;
        array[offset + 2] = this.b;
        return array;
      }
      fromBufferAttribute(attribute, index) {
        this.r = attribute.getX(index);
        this.g = attribute.getY(index);
        this.b = attribute.getZ(index);
        if (attribute.normalized === true) {
          this.r /= 255;
          this.g /= 255;
          this.b /= 255;
        }
        return this;
      }
      toJSON() {
        return this.getHex();
      }
    };
    Color.NAMES = _colorKeywords;
    Color.prototype.isColor = true;
    Color.prototype.r = 1;
    Color.prototype.g = 1;
    Color.prototype.b = 1;
    ImageUtils = class {
      static getDataURL(image) {
        if (/^data:/i.test(image.src)) {
          return image.src;
        }
        if (typeof HTMLCanvasElement == "undefined") {
          return image.src;
        }
        let canvas;
        if (image instanceof HTMLCanvasElement) {
          canvas = image;
        } else {
          if (_canvas === void 0)
            _canvas = createElementNS("canvas");
          _canvas.width = image.width;
          _canvas.height = image.height;
          const context = _canvas.getContext("2d");
          if (image instanceof ImageData) {
            context.putImageData(image, 0, 0);
          } else {
            context.drawImage(image, 0, 0, image.width, image.height);
          }
          canvas = _canvas;
        }
        if (canvas.width > 2048 || canvas.height > 2048) {
          console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image);
          return canvas.toDataURL("image/jpeg", 0.6);
        } else {
          return canvas.toDataURL("image/png");
        }
      }
      static sRGBToLinear(image) {
        if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
          const canvas = createElementNS("canvas");
          canvas.width = image.width;
          canvas.height = image.height;
          const context = canvas.getContext("2d");
          context.drawImage(image, 0, 0, image.width, image.height);
          const imageData = context.getImageData(0, 0, image.width, image.height);
          const data = imageData.data;
          for (let i2 = 0; i2 < data.length; i2++) {
            data[i2] = SRGBToLinear(data[i2] / 255) * 255;
          }
          context.putImageData(imageData, 0, 0);
          return canvas;
        } else if (image.data) {
          const data = image.data.slice(0);
          for (let i2 = 0; i2 < data.length; i2++) {
            if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
              data[i2] = Math.floor(SRGBToLinear(data[i2] / 255) * 255);
            } else {
              data[i2] = SRGBToLinear(data[i2]);
            }
          }
          return {
            data,
            width: image.width,
            height: image.height
          };
        } else {
          console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.");
          return image;
        }
      }
    };
    Source = class {
      constructor(data = null) {
        this.uuid = generateUUID();
        this.data = data;
        this.version = 0;
      }
      set needsUpdate(value) {
        if (value === true)
          this.version++;
      }
      toJSON(meta) {
        const isRootObject = meta === void 0 || typeof meta === "string";
        if (!isRootObject && meta.images[this.uuid] !== void 0) {
          return meta.images[this.uuid];
        }
        const output = {
          uuid: this.uuid,
          url: ""
        };
        const data = this.data;
        if (data !== null) {
          let url;
          if (Array.isArray(data)) {
            url = [];
            for (let i2 = 0, l = data.length; i2 < l; i2++) {
              if (data[i2].isDataTexture) {
                url.push(serializeImage(data[i2].image));
              } else {
                url.push(serializeImage(data[i2]));
              }
            }
          } else {
            url = serializeImage(data);
          }
          output.url = url;
        }
        if (!isRootObject) {
          meta.images[this.uuid] = output;
        }
        return output;
      }
    };
    Source.prototype.isSource = true;
    textureId = 0;
    Texture = class extends EventDispatcher {
      constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {
        super();
        Object.defineProperty(this, "id", { value: textureId++ });
        this.uuid = generateUUID();
        this.name = "";
        this.source = new Source(image);
        this.mipmaps = [];
        this.mapping = mapping;
        this.wrapS = wrapS;
        this.wrapT = wrapT;
        this.magFilter = magFilter;
        this.minFilter = minFilter;
        this.anisotropy = anisotropy;
        this.format = format;
        this.internalFormat = null;
        this.type = type;
        this.offset = new Vector2(0, 0);
        this.repeat = new Vector2(1, 1);
        this.center = new Vector2(0, 0);
        this.rotation = 0;
        this.matrixAutoUpdate = true;
        this.matrix = new Matrix3();
        this.generateMipmaps = true;
        this.premultiplyAlpha = false;
        this.flipY = true;
        this.unpackAlignment = 4;
        this.encoding = encoding;
        this.userData = {};
        this.version = 0;
        this.onUpdate = null;
        this.isRenderTargetTexture = false;
        this.needsPMREMUpdate = false;
      }
      get image() {
        return this.source.data;
      }
      set image(value) {
        this.source.data = value;
      }
      updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(source) {
        this.name = source.name;
        this.source = source.source;
        this.mipmaps = source.mipmaps.slice(0);
        this.mapping = source.mapping;
        this.wrapS = source.wrapS;
        this.wrapT = source.wrapT;
        this.magFilter = source.magFilter;
        this.minFilter = source.minFilter;
        this.anisotropy = source.anisotropy;
        this.format = source.format;
        this.internalFormat = source.internalFormat;
        this.type = source.type;
        this.offset.copy(source.offset);
        this.repeat.copy(source.repeat);
        this.center.copy(source.center);
        this.rotation = source.rotation;
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrix.copy(source.matrix);
        this.generateMipmaps = source.generateMipmaps;
        this.premultiplyAlpha = source.premultiplyAlpha;
        this.flipY = source.flipY;
        this.unpackAlignment = source.unpackAlignment;
        this.encoding = source.encoding;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        this.needsUpdate = true;
        return this;
      }
      toJSON(meta) {
        const isRootObject = meta === void 0 || typeof meta === "string";
        if (!isRootObject && meta.textures[this.uuid] !== void 0) {
          return meta.textures[this.uuid];
        }
        const output = {
          metadata: {
            version: 4.5,
            type: "Texture",
            generator: "Texture.toJSON"
          },
          uuid: this.uuid,
          name: this.name,
          image: this.source.toJSON(meta).uuid,
          mapping: this.mapping,
          repeat: [this.repeat.x, this.repeat.y],
          offset: [this.offset.x, this.offset.y],
          center: [this.center.x, this.center.y],
          rotation: this.rotation,
          wrap: [this.wrapS, this.wrapT],
          format: this.format,
          type: this.type,
          encoding: this.encoding,
          minFilter: this.minFilter,
          magFilter: this.magFilter,
          anisotropy: this.anisotropy,
          flipY: this.flipY,
          premultiplyAlpha: this.premultiplyAlpha,
          unpackAlignment: this.unpackAlignment
        };
        if (JSON.stringify(this.userData) !== "{}")
          output.userData = this.userData;
        if (!isRootObject) {
          meta.textures[this.uuid] = output;
        }
        return output;
      }
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
      transformUv(uv) {
        if (this.mapping !== UVMapping)
          return uv;
        uv.applyMatrix3(this.matrix);
        if (uv.x < 0 || uv.x > 1) {
          switch (this.wrapS) {
            case RepeatWrapping:
              uv.x = uv.x - Math.floor(uv.x);
              break;
            case ClampToEdgeWrapping:
              uv.x = uv.x < 0 ? 0 : 1;
              break;
            case MirroredRepeatWrapping:
              if (Math.abs(Math.floor(uv.x) % 2) === 1) {
                uv.x = Math.ceil(uv.x) - uv.x;
              } else {
                uv.x = uv.x - Math.floor(uv.x);
              }
              break;
          }
        }
        if (uv.y < 0 || uv.y > 1) {
          switch (this.wrapT) {
            case RepeatWrapping:
              uv.y = uv.y - Math.floor(uv.y);
              break;
            case ClampToEdgeWrapping:
              uv.y = uv.y < 0 ? 0 : 1;
              break;
            case MirroredRepeatWrapping:
              if (Math.abs(Math.floor(uv.y) % 2) === 1) {
                uv.y = Math.ceil(uv.y) - uv.y;
              } else {
                uv.y = uv.y - Math.floor(uv.y);
              }
              break;
          }
        }
        if (this.flipY) {
          uv.y = 1 - uv.y;
        }
        return uv;
      }
      set needsUpdate(value) {
        if (value === true) {
          this.version++;
          this.source.needsUpdate = true;
        }
      }
    };
    Texture.DEFAULT_IMAGE = null;
    Texture.DEFAULT_MAPPING = UVMapping;
    Texture.prototype.isTexture = true;
    Vector4 = class {
      constructor(x = 0, y2 = 0, z = 0, w = 1) {
        this.x = x;
        this.y = y2;
        this.z = z;
        this.w = w;
      }
      get width() {
        return this.z;
      }
      set width(value) {
        this.z = value;
      }
      get height() {
        return this.w;
      }
      set height(value) {
        this.w = value;
      }
      set(x, y2, z, w) {
        this.x = x;
        this.y = y2;
        this.z = z;
        this.w = w;
        return this;
      }
      setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        this.w = scalar;
        return this;
      }
      setX(x) {
        this.x = x;
        return this;
      }
      setY(y2) {
        this.y = y2;
        return this;
      }
      setZ(z) {
        this.z = z;
        return this;
      }
      setW(w) {
        this.w = w;
        return this;
      }
      setComponent(index, value) {
        switch (index) {
          case 0:
            this.x = value;
            break;
          case 1:
            this.y = value;
            break;
          case 2:
            this.z = value;
            break;
          case 3:
            this.w = value;
            break;
          default:
            throw new Error("index is out of range: " + index);
        }
        return this;
      }
      getComponent(index) {
        switch (index) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          case 3:
            return this.w;
          default:
            throw new Error("index is out of range: " + index);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y, this.z, this.w);
      }
      copy(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        this.w = v.w !== void 0 ? v.w : 1;
        return this;
      }
      add(v, w) {
        if (w !== void 0) {
          console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
          return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        this.w += v.w;
        return this;
      }
      addScalar(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        this.w += s;
        return this;
      }
      addVectors(a, b2) {
        this.x = a.x + b2.x;
        this.y = a.y + b2.y;
        this.z = a.z + b2.z;
        this.w = a.w + b2.w;
        return this;
      }
      addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        this.w += v.w * s;
        return this;
      }
      sub(v, w) {
        if (w !== void 0) {
          console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
          return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        this.w -= v.w;
        return this;
      }
      subScalar(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        this.w -= s;
        return this;
      }
      subVectors(a, b2) {
        this.x = a.x - b2.x;
        this.y = a.y - b2.y;
        this.z = a.z - b2.z;
        this.w = a.w - b2.w;
        return this;
      }
      multiply(v) {
        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;
        this.w *= v.w;
        return this;
      }
      multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        this.w *= scalar;
        return this;
      }
      applyMatrix4(m) {
        const x = this.x, y2 = this.y, z = this.z, w = this.w;
        const e = m.elements;
        this.x = e[0] * x + e[4] * y2 + e[8] * z + e[12] * w;
        this.y = e[1] * x + e[5] * y2 + e[9] * z + e[13] * w;
        this.z = e[2] * x + e[6] * y2 + e[10] * z + e[14] * w;
        this.w = e[3] * x + e[7] * y2 + e[11] * z + e[15] * w;
        return this;
      }
      divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
      }
      setAxisAngleFromQuaternion(q) {
        this.w = 2 * Math.acos(q.w);
        const s = Math.sqrt(1 - q.w * q.w);
        if (s < 1e-4) {
          this.x = 1;
          this.y = 0;
          this.z = 0;
        } else {
          this.x = q.x / s;
          this.y = q.y / s;
          this.z = q.z / s;
        }
        return this;
      }
      setAxisAngleFromRotationMatrix(m) {
        let angle, x, y2, z;
        const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
        if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
          if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
            this.set(1, 0, 0, 0);
            return this;
          }
          angle = Math.PI;
          const xx = (m11 + 1) / 2;
          const yy = (m22 + 1) / 2;
          const zz = (m33 + 1) / 2;
          const xy = (m12 + m21) / 4;
          const xz = (m13 + m31) / 4;
          const yz = (m23 + m32) / 4;
          if (xx > yy && xx > zz) {
            if (xx < epsilon) {
              x = 0;
              y2 = 0.707106781;
              z = 0.707106781;
            } else {
              x = Math.sqrt(xx);
              y2 = xy / x;
              z = xz / x;
            }
          } else if (yy > zz) {
            if (yy < epsilon) {
              x = 0.707106781;
              y2 = 0;
              z = 0.707106781;
            } else {
              y2 = Math.sqrt(yy);
              x = xy / y2;
              z = yz / y2;
            }
          } else {
            if (zz < epsilon) {
              x = 0.707106781;
              y2 = 0.707106781;
              z = 0;
            } else {
              z = Math.sqrt(zz);
              x = xz / z;
              y2 = yz / z;
            }
          }
          this.set(x, y2, z, angle);
          return this;
        }
        let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
        if (Math.abs(s) < 1e-3)
          s = 1;
        this.x = (m32 - m23) / s;
        this.y = (m13 - m31) / s;
        this.z = (m21 - m12) / s;
        this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
        return this;
      }
      min(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        this.z = Math.min(this.z, v.z);
        this.w = Math.min(this.w, v.w);
        return this;
      }
      max(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        this.z = Math.max(this.z, v.z);
        this.w = Math.max(this.w, v.w);
        return this;
      }
      clamp(min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        this.w = Math.max(min.w, Math.min(max.w, this.w));
        return this;
      }
      clampScalar(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        this.z = Math.max(minVal, Math.min(maxVal, this.z));
        this.w = Math.max(minVal, Math.min(maxVal, this.w));
        return this;
      }
      clampLength(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
      }
      floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        this.w = Math.floor(this.w);
        return this;
      }
      ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        this.w = Math.ceil(this.w);
        return this;
      }
      round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        this.w = Math.round(this.w);
        return this;
      }
      roundToZero() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
        this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
        return this;
      }
      negate() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        this.w = -this.w;
        return this;
      }
      dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      setLength(length) {
        return this.normalize().multiplyScalar(length);
      }
      lerp(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        this.w += (v.w - this.w) * alpha;
        return this;
      }
      lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        this.z = v1.z + (v2.z - v1.z) * alpha;
        this.w = v1.w + (v2.w - v1.w) * alpha;
        return this;
      }
      equals(v) {
        return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
      }
      fromArray(array, offset = 0) {
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        this.w = array[offset + 3];
        return this;
      }
      toArray(array = [], offset = 0) {
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        array[offset + 3] = this.w;
        return array;
      }
      fromBufferAttribute(attribute, index, offset) {
        if (offset !== void 0) {
          console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
        }
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        this.z = attribute.getZ(index);
        this.w = attribute.getW(index);
        return this;
      }
      random() {
        this.x = Math.random();
        this.y = Math.random();
        this.z = Math.random();
        this.w = Math.random();
        return this;
      }
      *[Symbol.iterator]() {
        yield this.x;
        yield this.y;
        yield this.z;
        yield this.w;
      }
    };
    Vector4.prototype.isVector4 = true;
    WebGLRenderTarget = class extends EventDispatcher {
      constructor(width, height, options = {}) {
        super();
        this.width = width;
        this.height = height;
        this.depth = 1;
        this.scissor = new Vector4(0, 0, width, height);
        this.scissorTest = false;
        this.viewport = new Vector4(0, 0, width, height);
        const image = { width, height, depth: 1 };
        this.texture = new Texture(image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
        this.texture.isRenderTargetTexture = true;
        this.texture.flipY = false;
        this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
        this.texture.internalFormat = options.internalFormat !== void 0 ? options.internalFormat : null;
        this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
        this.depthBuffer = options.depthBuffer !== void 0 ? options.depthBuffer : true;
        this.stencilBuffer = options.stencilBuffer !== void 0 ? options.stencilBuffer : false;
        this.depthTexture = options.depthTexture !== void 0 ? options.depthTexture : null;
        this.samples = options.samples !== void 0 ? options.samples : 0;
      }
      setSize(width, height, depth = 1) {
        if (this.width !== width || this.height !== height || this.depth !== depth) {
          this.width = width;
          this.height = height;
          this.depth = depth;
          this.texture.image.width = width;
          this.texture.image.height = height;
          this.texture.image.depth = depth;
          this.dispose();
        }
        this.viewport.set(0, 0, width, height);
        this.scissor.set(0, 0, width, height);
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(source) {
        this.width = source.width;
        this.height = source.height;
        this.depth = source.depth;
        this.viewport.copy(source.viewport);
        this.texture = source.texture.clone();
        this.texture.isRenderTargetTexture = true;
        this.texture.image = Object.assign({}, source.texture.image);
        this.depthBuffer = source.depthBuffer;
        this.stencilBuffer = source.stencilBuffer;
        if (source.depthTexture !== null)
          this.depthTexture = source.depthTexture.clone();
        this.samples = source.samples;
        return this;
      }
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
    };
    WebGLRenderTarget.prototype.isWebGLRenderTarget = true;
    DataArrayTexture = class extends Texture {
      constructor(data = null, width = 1, height = 1, depth = 1) {
        super(null);
        this.image = { data, width, height, depth };
        this.magFilter = NearestFilter;
        this.minFilter = NearestFilter;
        this.wrapR = ClampToEdgeWrapping;
        this.generateMipmaps = false;
        this.flipY = false;
        this.unpackAlignment = 1;
      }
    };
    DataArrayTexture.prototype.isDataArrayTexture = true;
    WebGLArrayRenderTarget = class extends WebGLRenderTarget {
      constructor(width, height, depth) {
        super(width, height);
        this.depth = depth;
        this.texture = new DataArrayTexture(null, width, height, depth);
        this.texture.isRenderTargetTexture = true;
      }
    };
    WebGLArrayRenderTarget.prototype.isWebGLArrayRenderTarget = true;
    Data3DTexture = class extends Texture {
      constructor(data = null, width = 1, height = 1, depth = 1) {
        super(null);
        this.image = { data, width, height, depth };
        this.magFilter = NearestFilter;
        this.minFilter = NearestFilter;
        this.wrapR = ClampToEdgeWrapping;
        this.generateMipmaps = false;
        this.flipY = false;
        this.unpackAlignment = 1;
      }
    };
    Data3DTexture.prototype.isData3DTexture = true;
    WebGL3DRenderTarget = class extends WebGLRenderTarget {
      constructor(width, height, depth) {
        super(width, height);
        this.depth = depth;
        this.texture = new Data3DTexture(null, width, height, depth);
        this.texture.isRenderTargetTexture = true;
      }
    };
    WebGL3DRenderTarget.prototype.isWebGL3DRenderTarget = true;
    WebGLMultipleRenderTargets = class extends WebGLRenderTarget {
      constructor(width, height, count, options = {}) {
        super(width, height, options);
        const texture = this.texture;
        this.texture = [];
        for (let i2 = 0; i2 < count; i2++) {
          this.texture[i2] = texture.clone();
          this.texture[i2].isRenderTargetTexture = true;
        }
      }
      setSize(width, height, depth = 1) {
        if (this.width !== width || this.height !== height || this.depth !== depth) {
          this.width = width;
          this.height = height;
          this.depth = depth;
          for (let i2 = 0, il = this.texture.length; i2 < il; i2++) {
            this.texture[i2].image.width = width;
            this.texture[i2].image.height = height;
            this.texture[i2].image.depth = depth;
          }
          this.dispose();
        }
        this.viewport.set(0, 0, width, height);
        this.scissor.set(0, 0, width, height);
        return this;
      }
      copy(source) {
        this.dispose();
        this.width = source.width;
        this.height = source.height;
        this.depth = source.depth;
        this.viewport.set(0, 0, this.width, this.height);
        this.scissor.set(0, 0, this.width, this.height);
        this.depthBuffer = source.depthBuffer;
        this.stencilBuffer = source.stencilBuffer;
        this.depthTexture = source.depthTexture;
        this.texture.length = 0;
        for (let i2 = 0, il = source.texture.length; i2 < il; i2++) {
          this.texture[i2] = source.texture[i2].clone();
        }
        return this;
      }
    };
    WebGLMultipleRenderTargets.prototype.isWebGLMultipleRenderTargets = true;
    Quaternion = class {
      constructor(x = 0, y2 = 0, z = 0, w = 1) {
        this._x = x;
        this._y = y2;
        this._z = z;
        this._w = w;
      }
      static slerp(qa, qb, qm, t2) {
        console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.");
        return qm.slerpQuaternions(qa, qb, t2);
      }
      static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t2) {
        let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
        const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
        if (t2 === 0) {
          dst[dstOffset + 0] = x0;
          dst[dstOffset + 1] = y0;
          dst[dstOffset + 2] = z0;
          dst[dstOffset + 3] = w0;
          return;
        }
        if (t2 === 1) {
          dst[dstOffset + 0] = x1;
          dst[dstOffset + 1] = y1;
          dst[dstOffset + 2] = z1;
          dst[dstOffset + 3] = w1;
          return;
        }
        if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
          let s = 1 - t2;
          const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
          if (sqrSin > Number.EPSILON) {
            const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
            s = Math.sin(s * len) / sin;
            t2 = Math.sin(t2 * len) / sin;
          }
          const tDir = t2 * dir;
          x0 = x0 * s + x1 * tDir;
          y0 = y0 * s + y1 * tDir;
          z0 = z0 * s + z1 * tDir;
          w0 = w0 * s + w1 * tDir;
          if (s === 1 - t2) {
            const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
            x0 *= f;
            y0 *= f;
            z0 *= f;
            w0 *= f;
          }
        }
        dst[dstOffset] = x0;
        dst[dstOffset + 1] = y0;
        dst[dstOffset + 2] = z0;
        dst[dstOffset + 3] = w0;
      }
      static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
        const x0 = src0[srcOffset0];
        const y0 = src0[srcOffset0 + 1];
        const z0 = src0[srcOffset0 + 2];
        const w0 = src0[srcOffset0 + 3];
        const x1 = src1[srcOffset1];
        const y1 = src1[srcOffset1 + 1];
        const z1 = src1[srcOffset1 + 2];
        const w1 = src1[srcOffset1 + 3];
        dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
        dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
        dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
        dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
        return dst;
      }
      get x() {
        return this._x;
      }
      set x(value) {
        this._x = value;
        this._onChangeCallback();
      }
      get y() {
        return this._y;
      }
      set y(value) {
        this._y = value;
        this._onChangeCallback();
      }
      get z() {
        return this._z;
      }
      set z(value) {
        this._z = value;
        this._onChangeCallback();
      }
      get w() {
        return this._w;
      }
      set w(value) {
        this._w = value;
        this._onChangeCallback();
      }
      set(x, y2, z, w) {
        this._x = x;
        this._y = y2;
        this._z = z;
        this._w = w;
        this._onChangeCallback();
        return this;
      }
      clone() {
        return new this.constructor(this._x, this._y, this._z, this._w);
      }
      copy(quaternion) {
        this._x = quaternion.x;
        this._y = quaternion.y;
        this._z = quaternion.z;
        this._w = quaternion.w;
        this._onChangeCallback();
        return this;
      }
      setFromEuler(euler, update) {
        if (!(euler && euler.isEuler)) {
          throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
        }
        const x = euler._x, y2 = euler._y, z = euler._z, order = euler._order;
        const cos = Math.cos;
        const sin = Math.sin;
        const c1 = cos(x / 2);
        const c2 = cos(y2 / 2);
        const c3 = cos(z / 2);
        const s1 = sin(x / 2);
        const s2 = sin(y2 / 2);
        const s3 = sin(z / 2);
        switch (order) {
          case "XYZ":
            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;
            break;
          case "YXZ":
            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;
            break;
          case "ZXY":
            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;
            break;
          case "ZYX":
            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;
            break;
          case "YZX":
            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;
            break;
          case "XZY":
            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;
            break;
          default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
        }
        if (update !== false)
          this._onChangeCallback();
        return this;
      }
      setFromAxisAngle(axis, angle) {
        const halfAngle = angle / 2, s = Math.sin(halfAngle);
        this._x = axis.x * s;
        this._y = axis.y * s;
        this._z = axis.z * s;
        this._w = Math.cos(halfAngle);
        this._onChangeCallback();
        return this;
      }
      setFromRotationMatrix(m) {
        const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
        if (trace > 0) {
          const s = 0.5 / Math.sqrt(trace + 1);
          this._w = 0.25 / s;
          this._x = (m32 - m23) * s;
          this._y = (m13 - m31) * s;
          this._z = (m21 - m12) * s;
        } else if (m11 > m22 && m11 > m33) {
          const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
          this._w = (m32 - m23) / s;
          this._x = 0.25 * s;
          this._y = (m12 + m21) / s;
          this._z = (m13 + m31) / s;
        } else if (m22 > m33) {
          const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
          this._w = (m13 - m31) / s;
          this._x = (m12 + m21) / s;
          this._y = 0.25 * s;
          this._z = (m23 + m32) / s;
        } else {
          const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
          this._w = (m21 - m12) / s;
          this._x = (m13 + m31) / s;
          this._y = (m23 + m32) / s;
          this._z = 0.25 * s;
        }
        this._onChangeCallback();
        return this;
      }
      setFromUnitVectors(vFrom, vTo) {
        let r3 = vFrom.dot(vTo) + 1;
        if (r3 < Number.EPSILON) {
          r3 = 0;
          if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
            this._x = -vFrom.y;
            this._y = vFrom.x;
            this._z = 0;
            this._w = r3;
          } else {
            this._x = 0;
            this._y = -vFrom.z;
            this._z = vFrom.y;
            this._w = r3;
          }
        } else {
          this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
          this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
          this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
          this._w = r3;
        }
        return this.normalize();
      }
      angleTo(q) {
        return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
      }
      rotateTowards(q, step) {
        const angle = this.angleTo(q);
        if (angle === 0)
          return this;
        const t2 = Math.min(1, step / angle);
        this.slerp(q, t2);
        return this;
      }
      identity() {
        return this.set(0, 0, 0, 1);
      }
      invert() {
        return this.conjugate();
      }
      conjugate() {
        this._x *= -1;
        this._y *= -1;
        this._z *= -1;
        this._onChangeCallback();
        return this;
      }
      dot(v) {
        return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
      }
      lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
      }
      length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
      }
      normalize() {
        let l = this.length();
        if (l === 0) {
          this._x = 0;
          this._y = 0;
          this._z = 0;
          this._w = 1;
        } else {
          l = 1 / l;
          this._x = this._x * l;
          this._y = this._y * l;
          this._z = this._z * l;
          this._w = this._w * l;
        }
        this._onChangeCallback();
        return this;
      }
      multiply(q, p) {
        if (p !== void 0) {
          console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
          return this.multiplyQuaternions(q, p);
        }
        return this.multiplyQuaternions(this, q);
      }
      premultiply(q) {
        return this.multiplyQuaternions(q, this);
      }
      multiplyQuaternions(a, b2) {
        const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
        const qbx = b2._x, qby = b2._y, qbz = b2._z, qbw = b2._w;
        this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
        this._onChangeCallback();
        return this;
      }
      slerp(qb, t2) {
        if (t2 === 0)
          return this;
        if (t2 === 1)
          return this.copy(qb);
        const x = this._x, y2 = this._y, z = this._z, w = this._w;
        let cosHalfTheta = w * qb._w + x * qb._x + y2 * qb._y + z * qb._z;
        if (cosHalfTheta < 0) {
          this._w = -qb._w;
          this._x = -qb._x;
          this._y = -qb._y;
          this._z = -qb._z;
          cosHalfTheta = -cosHalfTheta;
        } else {
          this.copy(qb);
        }
        if (cosHalfTheta >= 1) {
          this._w = w;
          this._x = x;
          this._y = y2;
          this._z = z;
          return this;
        }
        const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
        if (sqrSinHalfTheta <= Number.EPSILON) {
          const s = 1 - t2;
          this._w = s * w + t2 * this._w;
          this._x = s * x + t2 * this._x;
          this._y = s * y2 + t2 * this._y;
          this._z = s * z + t2 * this._z;
          this.normalize();
          this._onChangeCallback();
          return this;
        }
        const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
        const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
        const ratioA = Math.sin((1 - t2) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t2 * halfTheta) / sinHalfTheta;
        this._w = w * ratioA + this._w * ratioB;
        this._x = x * ratioA + this._x * ratioB;
        this._y = y2 * ratioA + this._y * ratioB;
        this._z = z * ratioA + this._z * ratioB;
        this._onChangeCallback();
        return this;
      }
      slerpQuaternions(qa, qb, t2) {
        return this.copy(qa).slerp(qb, t2);
      }
      random() {
        const u1 = Math.random();
        const sqrt1u1 = Math.sqrt(1 - u1);
        const sqrtu1 = Math.sqrt(u1);
        const u2 = 2 * Math.PI * Math.random();
        const u3 = 2 * Math.PI * Math.random();
        return this.set(sqrt1u1 * Math.cos(u2), sqrtu1 * Math.sin(u3), sqrtu1 * Math.cos(u3), sqrt1u1 * Math.sin(u2));
      }
      equals(quaternion) {
        return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
      }
      fromArray(array, offset = 0) {
        this._x = array[offset];
        this._y = array[offset + 1];
        this._z = array[offset + 2];
        this._w = array[offset + 3];
        this._onChangeCallback();
        return this;
      }
      toArray(array = [], offset = 0) {
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._w;
        return array;
      }
      fromBufferAttribute(attribute, index) {
        this._x = attribute.getX(index);
        this._y = attribute.getY(index);
        this._z = attribute.getZ(index);
        this._w = attribute.getW(index);
        return this;
      }
      _onChange(callback) {
        this._onChangeCallback = callback;
        return this;
      }
      _onChangeCallback() {
      }
    };
    Quaternion.prototype.isQuaternion = true;
    Vector3 = class {
      constructor(x = 0, y2 = 0, z = 0) {
        this.x = x;
        this.y = y2;
        this.z = z;
      }
      set(x, y2, z) {
        if (z === void 0)
          z = this.z;
        this.x = x;
        this.y = y2;
        this.z = z;
        return this;
      }
      setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        return this;
      }
      setX(x) {
        this.x = x;
        return this;
      }
      setY(y2) {
        this.y = y2;
        return this;
      }
      setZ(z) {
        this.z = z;
        return this;
      }
      setComponent(index, value) {
        switch (index) {
          case 0:
            this.x = value;
            break;
          case 1:
            this.y = value;
            break;
          case 2:
            this.z = value;
            break;
          default:
            throw new Error("index is out of range: " + index);
        }
        return this;
      }
      getComponent(index) {
        switch (index) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          default:
            throw new Error("index is out of range: " + index);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y, this.z);
      }
      copy(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        return this;
      }
      add(v, w) {
        if (w !== void 0) {
          console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
          return this.addVectors(v, w);
        }
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        return this;
      }
      addScalar(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        return this;
      }
      addVectors(a, b2) {
        this.x = a.x + b2.x;
        this.y = a.y + b2.y;
        this.z = a.z + b2.z;
        return this;
      }
      addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        return this;
      }
      sub(v, w) {
        if (w !== void 0) {
          console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
          return this.subVectors(v, w);
        }
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        return this;
      }
      subScalar(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        return this;
      }
      subVectors(a, b2) {
        this.x = a.x - b2.x;
        this.y = a.y - b2.y;
        this.z = a.z - b2.z;
        return this;
      }
      multiply(v, w) {
        if (w !== void 0) {
          console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
          return this.multiplyVectors(v, w);
        }
        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;
        return this;
      }
      multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        return this;
      }
      multiplyVectors(a, b2) {
        this.x = a.x * b2.x;
        this.y = a.y * b2.y;
        this.z = a.z * b2.z;
        return this;
      }
      applyEuler(euler) {
        if (!(euler && euler.isEuler)) {
          console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
        }
        return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
      }
      applyAxisAngle(axis, angle) {
        return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
      }
      applyMatrix3(m) {
        const x = this.x, y2 = this.y, z = this.z;
        const e = m.elements;
        this.x = e[0] * x + e[3] * y2 + e[6] * z;
        this.y = e[1] * x + e[4] * y2 + e[7] * z;
        this.z = e[2] * x + e[5] * y2 + e[8] * z;
        return this;
      }
      applyNormalMatrix(m) {
        return this.applyMatrix3(m).normalize();
      }
      applyMatrix4(m) {
        const x = this.x, y2 = this.y, z = this.z;
        const e = m.elements;
        const w = 1 / (e[3] * x + e[7] * y2 + e[11] * z + e[15]);
        this.x = (e[0] * x + e[4] * y2 + e[8] * z + e[12]) * w;
        this.y = (e[1] * x + e[5] * y2 + e[9] * z + e[13]) * w;
        this.z = (e[2] * x + e[6] * y2 + e[10] * z + e[14]) * w;
        return this;
      }
      applyQuaternion(q) {
        const x = this.x, y2 = this.y, z = this.z;
        const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
        const ix = qw * x + qy * z - qz * y2;
        const iy = qw * y2 + qz * x - qx * z;
        const iz = qw * z + qx * y2 - qy * x;
        const iw = -qx * x - qy * y2 - qz * z;
        this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
        return this;
      }
      project(camera) {
        return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
      }
      unproject(camera) {
        return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
      }
      transformDirection(m) {
        const x = this.x, y2 = this.y, z = this.z;
        const e = m.elements;
        this.x = e[0] * x + e[4] * y2 + e[8] * z;
        this.y = e[1] * x + e[5] * y2 + e[9] * z;
        this.z = e[2] * x + e[6] * y2 + e[10] * z;
        return this.normalize();
      }
      divide(v) {
        this.x /= v.x;
        this.y /= v.y;
        this.z /= v.z;
        return this;
      }
      divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
      }
      min(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        this.z = Math.min(this.z, v.z);
        return this;
      }
      max(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        this.z = Math.max(this.z, v.z);
        return this;
      }
      clamp(min, max) {
        this.x = Math.max(min.x, Math.min(max.x, this.x));
        this.y = Math.max(min.y, Math.min(max.y, this.y));
        this.z = Math.max(min.z, Math.min(max.z, this.z));
        return this;
      }
      clampScalar(minVal, maxVal) {
        this.x = Math.max(minVal, Math.min(maxVal, this.x));
        this.y = Math.max(minVal, Math.min(maxVal, this.y));
        this.z = Math.max(minVal, Math.min(maxVal, this.z));
        return this;
      }
      clampLength(min, max) {
        const length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
      }
      floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        return this;
      }
      ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        return this;
      }
      round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        return this;
      }
      roundToZero() {
        this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
        return this;
      }
      negate() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
      }
      dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z;
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      setLength(length) {
        return this.normalize().multiplyScalar(length);
      }
      lerp(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        return this;
      }
      lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        this.z = v1.z + (v2.z - v1.z) * alpha;
        return this;
      }
      cross(v, w) {
        if (w !== void 0) {
          console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
          return this.crossVectors(v, w);
        }
        return this.crossVectors(this, v);
      }
      crossVectors(a, b2) {
        const ax = a.x, ay = a.y, az = a.z;
        const bx = b2.x, by = b2.y, bz = b2.z;
        this.x = ay * bz - az * by;
        this.y = az * bx - ax * bz;
        this.z = ax * by - ay * bx;
        return this;
      }
      projectOnVector(v) {
        const denominator = v.lengthSq();
        if (denominator === 0)
          return this.set(0, 0, 0);
        const scalar = v.dot(this) / denominator;
        return this.copy(v).multiplyScalar(scalar);
      }
      projectOnPlane(planeNormal) {
        _vector$c.copy(this).projectOnVector(planeNormal);
        return this.sub(_vector$c);
      }
      reflect(normal2) {
        return this.sub(_vector$c.copy(normal2).multiplyScalar(2 * this.dot(normal2)));
      }
      angleTo(v) {
        const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
        if (denominator === 0)
          return Math.PI / 2;
        const theta = this.dot(v) / denominator;
        return Math.acos(clamp(theta, -1, 1));
      }
      distanceTo(v) {
        return Math.sqrt(this.distanceToSquared(v));
      }
      distanceToSquared(v) {
        const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
        return dx * dx + dy * dy + dz * dz;
      }
      manhattanDistanceTo(v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
      }
      setFromSpherical(s) {
        return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
      }
      setFromSphericalCoords(radius, phi, theta) {
        const sinPhiRadius = Math.sin(phi) * radius;
        this.x = sinPhiRadius * Math.sin(theta);
        this.y = Math.cos(phi) * radius;
        this.z = sinPhiRadius * Math.cos(theta);
        return this;
      }
      setFromCylindrical(c) {
        return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
      }
      setFromCylindricalCoords(radius, theta, y2) {
        this.x = radius * Math.sin(theta);
        this.y = y2;
        this.z = radius * Math.cos(theta);
        return this;
      }
      setFromMatrixPosition(m) {
        const e = m.elements;
        this.x = e[12];
        this.y = e[13];
        this.z = e[14];
        return this;
      }
      setFromMatrixScale(m) {
        const sx = this.setFromMatrixColumn(m, 0).length();
        const sy = this.setFromMatrixColumn(m, 1).length();
        const sz = this.setFromMatrixColumn(m, 2).length();
        this.x = sx;
        this.y = sy;
        this.z = sz;
        return this;
      }
      setFromMatrixColumn(m, index) {
        return this.fromArray(m.elements, index * 4);
      }
      setFromMatrix3Column(m, index) {
        return this.fromArray(m.elements, index * 3);
      }
      setFromEuler(e) {
        this.x = e._x;
        this.y = e._y;
        this.z = e._z;
        return this;
      }
      equals(v) {
        return v.x === this.x && v.y === this.y && v.z === this.z;
      }
      fromArray(array, offset = 0) {
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        return this;
      }
      toArray(array = [], offset = 0) {
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        return array;
      }
      fromBufferAttribute(attribute, index, offset) {
        if (offset !== void 0) {
          console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
        }
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        this.z = attribute.getZ(index);
        return this;
      }
      random() {
        this.x = Math.random();
        this.y = Math.random();
        this.z = Math.random();
        return this;
      }
      randomDirection() {
        const u = (Math.random() - 0.5) * 2;
        const t2 = Math.random() * Math.PI * 2;
        const f = Math.sqrt(1 - u ** 2);
        this.x = f * Math.cos(t2);
        this.y = f * Math.sin(t2);
        this.z = u;
        return this;
      }
      *[Symbol.iterator]() {
        yield this.x;
        yield this.y;
        yield this.z;
      }
    };
    Vector3.prototype.isVector3 = true;
    _vector$c = /* @__PURE__ */ new Vector3();
    _quaternion$4 = /* @__PURE__ */ new Quaternion();
    Box3 = class {
      constructor(min = new Vector3(Infinity, Infinity, Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
        this.min = min;
        this.max = max;
      }
      set(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
      }
      setFromArray(array) {
        let minX = Infinity;
        let minY = Infinity;
        let minZ = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        let maxZ = -Infinity;
        for (let i2 = 0, l = array.length; i2 < l; i2 += 3) {
          const x = array[i2];
          const y2 = array[i2 + 1];
          const z = array[i2 + 2];
          if (x < minX)
            minX = x;
          if (y2 < minY)
            minY = y2;
          if (z < minZ)
            minZ = z;
          if (x > maxX)
            maxX = x;
          if (y2 > maxY)
            maxY = y2;
          if (z > maxZ)
            maxZ = z;
        }
        this.min.set(minX, minY, minZ);
        this.max.set(maxX, maxY, maxZ);
        return this;
      }
      setFromBufferAttribute(attribute) {
        let minX = Infinity;
        let minY = Infinity;
        let minZ = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        let maxZ = -Infinity;
        for (let i2 = 0, l = attribute.count; i2 < l; i2++) {
          const x = attribute.getX(i2);
          const y2 = attribute.getY(i2);
          const z = attribute.getZ(i2);
          if (x < minX)
            minX = x;
          if (y2 < minY)
            minY = y2;
          if (z < minZ)
            minZ = z;
          if (x > maxX)
            maxX = x;
          if (y2 > maxY)
            maxY = y2;
          if (z > maxZ)
            maxZ = z;
        }
        this.min.set(minX, minY, minZ);
        this.max.set(maxX, maxY, maxZ);
        return this;
      }
      setFromPoints(points) {
        this.makeEmpty();
        for (let i2 = 0, il = points.length; i2 < il; i2++) {
          this.expandByPoint(points[i2]);
        }
        return this;
      }
      setFromCenterAndSize(center, size) {
        const halfSize = _vector$b.copy(size).multiplyScalar(0.5);
        this.min.copy(center).sub(halfSize);
        this.max.copy(center).add(halfSize);
        return this;
      }
      setFromObject(object, precise = false) {
        this.makeEmpty();
        return this.expandByObject(object, precise);
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
      }
      makeEmpty() {
        this.min.x = this.min.y = this.min.z = Infinity;
        this.max.x = this.max.y = this.max.z = -Infinity;
        return this;
      }
      isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
      }
      getCenter(target) {
        return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
      }
      getSize(target) {
        return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
      }
      expandByPoint(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
      }
      expandByVector(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
      }
      expandByScalar(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
      }
      expandByObject(object, precise = false) {
        object.updateWorldMatrix(false, false);
        const geometry = object.geometry;
        if (geometry !== void 0) {
          if (precise && geometry.attributes != void 0 && geometry.attributes.position !== void 0) {
            const position = geometry.attributes.position;
            for (let i2 = 0, l = position.count; i2 < l; i2++) {
              _vector$b.fromBufferAttribute(position, i2).applyMatrix4(object.matrixWorld);
              this.expandByPoint(_vector$b);
            }
          } else {
            if (geometry.boundingBox === null) {
              geometry.computeBoundingBox();
            }
            _box$3.copy(geometry.boundingBox);
            _box$3.applyMatrix4(object.matrixWorld);
            this.union(_box$3);
          }
        }
        const children = object.children;
        for (let i2 = 0, l = children.length; i2 < l; i2++) {
          this.expandByObject(children[i2], precise);
        }
        return this;
      }
      containsPoint(point) {
        return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
      }
      containsBox(box) {
        return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
      }
      getParameter(point, target) {
        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
      }
      intersectsBox(box) {
        return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
      }
      intersectsSphere(sphere) {
        this.clampPoint(sphere.center, _vector$b);
        return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
      }
      intersectsPlane(plane) {
        let min, max;
        if (plane.normal.x > 0) {
          min = plane.normal.x * this.min.x;
          max = plane.normal.x * this.max.x;
        } else {
          min = plane.normal.x * this.max.x;
          max = plane.normal.x * this.min.x;
        }
        if (plane.normal.y > 0) {
          min += plane.normal.y * this.min.y;
          max += plane.normal.y * this.max.y;
        } else {
          min += plane.normal.y * this.max.y;
          max += plane.normal.y * this.min.y;
        }
        if (plane.normal.z > 0) {
          min += plane.normal.z * this.min.z;
          max += plane.normal.z * this.max.z;
        } else {
          min += plane.normal.z * this.max.z;
          max += plane.normal.z * this.min.z;
        }
        return min <= -plane.constant && max >= -plane.constant;
      }
      intersectsTriangle(triangle) {
        if (this.isEmpty()) {
          return false;
        }
        this.getCenter(_center);
        _extents.subVectors(this.max, _center);
        _v0$2.subVectors(triangle.a, _center);
        _v1$7.subVectors(triangle.b, _center);
        _v2$3.subVectors(triangle.c, _center);
        _f0.subVectors(_v1$7, _v0$2);
        _f1.subVectors(_v2$3, _v1$7);
        _f2.subVectors(_v0$2, _v2$3);
        let axes = [
          0,
          -_f0.z,
          _f0.y,
          0,
          -_f1.z,
          _f1.y,
          0,
          -_f2.z,
          _f2.y,
          _f0.z,
          0,
          -_f0.x,
          _f1.z,
          0,
          -_f1.x,
          _f2.z,
          0,
          -_f2.x,
          -_f0.y,
          _f0.x,
          0,
          -_f1.y,
          _f1.x,
          0,
          -_f2.y,
          _f2.x,
          0
        ];
        if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
          return false;
        }
        axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
        if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {
          return false;
        }
        _triangleNormal.crossVectors(_f0, _f1);
        axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
        return satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents);
      }
      clampPoint(point, target) {
        return target.copy(point).clamp(this.min, this.max);
      }
      distanceToPoint(point) {
        const clampedPoint = _vector$b.copy(point).clamp(this.min, this.max);
        return clampedPoint.sub(point).length();
      }
      getBoundingSphere(target) {
        this.getCenter(target.center);
        target.radius = this.getSize(_vector$b).length() * 0.5;
        return target;
      }
      intersect(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        if (this.isEmpty())
          this.makeEmpty();
        return this;
      }
      union(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
      }
      applyMatrix4(matrix) {
        if (this.isEmpty())
          return this;
        _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
        _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
        _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
        _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
        _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
        _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
        _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
        _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
        this.setFromPoints(_points);
        return this;
      }
      translate(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
      }
      equals(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
      }
    };
    Box3.prototype.isBox3 = true;
    _points = [
      /* @__PURE__ */ new Vector3(),
      /* @__PURE__ */ new Vector3(),
      /* @__PURE__ */ new Vector3(),
      /* @__PURE__ */ new Vector3(),
      /* @__PURE__ */ new Vector3(),
      /* @__PURE__ */ new Vector3(),
      /* @__PURE__ */ new Vector3(),
      /* @__PURE__ */ new Vector3()
    ];
    _vector$b = /* @__PURE__ */ new Vector3();
    _box$3 = /* @__PURE__ */ new Box3();
    _v0$2 = /* @__PURE__ */ new Vector3();
    _v1$7 = /* @__PURE__ */ new Vector3();
    _v2$3 = /* @__PURE__ */ new Vector3();
    _f0 = /* @__PURE__ */ new Vector3();
    _f1 = /* @__PURE__ */ new Vector3();
    _f2 = /* @__PURE__ */ new Vector3();
    _center = /* @__PURE__ */ new Vector3();
    _extents = /* @__PURE__ */ new Vector3();
    _triangleNormal = /* @__PURE__ */ new Vector3();
    _testAxis = /* @__PURE__ */ new Vector3();
    _box$2 = /* @__PURE__ */ new Box3();
    _v1$6 = /* @__PURE__ */ new Vector3();
    _toFarthestPoint = /* @__PURE__ */ new Vector3();
    _toPoint = /* @__PURE__ */ new Vector3();
    Sphere = class {
      constructor(center = new Vector3(), radius = -1) {
        this.center = center;
        this.radius = radius;
      }
      set(center, radius) {
        this.center.copy(center);
        this.radius = radius;
        return this;
      }
      setFromPoints(points, optionalCenter) {
        const center = this.center;
        if (optionalCenter !== void 0) {
          center.copy(optionalCenter);
        } else {
          _box$2.setFromPoints(points).getCenter(center);
        }
        let maxRadiusSq = 0;
        for (let i2 = 0, il = points.length; i2 < il; i2++) {
          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i2]));
        }
        this.radius = Math.sqrt(maxRadiusSq);
        return this;
      }
      copy(sphere) {
        this.center.copy(sphere.center);
        this.radius = sphere.radius;
        return this;
      }
      isEmpty() {
        return this.radius < 0;
      }
      makeEmpty() {
        this.center.set(0, 0, 0);
        this.radius = -1;
        return this;
      }
      containsPoint(point) {
        return point.distanceToSquared(this.center) <= this.radius * this.radius;
      }
      distanceToPoint(point) {
        return point.distanceTo(this.center) - this.radius;
      }
      intersectsSphere(sphere) {
        const radiusSum = this.radius + sphere.radius;
        return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
      }
      intersectsBox(box) {
        return box.intersectsSphere(this);
      }
      intersectsPlane(plane) {
        return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
      }
      clampPoint(point, target) {
        const deltaLengthSq = this.center.distanceToSquared(point);
        target.copy(point);
        if (deltaLengthSq > this.radius * this.radius) {
          target.sub(this.center).normalize();
          target.multiplyScalar(this.radius).add(this.center);
        }
        return target;
      }
      getBoundingBox(target) {
        if (this.isEmpty()) {
          target.makeEmpty();
          return target;
        }
        target.set(this.center, this.center);
        target.expandByScalar(this.radius);
        return target;
      }
      applyMatrix4(matrix) {
        this.center.applyMatrix4(matrix);
        this.radius = this.radius * matrix.getMaxScaleOnAxis();
        return this;
      }
      translate(offset) {
        this.center.add(offset);
        return this;
      }
      expandByPoint(point) {
        _toPoint.subVectors(point, this.center);
        const lengthSq = _toPoint.lengthSq();
        if (lengthSq > this.radius * this.radius) {
          const length = Math.sqrt(lengthSq);
          const missingRadiusHalf = (length - this.radius) * 0.5;
          this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));
          this.radius += missingRadiusHalf;
        }
        return this;
      }
      union(sphere) {
        if (this.center.equals(sphere.center) === true) {
          _toFarthestPoint.set(0, 0, 1).multiplyScalar(sphere.radius);
        } else {
          _toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);
        }
        this.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint));
        this.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint));
        return this;
      }
      equals(sphere) {
        return sphere.center.equals(this.center) && sphere.radius === this.radius;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    };
    _vector$a = /* @__PURE__ */ new Vector3();
    _segCenter = /* @__PURE__ */ new Vector3();
    _segDir = /* @__PURE__ */ new Vector3();
    _diff = /* @__PURE__ */ new Vector3();
    _edge1 = /* @__PURE__ */ new Vector3();
    _edge2 = /* @__PURE__ */ new Vector3();
    _normal$1 = /* @__PURE__ */ new Vector3();
    Ray = class {
      constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
        this.origin = origin;
        this.direction = direction;
      }
      set(origin, direction) {
        this.origin.copy(origin);
        this.direction.copy(direction);
        return this;
      }
      copy(ray) {
        this.origin.copy(ray.origin);
        this.direction.copy(ray.direction);
        return this;
      }
      at(t2, target) {
        return target.copy(this.direction).multiplyScalar(t2).add(this.origin);
      }
      lookAt(v) {
        this.direction.copy(v).sub(this.origin).normalize();
        return this;
      }
      recast(t2) {
        this.origin.copy(this.at(t2, _vector$a));
        return this;
      }
      closestPointToPoint(point, target) {
        target.subVectors(point, this.origin);
        const directionDistance = target.dot(this.direction);
        if (directionDistance < 0) {
          return target.copy(this.origin);
        }
        return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
      }
      distanceToPoint(point) {
        return Math.sqrt(this.distanceSqToPoint(point));
      }
      distanceSqToPoint(point) {
        const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);
        if (directionDistance < 0) {
          return this.origin.distanceToSquared(point);
        }
        _vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
        return _vector$a.distanceToSquared(point);
      }
      distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
        _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
        _segDir.copy(v1).sub(v0).normalize();
        _diff.copy(this.origin).sub(_segCenter);
        const segExtent = v0.distanceTo(v1) * 0.5;
        const a01 = -this.direction.dot(_segDir);
        const b0 = _diff.dot(this.direction);
        const b1 = -_diff.dot(_segDir);
        const c = _diff.lengthSq();
        const det = Math.abs(1 - a01 * a01);
        let s0, s1, sqrDist, extDet;
        if (det > 0) {
          s0 = a01 * b1 - b0;
          s1 = a01 * b0 - b1;
          extDet = segExtent * det;
          if (s0 >= 0) {
            if (s1 >= -extDet) {
              if (s1 <= extDet) {
                const invDet = 1 / det;
                s0 *= invDet;
                s1 *= invDet;
                sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
              } else {
                s1 = segExtent;
                s0 = Math.max(0, -(a01 * s1 + b0));
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
              }
            } else {
              s1 = -segExtent;
              s0 = Math.max(0, -(a01 * s1 + b0));
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
          } else {
            if (s1 <= -extDet) {
              s0 = Math.max(0, -(-a01 * segExtent + b0));
              s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            } else if (s1 <= extDet) {
              s0 = 0;
              s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
              sqrDist = s1 * (s1 + 2 * b1) + c;
            } else {
              s0 = Math.max(0, -(a01 * segExtent + b0));
              s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
          }
        } else {
          s1 = a01 > 0 ? -segExtent : segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
        if (optionalPointOnRay) {
          optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
        }
        if (optionalPointOnSegment) {
          optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
        }
        return sqrDist;
      }
      intersectSphere(sphere, target) {
        _vector$a.subVectors(sphere.center, this.origin);
        const tca = _vector$a.dot(this.direction);
        const d2 = _vector$a.dot(_vector$a) - tca * tca;
        const radius2 = sphere.radius * sphere.radius;
        if (d2 > radius2)
          return null;
        const thc = Math.sqrt(radius2 - d2);
        const t0 = tca - thc;
        const t1 = tca + thc;
        if (t0 < 0 && t1 < 0)
          return null;
        if (t0 < 0)
          return this.at(t1, target);
        return this.at(t0, target);
      }
      intersectsSphere(sphere) {
        return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
      }
      distanceToPlane(plane) {
        const denominator = plane.normal.dot(this.direction);
        if (denominator === 0) {
          if (plane.distanceToPoint(this.origin) === 0) {
            return 0;
          }
          return null;
        }
        const t2 = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
        return t2 >= 0 ? t2 : null;
      }
      intersectPlane(plane, target) {
        const t2 = this.distanceToPlane(plane);
        if (t2 === null) {
          return null;
        }
        return this.at(t2, target);
      }
      intersectsPlane(plane) {
        const distToPoint = plane.distanceToPoint(this.origin);
        if (distToPoint === 0) {
          return true;
        }
        const denominator = plane.normal.dot(this.direction);
        if (denominator * distToPoint < 0) {
          return true;
        }
        return false;
      }
      intersectBox(box, target) {
        let tmin, tmax, tymin, tymax, tzmin, tzmax;
        const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
        const origin = this.origin;
        if (invdirx >= 0) {
          tmin = (box.min.x - origin.x) * invdirx;
          tmax = (box.max.x - origin.x) * invdirx;
        } else {
          tmin = (box.max.x - origin.x) * invdirx;
          tmax = (box.min.x - origin.x) * invdirx;
        }
        if (invdiry >= 0) {
          tymin = (box.min.y - origin.y) * invdiry;
          tymax = (box.max.y - origin.y) * invdiry;
        } else {
          tymin = (box.max.y - origin.y) * invdiry;
          tymax = (box.min.y - origin.y) * invdiry;
        }
        if (tmin > tymax || tymin > tmax)
          return null;
        if (tymin > tmin || tmin !== tmin)
          tmin = tymin;
        if (tymax < tmax || tmax !== tmax)
          tmax = tymax;
        if (invdirz >= 0) {
          tzmin = (box.min.z - origin.z) * invdirz;
          tzmax = (box.max.z - origin.z) * invdirz;
        } else {
          tzmin = (box.max.z - origin.z) * invdirz;
          tzmax = (box.min.z - origin.z) * invdirz;
        }
        if (tmin > tzmax || tzmin > tmax)
          return null;
        if (tzmin > tmin || tmin !== tmin)
          tmin = tzmin;
        if (tzmax < tmax || tmax !== tmax)
          tmax = tzmax;
        if (tmax < 0)
          return null;
        return this.at(tmin >= 0 ? tmin : tmax, target);
      }
      intersectsBox(box) {
        return this.intersectBox(box, _vector$a) !== null;
      }
      intersectTriangle(a, b2, c, backfaceCulling, target) {
        _edge1.subVectors(b2, a);
        _edge2.subVectors(c, a);
        _normal$1.crossVectors(_edge1, _edge2);
        let DdN = this.direction.dot(_normal$1);
        let sign2;
        if (DdN > 0) {
          if (backfaceCulling)
            return null;
          sign2 = 1;
        } else if (DdN < 0) {
          sign2 = -1;
          DdN = -DdN;
        } else {
          return null;
        }
        _diff.subVectors(this.origin, a);
        const DdQxE2 = sign2 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
        if (DdQxE2 < 0) {
          return null;
        }
        const DdE1xQ = sign2 * this.direction.dot(_edge1.cross(_diff));
        if (DdE1xQ < 0) {
          return null;
        }
        if (DdQxE2 + DdE1xQ > DdN) {
          return null;
        }
        const QdN = -sign2 * _diff.dot(_normal$1);
        if (QdN < 0) {
          return null;
        }
        return this.at(QdN / DdN, target);
      }
      applyMatrix4(matrix4) {
        this.origin.applyMatrix4(matrix4);
        this.direction.transformDirection(matrix4);
        return this;
      }
      equals(ray) {
        return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
      }
      clone() {
        return new this.constructor().copy(this);
      }
    };
    Matrix4 = class {
      constructor() {
        this.elements = [
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ];
        if (arguments.length > 0) {
          console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
        }
      }
      set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
        const te = this.elements;
        te[0] = n11;
        te[4] = n12;
        te[8] = n13;
        te[12] = n14;
        te[1] = n21;
        te[5] = n22;
        te[9] = n23;
        te[13] = n24;
        te[2] = n31;
        te[6] = n32;
        te[10] = n33;
        te[14] = n34;
        te[3] = n41;
        te[7] = n42;
        te[11] = n43;
        te[15] = n44;
        return this;
      }
      identity() {
        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
      }
      clone() {
        return new Matrix4().fromArray(this.elements);
      }
      copy(m) {
        const te = this.elements;
        const me = m.elements;
        te[0] = me[0];
        te[1] = me[1];
        te[2] = me[2];
        te[3] = me[3];
        te[4] = me[4];
        te[5] = me[5];
        te[6] = me[6];
        te[7] = me[7];
        te[8] = me[8];
        te[9] = me[9];
        te[10] = me[10];
        te[11] = me[11];
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        te[15] = me[15];
        return this;
      }
      copyPosition(m) {
        const te = this.elements, me = m.elements;
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        return this;
      }
      setFromMatrix3(m) {
        const me = m.elements;
        this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
        return this;
      }
      extractBasis(xAxis, yAxis, zAxis) {
        xAxis.setFromMatrixColumn(this, 0);
        yAxis.setFromMatrixColumn(this, 1);
        zAxis.setFromMatrixColumn(this, 2);
        return this;
      }
      makeBasis(xAxis, yAxis, zAxis) {
        this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
        return this;
      }
      extractRotation(m) {
        const te = this.elements;
        const me = m.elements;
        const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();
        const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();
        const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();
        te[0] = me[0] * scaleX;
        te[1] = me[1] * scaleX;
        te[2] = me[2] * scaleX;
        te[3] = 0;
        te[4] = me[4] * scaleY;
        te[5] = me[5] * scaleY;
        te[6] = me[6] * scaleY;
        te[7] = 0;
        te[8] = me[8] * scaleZ;
        te[9] = me[9] * scaleZ;
        te[10] = me[10] * scaleZ;
        te[11] = 0;
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
      }
      makeRotationFromEuler(euler) {
        if (!(euler && euler.isEuler)) {
          console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
        }
        const te = this.elements;
        const x = euler.x, y2 = euler.y, z = euler.z;
        const a = Math.cos(x), b2 = Math.sin(x);
        const c = Math.cos(y2), d2 = Math.sin(y2);
        const e = Math.cos(z), f = Math.sin(z);
        if (euler.order === "XYZ") {
          const ae = a * e, af = a * f, be = b2 * e, bf = b2 * f;
          te[0] = c * e;
          te[4] = -c * f;
          te[8] = d2;
          te[1] = af + be * d2;
          te[5] = ae - bf * d2;
          te[9] = -b2 * c;
          te[2] = bf - ae * d2;
          te[6] = be + af * d2;
          te[10] = a * c;
        } else if (euler.order === "YXZ") {
          const ce = c * e, cf = c * f, de = d2 * e, df = d2 * f;
          te[0] = ce + df * b2;
          te[4] = de * b2 - cf;
          te[8] = a * d2;
          te[1] = a * f;
          te[5] = a * e;
          te[9] = -b2;
          te[2] = cf * b2 - de;
          te[6] = df + ce * b2;
          te[10] = a * c;
        } else if (euler.order === "ZXY") {
          const ce = c * e, cf = c * f, de = d2 * e, df = d2 * f;
          te[0] = ce - df * b2;
          te[4] = -a * f;
          te[8] = de + cf * b2;
          te[1] = cf + de * b2;
          te[5] = a * e;
          te[9] = df - ce * b2;
          te[2] = -a * d2;
          te[6] = b2;
          te[10] = a * c;
        } else if (euler.order === "ZYX") {
          const ae = a * e, af = a * f, be = b2 * e, bf = b2 * f;
          te[0] = c * e;
          te[4] = be * d2 - af;
          te[8] = ae * d2 + bf;
          te[1] = c * f;
          te[5] = bf * d2 + ae;
          te[9] = af * d2 - be;
          te[2] = -d2;
          te[6] = b2 * c;
          te[10] = a * c;
        } else if (euler.order === "YZX") {
          const ac = a * c, ad = a * d2, bc = b2 * c, bd = b2 * d2;
          te[0] = c * e;
          te[4] = bd - ac * f;
          te[8] = bc * f + ad;
          te[1] = f;
          te[5] = a * e;
          te[9] = -b2 * e;
          te[2] = -d2 * e;
          te[6] = ad * f + bc;
          te[10] = ac - bd * f;
        } else if (euler.order === "XZY") {
          const ac = a * c, ad = a * d2, bc = b2 * c, bd = b2 * d2;
          te[0] = c * e;
          te[4] = -f;
          te[8] = d2 * e;
          te[1] = ac * f + bd;
          te[5] = a * e;
          te[9] = ad * f - bc;
          te[2] = bc * f - ad;
          te[6] = b2 * e;
          te[10] = bd * f + ac;
        }
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
      }
      makeRotationFromQuaternion(q) {
        return this.compose(_zero, q, _one);
      }
      lookAt(eye, target, up) {
        const te = this.elements;
        _z.subVectors(eye, target);
        if (_z.lengthSq() === 0) {
          _z.z = 1;
        }
        _z.normalize();
        _x.crossVectors(up, _z);
        if (_x.lengthSq() === 0) {
          if (Math.abs(up.z) === 1) {
            _z.x += 1e-4;
          } else {
            _z.z += 1e-4;
          }
          _z.normalize();
          _x.crossVectors(up, _z);
        }
        _x.normalize();
        _y.crossVectors(_z, _x);
        te[0] = _x.x;
        te[4] = _y.x;
        te[8] = _z.x;
        te[1] = _x.y;
        te[5] = _y.y;
        te[9] = _z.y;
        te[2] = _x.z;
        te[6] = _y.z;
        te[10] = _z.z;
        return this;
      }
      multiply(m, n) {
        if (n !== void 0) {
          console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
          return this.multiplyMatrices(m, n);
        }
        return this.multiplyMatrices(this, m);
      }
      premultiply(m) {
        return this.multiplyMatrices(m, this);
      }
      multiplyMatrices(a, b2) {
        const ae = a.elements;
        const be = b2.elements;
        const te = this.elements;
        const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
        const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
        const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
        const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
        const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
        const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
        const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
        const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
        return this;
      }
      multiplyScalar(s) {
        const te = this.elements;
        te[0] *= s;
        te[4] *= s;
        te[8] *= s;
        te[12] *= s;
        te[1] *= s;
        te[5] *= s;
        te[9] *= s;
        te[13] *= s;
        te[2] *= s;
        te[6] *= s;
        te[10] *= s;
        te[14] *= s;
        te[3] *= s;
        te[7] *= s;
        te[11] *= s;
        te[15] *= s;
        return this;
      }
      determinant() {
        const te = this.elements;
        const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
        const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
        const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
        const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
        return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
      }
      transpose() {
        const te = this.elements;
        let tmp2;
        tmp2 = te[1];
        te[1] = te[4];
        te[4] = tmp2;
        tmp2 = te[2];
        te[2] = te[8];
        te[8] = tmp2;
        tmp2 = te[6];
        te[6] = te[9];
        te[9] = tmp2;
        tmp2 = te[3];
        te[3] = te[12];
        te[12] = tmp2;
        tmp2 = te[7];
        te[7] = te[13];
        te[13] = tmp2;
        tmp2 = te[11];
        te[11] = te[14];
        te[14] = tmp2;
        return this;
      }
      setPosition(x, y2, z) {
        const te = this.elements;
        if (x.isVector3) {
          te[12] = x.x;
          te[13] = x.y;
          te[14] = x.z;
        } else {
          te[12] = x;
          te[13] = y2;
          te[14] = z;
        }
        return this;
      }
      invert() {
        const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
        const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
        if (det === 0)
          return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
        te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
        te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
        te[4] = t12 * detInv;
        te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
        te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
        te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
        te[8] = t13 * detInv;
        te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
        te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
        te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
        te[12] = t14 * detInv;
        te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
        te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
        te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
        return this;
      }
      scale(v) {
        const te = this.elements;
        const x = v.x, y2 = v.y, z = v.z;
        te[0] *= x;
        te[4] *= y2;
        te[8] *= z;
        te[1] *= x;
        te[5] *= y2;
        te[9] *= z;
        te[2] *= x;
        te[6] *= y2;
        te[10] *= z;
        te[3] *= x;
        te[7] *= y2;
        te[11] *= z;
        return this;
      }
      getMaxScaleOnAxis() {
        const te = this.elements;
        const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
        const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
        const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
        return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
      }
      makeTranslation(x, y2, z) {
        this.set(1, 0, 0, x, 0, 1, 0, y2, 0, 0, 1, z, 0, 0, 0, 1);
        return this;
      }
      makeRotationX(theta) {
        const c = Math.cos(theta), s = Math.sin(theta);
        this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
        return this;
      }
      makeRotationY(theta) {
        const c = Math.cos(theta), s = Math.sin(theta);
        this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
        return this;
      }
      makeRotationZ(theta) {
        const c = Math.cos(theta), s = Math.sin(theta);
        this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
      }
      makeRotationAxis(axis, angle) {
        const c = Math.cos(angle);
        const s = Math.sin(angle);
        const t2 = 1 - c;
        const x = axis.x, y2 = axis.y, z = axis.z;
        const tx = t2 * x, ty = t2 * y2;
        this.set(tx * x + c, tx * y2 - s * z, tx * z + s * y2, 0, tx * y2 + s * z, ty * y2 + c, ty * z - s * x, 0, tx * z - s * y2, ty * z + s * x, t2 * z * z + c, 0, 0, 0, 0, 1);
        return this;
      }
      makeScale(x, y2, z) {
        this.set(x, 0, 0, 0, 0, y2, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
        return this;
      }
      makeShear(xy, xz, yx, yz, zx, zy) {
        this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
        return this;
      }
      compose(position, quaternion, scale) {
        const te = this.elements;
        const x = quaternion._x, y2 = quaternion._y, z = quaternion._z, w = quaternion._w;
        const x2 = x + x, y22 = y2 + y2, z2 = z + z;
        const xx = x * x2, xy = x * y22, xz = x * z2;
        const yy = y2 * y22, yz = y2 * z2, zz = z * z2;
        const wx = w * x2, wy = w * y22, wz = w * z2;
        const sx = scale.x, sy = scale.y, sz = scale.z;
        te[0] = (1 - (yy + zz)) * sx;
        te[1] = (xy + wz) * sx;
        te[2] = (xz - wy) * sx;
        te[3] = 0;
        te[4] = (xy - wz) * sy;
        te[5] = (1 - (xx + zz)) * sy;
        te[6] = (yz + wx) * sy;
        te[7] = 0;
        te[8] = (xz + wy) * sz;
        te[9] = (yz - wx) * sz;
        te[10] = (1 - (xx + yy)) * sz;
        te[11] = 0;
        te[12] = position.x;
        te[13] = position.y;
        te[14] = position.z;
        te[15] = 1;
        return this;
      }
      decompose(position, quaternion, scale) {
        const te = this.elements;
        let sx = _v1$5.set(te[0], te[1], te[2]).length();
        const sy = _v1$5.set(te[4], te[5], te[6]).length();
        const sz = _v1$5.set(te[8], te[9], te[10]).length();
        const det = this.determinant();
        if (det < 0)
          sx = -sx;
        position.x = te[12];
        position.y = te[13];
        position.z = te[14];
        _m1$2.copy(this);
        const invSX = 1 / sx;
        const invSY = 1 / sy;
        const invSZ = 1 / sz;
        _m1$2.elements[0] *= invSX;
        _m1$2.elements[1] *= invSX;
        _m1$2.elements[2] *= invSX;
        _m1$2.elements[4] *= invSY;
        _m1$2.elements[5] *= invSY;
        _m1$2.elements[6] *= invSY;
        _m1$2.elements[8] *= invSZ;
        _m1$2.elements[9] *= invSZ;
        _m1$2.elements[10] *= invSZ;
        quaternion.setFromRotationMatrix(_m1$2);
        scale.x = sx;
        scale.y = sy;
        scale.z = sz;
        return this;
      }
      makePerspective(left, right, top, bottom, near, far) {
        if (far === void 0) {
          console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
        }
        const te = this.elements;
        const x = 2 * near / (right - left);
        const y2 = 2 * near / (top - bottom);
        const a = (right + left) / (right - left);
        const b2 = (top + bottom) / (top - bottom);
        const c = -(far + near) / (far - near);
        const d2 = -2 * far * near / (far - near);
        te[0] = x;
        te[4] = 0;
        te[8] = a;
        te[12] = 0;
        te[1] = 0;
        te[5] = y2;
        te[9] = b2;
        te[13] = 0;
        te[2] = 0;
        te[6] = 0;
        te[10] = c;
        te[14] = d2;
        te[3] = 0;
        te[7] = 0;
        te[11] = -1;
        te[15] = 0;
        return this;
      }
      makeOrthographic(left, right, top, bottom, near, far) {
        const te = this.elements;
        const w = 1 / (right - left);
        const h = 1 / (top - bottom);
        const p = 1 / (far - near);
        const x = (right + left) * w;
        const y2 = (top + bottom) * h;
        const z = (far + near) * p;
        te[0] = 2 * w;
        te[4] = 0;
        te[8] = 0;
        te[12] = -x;
        te[1] = 0;
        te[5] = 2 * h;
        te[9] = 0;
        te[13] = -y2;
        te[2] = 0;
        te[6] = 0;
        te[10] = -2 * p;
        te[14] = -z;
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[15] = 1;
        return this;
      }
      equals(matrix) {
        const te = this.elements;
        const me = matrix.elements;
        for (let i2 = 0; i2 < 16; i2++) {
          if (te[i2] !== me[i2])
            return false;
        }
        return true;
      }
      fromArray(array, offset = 0) {
        for (let i2 = 0; i2 < 16; i2++) {
          this.elements[i2] = array[i2 + offset];
        }
        return this;
      }
      toArray(array = [], offset = 0) {
        const te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        array[offset + 9] = te[9];
        array[offset + 10] = te[10];
        array[offset + 11] = te[11];
        array[offset + 12] = te[12];
        array[offset + 13] = te[13];
        array[offset + 14] = te[14];
        array[offset + 15] = te[15];
        return array;
      }
    };
    Matrix4.prototype.isMatrix4 = true;
    _v1$5 = /* @__PURE__ */ new Vector3();
    _m1$2 = /* @__PURE__ */ new Matrix4();
    _zero = /* @__PURE__ */ new Vector3(0, 0, 0);
    _one = /* @__PURE__ */ new Vector3(1, 1, 1);
    _x = /* @__PURE__ */ new Vector3();
    _y = /* @__PURE__ */ new Vector3();
    _z = /* @__PURE__ */ new Vector3();
    _matrix$1 = /* @__PURE__ */ new Matrix4();
    _quaternion$3 = /* @__PURE__ */ new Quaternion();
    Euler = class {
      constructor(x = 0, y2 = 0, z = 0, order = Euler.DefaultOrder) {
        this._x = x;
        this._y = y2;
        this._z = z;
        this._order = order;
      }
      get x() {
        return this._x;
      }
      set x(value) {
        this._x = value;
        this._onChangeCallback();
      }
      get y() {
        return this._y;
      }
      set y(value) {
        this._y = value;
        this._onChangeCallback();
      }
      get z() {
        return this._z;
      }
      set z(value) {
        this._z = value;
        this._onChangeCallback();
      }
      get order() {
        return this._order;
      }
      set order(value) {
        this._order = value;
        this._onChangeCallback();
      }
      set(x, y2, z, order = this._order) {
        this._x = x;
        this._y = y2;
        this._z = z;
        this._order = order;
        this._onChangeCallback();
        return this;
      }
      clone() {
        return new this.constructor(this._x, this._y, this._z, this._order);
      }
      copy(euler) {
        this._x = euler._x;
        this._y = euler._y;
        this._z = euler._z;
        this._order = euler._order;
        this._onChangeCallback();
        return this;
      }
      setFromRotationMatrix(m, order = this._order, update = true) {
        const te = m.elements;
        const m11 = te[0], m12 = te[4], m13 = te[8];
        const m21 = te[1], m22 = te[5], m23 = te[9];
        const m31 = te[2], m32 = te[6], m33 = te[10];
        switch (order) {
          case "XYZ":
            this._y = Math.asin(clamp(m13, -1, 1));
            if (Math.abs(m13) < 0.9999999) {
              this._x = Math.atan2(-m23, m33);
              this._z = Math.atan2(-m12, m11);
            } else {
              this._x = Math.atan2(m32, m22);
              this._z = 0;
            }
            break;
          case "YXZ":
            this._x = Math.asin(-clamp(m23, -1, 1));
            if (Math.abs(m23) < 0.9999999) {
              this._y = Math.atan2(m13, m33);
              this._z = Math.atan2(m21, m22);
            } else {
              this._y = Math.atan2(-m31, m11);
              this._z = 0;
            }
            break;
          case "ZXY":
            this._x = Math.asin(clamp(m32, -1, 1));
            if (Math.abs(m32) < 0.9999999) {
              this._y = Math.atan2(-m31, m33);
              this._z = Math.atan2(-m12, m22);
            } else {
              this._y = 0;
              this._z = Math.atan2(m21, m11);
            }
            break;
          case "ZYX":
            this._y = Math.asin(-clamp(m31, -1, 1));
            if (Math.abs(m31) < 0.9999999) {
              this._x = Math.atan2(m32, m33);
              this._z = Math.atan2(m21, m11);
            } else {
              this._x = 0;
              this._z = Math.atan2(-m12, m22);
            }
            break;
          case "YZX":
            this._z = Math.asin(clamp(m21, -1, 1));
            if (Math.abs(m21) < 0.9999999) {
              this._x = Math.atan2(-m23, m22);
              this._y = Math.atan2(-m31, m11);
            } else {
              this._x = 0;
              this._y = Math.atan2(m13, m33);
            }
            break;
          case "XZY":
            this._z = Math.asin(-clamp(m12, -1, 1));
            if (Math.abs(m12) < 0.9999999) {
              this._x = Math.atan2(m32, m22);
              this._y = Math.atan2(m13, m11);
            } else {
              this._x = Math.atan2(-m23, m33);
              this._y = 0;
            }
            break;
          default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
        }
        this._order = order;
        if (update === true)
          this._onChangeCallback();
        return this;
      }
      setFromQuaternion(q, order, update) {
        _matrix$1.makeRotationFromQuaternion(q);
        return this.setFromRotationMatrix(_matrix$1, order, update);
      }
      setFromVector3(v, order = this._order) {
        return this.set(v.x, v.y, v.z, order);
      }
      reorder(newOrder) {
        _quaternion$3.setFromEuler(this);
        return this.setFromQuaternion(_quaternion$3, newOrder);
      }
      equals(euler) {
        return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
      }
      fromArray(array) {
        this._x = array[0];
        this._y = array[1];
        this._z = array[2];
        if (array[3] !== void 0)
          this._order = array[3];
        this._onChangeCallback();
        return this;
      }
      toArray(array = [], offset = 0) {
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._order;
        return array;
      }
      _onChange(callback) {
        this._onChangeCallback = callback;
        return this;
      }
      _onChangeCallback() {
      }
    };
    Euler.prototype.isEuler = true;
    Euler.DefaultOrder = "XYZ";
    Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
    Layers = class {
      constructor() {
        this.mask = 1 | 0;
      }
      set(channel) {
        this.mask = (1 << channel | 0) >>> 0;
      }
      enable(channel) {
        this.mask |= 1 << channel | 0;
      }
      enableAll() {
        this.mask = 4294967295 | 0;
      }
      toggle(channel) {
        this.mask ^= 1 << channel | 0;
      }
      disable(channel) {
        this.mask &= ~(1 << channel | 0);
      }
      disableAll() {
        this.mask = 0;
      }
      test(layers) {
        return (this.mask & layers.mask) !== 0;
      }
      isEnabled(channel) {
        return (this.mask & (1 << channel | 0)) !== 0;
      }
    };
    _object3DId = 0;
    _v1$4 = /* @__PURE__ */ new Vector3();
    _q1 = /* @__PURE__ */ new Quaternion();
    _m1$1 = /* @__PURE__ */ new Matrix4();
    _target = /* @__PURE__ */ new Vector3();
    _position$3 = /* @__PURE__ */ new Vector3();
    _scale$2 = /* @__PURE__ */ new Vector3();
    _quaternion$2 = /* @__PURE__ */ new Quaternion();
    _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0);
    _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0);
    _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1);
    _addedEvent = { type: "added" };
    _removedEvent = { type: "removed" };
    Object3D = class extends EventDispatcher {
      constructor() {
        super();
        Object.defineProperty(this, "id", { value: _object3DId++ });
        this.uuid = generateUUID();
        this.name = "";
        this.type = "Object3D";
        this.parent = null;
        this.children = [];
        this.up = Object3D.DefaultUp.clone();
        const position = new Vector3();
        const rotation = new Euler();
        const quaternion = new Quaternion();
        const scale = new Vector3(1, 1, 1);
        function onRotationChange() {
          quaternion.setFromEuler(rotation, false);
        }
        function onQuaternionChange() {
          rotation.setFromQuaternion(quaternion, void 0, false);
        }
        rotation._onChange(onRotationChange);
        quaternion._onChange(onQuaternionChange);
        Object.defineProperties(this, {
          position: {
            configurable: true,
            enumerable: true,
            value: position
          },
          rotation: {
            configurable: true,
            enumerable: true,
            value: rotation
          },
          quaternion: {
            configurable: true,
            enumerable: true,
            value: quaternion
          },
          scale: {
            configurable: true,
            enumerable: true,
            value: scale
          },
          modelViewMatrix: {
            value: new Matrix4()
          },
          normalMatrix: {
            value: new Matrix3()
          }
        });
        this.matrix = new Matrix4();
        this.matrixWorld = new Matrix4();
        this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
        this.matrixWorldNeedsUpdate = false;
        this.layers = new Layers();
        this.visible = true;
        this.castShadow = false;
        this.receiveShadow = false;
        this.frustumCulled = true;
        this.renderOrder = 0;
        this.animations = [];
        this.userData = {};
      }
      onBeforeRender() {
      }
      onAfterRender() {
      }
      applyMatrix4(matrix) {
        if (this.matrixAutoUpdate)
          this.updateMatrix();
        this.matrix.premultiply(matrix);
        this.matrix.decompose(this.position, this.quaternion, this.scale);
      }
      applyQuaternion(q) {
        this.quaternion.premultiply(q);
        return this;
      }
      setRotationFromAxisAngle(axis, angle) {
        this.quaternion.setFromAxisAngle(axis, angle);
      }
      setRotationFromEuler(euler) {
        this.quaternion.setFromEuler(euler, true);
      }
      setRotationFromMatrix(m) {
        this.quaternion.setFromRotationMatrix(m);
      }
      setRotationFromQuaternion(q) {
        this.quaternion.copy(q);
      }
      rotateOnAxis(axis, angle) {
        _q1.setFromAxisAngle(axis, angle);
        this.quaternion.multiply(_q1);
        return this;
      }
      rotateOnWorldAxis(axis, angle) {
        _q1.setFromAxisAngle(axis, angle);
        this.quaternion.premultiply(_q1);
        return this;
      }
      rotateX(angle) {
        return this.rotateOnAxis(_xAxis, angle);
      }
      rotateY(angle) {
        return this.rotateOnAxis(_yAxis, angle);
      }
      rotateZ(angle) {
        return this.rotateOnAxis(_zAxis, angle);
      }
      translateOnAxis(axis, distance) {
        _v1$4.copy(axis).applyQuaternion(this.quaternion);
        this.position.add(_v1$4.multiplyScalar(distance));
        return this;
      }
      translateX(distance) {
        return this.translateOnAxis(_xAxis, distance);
      }
      translateY(distance) {
        return this.translateOnAxis(_yAxis, distance);
      }
      translateZ(distance) {
        return this.translateOnAxis(_zAxis, distance);
      }
      localToWorld(vector) {
        return vector.applyMatrix4(this.matrixWorld);
      }
      worldToLocal(vector) {
        return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
      }
      lookAt(x, y2, z) {
        if (x.isVector3) {
          _target.copy(x);
        } else {
          _target.set(x, y2, z);
        }
        const parent = this.parent;
        this.updateWorldMatrix(true, false);
        _position$3.setFromMatrixPosition(this.matrixWorld);
        if (this.isCamera || this.isLight) {
          _m1$1.lookAt(_position$3, _target, this.up);
        } else {
          _m1$1.lookAt(_target, _position$3, this.up);
        }
        this.quaternion.setFromRotationMatrix(_m1$1);
        if (parent) {
          _m1$1.extractRotation(parent.matrixWorld);
          _q1.setFromRotationMatrix(_m1$1);
          this.quaternion.premultiply(_q1.invert());
        }
      }
      add(object) {
        if (arguments.length > 1) {
          for (let i2 = 0; i2 < arguments.length; i2++) {
            this.add(arguments[i2]);
          }
          return this;
        }
        if (object === this) {
          console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
          return this;
        }
        if (object && object.isObject3D) {
          if (object.parent !== null) {
            object.parent.remove(object);
          }
          object.parent = this;
          this.children.push(object);
          object.dispatchEvent(_addedEvent);
        } else {
          console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
        }
        return this;
      }
      remove(object) {
        if (arguments.length > 1) {
          for (let i2 = 0; i2 < arguments.length; i2++) {
            this.remove(arguments[i2]);
          }
          return this;
        }
        const index = this.children.indexOf(object);
        if (index !== -1) {
          object.parent = null;
          this.children.splice(index, 1);
          object.dispatchEvent(_removedEvent);
        }
        return this;
      }
      removeFromParent() {
        const parent = this.parent;
        if (parent !== null) {
          parent.remove(this);
        }
        return this;
      }
      clear() {
        for (let i2 = 0; i2 < this.children.length; i2++) {
          const object = this.children[i2];
          object.parent = null;
          object.dispatchEvent(_removedEvent);
        }
        this.children.length = 0;
        return this;
      }
      attach(object) {
        this.updateWorldMatrix(true, false);
        _m1$1.copy(this.matrixWorld).invert();
        if (object.parent !== null) {
          object.parent.updateWorldMatrix(true, false);
          _m1$1.multiply(object.parent.matrixWorld);
        }
        object.applyMatrix4(_m1$1);
        this.add(object);
        object.updateWorldMatrix(false, true);
        return this;
      }
      getObjectById(id) {
        return this.getObjectByProperty("id", id);
      }
      getObjectByName(name) {
        return this.getObjectByProperty("name", name);
      }
      getObjectByProperty(name, value) {
        if (this[name] === value)
          return this;
        for (let i2 = 0, l = this.children.length; i2 < l; i2++) {
          const child = this.children[i2];
          const object = child.getObjectByProperty(name, value);
          if (object !== void 0) {
            return object;
          }
        }
        return void 0;
      }
      getWorldPosition(target) {
        this.updateWorldMatrix(true, false);
        return target.setFromMatrixPosition(this.matrixWorld);
      }
      getWorldQuaternion(target) {
        this.updateWorldMatrix(true, false);
        this.matrixWorld.decompose(_position$3, target, _scale$2);
        return target;
      }
      getWorldScale(target) {
        this.updateWorldMatrix(true, false);
        this.matrixWorld.decompose(_position$3, _quaternion$2, target);
        return target;
      }
      getWorldDirection(target) {
        this.updateWorldMatrix(true, false);
        const e = this.matrixWorld.elements;
        return target.set(e[8], e[9], e[10]).normalize();
      }
      raycast() {
      }
      traverse(callback) {
        callback(this);
        const children = this.children;
        for (let i2 = 0, l = children.length; i2 < l; i2++) {
          children[i2].traverse(callback);
        }
      }
      traverseVisible(callback) {
        if (this.visible === false)
          return;
        callback(this);
        const children = this.children;
        for (let i2 = 0, l = children.length; i2 < l; i2++) {
          children[i2].traverseVisible(callback);
        }
      }
      traverseAncestors(callback) {
        const parent = this.parent;
        if (parent !== null) {
          callback(parent);
          parent.traverseAncestors(callback);
        }
      }
      updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale);
        this.matrixWorldNeedsUpdate = true;
      }
      updateMatrixWorld(force) {
        if (this.matrixAutoUpdate)
          this.updateMatrix();
        if (this.matrixWorldNeedsUpdate || force) {
          if (this.parent === null) {
            this.matrixWorld.copy(this.matrix);
          } else {
            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
          }
          this.matrixWorldNeedsUpdate = false;
          force = true;
        }
        const children = this.children;
        for (let i2 = 0, l = children.length; i2 < l; i2++) {
          children[i2].updateMatrixWorld(force);
        }
      }
      updateWorldMatrix(updateParents, updateChildren) {
        const parent = this.parent;
        if (updateParents === true && parent !== null) {
          parent.updateWorldMatrix(true, false);
        }
        if (this.matrixAutoUpdate)
          this.updateMatrix();
        if (this.parent === null) {
          this.matrixWorld.copy(this.matrix);
        } else {
          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        }
        if (updateChildren === true) {
          const children = this.children;
          for (let i2 = 0, l = children.length; i2 < l; i2++) {
            children[i2].updateWorldMatrix(false, true);
          }
        }
      }
      toJSON(meta) {
        const isRootObject = meta === void 0 || typeof meta === "string";
        const output = {};
        if (isRootObject) {
          meta = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
          };
          output.metadata = {
            version: 4.5,
            type: "Object",
            generator: "Object3D.toJSON"
          };
        }
        const object = {};
        object.uuid = this.uuid;
        object.type = this.type;
        if (this.name !== "")
          object.name = this.name;
        if (this.castShadow === true)
          object.castShadow = true;
        if (this.receiveShadow === true)
          object.receiveShadow = true;
        if (this.visible === false)
          object.visible = false;
        if (this.frustumCulled === false)
          object.frustumCulled = false;
        if (this.renderOrder !== 0)
          object.renderOrder = this.renderOrder;
        if (JSON.stringify(this.userData) !== "{}")
          object.userData = this.userData;
        object.layers = this.layers.mask;
        object.matrix = this.matrix.toArray();
        if (this.matrixAutoUpdate === false)
          object.matrixAutoUpdate = false;
        if (this.isInstancedMesh) {
          object.type = "InstancedMesh";
          object.count = this.count;
          object.instanceMatrix = this.instanceMatrix.toJSON();
          if (this.instanceColor !== null)
            object.instanceColor = this.instanceColor.toJSON();
        }
        function serialize(library, element) {
          if (library[element.uuid] === void 0) {
            library[element.uuid] = element.toJSON(meta);
          }
          return element.uuid;
        }
        if (this.isScene) {
          if (this.background) {
            if (this.background.isColor) {
              object.background = this.background.toJSON();
            } else if (this.background.isTexture) {
              object.background = this.background.toJSON(meta).uuid;
            }
          }
          if (this.environment && this.environment.isTexture) {
            object.environment = this.environment.toJSON(meta).uuid;
          }
        } else if (this.isMesh || this.isLine || this.isPoints) {
          object.geometry = serialize(meta.geometries, this.geometry);
          const parameters = this.geometry.parameters;
          if (parameters !== void 0 && parameters.shapes !== void 0) {
            const shapes = parameters.shapes;
            if (Array.isArray(shapes)) {
              for (let i2 = 0, l = shapes.length; i2 < l; i2++) {
                const shape = shapes[i2];
                serialize(meta.shapes, shape);
              }
            } else {
              serialize(meta.shapes, shapes);
            }
          }
        }
        if (this.isSkinnedMesh) {
          object.bindMode = this.bindMode;
          object.bindMatrix = this.bindMatrix.toArray();
          if (this.skeleton !== void 0) {
            serialize(meta.skeletons, this.skeleton);
            object.skeleton = this.skeleton.uuid;
          }
        }
        if (this.material !== void 0) {
          if (Array.isArray(this.material)) {
            const uuids = [];
            for (let i2 = 0, l = this.material.length; i2 < l; i2++) {
              uuids.push(serialize(meta.materials, this.material[i2]));
            }
            object.material = uuids;
          } else {
            object.material = serialize(meta.materials, this.material);
          }
        }
        if (this.children.length > 0) {
          object.children = [];
          for (let i2 = 0; i2 < this.children.length; i2++) {
            object.children.push(this.children[i2].toJSON(meta).object);
          }
        }
        if (this.animations.length > 0) {
          object.animations = [];
          for (let i2 = 0; i2 < this.animations.length; i2++) {
            const animation = this.animations[i2];
            object.animations.push(serialize(meta.animations, animation));
          }
        }
        if (isRootObject) {
          const geometries = extractFromCache(meta.geometries);
          const materials = extractFromCache(meta.materials);
          const textures = extractFromCache(meta.textures);
          const images = extractFromCache(meta.images);
          const shapes = extractFromCache(meta.shapes);
          const skeletons = extractFromCache(meta.skeletons);
          const animations = extractFromCache(meta.animations);
          const nodes = extractFromCache(meta.nodes);
          if (geometries.length > 0)
            output.geometries = geometries;
          if (materials.length > 0)
            output.materials = materials;
          if (textures.length > 0)
            output.textures = textures;
          if (images.length > 0)
            output.images = images;
          if (shapes.length > 0)
            output.shapes = shapes;
          if (skeletons.length > 0)
            output.skeletons = skeletons;
          if (animations.length > 0)
            output.animations = animations;
          if (nodes.length > 0)
            output.nodes = nodes;
        }
        output.object = object;
        return output;
        function extractFromCache(cache) {
          const values = [];
          for (const key in cache) {
            const data = cache[key];
            delete data.metadata;
            values.push(data);
          }
          return values;
        }
      }
      clone(recursive) {
        return new this.constructor().copy(this, recursive);
      }
      copy(source, recursive = true) {
        this.name = source.name;
        this.up.copy(source.up);
        this.position.copy(source.position);
        this.rotation.order = source.rotation.order;
        this.quaternion.copy(source.quaternion);
        this.scale.copy(source.scale);
        this.matrix.copy(source.matrix);
        this.matrixWorld.copy(source.matrixWorld);
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
        this.layers.mask = source.layers.mask;
        this.visible = source.visible;
        this.castShadow = source.castShadow;
        this.receiveShadow = source.receiveShadow;
        this.frustumCulled = source.frustumCulled;
        this.renderOrder = source.renderOrder;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        if (recursive === true) {
          for (let i2 = 0; i2 < source.children.length; i2++) {
            const child = source.children[i2];
            this.add(child.clone());
          }
        }
        return this;
      }
    };
    Object3D.DefaultUp = new Vector3(0, 1, 0);
    Object3D.DefaultMatrixAutoUpdate = true;
    Object3D.prototype.isObject3D = true;
    _v0$1 = /* @__PURE__ */ new Vector3();
    _v1$3 = /* @__PURE__ */ new Vector3();
    _v2$2 = /* @__PURE__ */ new Vector3();
    _v3$1 = /* @__PURE__ */ new Vector3();
    _vab = /* @__PURE__ */ new Vector3();
    _vac = /* @__PURE__ */ new Vector3();
    _vbc = /* @__PURE__ */ new Vector3();
    _vap = /* @__PURE__ */ new Vector3();
    _vbp = /* @__PURE__ */ new Vector3();
    _vcp = /* @__PURE__ */ new Vector3();
    Triangle = class {
      constructor(a = new Vector3(), b2 = new Vector3(), c = new Vector3()) {
        this.a = a;
        this.b = b2;
        this.c = c;
      }
      static getNormal(a, b2, c, target) {
        target.subVectors(c, b2);
        _v0$1.subVectors(a, b2);
        target.cross(_v0$1);
        const targetLengthSq = target.lengthSq();
        if (targetLengthSq > 0) {
          return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
        }
        return target.set(0, 0, 0);
      }
      static getBarycoord(point, a, b2, c, target) {
        _v0$1.subVectors(c, a);
        _v1$3.subVectors(b2, a);
        _v2$2.subVectors(point, a);
        const dot00 = _v0$1.dot(_v0$1);
        const dot01 = _v0$1.dot(_v1$3);
        const dot02 = _v0$1.dot(_v2$2);
        const dot11 = _v1$3.dot(_v1$3);
        const dot12 = _v1$3.dot(_v2$2);
        const denom = dot00 * dot11 - dot01 * dot01;
        if (denom === 0) {
          return target.set(-2, -1, -1);
        }
        const invDenom = 1 / denom;
        const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
        return target.set(1 - u - v, v, u);
      }
      static containsPoint(point, a, b2, c) {
        this.getBarycoord(point, a, b2, c, _v3$1);
        return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;
      }
      static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
        this.getBarycoord(point, p1, p2, p3, _v3$1);
        target.set(0, 0);
        target.addScaledVector(uv1, _v3$1.x);
        target.addScaledVector(uv2, _v3$1.y);
        target.addScaledVector(uv3, _v3$1.z);
        return target;
      }
      static isFrontFacing(a, b2, c, direction) {
        _v0$1.subVectors(c, b2);
        _v1$3.subVectors(a, b2);
        return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
      }
      set(a, b2, c) {
        this.a.copy(a);
        this.b.copy(b2);
        this.c.copy(c);
        return this;
      }
      setFromPointsAndIndices(points, i0, i1, i2) {
        this.a.copy(points[i0]);
        this.b.copy(points[i1]);
        this.c.copy(points[i2]);
        return this;
      }
      setFromAttributeAndIndices(attribute, i0, i1, i2) {
        this.a.fromBufferAttribute(attribute, i0);
        this.b.fromBufferAttribute(attribute, i1);
        this.c.fromBufferAttribute(attribute, i2);
        return this;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(triangle) {
        this.a.copy(triangle.a);
        this.b.copy(triangle.b);
        this.c.copy(triangle.c);
        return this;
      }
      getArea() {
        _v0$1.subVectors(this.c, this.b);
        _v1$3.subVectors(this.a, this.b);
        return _v0$1.cross(_v1$3).length() * 0.5;
      }
      getMidpoint(target) {
        return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
      }
      getNormal(target) {
        return Triangle.getNormal(this.a, this.b, this.c, target);
      }
      getPlane(target) {
        return target.setFromCoplanarPoints(this.a, this.b, this.c);
      }
      getBarycoord(point, target) {
        return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
      }
      getUV(point, uv1, uv2, uv3, target) {
        return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
      }
      containsPoint(point) {
        return Triangle.containsPoint(point, this.a, this.b, this.c);
      }
      isFrontFacing(direction) {
        return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
      }
      intersectsBox(box) {
        return box.intersectsTriangle(this);
      }
      closestPointToPoint(p, target) {
        const a = this.a, b2 = this.b, c = this.c;
        let v, w;
        _vab.subVectors(b2, a);
        _vac.subVectors(c, a);
        _vap.subVectors(p, a);
        const d1 = _vab.dot(_vap);
        const d2 = _vac.dot(_vap);
        if (d1 <= 0 && d2 <= 0) {
          return target.copy(a);
        }
        _vbp.subVectors(p, b2);
        const d3 = _vab.dot(_vbp);
        const d4 = _vac.dot(_vbp);
        if (d3 >= 0 && d4 <= d3) {
          return target.copy(b2);
        }
        const vc = d1 * d4 - d3 * d2;
        if (vc <= 0 && d1 >= 0 && d3 <= 0) {
          v = d1 / (d1 - d3);
          return target.copy(a).addScaledVector(_vab, v);
        }
        _vcp.subVectors(p, c);
        const d5 = _vab.dot(_vcp);
        const d6 = _vac.dot(_vcp);
        if (d6 >= 0 && d5 <= d6) {
          return target.copy(c);
        }
        const vb = d5 * d2 - d1 * d6;
        if (vb <= 0 && d2 >= 0 && d6 <= 0) {
          w = d2 / (d2 - d6);
          return target.copy(a).addScaledVector(_vac, w);
        }
        const va = d3 * d6 - d5 * d4;
        if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
          _vbc.subVectors(c, b2);
          w = (d4 - d3) / (d4 - d3 + (d5 - d6));
          return target.copy(b2).addScaledVector(_vbc, w);
        }
        const denom = 1 / (va + vb + vc);
        v = vb * denom;
        w = vc * denom;
        return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
      }
      equals(triangle) {
        return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
      }
    };
    materialId = 0;
    Material = class extends EventDispatcher {
      constructor() {
        super();
        Object.defineProperty(this, "id", { value: materialId++ });
        this.uuid = generateUUID();
        this.name = "";
        this.type = "Material";
        this.fog = true;
        this.blending = NormalBlending;
        this.side = FrontSide;
        this.vertexColors = false;
        this.opacity = 1;
        this.transparent = false;
        this.blendSrc = SrcAlphaFactor;
        this.blendDst = OneMinusSrcAlphaFactor;
        this.blendEquation = AddEquation;
        this.blendSrcAlpha = null;
        this.blendDstAlpha = null;
        this.blendEquationAlpha = null;
        this.depthFunc = LessEqualDepth;
        this.depthTest = true;
        this.depthWrite = true;
        this.stencilWriteMask = 255;
        this.stencilFunc = AlwaysStencilFunc;
        this.stencilRef = 0;
        this.stencilFuncMask = 255;
        this.stencilFail = KeepStencilOp;
        this.stencilZFail = KeepStencilOp;
        this.stencilZPass = KeepStencilOp;
        this.stencilWrite = false;
        this.clippingPlanes = null;
        this.clipIntersection = false;
        this.clipShadows = false;
        this.shadowSide = null;
        this.colorWrite = true;
        this.precision = null;
        this.polygonOffset = false;
        this.polygonOffsetFactor = 0;
        this.polygonOffsetUnits = 0;
        this.dithering = false;
        this.alphaToCoverage = false;
        this.premultipliedAlpha = false;
        this.visible = true;
        this.toneMapped = true;
        this.userData = {};
        this.version = 0;
        this._alphaTest = 0;
      }
      get alphaTest() {
        return this._alphaTest;
      }
      set alphaTest(value) {
        if (this._alphaTest > 0 !== value > 0) {
          this.version++;
        }
        this._alphaTest = value;
      }
      onBuild() {
      }
      onBeforeRender() {
      }
      onBeforeCompile() {
      }
      customProgramCacheKey() {
        return this.onBeforeCompile.toString();
      }
      setValues(values) {
        if (values === void 0)
          return;
        for (const key in values) {
          const newValue = values[key];
          if (newValue === void 0) {
            console.warn("THREE.Material: '" + key + "' parameter is undefined.");
            continue;
          }
          if (key === "shading") {
            console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
            this.flatShading = newValue === FlatShading ? true : false;
            continue;
          }
          const currentValue = this[key];
          if (currentValue === void 0) {
            console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
            continue;
          }
          if (currentValue && currentValue.isColor) {
            currentValue.set(newValue);
          } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
            currentValue.copy(newValue);
          } else {
            this[key] = newValue;
          }
        }
      }
      toJSON(meta) {
        const isRootObject = meta === void 0 || typeof meta === "string";
        if (isRootObject) {
          meta = {
            textures: {},
            images: {}
          };
        }
        const data = {
          metadata: {
            version: 4.5,
            type: "Material",
            generator: "Material.toJSON"
          }
        };
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== "")
          data.name = this.name;
        if (this.color && this.color.isColor)
          data.color = this.color.getHex();
        if (this.roughness !== void 0)
          data.roughness = this.roughness;
        if (this.metalness !== void 0)
          data.metalness = this.metalness;
        if (this.sheen !== void 0)
          data.sheen = this.sheen;
        if (this.sheenColor && this.sheenColor.isColor)
          data.sheenColor = this.sheenColor.getHex();
        if (this.sheenRoughness !== void 0)
          data.sheenRoughness = this.sheenRoughness;
        if (this.emissive && this.emissive.isColor)
          data.emissive = this.emissive.getHex();
        if (this.emissiveIntensity && this.emissiveIntensity !== 1)
          data.emissiveIntensity = this.emissiveIntensity;
        if (this.specular && this.specular.isColor)
          data.specular = this.specular.getHex();
        if (this.specularIntensity !== void 0)
          data.specularIntensity = this.specularIntensity;
        if (this.specularColor && this.specularColor.isColor)
          data.specularColor = this.specularColor.getHex();
        if (this.shininess !== void 0)
          data.shininess = this.shininess;
        if (this.clearcoat !== void 0)
          data.clearcoat = this.clearcoat;
        if (this.clearcoatRoughness !== void 0)
          data.clearcoatRoughness = this.clearcoatRoughness;
        if (this.clearcoatMap && this.clearcoatMap.isTexture) {
          data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
        }
        if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
          data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
        }
        if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
          data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
          data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
        }
        if (this.map && this.map.isTexture)
          data.map = this.map.toJSON(meta).uuid;
        if (this.matcap && this.matcap.isTexture)
          data.matcap = this.matcap.toJSON(meta).uuid;
        if (this.alphaMap && this.alphaMap.isTexture)
          data.alphaMap = this.alphaMap.toJSON(meta).uuid;
        if (this.lightMap && this.lightMap.isTexture) {
          data.lightMap = this.lightMap.toJSON(meta).uuid;
          data.lightMapIntensity = this.lightMapIntensity;
        }
        if (this.aoMap && this.aoMap.isTexture) {
          data.aoMap = this.aoMap.toJSON(meta).uuid;
          data.aoMapIntensity = this.aoMapIntensity;
        }
        if (this.bumpMap && this.bumpMap.isTexture) {
          data.bumpMap = this.bumpMap.toJSON(meta).uuid;
          data.bumpScale = this.bumpScale;
        }
        if (this.normalMap && this.normalMap.isTexture) {
          data.normalMap = this.normalMap.toJSON(meta).uuid;
          data.normalMapType = this.normalMapType;
          data.normalScale = this.normalScale.toArray();
        }
        if (this.displacementMap && this.displacementMap.isTexture) {
          data.displacementMap = this.displacementMap.toJSON(meta).uuid;
          data.displacementScale = this.displacementScale;
          data.displacementBias = this.displacementBias;
        }
        if (this.roughnessMap && this.roughnessMap.isTexture)
          data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
        if (this.metalnessMap && this.metalnessMap.isTexture)
          data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
        if (this.emissiveMap && this.emissiveMap.isTexture)
          data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
        if (this.specularMap && this.specularMap.isTexture)
          data.specularMap = this.specularMap.toJSON(meta).uuid;
        if (this.specularIntensityMap && this.specularIntensityMap.isTexture)
          data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
        if (this.specularColorMap && this.specularColorMap.isTexture)
          data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
        if (this.envMap && this.envMap.isTexture) {
          data.envMap = this.envMap.toJSON(meta).uuid;
          if (this.combine !== void 0)
            data.combine = this.combine;
        }
        if (this.envMapIntensity !== void 0)
          data.envMapIntensity = this.envMapIntensity;
        if (this.reflectivity !== void 0)
          data.reflectivity = this.reflectivity;
        if (this.refractionRatio !== void 0)
          data.refractionRatio = this.refractionRatio;
        if (this.gradientMap && this.gradientMap.isTexture) {
          data.gradientMap = this.gradientMap.toJSON(meta).uuid;
        }
        if (this.transmission !== void 0)
          data.transmission = this.transmission;
        if (this.transmissionMap && this.transmissionMap.isTexture)
          data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
        if (this.thickness !== void 0)
          data.thickness = this.thickness;
        if (this.thicknessMap && this.thicknessMap.isTexture)
          data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
        if (this.attenuationDistance !== void 0)
          data.attenuationDistance = this.attenuationDistance;
        if (this.attenuationColor !== void 0)
          data.attenuationColor = this.attenuationColor.getHex();
        if (this.size !== void 0)
          data.size = this.size;
        if (this.shadowSide !== null)
          data.shadowSide = this.shadowSide;
        if (this.sizeAttenuation !== void 0)
          data.sizeAttenuation = this.sizeAttenuation;
        if (this.blending !== NormalBlending)
          data.blending = this.blending;
        if (this.side !== FrontSide)
          data.side = this.side;
        if (this.vertexColors)
          data.vertexColors = true;
        if (this.opacity < 1)
          data.opacity = this.opacity;
        if (this.transparent === true)
          data.transparent = this.transparent;
        data.depthFunc = this.depthFunc;
        data.depthTest = this.depthTest;
        data.depthWrite = this.depthWrite;
        data.colorWrite = this.colorWrite;
        data.stencilWrite = this.stencilWrite;
        data.stencilWriteMask = this.stencilWriteMask;
        data.stencilFunc = this.stencilFunc;
        data.stencilRef = this.stencilRef;
        data.stencilFuncMask = this.stencilFuncMask;
        data.stencilFail = this.stencilFail;
        data.stencilZFail = this.stencilZFail;
        data.stencilZPass = this.stencilZPass;
        if (this.rotation !== void 0 && this.rotation !== 0)
          data.rotation = this.rotation;
        if (this.polygonOffset === true)
          data.polygonOffset = true;
        if (this.polygonOffsetFactor !== 0)
          data.polygonOffsetFactor = this.polygonOffsetFactor;
        if (this.polygonOffsetUnits !== 0)
          data.polygonOffsetUnits = this.polygonOffsetUnits;
        if (this.linewidth !== void 0 && this.linewidth !== 1)
          data.linewidth = this.linewidth;
        if (this.dashSize !== void 0)
          data.dashSize = this.dashSize;
        if (this.gapSize !== void 0)
          data.gapSize = this.gapSize;
        if (this.scale !== void 0)
          data.scale = this.scale;
        if (this.dithering === true)
          data.dithering = true;
        if (this.alphaTest > 0)
          data.alphaTest = this.alphaTest;
        if (this.alphaToCoverage === true)
          data.alphaToCoverage = this.alphaToCoverage;
        if (this.premultipliedAlpha === true)
          data.premultipliedAlpha = this.premultipliedAlpha;
        if (this.wireframe === true)
          data.wireframe = this.wireframe;
        if (this.wireframeLinewidth > 1)
          data.wireframeLinewidth = this.wireframeLinewidth;
        if (this.wireframeLinecap !== "round")
          data.wireframeLinecap = this.wireframeLinecap;
        if (this.wireframeLinejoin !== "round")
          data.wireframeLinejoin = this.wireframeLinejoin;
        if (this.flatShading === true)
          data.flatShading = this.flatShading;
        if (this.visible === false)
          data.visible = false;
        if (this.toneMapped === false)
          data.toneMapped = false;
        if (JSON.stringify(this.userData) !== "{}")
          data.userData = this.userData;
        function extractFromCache(cache) {
          const values = [];
          for (const key in cache) {
            const data2 = cache[key];
            delete data2.metadata;
            values.push(data2);
          }
          return values;
        }
        if (isRootObject) {
          const textures = extractFromCache(meta.textures);
          const images = extractFromCache(meta.images);
          if (textures.length > 0)
            data.textures = textures;
          if (images.length > 0)
            data.images = images;
        }
        return data;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(source) {
        this.name = source.name;
        this.fog = source.fog;
        this.blending = source.blending;
        this.side = source.side;
        this.vertexColors = source.vertexColors;
        this.opacity = source.opacity;
        this.transparent = source.transparent;
        this.blendSrc = source.blendSrc;
        this.blendDst = source.blendDst;
        this.blendEquation = source.blendEquation;
        this.blendSrcAlpha = source.blendSrcAlpha;
        this.blendDstAlpha = source.blendDstAlpha;
        this.blendEquationAlpha = source.blendEquationAlpha;
        this.depthFunc = source.depthFunc;
        this.depthTest = source.depthTest;
        this.depthWrite = source.depthWrite;
        this.stencilWriteMask = source.stencilWriteMask;
        this.stencilFunc = source.stencilFunc;
        this.stencilRef = source.stencilRef;
        this.stencilFuncMask = source.stencilFuncMask;
        this.stencilFail = source.stencilFail;
        this.stencilZFail = source.stencilZFail;
        this.stencilZPass = source.stencilZPass;
        this.stencilWrite = source.stencilWrite;
        const srcPlanes = source.clippingPlanes;
        let dstPlanes = null;
        if (srcPlanes !== null) {
          const n = srcPlanes.length;
          dstPlanes = new Array(n);
          for (let i2 = 0; i2 !== n; ++i2) {
            dstPlanes[i2] = srcPlanes[i2].clone();
          }
        }
        this.clippingPlanes = dstPlanes;
        this.clipIntersection = source.clipIntersection;
        this.clipShadows = source.clipShadows;
        this.shadowSide = source.shadowSide;
        this.colorWrite = source.colorWrite;
        this.precision = source.precision;
        this.polygonOffset = source.polygonOffset;
        this.polygonOffsetFactor = source.polygonOffsetFactor;
        this.polygonOffsetUnits = source.polygonOffsetUnits;
        this.dithering = source.dithering;
        this.alphaTest = source.alphaTest;
        this.alphaToCoverage = source.alphaToCoverage;
        this.premultipliedAlpha = source.premultipliedAlpha;
        this.visible = source.visible;
        this.toneMapped = source.toneMapped;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        return this;
      }
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
      set needsUpdate(value) {
        if (value === true)
          this.version++;
      }
    };
    Material.prototype.isMaterial = true;
    Material.fromType = function() {
      return null;
    };
    MeshBasicMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.type = "MeshBasicMaterial";
        this.color = new Color(16777215);
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = "round";
        this.wireframeLinejoin = "round";
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        return this;
      }
    };
    MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
    _vector$9 = /* @__PURE__ */ new Vector3();
    _vector2$1 = /* @__PURE__ */ new Vector2();
    BufferAttribute = class {
      constructor(array, itemSize, normalized) {
        if (Array.isArray(array)) {
          throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        }
        this.name = "";
        this.array = array;
        this.itemSize = itemSize;
        this.count = array !== void 0 ? array.length / itemSize : 0;
        this.normalized = normalized === true;
        this.usage = StaticDrawUsage;
        this.updateRange = { offset: 0, count: -1 };
        this.version = 0;
      }
      onUploadCallback() {
      }
      set needsUpdate(value) {
        if (value === true)
          this.version++;
      }
      setUsage(value) {
        this.usage = value;
        return this;
      }
      copy(source) {
        this.name = source.name;
        this.array = new source.array.constructor(source.array);
        this.itemSize = source.itemSize;
        this.count = source.count;
        this.normalized = source.normalized;
        this.usage = source.usage;
        return this;
      }
      copyAt(index1, attribute, index2) {
        index1 *= this.itemSize;
        index2 *= attribute.itemSize;
        for (let i2 = 0, l = this.itemSize; i2 < l; i2++) {
          this.array[index1 + i2] = attribute.array[index2 + i2];
        }
        return this;
      }
      copyArray(array) {
        this.array.set(array);
        return this;
      }
      copyColorsArray(colors) {
        const array = this.array;
        let offset = 0;
        for (let i2 = 0, l = colors.length; i2 < l; i2++) {
          let color = colors[i2];
          if (color === void 0) {
            console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i2);
            color = new Color();
          }
          array[offset++] = color.r;
          array[offset++] = color.g;
          array[offset++] = color.b;
        }
        return this;
      }
      copyVector2sArray(vectors) {
        const array = this.array;
        let offset = 0;
        for (let i2 = 0, l = vectors.length; i2 < l; i2++) {
          let vector = vectors[i2];
          if (vector === void 0) {
            console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i2);
            vector = new Vector2();
          }
          array[offset++] = vector.x;
          array[offset++] = vector.y;
        }
        return this;
      }
      copyVector3sArray(vectors) {
        const array = this.array;
        let offset = 0;
        for (let i2 = 0, l = vectors.length; i2 < l; i2++) {
          let vector = vectors[i2];
          if (vector === void 0) {
            console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i2);
            vector = new Vector3();
          }
          array[offset++] = vector.x;
          array[offset++] = vector.y;
          array[offset++] = vector.z;
        }
        return this;
      }
      copyVector4sArray(vectors) {
        const array = this.array;
        let offset = 0;
        for (let i2 = 0, l = vectors.length; i2 < l; i2++) {
          let vector = vectors[i2];
          if (vector === void 0) {
            console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i2);
            vector = new Vector4();
          }
          array[offset++] = vector.x;
          array[offset++] = vector.y;
          array[offset++] = vector.z;
          array[offset++] = vector.w;
        }
        return this;
      }
      applyMatrix3(m) {
        if (this.itemSize === 2) {
          for (let i2 = 0, l = this.count; i2 < l; i2++) {
            _vector2$1.fromBufferAttribute(this, i2);
            _vector2$1.applyMatrix3(m);
            this.setXY(i2, _vector2$1.x, _vector2$1.y);
          }
        } else if (this.itemSize === 3) {
          for (let i2 = 0, l = this.count; i2 < l; i2++) {
            _vector$9.fromBufferAttribute(this, i2);
            _vector$9.applyMatrix3(m);
            this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
          }
        }
        return this;
      }
      applyMatrix4(m) {
        for (let i2 = 0, l = this.count; i2 < l; i2++) {
          _vector$9.fromBufferAttribute(this, i2);
          _vector$9.applyMatrix4(m);
          this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
        }
        return this;
      }
      applyNormalMatrix(m) {
        for (let i2 = 0, l = this.count; i2 < l; i2++) {
          _vector$9.fromBufferAttribute(this, i2);
          _vector$9.applyNormalMatrix(m);
          this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
        }
        return this;
      }
      transformDirection(m) {
        for (let i2 = 0, l = this.count; i2 < l; i2++) {
          _vector$9.fromBufferAttribute(this, i2);
          _vector$9.transformDirection(m);
          this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
        }
        return this;
      }
      set(value, offset = 0) {
        this.array.set(value, offset);
        return this;
      }
      getX(index) {
        return this.array[index * this.itemSize];
      }
      setX(index, x) {
        this.array[index * this.itemSize] = x;
        return this;
      }
      getY(index) {
        return this.array[index * this.itemSize + 1];
      }
      setY(index, y2) {
        this.array[index * this.itemSize + 1] = y2;
        return this;
      }
      getZ(index) {
        return this.array[index * this.itemSize + 2];
      }
      setZ(index, z) {
        this.array[index * this.itemSize + 2] = z;
        return this;
      }
      getW(index) {
        return this.array[index * this.itemSize + 3];
      }
      setW(index, w) {
        this.array[index * this.itemSize + 3] = w;
        return this;
      }
      setXY(index, x, y2) {
        index *= this.itemSize;
        this.array[index + 0] = x;
        this.array[index + 1] = y2;
        return this;
      }
      setXYZ(index, x, y2, z) {
        index *= this.itemSize;
        this.array[index + 0] = x;
        this.array[index + 1] = y2;
        this.array[index + 2] = z;
        return this;
      }
      setXYZW(index, x, y2, z, w) {
        index *= this.itemSize;
        this.array[index + 0] = x;
        this.array[index + 1] = y2;
        this.array[index + 2] = z;
        this.array[index + 3] = w;
        return this;
      }
      onUpload(callback) {
        this.onUploadCallback = callback;
        return this;
      }
      clone() {
        return new this.constructor(this.array, this.itemSize).copy(this);
      }
      toJSON() {
        const data = {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array: Array.prototype.slice.call(this.array),
          normalized: this.normalized
        };
        if (this.name !== "")
          data.name = this.name;
        if (this.usage !== StaticDrawUsage)
          data.usage = this.usage;
        if (this.updateRange.offset !== 0 || this.updateRange.count !== -1)
          data.updateRange = this.updateRange;
        return data;
      }
    };
    BufferAttribute.prototype.isBufferAttribute = true;
    Int8BufferAttribute = class extends BufferAttribute {
      constructor(array, itemSize, normalized) {
        super(new Int8Array(array), itemSize, normalized);
      }
    };
    Uint8BufferAttribute = class extends BufferAttribute {
      constructor(array, itemSize, normalized) {
        super(new Uint8Array(array), itemSize, normalized);
      }
    };
    Uint8ClampedBufferAttribute = class extends BufferAttribute {
      constructor(array, itemSize, normalized) {
        super(new Uint8ClampedArray(array), itemSize, normalized);
      }
    };
    Int16BufferAttribute = class extends BufferAttribute {
      constructor(array, itemSize, normalized) {
        super(new Int16Array(array), itemSize, normalized);
      }
    };
    Uint16BufferAttribute = class extends BufferAttribute {
      constructor(array, itemSize, normalized) {
        super(new Uint16Array(array), itemSize, normalized);
      }
    };
    Int32BufferAttribute = class extends BufferAttribute {
      constructor(array, itemSize, normalized) {
        super(new Int32Array(array), itemSize, normalized);
      }
    };
    Uint32BufferAttribute = class extends BufferAttribute {
      constructor(array, itemSize, normalized) {
        super(new Uint32Array(array), itemSize, normalized);
      }
    };
    Float16BufferAttribute = class extends BufferAttribute {
      constructor(array, itemSize, normalized) {
        super(new Uint16Array(array), itemSize, normalized);
      }
    };
    Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;
    Float32BufferAttribute = class extends BufferAttribute {
      constructor(array, itemSize, normalized) {
        super(new Float32Array(array), itemSize, normalized);
      }
    };
    Float64BufferAttribute = class extends BufferAttribute {
      constructor(array, itemSize, normalized) {
        super(new Float64Array(array), itemSize, normalized);
      }
    };
    _id$1 = 0;
    _m1 = /* @__PURE__ */ new Matrix4();
    _obj = /* @__PURE__ */ new Object3D();
    _offset = /* @__PURE__ */ new Vector3();
    _box$1 = /* @__PURE__ */ new Box3();
    _boxMorphTargets = /* @__PURE__ */ new Box3();
    _vector$8 = /* @__PURE__ */ new Vector3();
    BufferGeometry = class extends EventDispatcher {
      constructor() {
        super();
        Object.defineProperty(this, "id", { value: _id$1++ });
        this.uuid = generateUUID();
        this.name = "";
        this.type = "BufferGeometry";
        this.index = null;
        this.attributes = {};
        this.morphAttributes = {};
        this.morphTargetsRelative = false;
        this.groups = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        this.drawRange = { start: 0, count: Infinity };
        this.userData = {};
      }
      getIndex() {
        return this.index;
      }
      setIndex(index) {
        if (Array.isArray(index)) {
          this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
        } else {
          this.index = index;
        }
        return this;
      }
      getAttribute(name) {
        return this.attributes[name];
      }
      setAttribute(name, attribute) {
        this.attributes[name] = attribute;
        return this;
      }
      deleteAttribute(name) {
        delete this.attributes[name];
        return this;
      }
      hasAttribute(name) {
        return this.attributes[name] !== void 0;
      }
      addGroup(start, count, materialIndex = 0) {
        this.groups.push({
          start,
          count,
          materialIndex
        });
      }
      clearGroups() {
        this.groups = [];
      }
      setDrawRange(start, count) {
        this.drawRange.start = start;
        this.drawRange.count = count;
      }
      applyMatrix4(matrix) {
        const position = this.attributes.position;
        if (position !== void 0) {
          position.applyMatrix4(matrix);
          position.needsUpdate = true;
        }
        const normal2 = this.attributes.normal;
        if (normal2 !== void 0) {
          const normalMatrix = new Matrix3().getNormalMatrix(matrix);
          normal2.applyNormalMatrix(normalMatrix);
          normal2.needsUpdate = true;
        }
        const tangent = this.attributes.tangent;
        if (tangent !== void 0) {
          tangent.transformDirection(matrix);
          tangent.needsUpdate = true;
        }
        if (this.boundingBox !== null) {
          this.computeBoundingBox();
        }
        if (this.boundingSphere !== null) {
          this.computeBoundingSphere();
        }
        return this;
      }
      applyQuaternion(q) {
        _m1.makeRotationFromQuaternion(q);
        this.applyMatrix4(_m1);
        return this;
      }
      rotateX(angle) {
        _m1.makeRotationX(angle);
        this.applyMatrix4(_m1);
        return this;
      }
      rotateY(angle) {
        _m1.makeRotationY(angle);
        this.applyMatrix4(_m1);
        return this;
      }
      rotateZ(angle) {
        _m1.makeRotationZ(angle);
        this.applyMatrix4(_m1);
        return this;
      }
      translate(x, y2, z) {
        _m1.makeTranslation(x, y2, z);
        this.applyMatrix4(_m1);
        return this;
      }
      scale(x, y2, z) {
        _m1.makeScale(x, y2, z);
        this.applyMatrix4(_m1);
        return this;
      }
      lookAt(vector) {
        _obj.lookAt(vector);
        _obj.updateMatrix();
        this.applyMatrix4(_obj.matrix);
        return this;
      }
      center() {
        this.computeBoundingBox();
        this.boundingBox.getCenter(_offset).negate();
        this.translate(_offset.x, _offset.y, _offset.z);
        return this;
      }
      setFromPoints(points) {
        const position = [];
        for (let i2 = 0, l = points.length; i2 < l; i2++) {
          const point = points[i2];
          position.push(point.x, point.y, point.z || 0);
        }
        this.setAttribute("position", new Float32BufferAttribute(position, 3));
        return this;
      }
      computeBoundingBox() {
        if (this.boundingBox === null) {
          this.boundingBox = new Box3();
        }
        const position = this.attributes.position;
        const morphAttributesPosition = this.morphAttributes.position;
        if (position && position.isGLBufferAttribute) {
          console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
          this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(Infinity, Infinity, Infinity));
          return;
        }
        if (position !== void 0) {
          this.boundingBox.setFromBufferAttribute(position);
          if (morphAttributesPosition) {
            for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
              const morphAttribute = morphAttributesPosition[i2];
              _box$1.setFromBufferAttribute(morphAttribute);
              if (this.morphTargetsRelative) {
                _vector$8.addVectors(this.boundingBox.min, _box$1.min);
                this.boundingBox.expandByPoint(_vector$8);
                _vector$8.addVectors(this.boundingBox.max, _box$1.max);
                this.boundingBox.expandByPoint(_vector$8);
              } else {
                this.boundingBox.expandByPoint(_box$1.min);
                this.boundingBox.expandByPoint(_box$1.max);
              }
            }
          }
        } else {
          this.boundingBox.makeEmpty();
        }
        if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
          console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
        }
      }
      computeBoundingSphere() {
        if (this.boundingSphere === null) {
          this.boundingSphere = new Sphere();
        }
        const position = this.attributes.position;
        const morphAttributesPosition = this.morphAttributes.position;
        if (position && position.isGLBufferAttribute) {
          console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
          this.boundingSphere.set(new Vector3(), Infinity);
          return;
        }
        if (position) {
          const center = this.boundingSphere.center;
          _box$1.setFromBufferAttribute(position);
          if (morphAttributesPosition) {
            for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
              const morphAttribute = morphAttributesPosition[i2];
              _boxMorphTargets.setFromBufferAttribute(morphAttribute);
              if (this.morphTargetsRelative) {
                _vector$8.addVectors(_box$1.min, _boxMorphTargets.min);
                _box$1.expandByPoint(_vector$8);
                _vector$8.addVectors(_box$1.max, _boxMorphTargets.max);
                _box$1.expandByPoint(_vector$8);
              } else {
                _box$1.expandByPoint(_boxMorphTargets.min);
                _box$1.expandByPoint(_boxMorphTargets.max);
              }
            }
          }
          _box$1.getCenter(center);
          let maxRadiusSq = 0;
          for (let i2 = 0, il = position.count; i2 < il; i2++) {
            _vector$8.fromBufferAttribute(position, i2);
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
          }
          if (morphAttributesPosition) {
            for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
              const morphAttribute = morphAttributesPosition[i2];
              const morphTargetsRelative = this.morphTargetsRelative;
              for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
                _vector$8.fromBufferAttribute(morphAttribute, j);
                if (morphTargetsRelative) {
                  _offset.fromBufferAttribute(position, j);
                  _vector$8.add(_offset);
                }
                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
              }
            }
          }
          this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
          if (isNaN(this.boundingSphere.radius)) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
          }
        }
      }
      computeTangents() {
        const index = this.index;
        const attributes = this.attributes;
        if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
          console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
          return;
        }
        const indices = index.array;
        const positions = attributes.position.array;
        const normals = attributes.normal.array;
        const uvs = attributes.uv.array;
        const nVertices = positions.length / 3;
        if (this.hasAttribute("tangent") === false) {
          this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * nVertices), 4));
        }
        const tangents = this.getAttribute("tangent").array;
        const tan1 = [], tan2 = [];
        for (let i2 = 0; i2 < nVertices; i2++) {
          tan1[i2] = new Vector3();
          tan2[i2] = new Vector3();
        }
        const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
        function handleTriangle(a, b2, c) {
          vA.fromArray(positions, a * 3);
          vB.fromArray(positions, b2 * 3);
          vC.fromArray(positions, c * 3);
          uvA.fromArray(uvs, a * 2);
          uvB.fromArray(uvs, b2 * 2);
          uvC.fromArray(uvs, c * 2);
          vB.sub(vA);
          vC.sub(vA);
          uvB.sub(uvA);
          uvC.sub(uvA);
          const r3 = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
          if (!isFinite(r3))
            return;
          sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r3);
          tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r3);
          tan1[a].add(sdir);
          tan1[b2].add(sdir);
          tan1[c].add(sdir);
          tan2[a].add(tdir);
          tan2[b2].add(tdir);
          tan2[c].add(tdir);
        }
        let groups = this.groups;
        if (groups.length === 0) {
          groups = [{
            start: 0,
            count: indices.length
          }];
        }
        for (let i2 = 0, il = groups.length; i2 < il; ++i2) {
          const group = groups[i2];
          const start = group.start;
          const count = group.count;
          for (let j = start, jl = start + count; j < jl; j += 3) {
            handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);
          }
        }
        const tmp2 = new Vector3(), tmp22 = new Vector3();
        const n = new Vector3(), n2 = new Vector3();
        function handleVertex(v) {
          n.fromArray(normals, v * 3);
          n2.copy(n);
          const t2 = tan1[v];
          tmp2.copy(t2);
          tmp2.sub(n.multiplyScalar(n.dot(t2))).normalize();
          tmp22.crossVectors(n2, t2);
          const test = tmp22.dot(tan2[v]);
          const w = test < 0 ? -1 : 1;
          tangents[v * 4] = tmp2.x;
          tangents[v * 4 + 1] = tmp2.y;
          tangents[v * 4 + 2] = tmp2.z;
          tangents[v * 4 + 3] = w;
        }
        for (let i2 = 0, il = groups.length; i2 < il; ++i2) {
          const group = groups[i2];
          const start = group.start;
          const count = group.count;
          for (let j = start, jl = start + count; j < jl; j += 3) {
            handleVertex(indices[j + 0]);
            handleVertex(indices[j + 1]);
            handleVertex(indices[j + 2]);
          }
        }
      }
      computeVertexNormals() {
        const index = this.index;
        const positionAttribute = this.getAttribute("position");
        if (positionAttribute !== void 0) {
          let normalAttribute = this.getAttribute("normal");
          if (normalAttribute === void 0) {
            normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
            this.setAttribute("normal", normalAttribute);
          } else {
            for (let i2 = 0, il = normalAttribute.count; i2 < il; i2++) {
              normalAttribute.setXYZ(i2, 0, 0, 0);
            }
          }
          const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
          const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
          const cb = new Vector3(), ab = new Vector3();
          if (index) {
            for (let i2 = 0, il = index.count; i2 < il; i2 += 3) {
              const vA = index.getX(i2 + 0);
              const vB = index.getX(i2 + 1);
              const vC = index.getX(i2 + 2);
              pA.fromBufferAttribute(positionAttribute, vA);
              pB.fromBufferAttribute(positionAttribute, vB);
              pC.fromBufferAttribute(positionAttribute, vC);
              cb.subVectors(pC, pB);
              ab.subVectors(pA, pB);
              cb.cross(ab);
              nA.fromBufferAttribute(normalAttribute, vA);
              nB.fromBufferAttribute(normalAttribute, vB);
              nC.fromBufferAttribute(normalAttribute, vC);
              nA.add(cb);
              nB.add(cb);
              nC.add(cb);
              normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
              normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
              normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
            }
          } else {
            for (let i2 = 0, il = positionAttribute.count; i2 < il; i2 += 3) {
              pA.fromBufferAttribute(positionAttribute, i2 + 0);
              pB.fromBufferAttribute(positionAttribute, i2 + 1);
              pC.fromBufferAttribute(positionAttribute, i2 + 2);
              cb.subVectors(pC, pB);
              ab.subVectors(pA, pB);
              cb.cross(ab);
              normalAttribute.setXYZ(i2 + 0, cb.x, cb.y, cb.z);
              normalAttribute.setXYZ(i2 + 1, cb.x, cb.y, cb.z);
              normalAttribute.setXYZ(i2 + 2, cb.x, cb.y, cb.z);
            }
          }
          this.normalizeNormals();
          normalAttribute.needsUpdate = true;
        }
      }
      merge(geometry, offset) {
        if (!(geometry && geometry.isBufferGeometry)) {
          console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
          return;
        }
        if (offset === void 0) {
          offset = 0;
          console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.");
        }
        const attributes = this.attributes;
        for (const key in attributes) {
          if (geometry.attributes[key] === void 0)
            continue;
          const attribute1 = attributes[key];
          const attributeArray1 = attribute1.array;
          const attribute2 = geometry.attributes[key];
          const attributeArray2 = attribute2.array;
          const attributeOffset = attribute2.itemSize * offset;
          const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
          for (let i2 = 0, j = attributeOffset; i2 < length; i2++, j++) {
            attributeArray1[j] = attributeArray2[i2];
          }
        }
        return this;
      }
      normalizeNormals() {
        const normals = this.attributes.normal;
        for (let i2 = 0, il = normals.count; i2 < il; i2++) {
          _vector$8.fromBufferAttribute(normals, i2);
          _vector$8.normalize();
          normals.setXYZ(i2, _vector$8.x, _vector$8.y, _vector$8.z);
        }
      }
      toNonIndexed() {
        function convertBufferAttribute(attribute, indices2) {
          const array = attribute.array;
          const itemSize = attribute.itemSize;
          const normalized = attribute.normalized;
          const array2 = new array.constructor(indices2.length * itemSize);
          let index = 0, index2 = 0;
          for (let i2 = 0, l = indices2.length; i2 < l; i2++) {
            if (attribute.isInterleavedBufferAttribute) {
              index = indices2[i2] * attribute.data.stride + attribute.offset;
            } else {
              index = indices2[i2] * itemSize;
            }
            for (let j = 0; j < itemSize; j++) {
              array2[index2++] = array[index++];
            }
          }
          return new BufferAttribute(array2, itemSize, normalized);
        }
        if (this.index === null) {
          console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
          return this;
        }
        const geometry2 = new BufferGeometry();
        const indices = this.index.array;
        const attributes = this.attributes;
        for (const name in attributes) {
          const attribute = attributes[name];
          const newAttribute = convertBufferAttribute(attribute, indices);
          geometry2.setAttribute(name, newAttribute);
        }
        const morphAttributes = this.morphAttributes;
        for (const name in morphAttributes) {
          const morphArray = [];
          const morphAttribute = morphAttributes[name];
          for (let i2 = 0, il = morphAttribute.length; i2 < il; i2++) {
            const attribute = morphAttribute[i2];
            const newAttribute = convertBufferAttribute(attribute, indices);
            morphArray.push(newAttribute);
          }
          geometry2.morphAttributes[name] = morphArray;
        }
        geometry2.morphTargetsRelative = this.morphTargetsRelative;
        const groups = this.groups;
        for (let i2 = 0, l = groups.length; i2 < l; i2++) {
          const group = groups[i2];
          geometry2.addGroup(group.start, group.count, group.materialIndex);
        }
        return geometry2;
      }
      toJSON() {
        const data = {
          metadata: {
            version: 4.5,
            type: "BufferGeometry",
            generator: "BufferGeometry.toJSON"
          }
        };
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== "")
          data.name = this.name;
        if (Object.keys(this.userData).length > 0)
          data.userData = this.userData;
        if (this.parameters !== void 0) {
          const parameters = this.parameters;
          for (const key in parameters) {
            if (parameters[key] !== void 0)
              data[key] = parameters[key];
          }
          return data;
        }
        data.data = { attributes: {} };
        const index = this.index;
        if (index !== null) {
          data.data.index = {
            type: index.array.constructor.name,
            array: Array.prototype.slice.call(index.array)
          };
        }
        const attributes = this.attributes;
        for (const key in attributes) {
          const attribute = attributes[key];
          data.data.attributes[key] = attribute.toJSON(data.data);
        }
        const morphAttributes = {};
        let hasMorphAttributes = false;
        for (const key in this.morphAttributes) {
          const attributeArray = this.morphAttributes[key];
          const array = [];
          for (let i2 = 0, il = attributeArray.length; i2 < il; i2++) {
            const attribute = attributeArray[i2];
            array.push(attribute.toJSON(data.data));
          }
          if (array.length > 0) {
            morphAttributes[key] = array;
            hasMorphAttributes = true;
          }
        }
        if (hasMorphAttributes) {
          data.data.morphAttributes = morphAttributes;
          data.data.morphTargetsRelative = this.morphTargetsRelative;
        }
        const groups = this.groups;
        if (groups.length > 0) {
          data.data.groups = JSON.parse(JSON.stringify(groups));
        }
        const boundingSphere = this.boundingSphere;
        if (boundingSphere !== null) {
          data.data.boundingSphere = {
            center: boundingSphere.center.toArray(),
            radius: boundingSphere.radius
          };
        }
        return data;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(source) {
        this.index = null;
        this.attributes = {};
        this.morphAttributes = {};
        this.groups = [];
        this.boundingBox = null;
        this.boundingSphere = null;
        const data = {};
        this.name = source.name;
        const index = source.index;
        if (index !== null) {
          this.setIndex(index.clone(data));
        }
        const attributes = source.attributes;
        for (const name in attributes) {
          const attribute = attributes[name];
          this.setAttribute(name, attribute.clone(data));
        }
        const morphAttributes = source.morphAttributes;
        for (const name in morphAttributes) {
          const array = [];
          const morphAttribute = morphAttributes[name];
          for (let i2 = 0, l = morphAttribute.length; i2 < l; i2++) {
            array.push(morphAttribute[i2].clone(data));
          }
          this.morphAttributes[name] = array;
        }
        this.morphTargetsRelative = source.morphTargetsRelative;
        const groups = source.groups;
        for (let i2 = 0, l = groups.length; i2 < l; i2++) {
          const group = groups[i2];
          this.addGroup(group.start, group.count, group.materialIndex);
        }
        const boundingBox = source.boundingBox;
        if (boundingBox !== null) {
          this.boundingBox = boundingBox.clone();
        }
        const boundingSphere = source.boundingSphere;
        if (boundingSphere !== null) {
          this.boundingSphere = boundingSphere.clone();
        }
        this.drawRange.start = source.drawRange.start;
        this.drawRange.count = source.drawRange.count;
        this.userData = source.userData;
        if (source.parameters !== void 0)
          this.parameters = Object.assign({}, source.parameters);
        return this;
      }
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
    };
    BufferGeometry.prototype.isBufferGeometry = true;
    _inverseMatrix$2 = /* @__PURE__ */ new Matrix4();
    _ray$2 = /* @__PURE__ */ new Ray();
    _sphere$3 = /* @__PURE__ */ new Sphere();
    _vA$1 = /* @__PURE__ */ new Vector3();
    _vB$1 = /* @__PURE__ */ new Vector3();
    _vC$1 = /* @__PURE__ */ new Vector3();
    _tempA = /* @__PURE__ */ new Vector3();
    _tempB = /* @__PURE__ */ new Vector3();
    _tempC = /* @__PURE__ */ new Vector3();
    _morphA = /* @__PURE__ */ new Vector3();
    _morphB = /* @__PURE__ */ new Vector3();
    _morphC = /* @__PURE__ */ new Vector3();
    _uvA$1 = /* @__PURE__ */ new Vector2();
    _uvB$1 = /* @__PURE__ */ new Vector2();
    _uvC$1 = /* @__PURE__ */ new Vector2();
    _intersectionPoint = /* @__PURE__ */ new Vector3();
    _intersectionPointWorld = /* @__PURE__ */ new Vector3();
    Mesh = class extends Object3D {
      constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
        super();
        this.type = "Mesh";
        this.geometry = geometry;
        this.material = material;
        this.updateMorphTargets();
      }
      copy(source) {
        super.copy(source);
        if (source.morphTargetInfluences !== void 0) {
          this.morphTargetInfluences = source.morphTargetInfluences.slice();
        }
        if (source.morphTargetDictionary !== void 0) {
          this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
        }
        this.material = source.material;
        this.geometry = source.geometry;
        return this;
      }
      updateMorphTargets() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
          const morphAttributes = geometry.morphAttributes;
          const keys = Object.keys(morphAttributes);
          if (keys.length > 0) {
            const morphAttribute = morphAttributes[keys[0]];
            if (morphAttribute !== void 0) {
              this.morphTargetInfluences = [];
              this.morphTargetDictionary = {};
              for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
                const name = morphAttribute[m].name || String(m);
                this.morphTargetInfluences.push(0);
                this.morphTargetDictionary[name] = m;
              }
            }
          }
        } else {
          const morphTargets = geometry.morphTargets;
          if (morphTargets !== void 0 && morphTargets.length > 0) {
            console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
        }
      }
      raycast(raycaster, intersects2) {
        const geometry = this.geometry;
        const material = this.material;
        const matrixWorld = this.matrixWorld;
        if (material === void 0)
          return;
        if (geometry.boundingSphere === null)
          geometry.computeBoundingSphere();
        _sphere$3.copy(geometry.boundingSphere);
        _sphere$3.applyMatrix4(matrixWorld);
        if (raycaster.ray.intersectsSphere(_sphere$3) === false)
          return;
        _inverseMatrix$2.copy(matrixWorld).invert();
        _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
        if (geometry.boundingBox !== null) {
          if (_ray$2.intersectsBox(geometry.boundingBox) === false)
            return;
        }
        let intersection;
        if (geometry.isBufferGeometry) {
          const index = geometry.index;
          const position = geometry.attributes.position;
          const morphPosition = geometry.morphAttributes.position;
          const morphTargetsRelative = geometry.morphTargetsRelative;
          const uv = geometry.attributes.uv;
          const uv2 = geometry.attributes.uv2;
          const groups = geometry.groups;
          const drawRange = geometry.drawRange;
          if (index !== null) {
            if (Array.isArray(material)) {
              for (let i2 = 0, il = groups.length; i2 < il; i2++) {
                const group = groups[i2];
                const groupMaterial = material[group.materialIndex];
                const start = Math.max(group.start, drawRange.start);
                const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
                for (let j = start, jl = end; j < jl; j += 3) {
                  const a = index.getX(j);
                  const b2 = index.getX(j + 1);
                  const c = index.getX(j + 2);
                  intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b2, c);
                  if (intersection) {
                    intersection.faceIndex = Math.floor(j / 3);
                    intersection.face.materialIndex = group.materialIndex;
                    intersects2.push(intersection);
                  }
                }
              }
            } else {
              const start = Math.max(0, drawRange.start);
              const end = Math.min(index.count, drawRange.start + drawRange.count);
              for (let i2 = start, il = end; i2 < il; i2 += 3) {
                const a = index.getX(i2);
                const b2 = index.getX(i2 + 1);
                const c = index.getX(i2 + 2);
                intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b2, c);
                if (intersection) {
                  intersection.faceIndex = Math.floor(i2 / 3);
                  intersects2.push(intersection);
                }
              }
            }
          } else if (position !== void 0) {
            if (Array.isArray(material)) {
              for (let i2 = 0, il = groups.length; i2 < il; i2++) {
                const group = groups[i2];
                const groupMaterial = material[group.materialIndex];
                const start = Math.max(group.start, drawRange.start);
                const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
                for (let j = start, jl = end; j < jl; j += 3) {
                  const a = j;
                  const b2 = j + 1;
                  const c = j + 2;
                  intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b2, c);
                  if (intersection) {
                    intersection.faceIndex = Math.floor(j / 3);
                    intersection.face.materialIndex = group.materialIndex;
                    intersects2.push(intersection);
                  }
                }
              }
            } else {
              const start = Math.max(0, drawRange.start);
              const end = Math.min(position.count, drawRange.start + drawRange.count);
              for (let i2 = start, il = end; i2 < il; i2 += 3) {
                const a = i2;
                const b2 = i2 + 1;
                const c = i2 + 2;
                intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b2, c);
                if (intersection) {
                  intersection.faceIndex = Math.floor(i2 / 3);
                  intersects2.push(intersection);
                }
              }
            }
          }
        } else if (geometry.isGeometry) {
          console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
      }
    };
    Mesh.prototype.isMesh = true;
    BoxGeometry = class extends BufferGeometry {
      constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
        super();
        this.type = "BoxGeometry";
        this.parameters = {
          width,
          height,
          depth,
          widthSegments,
          heightSegments,
          depthSegments
        };
        const scope = this;
        widthSegments = Math.floor(widthSegments);
        heightSegments = Math.floor(heightSegments);
        depthSegments = Math.floor(depthSegments);
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        let numberOfVertices = 0;
        let groupStart = 0;
        buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
        buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
        buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
        buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
        buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
        buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
        this.setIndex(indices);
        this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        function buildPlane(u, v, w, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
          const segmentWidth = width2 / gridX;
          const segmentHeight = height2 / gridY;
          const widthHalf = width2 / 2;
          const heightHalf = height2 / 2;
          const depthHalf = depth2 / 2;
          const gridX1 = gridX + 1;
          const gridY1 = gridY + 1;
          let vertexCounter = 0;
          let groupCount = 0;
          const vector = new Vector3();
          for (let iy = 0; iy < gridY1; iy++) {
            const y2 = iy * segmentHeight - heightHalf;
            for (let ix = 0; ix < gridX1; ix++) {
              const x = ix * segmentWidth - widthHalf;
              vector[u] = x * udir;
              vector[v] = y2 * vdir;
              vector[w] = depthHalf;
              vertices.push(vector.x, vector.y, vector.z);
              vector[u] = 0;
              vector[v] = 0;
              vector[w] = depth2 > 0 ? 1 : -1;
              normals.push(vector.x, vector.y, vector.z);
              uvs.push(ix / gridX);
              uvs.push(1 - iy / gridY);
              vertexCounter += 1;
            }
          }
          for (let iy = 0; iy < gridY; iy++) {
            for (let ix = 0; ix < gridX; ix++) {
              const a = numberOfVertices + ix + gridX1 * iy;
              const b2 = numberOfVertices + ix + gridX1 * (iy + 1);
              const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
              const d2 = numberOfVertices + (ix + 1) + gridX1 * iy;
              indices.push(a, b2, d2);
              indices.push(b2, c, d2);
              groupCount += 6;
            }
          }
          scope.addGroup(groupStart, groupCount, materialIndex);
          groupStart += groupCount;
          numberOfVertices += vertexCounter;
        }
      }
      static fromJSON(data) {
        return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
      }
    };
    UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
    default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
    default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
    ShaderMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.type = "ShaderMaterial";
        this.defines = {};
        this.uniforms = {};
        this.vertexShader = default_vertex;
        this.fragmentShader = default_fragment;
        this.linewidth = 1;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.fog = false;
        this.lights = false;
        this.clipping = false;
        this.extensions = {
          derivatives: false,
          fragDepth: false,
          drawBuffers: false,
          shaderTextureLOD: false
        };
        this.defaultAttributeValues = {
          "color": [1, 1, 1],
          "uv": [0, 0],
          "uv2": [0, 0]
        };
        this.index0AttributeName = void 0;
        this.uniformsNeedUpdate = false;
        this.glslVersion = null;
        if (parameters !== void 0) {
          if (parameters.attributes !== void 0) {
            console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");
          }
          this.setValues(parameters);
        }
      }
      copy(source) {
        super.copy(source);
        this.fragmentShader = source.fragmentShader;
        this.vertexShader = source.vertexShader;
        this.uniforms = cloneUniforms(source.uniforms);
        this.defines = Object.assign({}, source.defines);
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.lights = source.lights;
        this.clipping = source.clipping;
        this.extensions = Object.assign({}, source.extensions);
        this.glslVersion = source.glslVersion;
        return this;
      }
      toJSON(meta) {
        const data = super.toJSON(meta);
        data.glslVersion = this.glslVersion;
        data.uniforms = {};
        for (const name in this.uniforms) {
          const uniform = this.uniforms[name];
          const value = uniform.value;
          if (value && value.isTexture) {
            data.uniforms[name] = {
              type: "t",
              value: value.toJSON(meta).uuid
            };
          } else if (value && value.isColor) {
            data.uniforms[name] = {
              type: "c",
              value: value.getHex()
            };
          } else if (value && value.isVector2) {
            data.uniforms[name] = {
              type: "v2",
              value: value.toArray()
            };
          } else if (value && value.isVector3) {
            data.uniforms[name] = {
              type: "v3",
              value: value.toArray()
            };
          } else if (value && value.isVector4) {
            data.uniforms[name] = {
              type: "v4",
              value: value.toArray()
            };
          } else if (value && value.isMatrix3) {
            data.uniforms[name] = {
              type: "m3",
              value: value.toArray()
            };
          } else if (value && value.isMatrix4) {
            data.uniforms[name] = {
              type: "m4",
              value: value.toArray()
            };
          } else {
            data.uniforms[name] = {
              value
            };
          }
        }
        if (Object.keys(this.defines).length > 0)
          data.defines = this.defines;
        data.vertexShader = this.vertexShader;
        data.fragmentShader = this.fragmentShader;
        const extensions = {};
        for (const key in this.extensions) {
          if (this.extensions[key] === true)
            extensions[key] = true;
        }
        if (Object.keys(extensions).length > 0)
          data.extensions = extensions;
        return data;
      }
    };
    ShaderMaterial.prototype.isShaderMaterial = true;
    Camera = class extends Object3D {
      constructor() {
        super();
        this.type = "Camera";
        this.matrixWorldInverse = new Matrix4();
        this.projectionMatrix = new Matrix4();
        this.projectionMatrixInverse = new Matrix4();
      }
      copy(source, recursive) {
        super.copy(source, recursive);
        this.matrixWorldInverse.copy(source.matrixWorldInverse);
        this.projectionMatrix.copy(source.projectionMatrix);
        this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
        return this;
      }
      getWorldDirection(target) {
        this.updateWorldMatrix(true, false);
        const e = this.matrixWorld.elements;
        return target.set(-e[8], -e[9], -e[10]).normalize();
      }
      updateMatrixWorld(force) {
        super.updateMatrixWorld(force);
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
      }
      updateWorldMatrix(updateParents, updateChildren) {
        super.updateWorldMatrix(updateParents, updateChildren);
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
      }
      clone() {
        return new this.constructor().copy(this);
      }
    };
    Camera.prototype.isCamera = true;
    PerspectiveCamera = class extends Camera {
      constructor(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
        super();
        this.type = "PerspectiveCamera";
        this.fov = fov2;
        this.zoom = 1;
        this.near = near;
        this.far = far;
        this.focus = 10;
        this.aspect = aspect2;
        this.view = null;
        this.filmGauge = 35;
        this.filmOffset = 0;
        this.updateProjectionMatrix();
      }
      copy(source, recursive) {
        super.copy(source, recursive);
        this.fov = source.fov;
        this.zoom = source.zoom;
        this.near = source.near;
        this.far = source.far;
        this.focus = source.focus;
        this.aspect = source.aspect;
        this.view = source.view === null ? null : Object.assign({}, source.view);
        this.filmGauge = source.filmGauge;
        this.filmOffset = source.filmOffset;
        return this;
      }
      setFocalLength(focalLength) {
        const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
        this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
        this.updateProjectionMatrix();
      }
      getFocalLength() {
        const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
        return 0.5 * this.getFilmHeight() / vExtentSlope;
      }
      getEffectiveFOV() {
        return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);
      }
      getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1);
      }
      getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1);
      }
      setViewOffset(fullWidth, fullHeight, x, y2, width, height) {
        this.aspect = fullWidth / fullHeight;
        if (this.view === null) {
          this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
          };
        }
        this.view.enabled = true;
        this.view.fullWidth = fullWidth;
        this.view.fullHeight = fullHeight;
        this.view.offsetX = x;
        this.view.offsetY = y2;
        this.view.width = width;
        this.view.height = height;
        this.updateProjectionMatrix();
      }
      clearViewOffset() {
        if (this.view !== null) {
          this.view.enabled = false;
        }
        this.updateProjectionMatrix();
      }
      updateProjectionMatrix() {
        const near = this.near;
        let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
        let height = 2 * top;
        let width = this.aspect * height;
        let left = -0.5 * width;
        const view = this.view;
        if (this.view !== null && this.view.enabled) {
          const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
          left += view.offsetX * width / fullWidth;
          top -= view.offsetY * height / fullHeight;
          width *= view.width / fullWidth;
          height *= view.height / fullHeight;
        }
        const skew = this.filmOffset;
        if (skew !== 0)
          left += near * skew / this.getFilmWidth();
        this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
      }
      toJSON(meta) {
        const data = super.toJSON(meta);
        data.object.fov = this.fov;
        data.object.zoom = this.zoom;
        data.object.near = this.near;
        data.object.far = this.far;
        data.object.focus = this.focus;
        data.object.aspect = this.aspect;
        if (this.view !== null)
          data.object.view = Object.assign({}, this.view);
        data.object.filmGauge = this.filmGauge;
        data.object.filmOffset = this.filmOffset;
        return data;
      }
    };
    PerspectiveCamera.prototype.isPerspectiveCamera = true;
    fov = 90;
    aspect = 1;
    CubeCamera = class extends Object3D {
      constructor(near, far, renderTarget) {
        super();
        this.type = "CubeCamera";
        if (renderTarget.isWebGLCubeRenderTarget !== true) {
          console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
          return;
        }
        this.renderTarget = renderTarget;
        const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
        cameraPX.layers = this.layers;
        cameraPX.up.set(0, -1, 0);
        cameraPX.lookAt(new Vector3(1, 0, 0));
        this.add(cameraPX);
        const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
        cameraNX.layers = this.layers;
        cameraNX.up.set(0, -1, 0);
        cameraNX.lookAt(new Vector3(-1, 0, 0));
        this.add(cameraNX);
        const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
        cameraPY.layers = this.layers;
        cameraPY.up.set(0, 0, 1);
        cameraPY.lookAt(new Vector3(0, 1, 0));
        this.add(cameraPY);
        const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
        cameraNY.layers = this.layers;
        cameraNY.up.set(0, 0, -1);
        cameraNY.lookAt(new Vector3(0, -1, 0));
        this.add(cameraNY);
        const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
        cameraPZ.layers = this.layers;
        cameraPZ.up.set(0, -1, 0);
        cameraPZ.lookAt(new Vector3(0, 0, 1));
        this.add(cameraPZ);
        const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
        cameraNZ.layers = this.layers;
        cameraNZ.up.set(0, -1, 0);
        cameraNZ.lookAt(new Vector3(0, 0, -1));
        this.add(cameraNZ);
      }
      update(renderer, scene) {
        if (this.parent === null)
          this.updateMatrixWorld();
        const renderTarget = this.renderTarget;
        const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
        const currentRenderTarget = renderer.getRenderTarget();
        const currentOutputEncoding = renderer.outputEncoding;
        const currentToneMapping = renderer.toneMapping;
        const currentXrEnabled = renderer.xr.enabled;
        renderer.outputEncoding = LinearEncoding;
        renderer.toneMapping = NoToneMapping;
        renderer.xr.enabled = false;
        const generateMipmaps = renderTarget.texture.generateMipmaps;
        renderTarget.texture.generateMipmaps = false;
        renderer.setRenderTarget(renderTarget, 0);
        renderer.render(scene, cameraPX);
        renderer.setRenderTarget(renderTarget, 1);
        renderer.render(scene, cameraNX);
        renderer.setRenderTarget(renderTarget, 2);
        renderer.render(scene, cameraPY);
        renderer.setRenderTarget(renderTarget, 3);
        renderer.render(scene, cameraNY);
        renderer.setRenderTarget(renderTarget, 4);
        renderer.render(scene, cameraPZ);
        renderTarget.texture.generateMipmaps = generateMipmaps;
        renderer.setRenderTarget(renderTarget, 5);
        renderer.render(scene, cameraNZ);
        renderer.setRenderTarget(currentRenderTarget);
        renderer.outputEncoding = currentOutputEncoding;
        renderer.toneMapping = currentToneMapping;
        renderer.xr.enabled = currentXrEnabled;
        renderTarget.texture.needsPMREMUpdate = true;
      }
    };
    CubeTexture = class extends Texture {
      constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
        images = images !== void 0 ? images : [];
        mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
        super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
        this.flipY = false;
      }
      get images() {
        return this.image;
      }
      set images(value) {
        this.image = value;
      }
    };
    CubeTexture.prototype.isCubeTexture = true;
    WebGLCubeRenderTarget = class extends WebGLRenderTarget {
      constructor(size, options = {}) {
        super(size, size, options);
        const image = { width: size, height: size, depth: 1 };
        const images = [image, image, image, image, image, image];
        this.texture = new CubeTexture(images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
        this.texture.isRenderTargetTexture = true;
        this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
        this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
      }
      fromEquirectangularTexture(renderer, texture) {
        this.texture.type = texture.type;
        this.texture.encoding = texture.encoding;
        this.texture.generateMipmaps = texture.generateMipmaps;
        this.texture.minFilter = texture.minFilter;
        this.texture.magFilter = texture.magFilter;
        const shader = {
          uniforms: {
            tEquirect: { value: null }
          },
          vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
          fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
        };
        const geometry = new BoxGeometry(5, 5, 5);
        const material = new ShaderMaterial({
          name: "CubemapFromEquirect",
          uniforms: cloneUniforms(shader.uniforms),
          vertexShader: shader.vertexShader,
          fragmentShader: shader.fragmentShader,
          side: BackSide,
          blending: NoBlending
        });
        material.uniforms.tEquirect.value = texture;
        const mesh = new Mesh(geometry, material);
        const currentMinFilter = texture.minFilter;
        if (texture.minFilter === LinearMipmapLinearFilter)
          texture.minFilter = LinearFilter;
        const camera = new CubeCamera(1, 10, this);
        camera.update(renderer, mesh);
        texture.minFilter = currentMinFilter;
        mesh.geometry.dispose();
        mesh.material.dispose();
        return this;
      }
      clear(renderer, color, depth, stencil) {
        const currentRenderTarget = renderer.getRenderTarget();
        for (let i2 = 0; i2 < 6; i2++) {
          renderer.setRenderTarget(this, i2);
          renderer.clear(color, depth, stencil);
        }
        renderer.setRenderTarget(currentRenderTarget);
      }
    };
    WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;
    _vector1 = /* @__PURE__ */ new Vector3();
    _vector2 = /* @__PURE__ */ new Vector3();
    _normalMatrix = /* @__PURE__ */ new Matrix3();
    Plane = class {
      constructor(normal2 = new Vector3(1, 0, 0), constant = 0) {
        this.normal = normal2;
        this.constant = constant;
      }
      set(normal2, constant) {
        this.normal.copy(normal2);
        this.constant = constant;
        return this;
      }
      setComponents(x, y2, z, w) {
        this.normal.set(x, y2, z);
        this.constant = w;
        return this;
      }
      setFromNormalAndCoplanarPoint(normal2, point) {
        this.normal.copy(normal2);
        this.constant = -point.dot(this.normal);
        return this;
      }
      setFromCoplanarPoints(a, b2, c) {
        const normal2 = _vector1.subVectors(c, b2).cross(_vector2.subVectors(a, b2)).normalize();
        this.setFromNormalAndCoplanarPoint(normal2, a);
        return this;
      }
      copy(plane) {
        this.normal.copy(plane.normal);
        this.constant = plane.constant;
        return this;
      }
      normalize() {
        const inverseNormalLength = 1 / this.normal.length();
        this.normal.multiplyScalar(inverseNormalLength);
        this.constant *= inverseNormalLength;
        return this;
      }
      negate() {
        this.constant *= -1;
        this.normal.negate();
        return this;
      }
      distanceToPoint(point) {
        return this.normal.dot(point) + this.constant;
      }
      distanceToSphere(sphere) {
        return this.distanceToPoint(sphere.center) - sphere.radius;
      }
      projectPoint(point, target) {
        return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
      }
      intersectLine(line, target) {
        const direction = line.delta(_vector1);
        const denominator = this.normal.dot(direction);
        if (denominator === 0) {
          if (this.distanceToPoint(line.start) === 0) {
            return target.copy(line.start);
          }
          return null;
        }
        const t2 = -(line.start.dot(this.normal) + this.constant) / denominator;
        if (t2 < 0 || t2 > 1) {
          return null;
        }
        return target.copy(direction).multiplyScalar(t2).add(line.start);
      }
      intersectsLine(line) {
        const startSign = this.distanceToPoint(line.start);
        const endSign = this.distanceToPoint(line.end);
        return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
      }
      intersectsBox(box) {
        return box.intersectsPlane(this);
      }
      intersectsSphere(sphere) {
        return sphere.intersectsPlane(this);
      }
      coplanarPoint(target) {
        return target.copy(this.normal).multiplyScalar(-this.constant);
      }
      applyMatrix4(matrix, optionalNormalMatrix) {
        const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
        const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
        const normal2 = this.normal.applyMatrix3(normalMatrix).normalize();
        this.constant = -referencePoint.dot(normal2);
        return this;
      }
      translate(offset) {
        this.constant -= offset.dot(this.normal);
        return this;
      }
      equals(plane) {
        return plane.normal.equals(this.normal) && plane.constant === this.constant;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    };
    Plane.prototype.isPlane = true;
    _sphere$2 = /* @__PURE__ */ new Sphere();
    _vector$7 = /* @__PURE__ */ new Vector3();
    Frustum = class {
      constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
        this.planes = [p0, p1, p2, p3, p4, p5];
      }
      set(p0, p1, p2, p3, p4, p5) {
        const planes = this.planes;
        planes[0].copy(p0);
        planes[1].copy(p1);
        planes[2].copy(p2);
        planes[3].copy(p3);
        planes[4].copy(p4);
        planes[5].copy(p5);
        return this;
      }
      copy(frustum) {
        const planes = this.planes;
        for (let i2 = 0; i2 < 6; i2++) {
          planes[i2].copy(frustum.planes[i2]);
        }
        return this;
      }
      setFromProjectionMatrix(m) {
        const planes = this.planes;
        const me = m.elements;
        const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
        const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
        const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
        const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
        planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
        planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
        planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
        planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
        planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
        planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
        return this;
      }
      intersectsObject(object) {
        const geometry = object.geometry;
        if (geometry.boundingSphere === null)
          geometry.computeBoundingSphere();
        _sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
        return this.intersectsSphere(_sphere$2);
      }
      intersectsSprite(sprite) {
        _sphere$2.center.set(0, 0, 0);
        _sphere$2.radius = 0.7071067811865476;
        _sphere$2.applyMatrix4(sprite.matrixWorld);
        return this.intersectsSphere(_sphere$2);
      }
      intersectsSphere(sphere) {
        const planes = this.planes;
        const center = sphere.center;
        const negRadius = -sphere.radius;
        for (let i2 = 0; i2 < 6; i2++) {
          const distance = planes[i2].distanceToPoint(center);
          if (distance < negRadius) {
            return false;
          }
        }
        return true;
      }
      intersectsBox(box) {
        const planes = this.planes;
        for (let i2 = 0; i2 < 6; i2++) {
          const plane = planes[i2];
          _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
          _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
          _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
          if (plane.distanceToPoint(_vector$7) < 0) {
            return false;
          }
        }
        return true;
      }
      containsPoint(point) {
        const planes = this.planes;
        for (let i2 = 0; i2 < 6; i2++) {
          if (planes[i2].distanceToPoint(point) < 0) {
            return false;
          }
        }
        return true;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    };
    PlaneGeometry = class extends BufferGeometry {
      constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
        super();
        this.type = "PlaneGeometry";
        this.parameters = {
          width,
          height,
          widthSegments,
          heightSegments
        };
        const width_half = width / 2;
        const height_half = height / 2;
        const gridX = Math.floor(widthSegments);
        const gridY = Math.floor(heightSegments);
        const gridX1 = gridX + 1;
        const gridY1 = gridY + 1;
        const segment_width = width / gridX;
        const segment_height = height / gridY;
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        for (let iy = 0; iy < gridY1; iy++) {
          const y2 = iy * segment_height - height_half;
          for (let ix = 0; ix < gridX1; ix++) {
            const x = ix * segment_width - width_half;
            vertices.push(x, -y2, 0);
            normals.push(0, 0, 1);
            uvs.push(ix / gridX);
            uvs.push(1 - iy / gridY);
          }
        }
        for (let iy = 0; iy < gridY; iy++) {
          for (let ix = 0; ix < gridX; ix++) {
            const a = ix + gridX1 * iy;
            const b2 = ix + gridX1 * (iy + 1);
            const c = ix + 1 + gridX1 * (iy + 1);
            const d2 = ix + 1 + gridX1 * iy;
            indices.push(a, b2, d2);
            indices.push(b2, c, d2);
          }
        }
        this.setIndex(indices);
        this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
      }
      static fromJSON(data) {
        return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
      }
    };
    alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
    alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
    alphatest_fragment = "#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif";
    alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif";
    aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif";
    aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
    begin_vertex = "vec3 transformed = vec3( position );";
    beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
    bsdfs = "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif";
    bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
    clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif";
    clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
    clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
    clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
    color_fragment = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif";
    color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif";
    color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif";
    color_vertex = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif";
    common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}";
    cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
    defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
    displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
    displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
    emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
    emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
    encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
    encodings_pars_fragment = "vec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";
    envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
    envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
    envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
    envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
    envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
    fog_vertex = "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif";
    fog_pars_vertex = "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif";
    fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
    fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
    gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}";
    lightmap_fragment = "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";
    lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
    lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointLightInfo( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotLightInfo( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif";
    lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#else\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif";
    envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n#endif";
    lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
    lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)";
    lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
    lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)";
    lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	#ifdef SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULARINTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n		#endif\n		#ifdef USE_SPECULARCOLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEENCOLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEENROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n	#endif\n#endif";
    lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
    lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
    lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometry.normal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif";
    lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
    logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
    logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
    logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif";
    logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif";
    map_fragment = "#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif";
    map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
    map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
    map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
    metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
    metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
    morphcolor_vertex = "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif";
    morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif";
    morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform ivec2 morphTargetsTextureSize;\n		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n			int y = texelIndex / morphTargetsTextureSize.x;\n			int x = texelIndex - y * morphTargetsTextureSize.x;\n			ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n			return texelFetch( morphTargetsTexture, morphUV, 0 );\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif";
    morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif";
    normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;";
    normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
    normal_pars_fragment = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
    normal_pars_vertex = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
    normal_vertex = "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif";
    normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif";
    clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif";
    clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif";
    clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif";
    output_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
    packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
    premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
    project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
    dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
    dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
    roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
    roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
    shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif";
    shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
    shadowmap_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif";
    shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
    skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
    skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform highp sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif";
    skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
    skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
    specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
    specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
    tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
    tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
    transmission_fragment = "#ifdef USE_TRANSMISSION\n	float transmissionAlpha = 1.0;\n	float transmissionFactor = transmission;\n	float thicknessFactor = thickness;\n	#ifdef USE_TRANSMISSIONMAP\n		transmissionFactor *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		thicknessFactor *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmission = getIBLVolumeRefraction(\n		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n		attenuationColor, attenuationDistance );\n	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif";
    transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		#ifdef texture2DLodEXT\n			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#else\n			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#endif\n	}\n	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( attenuationDistance == 0.0 ) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n	}\n#endif";
    uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif";
    uv_pars_vertex = "#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif";
    uv_vertex = "#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
    uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
    uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif";
    uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
    worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
    vertex$g = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
    fragment$g = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	gl_FragColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n	#endif\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
    vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
    fragment$f = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
    vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
    fragment$e = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}";
    vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
    fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
    vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
    fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
    vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
    fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
    vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
    fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
    vertex$9 = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
    fragment$9 = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
    vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
    fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
    vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
    fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}";
    vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
    fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
    vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}";
    fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULARINTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n	#ifdef USE_SPECULARCOLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEENCOLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEENROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n	#endif\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
    vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
    fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
    vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
    fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
    vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
    fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
    vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
    fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
    ShaderChunk = {
      alphamap_fragment,
      alphamap_pars_fragment,
      alphatest_fragment,
      alphatest_pars_fragment,
      aomap_fragment,
      aomap_pars_fragment,
      begin_vertex,
      beginnormal_vertex,
      bsdfs,
      bumpmap_pars_fragment,
      clipping_planes_fragment,
      clipping_planes_pars_fragment,
      clipping_planes_pars_vertex,
      clipping_planes_vertex,
      color_fragment,
      color_pars_fragment,
      color_pars_vertex,
      color_vertex,
      common,
      cube_uv_reflection_fragment,
      defaultnormal_vertex,
      displacementmap_pars_vertex,
      displacementmap_vertex,
      emissivemap_fragment,
      emissivemap_pars_fragment,
      encodings_fragment,
      encodings_pars_fragment,
      envmap_fragment,
      envmap_common_pars_fragment,
      envmap_pars_fragment,
      envmap_pars_vertex,
      envmap_physical_pars_fragment,
      envmap_vertex,
      fog_vertex,
      fog_pars_vertex,
      fog_fragment,
      fog_pars_fragment,
      gradientmap_pars_fragment,
      lightmap_fragment,
      lightmap_pars_fragment,
      lights_lambert_vertex,
      lights_pars_begin,
      lights_toon_fragment,
      lights_toon_pars_fragment,
      lights_phong_fragment,
      lights_phong_pars_fragment,
      lights_physical_fragment,
      lights_physical_pars_fragment,
      lights_fragment_begin,
      lights_fragment_maps,
      lights_fragment_end,
      logdepthbuf_fragment,
      logdepthbuf_pars_fragment,
      logdepthbuf_pars_vertex,
      logdepthbuf_vertex,
      map_fragment,
      map_pars_fragment,
      map_particle_fragment,
      map_particle_pars_fragment,
      metalnessmap_fragment,
      metalnessmap_pars_fragment,
      morphcolor_vertex,
      morphnormal_vertex,
      morphtarget_pars_vertex,
      morphtarget_vertex,
      normal_fragment_begin,
      normal_fragment_maps,
      normal_pars_fragment,
      normal_pars_vertex,
      normal_vertex,
      normalmap_pars_fragment,
      clearcoat_normal_fragment_begin,
      clearcoat_normal_fragment_maps,
      clearcoat_pars_fragment,
      output_fragment,
      packing,
      premultiplied_alpha_fragment,
      project_vertex,
      dithering_fragment,
      dithering_pars_fragment,
      roughnessmap_fragment,
      roughnessmap_pars_fragment,
      shadowmap_pars_fragment,
      shadowmap_pars_vertex,
      shadowmap_vertex,
      shadowmask_pars_fragment,
      skinbase_vertex,
      skinning_pars_vertex,
      skinning_vertex,
      skinnormal_vertex,
      specularmap_fragment,
      specularmap_pars_fragment,
      tonemapping_fragment,
      tonemapping_pars_fragment,
      transmission_fragment,
      transmission_pars_fragment,
      uv_pars_fragment,
      uv_pars_vertex,
      uv_vertex,
      uv2_pars_fragment,
      uv2_pars_vertex,
      uv2_vertex,
      worldpos_vertex,
      background_vert: vertex$g,
      background_frag: fragment$g,
      cube_vert: vertex$f,
      cube_frag: fragment$f,
      depth_vert: vertex$e,
      depth_frag: fragment$e,
      distanceRGBA_vert: vertex$d,
      distanceRGBA_frag: fragment$d,
      equirect_vert: vertex$c,
      equirect_frag: fragment$c,
      linedashed_vert: vertex$b,
      linedashed_frag: fragment$b,
      meshbasic_vert: vertex$a,
      meshbasic_frag: fragment$a,
      meshlambert_vert: vertex$9,
      meshlambert_frag: fragment$9,
      meshmatcap_vert: vertex$8,
      meshmatcap_frag: fragment$8,
      meshnormal_vert: vertex$7,
      meshnormal_frag: fragment$7,
      meshphong_vert: vertex$6,
      meshphong_frag: fragment$6,
      meshphysical_vert: vertex$5,
      meshphysical_frag: fragment$5,
      meshtoon_vert: vertex$4,
      meshtoon_frag: fragment$4,
      points_vert: vertex$3,
      points_frag: fragment$3,
      shadow_vert: vertex$2,
      shadow_frag: fragment$2,
      sprite_vert: vertex$1,
      sprite_frag: fragment$1
    };
    UniformsLib = {
      common: {
        diffuse: { value: new Color(16777215) },
        opacity: { value: 1 },
        map: { value: null },
        uvTransform: { value: new Matrix3() },
        uv2Transform: { value: new Matrix3() },
        alphaMap: { value: null },
        alphaTest: { value: 0 }
      },
      specularmap: {
        specularMap: { value: null }
      },
      envmap: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        reflectivity: { value: 1 },
        ior: { value: 1.5 },
        refractionRatio: { value: 0.98 }
      },
      aomap: {
        aoMap: { value: null },
        aoMapIntensity: { value: 1 }
      },
      lightmap: {
        lightMap: { value: null },
        lightMapIntensity: { value: 1 }
      },
      emissivemap: {
        emissiveMap: { value: null }
      },
      bumpmap: {
        bumpMap: { value: null },
        bumpScale: { value: 1 }
      },
      normalmap: {
        normalMap: { value: null },
        normalScale: { value: new Vector2(1, 1) }
      },
      displacementmap: {
        displacementMap: { value: null },
        displacementScale: { value: 1 },
        displacementBias: { value: 0 }
      },
      roughnessmap: {
        roughnessMap: { value: null }
      },
      metalnessmap: {
        metalnessMap: { value: null }
      },
      gradientmap: {
        gradientMap: { value: null }
      },
      fog: {
        fogDensity: { value: 25e-5 },
        fogNear: { value: 1 },
        fogFar: { value: 2e3 },
        fogColor: { value: new Color(16777215) }
      },
      lights: {
        ambientLightColor: { value: [] },
        lightProbe: { value: [] },
        directionalLights: { value: [], properties: {
          direction: {},
          color: {}
        } },
        directionalLightShadows: { value: [], properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {}
        } },
        directionalShadowMap: { value: [] },
        directionalShadowMatrix: { value: [] },
        spotLights: { value: [], properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {}
        } },
        spotLightShadows: { value: [], properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {}
        } },
        spotShadowMap: { value: [] },
        spotShadowMatrix: { value: [] },
        pointLights: { value: [], properties: {
          color: {},
          position: {},
          decay: {},
          distance: {}
        } },
        pointLightShadows: { value: [], properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {}
        } },
        pointShadowMap: { value: [] },
        pointShadowMatrix: { value: [] },
        hemisphereLights: { value: [], properties: {
          direction: {},
          skyColor: {},
          groundColor: {}
        } },
        rectAreaLights: { value: [], properties: {
          color: {},
          position: {},
          width: {},
          height: {}
        } },
        ltc_1: { value: null },
        ltc_2: { value: null }
      },
      points: {
        diffuse: { value: new Color(16777215) },
        opacity: { value: 1 },
        size: { value: 1 },
        scale: { value: 1 },
        map: { value: null },
        alphaMap: { value: null },
        alphaTest: { value: 0 },
        uvTransform: { value: new Matrix3() }
      },
      sprite: {
        diffuse: { value: new Color(16777215) },
        opacity: { value: 1 },
        center: { value: new Vector2(0.5, 0.5) },
        rotation: { value: 0 },
        map: { value: null },
        alphaMap: { value: null },
        alphaTest: { value: 0 },
        uvTransform: { value: new Matrix3() }
      }
    };
    ShaderLib = {
      basic: {
        uniforms: mergeUniforms([
          UniformsLib.common,
          UniformsLib.specularmap,
          UniformsLib.envmap,
          UniformsLib.aomap,
          UniformsLib.lightmap,
          UniformsLib.fog
        ]),
        vertexShader: ShaderChunk.meshbasic_vert,
        fragmentShader: ShaderChunk.meshbasic_frag
      },
      lambert: {
        uniforms: mergeUniforms([
          UniformsLib.common,
          UniformsLib.specularmap,
          UniformsLib.envmap,
          UniformsLib.aomap,
          UniformsLib.lightmap,
          UniformsLib.emissivemap,
          UniformsLib.fog,
          UniformsLib.lights,
          {
            emissive: { value: new Color(0) }
          }
        ]),
        vertexShader: ShaderChunk.meshlambert_vert,
        fragmentShader: ShaderChunk.meshlambert_frag
      },
      phong: {
        uniforms: mergeUniforms([
          UniformsLib.common,
          UniformsLib.specularmap,
          UniformsLib.envmap,
          UniformsLib.aomap,
          UniformsLib.lightmap,
          UniformsLib.emissivemap,
          UniformsLib.bumpmap,
          UniformsLib.normalmap,
          UniformsLib.displacementmap,
          UniformsLib.fog,
          UniformsLib.lights,
          {
            emissive: { value: new Color(0) },
            specular: { value: new Color(1118481) },
            shininess: { value: 30 }
          }
        ]),
        vertexShader: ShaderChunk.meshphong_vert,
        fragmentShader: ShaderChunk.meshphong_frag
      },
      standard: {
        uniforms: mergeUniforms([
          UniformsLib.common,
          UniformsLib.envmap,
          UniformsLib.aomap,
          UniformsLib.lightmap,
          UniformsLib.emissivemap,
          UniformsLib.bumpmap,
          UniformsLib.normalmap,
          UniformsLib.displacementmap,
          UniformsLib.roughnessmap,
          UniformsLib.metalnessmap,
          UniformsLib.fog,
          UniformsLib.lights,
          {
            emissive: { value: new Color(0) },
            roughness: { value: 1 },
            metalness: { value: 0 },
            envMapIntensity: { value: 1 }
          }
        ]),
        vertexShader: ShaderChunk.meshphysical_vert,
        fragmentShader: ShaderChunk.meshphysical_frag
      },
      toon: {
        uniforms: mergeUniforms([
          UniformsLib.common,
          UniformsLib.aomap,
          UniformsLib.lightmap,
          UniformsLib.emissivemap,
          UniformsLib.bumpmap,
          UniformsLib.normalmap,
          UniformsLib.displacementmap,
          UniformsLib.gradientmap,
          UniformsLib.fog,
          UniformsLib.lights,
          {
            emissive: { value: new Color(0) }
          }
        ]),
        vertexShader: ShaderChunk.meshtoon_vert,
        fragmentShader: ShaderChunk.meshtoon_frag
      },
      matcap: {
        uniforms: mergeUniforms([
          UniformsLib.common,
          UniformsLib.bumpmap,
          UniformsLib.normalmap,
          UniformsLib.displacementmap,
          UniformsLib.fog,
          {
            matcap: { value: null }
          }
        ]),
        vertexShader: ShaderChunk.meshmatcap_vert,
        fragmentShader: ShaderChunk.meshmatcap_frag
      },
      points: {
        uniforms: mergeUniforms([
          UniformsLib.points,
          UniformsLib.fog
        ]),
        vertexShader: ShaderChunk.points_vert,
        fragmentShader: ShaderChunk.points_frag
      },
      dashed: {
        uniforms: mergeUniforms([
          UniformsLib.common,
          UniformsLib.fog,
          {
            scale: { value: 1 },
            dashSize: { value: 1 },
            totalSize: { value: 2 }
          }
        ]),
        vertexShader: ShaderChunk.linedashed_vert,
        fragmentShader: ShaderChunk.linedashed_frag
      },
      depth: {
        uniforms: mergeUniforms([
          UniformsLib.common,
          UniformsLib.displacementmap
        ]),
        vertexShader: ShaderChunk.depth_vert,
        fragmentShader: ShaderChunk.depth_frag
      },
      normal: {
        uniforms: mergeUniforms([
          UniformsLib.common,
          UniformsLib.bumpmap,
          UniformsLib.normalmap,
          UniformsLib.displacementmap,
          {
            opacity: { value: 1 }
          }
        ]),
        vertexShader: ShaderChunk.meshnormal_vert,
        fragmentShader: ShaderChunk.meshnormal_frag
      },
      sprite: {
        uniforms: mergeUniforms([
          UniformsLib.sprite,
          UniformsLib.fog
        ]),
        vertexShader: ShaderChunk.sprite_vert,
        fragmentShader: ShaderChunk.sprite_frag
      },
      background: {
        uniforms: {
          uvTransform: { value: new Matrix3() },
          t2D: { value: null }
        },
        vertexShader: ShaderChunk.background_vert,
        fragmentShader: ShaderChunk.background_frag
      },
      cube: {
        uniforms: mergeUniforms([
          UniformsLib.envmap,
          {
            opacity: { value: 1 }
          }
        ]),
        vertexShader: ShaderChunk.cube_vert,
        fragmentShader: ShaderChunk.cube_frag
      },
      equirect: {
        uniforms: {
          tEquirect: { value: null }
        },
        vertexShader: ShaderChunk.equirect_vert,
        fragmentShader: ShaderChunk.equirect_frag
      },
      distanceRGBA: {
        uniforms: mergeUniforms([
          UniformsLib.common,
          UniformsLib.displacementmap,
          {
            referencePosition: { value: new Vector3() },
            nearDistance: { value: 1 },
            farDistance: { value: 1e3 }
          }
        ]),
        vertexShader: ShaderChunk.distanceRGBA_vert,
        fragmentShader: ShaderChunk.distanceRGBA_frag
      },
      shadow: {
        uniforms: mergeUniforms([
          UniformsLib.lights,
          UniformsLib.fog,
          {
            color: { value: new Color(0) },
            opacity: { value: 1 }
          }
        ]),
        vertexShader: ShaderChunk.shadow_vert,
        fragmentShader: ShaderChunk.shadow_frag
      }
    };
    ShaderLib.physical = {
      uniforms: mergeUniforms([
        ShaderLib.standard.uniforms,
        {
          clearcoat: { value: 0 },
          clearcoatMap: { value: null },
          clearcoatRoughness: { value: 0 },
          clearcoatRoughnessMap: { value: null },
          clearcoatNormalScale: { value: new Vector2(1, 1) },
          clearcoatNormalMap: { value: null },
          sheen: { value: 0 },
          sheenColor: { value: new Color(0) },
          sheenColorMap: { value: null },
          sheenRoughness: { value: 1 },
          sheenRoughnessMap: { value: null },
          transmission: { value: 0 },
          transmissionMap: { value: null },
          transmissionSamplerSize: { value: new Vector2() },
          transmissionSamplerMap: { value: null },
          thickness: { value: 0 },
          thicknessMap: { value: null },
          attenuationDistance: { value: 0 },
          attenuationColor: { value: new Color(0) },
          specularIntensity: { value: 1 },
          specularIntensityMap: { value: null },
          specularColor: { value: new Color(1, 1, 1) },
          specularColorMap: { value: null }
        }
      ]),
      vertexShader: ShaderChunk.meshphysical_vert,
      fragmentShader: ShaderChunk.meshphysical_frag
    };
    OrthographicCamera = class extends Camera {
      constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
        super();
        this.type = "OrthographicCamera";
        this.zoom = 1;
        this.view = null;
        this.left = left;
        this.right = right;
        this.top = top;
        this.bottom = bottom;
        this.near = near;
        this.far = far;
        this.updateProjectionMatrix();
      }
      copy(source, recursive) {
        super.copy(source, recursive);
        this.left = source.left;
        this.right = source.right;
        this.top = source.top;
        this.bottom = source.bottom;
        this.near = source.near;
        this.far = source.far;
        this.zoom = source.zoom;
        this.view = source.view === null ? null : Object.assign({}, source.view);
        return this;
      }
      setViewOffset(fullWidth, fullHeight, x, y2, width, height) {
        if (this.view === null) {
          this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
          };
        }
        this.view.enabled = true;
        this.view.fullWidth = fullWidth;
        this.view.fullHeight = fullHeight;
        this.view.offsetX = x;
        this.view.offsetY = y2;
        this.view.width = width;
        this.view.height = height;
        this.updateProjectionMatrix();
      }
      clearViewOffset() {
        if (this.view !== null) {
          this.view.enabled = false;
        }
        this.updateProjectionMatrix();
      }
      updateProjectionMatrix() {
        const dx = (this.right - this.left) / (2 * this.zoom);
        const dy = (this.top - this.bottom) / (2 * this.zoom);
        const cx = (this.right + this.left) / 2;
        const cy = (this.top + this.bottom) / 2;
        let left = cx - dx;
        let right = cx + dx;
        let top = cy + dy;
        let bottom = cy - dy;
        if (this.view !== null && this.view.enabled) {
          const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
          const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
          left += scaleW * this.view.offsetX;
          right = left + scaleW * this.view.width;
          top -= scaleH * this.view.offsetY;
          bottom = top - scaleH * this.view.height;
        }
        this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
      }
      toJSON(meta) {
        const data = super.toJSON(meta);
        data.object.zoom = this.zoom;
        data.object.left = this.left;
        data.object.right = this.right;
        data.object.top = this.top;
        data.object.bottom = this.bottom;
        data.object.near = this.near;
        data.object.far = this.far;
        if (this.view !== null)
          data.object.view = Object.assign({}, this.view);
        return data;
      }
    };
    OrthographicCamera.prototype.isOrthographicCamera = true;
    LOD_MIN = 4;
    EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
    MAX_SAMPLES = 20;
    _flatCamera = /* @__PURE__ */ new OrthographicCamera();
    _clearColor = /* @__PURE__ */ new Color();
    _oldTarget = null;
    PHI = (1 + Math.sqrt(5)) / 2;
    INV_PHI = 1 / PHI;
    _axisDirections = [
      /* @__PURE__ */ new Vector3(1, 1, 1),
      /* @__PURE__ */ new Vector3(-1, 1, 1),
      /* @__PURE__ */ new Vector3(1, 1, -1),
      /* @__PURE__ */ new Vector3(-1, 1, -1),
      /* @__PURE__ */ new Vector3(0, PHI, INV_PHI),
      /* @__PURE__ */ new Vector3(0, PHI, -INV_PHI),
      /* @__PURE__ */ new Vector3(INV_PHI, 0, PHI),
      /* @__PURE__ */ new Vector3(-INV_PHI, 0, PHI),
      /* @__PURE__ */ new Vector3(PHI, INV_PHI, 0),
      /* @__PURE__ */ new Vector3(-PHI, INV_PHI, 0)
    ];
    PMREMGenerator = class {
      constructor(renderer) {
        this._renderer = renderer;
        this._pingPongRenderTarget = null;
        this._lodMax = 0;
        this._cubeSize = 0;
        this._lodPlanes = [];
        this._sizeLods = [];
        this._sigmas = [];
        this._blurMaterial = null;
        this._cubemapMaterial = null;
        this._equirectMaterial = null;
        this._compileMaterial(this._blurMaterial);
      }
      fromScene(scene, sigma = 0, near = 0.1, far = 100) {
        _oldTarget = this._renderer.getRenderTarget();
        this._setSize(256);
        const cubeUVRenderTarget = this._allocateTargets();
        cubeUVRenderTarget.depthBuffer = true;
        this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
        if (sigma > 0) {
          this._blur(cubeUVRenderTarget, 0, 0, sigma);
        }
        this._applyPMREM(cubeUVRenderTarget);
        this._cleanup(cubeUVRenderTarget);
        return cubeUVRenderTarget;
      }
      fromEquirectangular(equirectangular, renderTarget = null) {
        return this._fromTexture(equirectangular, renderTarget);
      }
      fromCubemap(cubemap, renderTarget = null) {
        return this._fromTexture(cubemap, renderTarget);
      }
      compileCubemapShader() {
        if (this._cubemapMaterial === null) {
          this._cubemapMaterial = _getCubemapMaterial();
          this._compileMaterial(this._cubemapMaterial);
        }
      }
      compileEquirectangularShader() {
        if (this._equirectMaterial === null) {
          this._equirectMaterial = _getEquirectMaterial();
          this._compileMaterial(this._equirectMaterial);
        }
      }
      dispose() {
        this._dispose();
        if (this._cubemapMaterial !== null)
          this._cubemapMaterial.dispose();
        if (this._equirectMaterial !== null)
          this._equirectMaterial.dispose();
      }
      _setSize(cubeSize) {
        this._lodMax = Math.floor(Math.log2(cubeSize));
        this._cubeSize = Math.pow(2, this._lodMax);
      }
      _dispose() {
        if (this._blurMaterial !== null)
          this._blurMaterial.dispose();
        if (this._pingPongRenderTarget !== null)
          this._pingPongRenderTarget.dispose();
        for (let i2 = 0; i2 < this._lodPlanes.length; i2++) {
          this._lodPlanes[i2].dispose();
        }
      }
      _cleanup(outputTarget) {
        this._renderer.setRenderTarget(_oldTarget);
        outputTarget.scissorTest = false;
        _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
      }
      _fromTexture(texture, renderTarget) {
        if (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping) {
          this._setSize(texture.image.length === 0 ? 16 : texture.image[0].width || texture.image[0].image.width);
        } else {
          this._setSize(texture.image.width / 4);
        }
        _oldTarget = this._renderer.getRenderTarget();
        const cubeUVRenderTarget = renderTarget || this._allocateTargets();
        this._textureToCubeUV(texture, cubeUVRenderTarget);
        this._applyPMREM(cubeUVRenderTarget);
        this._cleanup(cubeUVRenderTarget);
        return cubeUVRenderTarget;
      }
      _allocateTargets() {
        const width = 3 * Math.max(this._cubeSize, 16 * 7);
        const height = 4 * this._cubeSize - 32;
        const params = {
          magFilter: LinearFilter,
          minFilter: LinearFilter,
          generateMipmaps: false,
          type: HalfFloatType,
          format: RGBAFormat,
          encoding: LinearEncoding,
          depthBuffer: false
        };
        const cubeUVRenderTarget = _createRenderTarget(width, height, params);
        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width) {
          if (this._pingPongRenderTarget !== null) {
            this._dispose();
          }
          this._pingPongRenderTarget = _createRenderTarget(width, height, params);
          const { _lodMax } = this;
          ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes(_lodMax));
          this._blurMaterial = _getBlurShader(_lodMax, width, height);
        }
        return cubeUVRenderTarget;
      }
      _compileMaterial(material) {
        const tmpMesh = new Mesh(this._lodPlanes[0], material);
        this._renderer.compile(tmpMesh, _flatCamera);
      }
      _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
        const fov2 = 90;
        const aspect2 = 1;
        const cubeCamera = new PerspectiveCamera(fov2, aspect2, near, far);
        const upSign = [1, -1, 1, 1, 1, 1];
        const forwardSign = [1, 1, 1, -1, -1, -1];
        const renderer = this._renderer;
        const originalAutoClear = renderer.autoClear;
        const toneMapping = renderer.toneMapping;
        renderer.getClearColor(_clearColor);
        renderer.toneMapping = NoToneMapping;
        renderer.autoClear = false;
        const backgroundMaterial = new MeshBasicMaterial({
          name: "PMREM.Background",
          side: BackSide,
          depthWrite: false,
          depthTest: false
        });
        const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
        let useSolidColor = false;
        const background = scene.background;
        if (background) {
          if (background.isColor) {
            backgroundMaterial.color.copy(background);
            scene.background = null;
            useSolidColor = true;
          }
        } else {
          backgroundMaterial.color.copy(_clearColor);
          useSolidColor = true;
        }
        for (let i2 = 0; i2 < 6; i2++) {
          const col = i2 % 3;
          if (col === 0) {
            cubeCamera.up.set(0, upSign[i2], 0);
            cubeCamera.lookAt(forwardSign[i2], 0, 0);
          } else if (col === 1) {
            cubeCamera.up.set(0, 0, upSign[i2]);
            cubeCamera.lookAt(0, forwardSign[i2], 0);
          } else {
            cubeCamera.up.set(0, upSign[i2], 0);
            cubeCamera.lookAt(0, 0, forwardSign[i2]);
          }
          const size = this._cubeSize;
          _setViewport(cubeUVRenderTarget, col * size, i2 > 2 ? size : 0, size, size);
          renderer.setRenderTarget(cubeUVRenderTarget);
          if (useSolidColor) {
            renderer.render(backgroundBox, cubeCamera);
          }
          renderer.render(scene, cubeCamera);
        }
        backgroundBox.geometry.dispose();
        backgroundBox.material.dispose();
        renderer.toneMapping = toneMapping;
        renderer.autoClear = originalAutoClear;
        scene.background = background;
      }
      _textureToCubeUV(texture, cubeUVRenderTarget) {
        const renderer = this._renderer;
        const isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;
        if (isCubeTexture) {
          if (this._cubemapMaterial === null) {
            this._cubemapMaterial = _getCubemapMaterial();
          }
          this._cubemapMaterial.uniforms.flipEnvMap.value = texture.isRenderTargetTexture === false ? -1 : 1;
        } else {
          if (this._equirectMaterial === null) {
            this._equirectMaterial = _getEquirectMaterial();
          }
        }
        const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
        const mesh = new Mesh(this._lodPlanes[0], material);
        const uniforms = material.uniforms;
        uniforms["envMap"].value = texture;
        const size = this._cubeSize;
        _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);
        renderer.setRenderTarget(cubeUVRenderTarget);
        renderer.render(mesh, _flatCamera);
      }
      _applyPMREM(cubeUVRenderTarget) {
        const renderer = this._renderer;
        const autoClear = renderer.autoClear;
        renderer.autoClear = false;
        for (let i2 = 1; i2 < this._lodPlanes.length; i2++) {
          const sigma = Math.sqrt(this._sigmas[i2] * this._sigmas[i2] - this._sigmas[i2 - 1] * this._sigmas[i2 - 1]);
          const poleAxis = _axisDirections[(i2 - 1) % _axisDirections.length];
          this._blur(cubeUVRenderTarget, i2 - 1, i2, sigma, poleAxis);
        }
        renderer.autoClear = autoClear;
      }
      _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
        const pingPongRenderTarget = this._pingPongRenderTarget;
        this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, "latitudinal", poleAxis);
        this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, "longitudinal", poleAxis);
      }
      _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
        const renderer = this._renderer;
        const blurMaterial = this._blurMaterial;
        if (direction !== "latitudinal" && direction !== "longitudinal") {
          console.error("blur direction must be either latitudinal or longitudinal!");
        }
        const STANDARD_DEVIATIONS = 3;
        const blurMesh = new Mesh(this._lodPlanes[lodOut], blurMaterial);
        const blurUniforms = blurMaterial.uniforms;
        const pixels = this._sizeLods[lodIn] - 1;
        const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
        const sigmaPixels = sigmaRadians / radiansPerPixel;
        const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
        if (samples > MAX_SAMPLES) {
          console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
        }
        const weights = [];
        let sum = 0;
        for (let i2 = 0; i2 < MAX_SAMPLES; ++i2) {
          const x2 = i2 / sigmaPixels;
          const weight = Math.exp(-x2 * x2 / 2);
          weights.push(weight);
          if (i2 === 0) {
            sum += weight;
          } else if (i2 < samples) {
            sum += 2 * weight;
          }
        }
        for (let i2 = 0; i2 < weights.length; i2++) {
          weights[i2] = weights[i2] / sum;
        }
        blurUniforms["envMap"].value = targetIn.texture;
        blurUniforms["samples"].value = samples;
        blurUniforms["weights"].value = weights;
        blurUniforms["latitudinal"].value = direction === "latitudinal";
        if (poleAxis) {
          blurUniforms["poleAxis"].value = poleAxis;
        }
        const { _lodMax } = this;
        blurUniforms["dTheta"].value = radiansPerPixel;
        blurUniforms["mipInt"].value = _lodMax - lodIn;
        const outputSize = this._sizeLods[lodOut];
        const x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
        const y2 = 4 * (this._cubeSize - outputSize);
        _setViewport(targetOut, x, y2, 3 * outputSize, 2 * outputSize);
        renderer.setRenderTarget(targetOut);
        renderer.render(blurMesh, _flatCamera);
      }
    };
    emptyTexture = new Texture();
    emptyArrayTexture = new DataArrayTexture();
    empty3dTexture = new Data3DTexture();
    emptyCubeTexture = new CubeTexture();
    arrayCacheF32 = [];
    arrayCacheI32 = [];
    mat4array = new Float32Array(16);
    mat3array = new Float32Array(9);
    mat2array = new Float32Array(4);
    PureArrayUniform.prototype.updateCache = function(data) {
      const cache = this.cache;
      if (data instanceof Float32Array && cache.length !== data.length) {
        this.cache = new Float32Array(data.length);
      }
      copyArray(cache, data);
    };
    StructuredUniform.prototype.setValue = function(gl, value, textures) {
      const seq = this.seq;
      for (let i2 = 0, n = seq.length; i2 !== n; ++i2) {
        const u = seq[i2];
        u.setValue(gl, value[u.id], textures);
      }
    };
    RePathPart = /(\w+)(\])?(\[|\.)?/g;
    WebGLUniforms.prototype.setValue = function(gl, name, value, textures) {
      const u = this.map[name];
      if (u !== void 0)
        u.setValue(gl, value, textures);
    };
    WebGLUniforms.prototype.setOptional = function(gl, object, name) {
      const v = object[name];
      if (v !== void 0)
        this.setValue(gl, name, v);
    };
    WebGLUniforms.upload = function(gl, seq, values, textures) {
      for (let i2 = 0, n = seq.length; i2 !== n; ++i2) {
        const u = seq[i2], v = values[u.id];
        if (v.needsUpdate !== false) {
          u.setValue(gl, v.value, textures);
        }
      }
    };
    WebGLUniforms.seqWithValue = function(seq, values) {
      const r3 = [];
      for (let i2 = 0, n = seq.length; i2 !== n; ++i2) {
        const u = seq[i2];
        if (u.id in values)
          r3.push(u);
      }
      return r3;
    };
    programIdCount = 0;
    includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
    deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
    unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
    _id = 0;
    WebGLShaderCache = class {
      constructor() {
        this.shaderCache = /* @__PURE__ */ new Map();
        this.materialCache = /* @__PURE__ */ new Map();
      }
      update(material) {
        const vertexShader = material.vertexShader;
        const fragmentShader = material.fragmentShader;
        const vertexShaderStage = this._getShaderStage(vertexShader);
        const fragmentShaderStage = this._getShaderStage(fragmentShader);
        const materialShaders = this._getShaderCacheForMaterial(material);
        if (materialShaders.has(vertexShaderStage) === false) {
          materialShaders.add(vertexShaderStage);
          vertexShaderStage.usedTimes++;
        }
        if (materialShaders.has(fragmentShaderStage) === false) {
          materialShaders.add(fragmentShaderStage);
          fragmentShaderStage.usedTimes++;
        }
        return this;
      }
      remove(material) {
        const materialShaders = this.materialCache.get(material);
        for (const shaderStage of materialShaders) {
          shaderStage.usedTimes--;
          if (shaderStage.usedTimes === 0)
            this.shaderCache.delete(shaderStage.code);
        }
        this.materialCache.delete(material);
        return this;
      }
      getVertexShaderID(material) {
        return this._getShaderStage(material.vertexShader).id;
      }
      getFragmentShaderID(material) {
        return this._getShaderStage(material.fragmentShader).id;
      }
      dispose() {
        this.shaderCache.clear();
        this.materialCache.clear();
      }
      _getShaderCacheForMaterial(material) {
        const cache = this.materialCache;
        if (cache.has(material) === false) {
          cache.set(material, /* @__PURE__ */ new Set());
        }
        return cache.get(material);
      }
      _getShaderStage(code) {
        const cache = this.shaderCache;
        if (cache.has(code) === false) {
          const stage = new WebGLShaderStage(code);
          cache.set(code, stage);
        }
        return cache.get(code);
      }
    };
    WebGLShaderStage = class {
      constructor(code) {
        this.id = _id++;
        this.code = code;
        this.usedTimes = 0;
      }
    };
    nextVersion = 0;
    MeshDepthMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.type = "MeshDepthMaterial";
        this.depthPacking = BasicDepthPacking;
        this.map = null;
        this.alphaMap = null;
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.fog = false;
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.depthPacking = source.depthPacking;
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        return this;
      }
    };
    MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
    MeshDistanceMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.type = "MeshDistanceMaterial";
        this.referencePosition = new Vector3();
        this.nearDistance = 1;
        this.farDistance = 1e3;
        this.map = null;
        this.alphaMap = null;
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.fog = false;
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.referencePosition.copy(source.referencePosition);
        this.nearDistance = source.nearDistance;
        this.farDistance = source.farDistance;
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        return this;
      }
    };
    MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
    vertex = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
    fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
    ArrayCamera = class extends PerspectiveCamera {
      constructor(array = []) {
        super();
        this.cameras = array;
      }
    };
    ArrayCamera.prototype.isArrayCamera = true;
    Group = class extends Object3D {
      constructor() {
        super();
        this.type = "Group";
      }
    };
    Group.prototype.isGroup = true;
    _moveEvent = { type: "move" };
    WebXRController = class {
      constructor() {
        this._targetRay = null;
        this._grip = null;
        this._hand = null;
      }
      getHandSpace() {
        if (this._hand === null) {
          this._hand = new Group();
          this._hand.matrixAutoUpdate = false;
          this._hand.visible = false;
          this._hand.joints = {};
          this._hand.inputState = { pinching: false };
        }
        return this._hand;
      }
      getTargetRaySpace() {
        if (this._targetRay === null) {
          this._targetRay = new Group();
          this._targetRay.matrixAutoUpdate = false;
          this._targetRay.visible = false;
          this._targetRay.hasLinearVelocity = false;
          this._targetRay.linearVelocity = new Vector3();
          this._targetRay.hasAngularVelocity = false;
          this._targetRay.angularVelocity = new Vector3();
        }
        return this._targetRay;
      }
      getGripSpace() {
        if (this._grip === null) {
          this._grip = new Group();
          this._grip.matrixAutoUpdate = false;
          this._grip.visible = false;
          this._grip.hasLinearVelocity = false;
          this._grip.linearVelocity = new Vector3();
          this._grip.hasAngularVelocity = false;
          this._grip.angularVelocity = new Vector3();
        }
        return this._grip;
      }
      dispatchEvent(event) {
        if (this._targetRay !== null) {
          this._targetRay.dispatchEvent(event);
        }
        if (this._grip !== null) {
          this._grip.dispatchEvent(event);
        }
        if (this._hand !== null) {
          this._hand.dispatchEvent(event);
        }
        return this;
      }
      disconnect(inputSource) {
        this.dispatchEvent({ type: "disconnected", data: inputSource });
        if (this._targetRay !== null) {
          this._targetRay.visible = false;
        }
        if (this._grip !== null) {
          this._grip.visible = false;
        }
        if (this._hand !== null) {
          this._hand.visible = false;
        }
        return this;
      }
      update(inputSource, frame, referenceSpace) {
        let inputPose = null;
        let gripPose = null;
        let handPose = null;
        const targetRay = this._targetRay;
        const grip = this._grip;
        const hand = this._hand;
        if (inputSource && frame.session.visibilityState !== "visible-blurred") {
          if (targetRay !== null) {
            inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
            if (inputPose !== null) {
              targetRay.matrix.fromArray(inputPose.transform.matrix);
              targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
              if (inputPose.linearVelocity) {
                targetRay.hasLinearVelocity = true;
                targetRay.linearVelocity.copy(inputPose.linearVelocity);
              } else {
                targetRay.hasLinearVelocity = false;
              }
              if (inputPose.angularVelocity) {
                targetRay.hasAngularVelocity = true;
                targetRay.angularVelocity.copy(inputPose.angularVelocity);
              } else {
                targetRay.hasAngularVelocity = false;
              }
              this.dispatchEvent(_moveEvent);
            }
          }
          if (hand && inputSource.hand) {
            handPose = true;
            for (const inputjoint of inputSource.hand.values()) {
              const jointPose = frame.getJointPose(inputjoint, referenceSpace);
              if (hand.joints[inputjoint.jointName] === void 0) {
                const joint2 = new Group();
                joint2.matrixAutoUpdate = false;
                joint2.visible = false;
                hand.joints[inputjoint.jointName] = joint2;
                hand.add(joint2);
              }
              const joint = hand.joints[inputjoint.jointName];
              if (jointPose !== null) {
                joint.matrix.fromArray(jointPose.transform.matrix);
                joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
                joint.jointRadius = jointPose.radius;
              }
              joint.visible = jointPose !== null;
            }
            const indexTip = hand.joints["index-finger-tip"];
            const thumbTip = hand.joints["thumb-tip"];
            const distance = indexTip.position.distanceTo(thumbTip.position);
            const distanceToPinch = 0.02;
            const threshold = 5e-3;
            if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
              hand.inputState.pinching = false;
              this.dispatchEvent({
                type: "pinchend",
                handedness: inputSource.handedness,
                target: this
              });
            } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
              hand.inputState.pinching = true;
              this.dispatchEvent({
                type: "pinchstart",
                handedness: inputSource.handedness,
                target: this
              });
            }
          } else {
            if (grip !== null && inputSource.gripSpace) {
              gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
              if (gripPose !== null) {
                grip.matrix.fromArray(gripPose.transform.matrix);
                grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
                if (gripPose.linearVelocity) {
                  grip.hasLinearVelocity = true;
                  grip.linearVelocity.copy(gripPose.linearVelocity);
                } else {
                  grip.hasLinearVelocity = false;
                }
                if (gripPose.angularVelocity) {
                  grip.hasAngularVelocity = true;
                  grip.angularVelocity.copy(gripPose.angularVelocity);
                } else {
                  grip.hasAngularVelocity = false;
                }
              }
            }
          }
        }
        if (targetRay !== null) {
          targetRay.visible = inputPose !== null;
        }
        if (grip !== null) {
          grip.visible = gripPose !== null;
        }
        if (hand !== null) {
          hand.visible = handPose !== null;
        }
        return this;
      }
    };
    DepthTexture = class extends Texture {
      constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
        format = format !== void 0 ? format : DepthFormat;
        if (format !== DepthFormat && format !== DepthStencilFormat) {
          throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        }
        if (type === void 0 && format === DepthFormat)
          type = UnsignedShortType;
        if (type === void 0 && format === DepthStencilFormat)
          type = UnsignedInt248Type;
        super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
        this.image = { width, height };
        this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
        this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
        this.flipY = false;
        this.generateMipmaps = false;
      }
    };
    DepthTexture.prototype.isDepthTexture = true;
    WebXRManager = class extends EventDispatcher {
      constructor(renderer, gl) {
        super();
        const scope = this;
        let session = null;
        let framebufferScaleFactor = 1;
        let referenceSpace = null;
        let referenceSpaceType = "local-floor";
        let pose = null;
        let glBinding = null;
        let glProjLayer = null;
        let glBaseLayer = null;
        let xrFrame = null;
        const attributes = gl.getContextAttributes();
        let initialRenderTarget = null;
        let newRenderTarget = null;
        const controllers = [];
        const inputSourcesMap = /* @__PURE__ */ new Map();
        const cameraL = new PerspectiveCamera();
        cameraL.layers.enable(1);
        cameraL.viewport = new Vector4();
        const cameraR = new PerspectiveCamera();
        cameraR.layers.enable(2);
        cameraR.viewport = new Vector4();
        const cameras = [cameraL, cameraR];
        const cameraVR = new ArrayCamera();
        cameraVR.layers.enable(1);
        cameraVR.layers.enable(2);
        let _currentDepthNear = null;
        let _currentDepthFar = null;
        this.cameraAutoUpdate = true;
        this.enabled = false;
        this.isPresenting = false;
        this.getController = function(index) {
          let controller = controllers[index];
          if (controller === void 0) {
            controller = new WebXRController();
            controllers[index] = controller;
          }
          return controller.getTargetRaySpace();
        };
        this.getControllerGrip = function(index) {
          let controller = controllers[index];
          if (controller === void 0) {
            controller = new WebXRController();
            controllers[index] = controller;
          }
          return controller.getGripSpace();
        };
        this.getHand = function(index) {
          let controller = controllers[index];
          if (controller === void 0) {
            controller = new WebXRController();
            controllers[index] = controller;
          }
          return controller.getHandSpace();
        };
        function onSessionEvent(event) {
          const controller = inputSourcesMap.get(event.inputSource);
          if (controller) {
            controller.dispatchEvent({ type: event.type, data: event.inputSource });
          }
        }
        function onSessionEnd() {
          inputSourcesMap.forEach(function(controller, inputSource) {
            controller.disconnect(inputSource);
          });
          inputSourcesMap.clear();
          _currentDepthNear = null;
          _currentDepthFar = null;
          renderer.setRenderTarget(initialRenderTarget);
          glBaseLayer = null;
          glProjLayer = null;
          glBinding = null;
          session = null;
          newRenderTarget = null;
          animation.stop();
          scope.isPresenting = false;
          scope.dispatchEvent({ type: "sessionend" });
        }
        this.setFramebufferScaleFactor = function(value) {
          framebufferScaleFactor = value;
          if (scope.isPresenting === true) {
            console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
          }
        };
        this.setReferenceSpaceType = function(value) {
          referenceSpaceType = value;
          if (scope.isPresenting === true) {
            console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
          }
        };
        this.getReferenceSpace = function() {
          return referenceSpace;
        };
        this.getBaseLayer = function() {
          return glProjLayer !== null ? glProjLayer : glBaseLayer;
        };
        this.getBinding = function() {
          return glBinding;
        };
        this.getFrame = function() {
          return xrFrame;
        };
        this.getSession = function() {
          return session;
        };
        this.setSession = async function(value) {
          session = value;
          if (session !== null) {
            initialRenderTarget = renderer.getRenderTarget();
            session.addEventListener("select", onSessionEvent);
            session.addEventListener("selectstart", onSessionEvent);
            session.addEventListener("selectend", onSessionEvent);
            session.addEventListener("squeeze", onSessionEvent);
            session.addEventListener("squeezestart", onSessionEvent);
            session.addEventListener("squeezeend", onSessionEvent);
            session.addEventListener("end", onSessionEnd);
            session.addEventListener("inputsourceschange", onInputSourcesChange);
            if (attributes.xrCompatible !== true) {
              await gl.makeXRCompatible();
            }
            if (session.renderState.layers === void 0 || renderer.capabilities.isWebGL2 === false) {
              const layerInit = {
                antialias: session.renderState.layers === void 0 ? attributes.antialias : true,
                alpha: attributes.alpha,
                depth: attributes.depth,
                stencil: attributes.stencil,
                framebufferScaleFactor
              };
              glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
              session.updateRenderState({ baseLayer: glBaseLayer });
              newRenderTarget = new WebGLRenderTarget(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, {
                format: RGBAFormat,
                type: UnsignedByteType,
                encoding: renderer.outputEncoding
              });
            } else {
              let depthFormat = null;
              let depthType = null;
              let glDepthFormat = null;
              if (attributes.depth) {
                glDepthFormat = attributes.stencil ? 35056 : 33190;
                depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
                depthType = attributes.stencil ? UnsignedInt248Type : UnsignedShortType;
              }
              const projectionlayerInit = {
                colorFormat: renderer.outputEncoding === sRGBEncoding ? 35907 : 32856,
                depthFormat: glDepthFormat,
                scaleFactor: framebufferScaleFactor
              };
              glBinding = new XRWebGLBinding(session, gl);
              glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
              session.updateRenderState({ layers: [glProjLayer] });
              newRenderTarget = new WebGLRenderTarget(glProjLayer.textureWidth, glProjLayer.textureHeight, {
                format: RGBAFormat,
                type: UnsignedByteType,
                depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, void 0, void 0, void 0, void 0, void 0, void 0, depthFormat),
                stencilBuffer: attributes.stencil,
                encoding: renderer.outputEncoding,
                samples: attributes.antialias ? 4 : 0
              });
              const renderTargetProperties = renderer.properties.get(newRenderTarget);
              renderTargetProperties.__ignoreDepthValues = glProjLayer.ignoreDepthValues;
            }
            newRenderTarget.isXRRenderTarget = true;
            this.setFoveation(1);
            referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
            animation.setContext(session);
            animation.start();
            scope.isPresenting = true;
            scope.dispatchEvent({ type: "sessionstart" });
          }
        };
        function onInputSourcesChange(event) {
          const inputSources = session.inputSources;
          for (let i2 = 0; i2 < controllers.length; i2++) {
            inputSourcesMap.set(inputSources[i2], controllers[i2]);
          }
          for (let i2 = 0; i2 < event.removed.length; i2++) {
            const inputSource = event.removed[i2];
            const controller = inputSourcesMap.get(inputSource);
            if (controller) {
              controller.dispatchEvent({ type: "disconnected", data: inputSource });
              inputSourcesMap.delete(inputSource);
            }
          }
          for (let i2 = 0; i2 < event.added.length; i2++) {
            const inputSource = event.added[i2];
            const controller = inputSourcesMap.get(inputSource);
            if (controller) {
              controller.dispatchEvent({ type: "connected", data: inputSource });
            }
          }
        }
        const cameraLPos = new Vector3();
        const cameraRPos = new Vector3();
        function setProjectionFromUnion(camera, cameraL2, cameraR2) {
          cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
          cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
          const ipd = cameraLPos.distanceTo(cameraRPos);
          const projL = cameraL2.projectionMatrix.elements;
          const projR = cameraR2.projectionMatrix.elements;
          const near = projL[14] / (projL[10] - 1);
          const far = projL[14] / (projL[10] + 1);
          const topFov = (projL[9] + 1) / projL[5];
          const bottomFov = (projL[9] - 1) / projL[5];
          const leftFov = (projL[8] - 1) / projL[0];
          const rightFov = (projR[8] + 1) / projR[0];
          const left = near * leftFov;
          const right = near * rightFov;
          const zOffset = ipd / (-leftFov + rightFov);
          const xOffset = zOffset * -leftFov;
          cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
          camera.translateX(xOffset);
          camera.translateZ(zOffset);
          camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
          camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
          const near2 = near + zOffset;
          const far2 = far + zOffset;
          const left2 = left - xOffset;
          const right2 = right + (ipd - xOffset);
          const top2 = topFov * far / far2 * near2;
          const bottom2 = bottomFov * far / far2 * near2;
          camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
        }
        function updateCamera(camera, parent) {
          if (parent === null) {
            camera.matrixWorld.copy(camera.matrix);
          } else {
            camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
          }
          camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
        }
        this.updateCamera = function(camera) {
          if (session === null)
            return;
          cameraVR.near = cameraR.near = cameraL.near = camera.near;
          cameraVR.far = cameraR.far = cameraL.far = camera.far;
          if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
            session.updateRenderState({
              depthNear: cameraVR.near,
              depthFar: cameraVR.far
            });
            _currentDepthNear = cameraVR.near;
            _currentDepthFar = cameraVR.far;
          }
          const parent = camera.parent;
          const cameras2 = cameraVR.cameras;
          updateCamera(cameraVR, parent);
          for (let i2 = 0; i2 < cameras2.length; i2++) {
            updateCamera(cameras2[i2], parent);
          }
          cameraVR.matrixWorld.decompose(cameraVR.position, cameraVR.quaternion, cameraVR.scale);
          camera.position.copy(cameraVR.position);
          camera.quaternion.copy(cameraVR.quaternion);
          camera.scale.copy(cameraVR.scale);
          camera.matrix.copy(cameraVR.matrix);
          camera.matrixWorld.copy(cameraVR.matrixWorld);
          const children = camera.children;
          for (let i2 = 0, l = children.length; i2 < l; i2++) {
            children[i2].updateMatrixWorld(true);
          }
          if (cameras2.length === 2) {
            setProjectionFromUnion(cameraVR, cameraL, cameraR);
          } else {
            cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);
          }
        };
        this.getCamera = function() {
          return cameraVR;
        };
        this.getFoveation = function() {
          if (glProjLayer !== null) {
            return glProjLayer.fixedFoveation;
          }
          if (glBaseLayer !== null) {
            return glBaseLayer.fixedFoveation;
          }
          return void 0;
        };
        this.setFoveation = function(foveation) {
          if (glProjLayer !== null) {
            glProjLayer.fixedFoveation = foveation;
          }
          if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== void 0) {
            glBaseLayer.fixedFoveation = foveation;
          }
        };
        let onAnimationFrameCallback = null;
        function onAnimationFrame(time, frame) {
          pose = frame.getViewerPose(referenceSpace);
          xrFrame = frame;
          if (pose !== null) {
            const views = pose.views;
            if (glBaseLayer !== null) {
              renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);
              renderer.setRenderTarget(newRenderTarget);
            }
            let cameraVRNeedsUpdate = false;
            if (views.length !== cameraVR.cameras.length) {
              cameraVR.cameras.length = 0;
              cameraVRNeedsUpdate = true;
            }
            for (let i2 = 0; i2 < views.length; i2++) {
              const view = views[i2];
              let viewport = null;
              if (glBaseLayer !== null) {
                viewport = glBaseLayer.getViewport(view);
              } else {
                const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
                viewport = glSubImage.viewport;
                if (i2 === 0) {
                  renderer.setRenderTargetTextures(newRenderTarget, glSubImage.colorTexture, glProjLayer.ignoreDepthValues ? void 0 : glSubImage.depthStencilTexture);
                  renderer.setRenderTarget(newRenderTarget);
                }
              }
              const camera = cameras[i2];
              camera.matrix.fromArray(view.transform.matrix);
              camera.projectionMatrix.fromArray(view.projectionMatrix);
              camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
              if (i2 === 0) {
                cameraVR.matrix.copy(camera.matrix);
              }
              if (cameraVRNeedsUpdate === true) {
                cameraVR.cameras.push(camera);
              }
            }
          }
          const inputSources = session.inputSources;
          for (let i2 = 0; i2 < controllers.length; i2++) {
            const controller = controllers[i2];
            const inputSource = inputSources[i2];
            controller.update(inputSource, frame, referenceSpace);
          }
          if (onAnimationFrameCallback)
            onAnimationFrameCallback(time, frame);
          xrFrame = null;
        }
        const animation = new WebGLAnimation();
        animation.setAnimationLoop(onAnimationFrame);
        this.setAnimationLoop = function(callback) {
          onAnimationFrameCallback = callback;
        };
        this.dispose = function() {
        };
      }
    };
    WebGLRenderer.prototype.isWebGLRenderer = true;
    WebGL1Renderer = class extends WebGLRenderer {
    };
    WebGL1Renderer.prototype.isWebGL1Renderer = true;
    FogExp2 = class {
      constructor(color, density = 25e-5) {
        this.name = "";
        this.color = new Color(color);
        this.density = density;
      }
      clone() {
        return new FogExp2(this.color, this.density);
      }
      toJSON() {
        return {
          type: "FogExp2",
          color: this.color.getHex(),
          density: this.density
        };
      }
    };
    FogExp2.prototype.isFogExp2 = true;
    Fog = class {
      constructor(color, near = 1, far = 1e3) {
        this.name = "";
        this.color = new Color(color);
        this.near = near;
        this.far = far;
      }
      clone() {
        return new Fog(this.color, this.near, this.far);
      }
      toJSON() {
        return {
          type: "Fog",
          color: this.color.getHex(),
          near: this.near,
          far: this.far
        };
      }
    };
    Fog.prototype.isFog = true;
    Scene = class extends Object3D {
      constructor() {
        super();
        this.type = "Scene";
        this.background = null;
        this.environment = null;
        this.fog = null;
        this.overrideMaterial = null;
        this.autoUpdate = true;
        if (typeof __THREE_DEVTOOLS__ !== "undefined") {
          __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
        }
      }
      copy(source, recursive) {
        super.copy(source, recursive);
        if (source.background !== null)
          this.background = source.background.clone();
        if (source.environment !== null)
          this.environment = source.environment.clone();
        if (source.fog !== null)
          this.fog = source.fog.clone();
        if (source.overrideMaterial !== null)
          this.overrideMaterial = source.overrideMaterial.clone();
        this.autoUpdate = source.autoUpdate;
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        return this;
      }
      toJSON(meta) {
        const data = super.toJSON(meta);
        if (this.fog !== null)
          data.object.fog = this.fog.toJSON();
        return data;
      }
    };
    Scene.prototype.isScene = true;
    InterleavedBuffer = class {
      constructor(array, stride) {
        this.array = array;
        this.stride = stride;
        this.count = array !== void 0 ? array.length / stride : 0;
        this.usage = StaticDrawUsage;
        this.updateRange = { offset: 0, count: -1 };
        this.version = 0;
        this.uuid = generateUUID();
      }
      onUploadCallback() {
      }
      set needsUpdate(value) {
        if (value === true)
          this.version++;
      }
      setUsage(value) {
        this.usage = value;
        return this;
      }
      copy(source) {
        this.array = new source.array.constructor(source.array);
        this.count = source.count;
        this.stride = source.stride;
        this.usage = source.usage;
        return this;
      }
      copyAt(index1, attribute, index2) {
        index1 *= this.stride;
        index2 *= attribute.stride;
        for (let i2 = 0, l = this.stride; i2 < l; i2++) {
          this.array[index1 + i2] = attribute.array[index2 + i2];
        }
        return this;
      }
      set(value, offset = 0) {
        this.array.set(value, offset);
        return this;
      }
      clone(data) {
        if (data.arrayBuffers === void 0) {
          data.arrayBuffers = {};
        }
        if (this.array.buffer._uuid === void 0) {
          this.array.buffer._uuid = generateUUID();
        }
        if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
          data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
        }
        const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
        const ib = new this.constructor(array, this.stride);
        ib.setUsage(this.usage);
        return ib;
      }
      onUpload(callback) {
        this.onUploadCallback = callback;
        return this;
      }
      toJSON(data) {
        if (data.arrayBuffers === void 0) {
          data.arrayBuffers = {};
        }
        if (this.array.buffer._uuid === void 0) {
          this.array.buffer._uuid = generateUUID();
        }
        if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
          data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));
        }
        return {
          uuid: this.uuid,
          buffer: this.array.buffer._uuid,
          type: this.array.constructor.name,
          stride: this.stride
        };
      }
    };
    InterleavedBuffer.prototype.isInterleavedBuffer = true;
    _vector$6 = /* @__PURE__ */ new Vector3();
    InterleavedBufferAttribute = class {
      constructor(interleavedBuffer, itemSize, offset, normalized = false) {
        this.name = "";
        this.data = interleavedBuffer;
        this.itemSize = itemSize;
        this.offset = offset;
        this.normalized = normalized === true;
      }
      get count() {
        return this.data.count;
      }
      get array() {
        return this.data.array;
      }
      set needsUpdate(value) {
        this.data.needsUpdate = value;
      }
      applyMatrix4(m) {
        for (let i2 = 0, l = this.data.count; i2 < l; i2++) {
          _vector$6.fromBufferAttribute(this, i2);
          _vector$6.applyMatrix4(m);
          this.setXYZ(i2, _vector$6.x, _vector$6.y, _vector$6.z);
        }
        return this;
      }
      applyNormalMatrix(m) {
        for (let i2 = 0, l = this.count; i2 < l; i2++) {
          _vector$6.fromBufferAttribute(this, i2);
          _vector$6.applyNormalMatrix(m);
          this.setXYZ(i2, _vector$6.x, _vector$6.y, _vector$6.z);
        }
        return this;
      }
      transformDirection(m) {
        for (let i2 = 0, l = this.count; i2 < l; i2++) {
          _vector$6.fromBufferAttribute(this, i2);
          _vector$6.transformDirection(m);
          this.setXYZ(i2, _vector$6.x, _vector$6.y, _vector$6.z);
        }
        return this;
      }
      setX(index, x) {
        this.data.array[index * this.data.stride + this.offset] = x;
        return this;
      }
      setY(index, y2) {
        this.data.array[index * this.data.stride + this.offset + 1] = y2;
        return this;
      }
      setZ(index, z) {
        this.data.array[index * this.data.stride + this.offset + 2] = z;
        return this;
      }
      setW(index, w) {
        this.data.array[index * this.data.stride + this.offset + 3] = w;
        return this;
      }
      getX(index) {
        return this.data.array[index * this.data.stride + this.offset];
      }
      getY(index) {
        return this.data.array[index * this.data.stride + this.offset + 1];
      }
      getZ(index) {
        return this.data.array[index * this.data.stride + this.offset + 2];
      }
      getW(index) {
        return this.data.array[index * this.data.stride + this.offset + 3];
      }
      setXY(index, x, y2) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y2;
        return this;
      }
      setXYZ(index, x, y2, z) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y2;
        this.data.array[index + 2] = z;
        return this;
      }
      setXYZW(index, x, y2, z, w) {
        index = index * this.data.stride + this.offset;
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y2;
        this.data.array[index + 2] = z;
        this.data.array[index + 3] = w;
        return this;
      }
      clone(data) {
        if (data === void 0) {
          console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
          const array = [];
          for (let i2 = 0; i2 < this.count; i2++) {
            const index = i2 * this.data.stride + this.offset;
            for (let j = 0; j < this.itemSize; j++) {
              array.push(this.data.array[index + j]);
            }
          }
          return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
        } else {
          if (data.interleavedBuffers === void 0) {
            data.interleavedBuffers = {};
          }
          if (data.interleavedBuffers[this.data.uuid] === void 0) {
            data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
          }
          return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
        }
      }
      toJSON(data) {
        if (data === void 0) {
          console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
          const array = [];
          for (let i2 = 0; i2 < this.count; i2++) {
            const index = i2 * this.data.stride + this.offset;
            for (let j = 0; j < this.itemSize; j++) {
              array.push(this.data.array[index + j]);
            }
          }
          return {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array,
            normalized: this.normalized
          };
        } else {
          if (data.interleavedBuffers === void 0) {
            data.interleavedBuffers = {};
          }
          if (data.interleavedBuffers[this.data.uuid] === void 0) {
            data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
          }
          return {
            isInterleavedBufferAttribute: true,
            itemSize: this.itemSize,
            data: this.data.uuid,
            offset: this.offset,
            normalized: this.normalized
          };
        }
      }
    };
    InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;
    SpriteMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.type = "SpriteMaterial";
        this.color = new Color(16777215);
        this.map = null;
        this.alphaMap = null;
        this.rotation = 0;
        this.sizeAttenuation = true;
        this.transparent = true;
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.rotation = source.rotation;
        this.sizeAttenuation = source.sizeAttenuation;
        return this;
      }
    };
    SpriteMaterial.prototype.isSpriteMaterial = true;
    _intersectPoint = /* @__PURE__ */ new Vector3();
    _worldScale = /* @__PURE__ */ new Vector3();
    _mvPosition = /* @__PURE__ */ new Vector3();
    _alignedPosition = /* @__PURE__ */ new Vector2();
    _rotatedPosition = /* @__PURE__ */ new Vector2();
    _viewWorldMatrix = /* @__PURE__ */ new Matrix4();
    _vA = /* @__PURE__ */ new Vector3();
    _vB = /* @__PURE__ */ new Vector3();
    _vC = /* @__PURE__ */ new Vector3();
    _uvA = /* @__PURE__ */ new Vector2();
    _uvB = /* @__PURE__ */ new Vector2();
    _uvC = /* @__PURE__ */ new Vector2();
    Sprite = class extends Object3D {
      constructor(material) {
        super();
        this.type = "Sprite";
        if (_geometry === void 0) {
          _geometry = new BufferGeometry();
          const float32Array = new Float32Array([
            -0.5,
            -0.5,
            0,
            0,
            0,
            0.5,
            -0.5,
            0,
            1,
            0,
            0.5,
            0.5,
            0,
            1,
            1,
            -0.5,
            0.5,
            0,
            0,
            1
          ]);
          const interleavedBuffer = new InterleavedBuffer(float32Array, 5);
          _geometry.setIndex([0, 1, 2, 0, 2, 3]);
          _geometry.setAttribute("position", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
          _geometry.setAttribute("uv", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
        }
        this.geometry = _geometry;
        this.material = material !== void 0 ? material : new SpriteMaterial();
        this.center = new Vector2(0.5, 0.5);
      }
      raycast(raycaster, intersects2) {
        if (raycaster.camera === null) {
          console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
        }
        _worldScale.setFromMatrixScale(this.matrixWorld);
        _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
        this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
        _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
        if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
          _worldScale.multiplyScalar(-_mvPosition.z);
        }
        const rotation = this.material.rotation;
        let sin, cos;
        if (rotation !== 0) {
          cos = Math.cos(rotation);
          sin = Math.sin(rotation);
        }
        const center = this.center;
        transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
        transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
        transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
        _uvA.set(0, 0);
        _uvB.set(1, 0);
        _uvC.set(1, 1);
        let intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);
        if (intersect === null) {
          transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
          _uvB.set(0, 1);
          intersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);
          if (intersect === null) {
            return;
          }
        }
        const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
        if (distance < raycaster.near || distance > raycaster.far)
          return;
        intersects2.push({
          distance,
          point: _intersectPoint.clone(),
          uv: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),
          face: null,
          object: this
        });
      }
      copy(source) {
        super.copy(source);
        if (source.center !== void 0)
          this.center.copy(source.center);
        this.material = source.material;
        return this;
      }
    };
    Sprite.prototype.isSprite = true;
    _v1$2 = /* @__PURE__ */ new Vector3();
    _v2$1 = /* @__PURE__ */ new Vector3();
    LOD = class extends Object3D {
      constructor() {
        super();
        this._currentLevel = 0;
        this.type = "LOD";
        Object.defineProperties(this, {
          levels: {
            enumerable: true,
            value: []
          },
          isLOD: {
            value: true
          }
        });
        this.autoUpdate = true;
      }
      copy(source) {
        super.copy(source, false);
        const levels = source.levels;
        for (let i2 = 0, l = levels.length; i2 < l; i2++) {
          const level = levels[i2];
          this.addLevel(level.object.clone(), level.distance);
        }
        this.autoUpdate = source.autoUpdate;
        return this;
      }
      addLevel(object, distance = 0) {
        distance = Math.abs(distance);
        const levels = this.levels;
        let l;
        for (l = 0; l < levels.length; l++) {
          if (distance < levels[l].distance) {
            break;
          }
        }
        levels.splice(l, 0, { distance, object });
        this.add(object);
        return this;
      }
      getCurrentLevel() {
        return this._currentLevel;
      }
      getObjectForDistance(distance) {
        const levels = this.levels;
        if (levels.length > 0) {
          let i2, l;
          for (i2 = 1, l = levels.length; i2 < l; i2++) {
            if (distance < levels[i2].distance) {
              break;
            }
          }
          return levels[i2 - 1].object;
        }
        return null;
      }
      raycast(raycaster, intersects2) {
        const levels = this.levels;
        if (levels.length > 0) {
          _v1$2.setFromMatrixPosition(this.matrixWorld);
          const distance = raycaster.ray.origin.distanceTo(_v1$2);
          this.getObjectForDistance(distance).raycast(raycaster, intersects2);
        }
      }
      update(camera) {
        const levels = this.levels;
        if (levels.length > 1) {
          _v1$2.setFromMatrixPosition(camera.matrixWorld);
          _v2$1.setFromMatrixPosition(this.matrixWorld);
          const distance = _v1$2.distanceTo(_v2$1) / camera.zoom;
          levels[0].object.visible = true;
          let i2, l;
          for (i2 = 1, l = levels.length; i2 < l; i2++) {
            if (distance >= levels[i2].distance) {
              levels[i2 - 1].object.visible = false;
              levels[i2].object.visible = true;
            } else {
              break;
            }
          }
          this._currentLevel = i2 - 1;
          for (; i2 < l; i2++) {
            levels[i2].object.visible = false;
          }
        }
      }
      toJSON(meta) {
        const data = super.toJSON(meta);
        if (this.autoUpdate === false)
          data.object.autoUpdate = false;
        data.object.levels = [];
        const levels = this.levels;
        for (let i2 = 0, l = levels.length; i2 < l; i2++) {
          const level = levels[i2];
          data.object.levels.push({
            object: level.object.uuid,
            distance: level.distance
          });
        }
        return data;
      }
    };
    _basePosition = /* @__PURE__ */ new Vector3();
    _skinIndex = /* @__PURE__ */ new Vector4();
    _skinWeight = /* @__PURE__ */ new Vector4();
    _vector$5 = /* @__PURE__ */ new Vector3();
    _matrix = /* @__PURE__ */ new Matrix4();
    SkinnedMesh = class extends Mesh {
      constructor(geometry, material) {
        super(geometry, material);
        this.type = "SkinnedMesh";
        this.bindMode = "attached";
        this.bindMatrix = new Matrix4();
        this.bindMatrixInverse = new Matrix4();
      }
      copy(source) {
        super.copy(source);
        this.bindMode = source.bindMode;
        this.bindMatrix.copy(source.bindMatrix);
        this.bindMatrixInverse.copy(source.bindMatrixInverse);
        this.skeleton = source.skeleton;
        return this;
      }
      bind(skeleton, bindMatrix) {
        this.skeleton = skeleton;
        if (bindMatrix === void 0) {
          this.updateMatrixWorld(true);
          this.skeleton.calculateInverses();
          bindMatrix = this.matrixWorld;
        }
        this.bindMatrix.copy(bindMatrix);
        this.bindMatrixInverse.copy(bindMatrix).invert();
      }
      pose() {
        this.skeleton.pose();
      }
      normalizeSkinWeights() {
        const vector = new Vector4();
        const skinWeight = this.geometry.attributes.skinWeight;
        for (let i2 = 0, l = skinWeight.count; i2 < l; i2++) {
          vector.fromBufferAttribute(skinWeight, i2);
          const scale = 1 / vector.manhattanLength();
          if (scale !== Infinity) {
            vector.multiplyScalar(scale);
          } else {
            vector.set(1, 0, 0, 0);
          }
          skinWeight.setXYZW(i2, vector.x, vector.y, vector.z, vector.w);
        }
      }
      updateMatrixWorld(force) {
        super.updateMatrixWorld(force);
        if (this.bindMode === "attached") {
          this.bindMatrixInverse.copy(this.matrixWorld).invert();
        } else if (this.bindMode === "detached") {
          this.bindMatrixInverse.copy(this.bindMatrix).invert();
        } else {
          console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
        }
      }
      boneTransform(index, target) {
        const skeleton = this.skeleton;
        const geometry = this.geometry;
        _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
        _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
        _basePosition.copy(target).applyMatrix4(this.bindMatrix);
        target.set(0, 0, 0);
        for (let i2 = 0; i2 < 4; i2++) {
          const weight = _skinWeight.getComponent(i2);
          if (weight !== 0) {
            const boneIndex = _skinIndex.getComponent(i2);
            _matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
            target.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), weight);
          }
        }
        return target.applyMatrix4(this.bindMatrixInverse);
      }
    };
    SkinnedMesh.prototype.isSkinnedMesh = true;
    Bone = class extends Object3D {
      constructor() {
        super();
        this.type = "Bone";
      }
    };
    Bone.prototype.isBone = true;
    DataTexture = class extends Texture {
      constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, encoding) {
        super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
        this.image = { data, width, height };
        this.generateMipmaps = false;
        this.flipY = false;
        this.unpackAlignment = 1;
      }
    };
    DataTexture.prototype.isDataTexture = true;
    _offsetMatrix = /* @__PURE__ */ new Matrix4();
    _identityMatrix = /* @__PURE__ */ new Matrix4();
    Skeleton = class {
      constructor(bones = [], boneInverses = []) {
        this.uuid = generateUUID();
        this.bones = bones.slice(0);
        this.boneInverses = boneInverses;
        this.boneMatrices = null;
        this.boneTexture = null;
        this.boneTextureSize = 0;
        this.frame = -1;
        this.init();
      }
      init() {
        const bones = this.bones;
        const boneInverses = this.boneInverses;
        this.boneMatrices = new Float32Array(bones.length * 16);
        if (boneInverses.length === 0) {
          this.calculateInverses();
        } else {
          if (bones.length !== boneInverses.length) {
            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.");
            this.boneInverses = [];
            for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
              this.boneInverses.push(new Matrix4());
            }
          }
        }
      }
      calculateInverses() {
        this.boneInverses.length = 0;
        for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
          const inverse = new Matrix4();
          if (this.bones[i2]) {
            inverse.copy(this.bones[i2].matrixWorld).invert();
          }
          this.boneInverses.push(inverse);
        }
      }
      pose() {
        for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
          const bone = this.bones[i2];
          if (bone) {
            bone.matrixWorld.copy(this.boneInverses[i2]).invert();
          }
        }
        for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
          const bone = this.bones[i2];
          if (bone) {
            if (bone.parent && bone.parent.isBone) {
              bone.matrix.copy(bone.parent.matrixWorld).invert();
              bone.matrix.multiply(bone.matrixWorld);
            } else {
              bone.matrix.copy(bone.matrixWorld);
            }
            bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
          }
        }
      }
      update() {
        const bones = this.bones;
        const boneInverses = this.boneInverses;
        const boneMatrices = this.boneMatrices;
        const boneTexture = this.boneTexture;
        for (let i2 = 0, il = bones.length; i2 < il; i2++) {
          const matrix = bones[i2] ? bones[i2].matrixWorld : _identityMatrix;
          _offsetMatrix.multiplyMatrices(matrix, boneInverses[i2]);
          _offsetMatrix.toArray(boneMatrices, i2 * 16);
        }
        if (boneTexture !== null) {
          boneTexture.needsUpdate = true;
        }
      }
      clone() {
        return new Skeleton(this.bones, this.boneInverses);
      }
      computeBoneTexture() {
        let size = Math.sqrt(this.bones.length * 4);
        size = ceilPowerOfTwo(size);
        size = Math.max(size, 4);
        const boneMatrices = new Float32Array(size * size * 4);
        boneMatrices.set(this.boneMatrices);
        const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
        boneTexture.needsUpdate = true;
        this.boneMatrices = boneMatrices;
        this.boneTexture = boneTexture;
        this.boneTextureSize = size;
        return this;
      }
      getBoneByName(name) {
        for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
          const bone = this.bones[i2];
          if (bone.name === name) {
            return bone;
          }
        }
        return void 0;
      }
      dispose() {
        if (this.boneTexture !== null) {
          this.boneTexture.dispose();
          this.boneTexture = null;
        }
      }
      fromJSON(json, bones) {
        this.uuid = json.uuid;
        for (let i2 = 0, l = json.bones.length; i2 < l; i2++) {
          const uuid = json.bones[i2];
          let bone = bones[uuid];
          if (bone === void 0) {
            console.warn("THREE.Skeleton: No bone found with UUID:", uuid);
            bone = new Bone();
          }
          this.bones.push(bone);
          this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i2]));
        }
        this.init();
        return this;
      }
      toJSON() {
        const data = {
          metadata: {
            version: 4.5,
            type: "Skeleton",
            generator: "Skeleton.toJSON"
          },
          bones: [],
          boneInverses: []
        };
        data.uuid = this.uuid;
        const bones = this.bones;
        const boneInverses = this.boneInverses;
        for (let i2 = 0, l = bones.length; i2 < l; i2++) {
          const bone = bones[i2];
          data.bones.push(bone.uuid);
          const boneInverse = boneInverses[i2];
          data.boneInverses.push(boneInverse.toArray());
        }
        return data;
      }
    };
    InstancedBufferAttribute = class extends BufferAttribute {
      constructor(array, itemSize, normalized, meshPerAttribute = 1) {
        if (typeof normalized === "number") {
          meshPerAttribute = normalized;
          normalized = false;
          console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.");
        }
        super(array, itemSize, normalized);
        this.meshPerAttribute = meshPerAttribute;
      }
      copy(source) {
        super.copy(source);
        this.meshPerAttribute = source.meshPerAttribute;
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.meshPerAttribute = this.meshPerAttribute;
        data.isInstancedBufferAttribute = true;
        return data;
      }
    };
    InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;
    _instanceLocalMatrix = /* @__PURE__ */ new Matrix4();
    _instanceWorldMatrix = /* @__PURE__ */ new Matrix4();
    _instanceIntersects = [];
    _mesh = /* @__PURE__ */ new Mesh();
    InstancedMesh = class extends Mesh {
      constructor(geometry, material, count) {
        super(geometry, material);
        this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);
        this.instanceColor = null;
        this.count = count;
        this.frustumCulled = false;
      }
      copy(source) {
        super.copy(source);
        this.instanceMatrix.copy(source.instanceMatrix);
        if (source.instanceColor !== null)
          this.instanceColor = source.instanceColor.clone();
        this.count = source.count;
        return this;
      }
      getColorAt(index, color) {
        color.fromArray(this.instanceColor.array, index * 3);
      }
      getMatrixAt(index, matrix) {
        matrix.fromArray(this.instanceMatrix.array, index * 16);
      }
      raycast(raycaster, intersects2) {
        const matrixWorld = this.matrixWorld;
        const raycastTimes = this.count;
        _mesh.geometry = this.geometry;
        _mesh.material = this.material;
        if (_mesh.material === void 0)
          return;
        for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
          this.getMatrixAt(instanceId, _instanceLocalMatrix);
          _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
          _mesh.matrixWorld = _instanceWorldMatrix;
          _mesh.raycast(raycaster, _instanceIntersects);
          for (let i2 = 0, l = _instanceIntersects.length; i2 < l; i2++) {
            const intersect = _instanceIntersects[i2];
            intersect.instanceId = instanceId;
            intersect.object = this;
            intersects2.push(intersect);
          }
          _instanceIntersects.length = 0;
        }
      }
      setColorAt(index, color) {
        if (this.instanceColor === null) {
          this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3), 3);
        }
        color.toArray(this.instanceColor.array, index * 3);
      }
      setMatrixAt(index, matrix) {
        matrix.toArray(this.instanceMatrix.array, index * 16);
      }
      updateMorphTargets() {
      }
      dispose() {
        this.dispatchEvent({ type: "dispose" });
      }
    };
    InstancedMesh.prototype.isInstancedMesh = true;
    LineBasicMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.type = "LineBasicMaterial";
        this.color = new Color(16777215);
        this.linewidth = 1;
        this.linecap = "round";
        this.linejoin = "round";
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.linewidth = source.linewidth;
        this.linecap = source.linecap;
        this.linejoin = source.linejoin;
        return this;
      }
    };
    LineBasicMaterial.prototype.isLineBasicMaterial = true;
    _start$1 = /* @__PURE__ */ new Vector3();
    _end$1 = /* @__PURE__ */ new Vector3();
    _inverseMatrix$1 = /* @__PURE__ */ new Matrix4();
    _ray$1 = /* @__PURE__ */ new Ray();
    _sphere$1 = /* @__PURE__ */ new Sphere();
    Line = class extends Object3D {
      constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
        super();
        this.type = "Line";
        this.geometry = geometry;
        this.material = material;
        this.updateMorphTargets();
      }
      copy(source) {
        super.copy(source);
        this.material = source.material;
        this.geometry = source.geometry;
        return this;
      }
      computeLineDistances() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
          if (geometry.index === null) {
            const positionAttribute = geometry.attributes.position;
            const lineDistances = [0];
            for (let i2 = 1, l = positionAttribute.count; i2 < l; i2++) {
              _start$1.fromBufferAttribute(positionAttribute, i2 - 1);
              _end$1.fromBufferAttribute(positionAttribute, i2);
              lineDistances[i2] = lineDistances[i2 - 1];
              lineDistances[i2] += _start$1.distanceTo(_end$1);
            }
            geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
          } else {
            console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          }
        } else if (geometry.isGeometry) {
          console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
        return this;
      }
      raycast(raycaster, intersects2) {
        const geometry = this.geometry;
        const matrixWorld = this.matrixWorld;
        const threshold = raycaster.params.Line.threshold;
        const drawRange = geometry.drawRange;
        if (geometry.boundingSphere === null)
          geometry.computeBoundingSphere();
        _sphere$1.copy(geometry.boundingSphere);
        _sphere$1.applyMatrix4(matrixWorld);
        _sphere$1.radius += threshold;
        if (raycaster.ray.intersectsSphere(_sphere$1) === false)
          return;
        _inverseMatrix$1.copy(matrixWorld).invert();
        _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
        const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
        const localThresholdSq = localThreshold * localThreshold;
        const vStart = new Vector3();
        const vEnd = new Vector3();
        const interSegment = new Vector3();
        const interRay = new Vector3();
        const step = this.isLineSegments ? 2 : 1;
        if (geometry.isBufferGeometry) {
          const index = geometry.index;
          const attributes = geometry.attributes;
          const positionAttribute = attributes.position;
          if (index !== null) {
            const start = Math.max(0, drawRange.start);
            const end = Math.min(index.count, drawRange.start + drawRange.count);
            for (let i2 = start, l = end - 1; i2 < l; i2 += step) {
              const a = index.getX(i2);
              const b2 = index.getX(i2 + 1);
              vStart.fromBufferAttribute(positionAttribute, a);
              vEnd.fromBufferAttribute(positionAttribute, b2);
              const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
              if (distSq > localThresholdSq)
                continue;
              interRay.applyMatrix4(this.matrixWorld);
              const distance = raycaster.ray.origin.distanceTo(interRay);
              if (distance < raycaster.near || distance > raycaster.far)
                continue;
              intersects2.push({
                distance,
                point: interSegment.clone().applyMatrix4(this.matrixWorld),
                index: i2,
                face: null,
                faceIndex: null,
                object: this
              });
            }
          } else {
            const start = Math.max(0, drawRange.start);
            const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
            for (let i2 = start, l = end - 1; i2 < l; i2 += step) {
              vStart.fromBufferAttribute(positionAttribute, i2);
              vEnd.fromBufferAttribute(positionAttribute, i2 + 1);
              const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
              if (distSq > localThresholdSq)
                continue;
              interRay.applyMatrix4(this.matrixWorld);
              const distance = raycaster.ray.origin.distanceTo(interRay);
              if (distance < raycaster.near || distance > raycaster.far)
                continue;
              intersects2.push({
                distance,
                point: interSegment.clone().applyMatrix4(this.matrixWorld),
                index: i2,
                face: null,
                faceIndex: null,
                object: this
              });
            }
          }
        } else if (geometry.isGeometry) {
          console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
      }
      updateMorphTargets() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
          const morphAttributes = geometry.morphAttributes;
          const keys = Object.keys(morphAttributes);
          if (keys.length > 0) {
            const morphAttribute = morphAttributes[keys[0]];
            if (morphAttribute !== void 0) {
              this.morphTargetInfluences = [];
              this.morphTargetDictionary = {};
              for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
                const name = morphAttribute[m].name || String(m);
                this.morphTargetInfluences.push(0);
                this.morphTargetDictionary[name] = m;
              }
            }
          }
        } else {
          const morphTargets = geometry.morphTargets;
          if (morphTargets !== void 0 && morphTargets.length > 0) {
            console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
        }
      }
    };
    Line.prototype.isLine = true;
    _start = /* @__PURE__ */ new Vector3();
    _end = /* @__PURE__ */ new Vector3();
    LineSegments = class extends Line {
      constructor(geometry, material) {
        super(geometry, material);
        this.type = "LineSegments";
      }
      computeLineDistances() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
          if (geometry.index === null) {
            const positionAttribute = geometry.attributes.position;
            const lineDistances = [];
            for (let i2 = 0, l = positionAttribute.count; i2 < l; i2 += 2) {
              _start.fromBufferAttribute(positionAttribute, i2);
              _end.fromBufferAttribute(positionAttribute, i2 + 1);
              lineDistances[i2] = i2 === 0 ? 0 : lineDistances[i2 - 1];
              lineDistances[i2 + 1] = lineDistances[i2] + _start.distanceTo(_end);
            }
            geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
          } else {
            console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          }
        } else if (geometry.isGeometry) {
          console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
        return this;
      }
    };
    LineSegments.prototype.isLineSegments = true;
    LineLoop = class extends Line {
      constructor(geometry, material) {
        super(geometry, material);
        this.type = "LineLoop";
      }
    };
    LineLoop.prototype.isLineLoop = true;
    PointsMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.type = "PointsMaterial";
        this.color = new Color(16777215);
        this.map = null;
        this.alphaMap = null;
        this.size = 1;
        this.sizeAttenuation = true;
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.size = source.size;
        this.sizeAttenuation = source.sizeAttenuation;
        return this;
      }
    };
    PointsMaterial.prototype.isPointsMaterial = true;
    _inverseMatrix = /* @__PURE__ */ new Matrix4();
    _ray = /* @__PURE__ */ new Ray();
    _sphere = /* @__PURE__ */ new Sphere();
    _position$2 = /* @__PURE__ */ new Vector3();
    Points = class extends Object3D {
      constructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {
        super();
        this.type = "Points";
        this.geometry = geometry;
        this.material = material;
        this.updateMorphTargets();
      }
      copy(source) {
        super.copy(source);
        this.material = source.material;
        this.geometry = source.geometry;
        return this;
      }
      raycast(raycaster, intersects2) {
        const geometry = this.geometry;
        const matrixWorld = this.matrixWorld;
        const threshold = raycaster.params.Points.threshold;
        const drawRange = geometry.drawRange;
        if (geometry.boundingSphere === null)
          geometry.computeBoundingSphere();
        _sphere.copy(geometry.boundingSphere);
        _sphere.applyMatrix4(matrixWorld);
        _sphere.radius += threshold;
        if (raycaster.ray.intersectsSphere(_sphere) === false)
          return;
        _inverseMatrix.copy(matrixWorld).invert();
        _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
        const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
        const localThresholdSq = localThreshold * localThreshold;
        if (geometry.isBufferGeometry) {
          const index = geometry.index;
          const attributes = geometry.attributes;
          const positionAttribute = attributes.position;
          if (index !== null) {
            const start = Math.max(0, drawRange.start);
            const end = Math.min(index.count, drawRange.start + drawRange.count);
            for (let i2 = start, il = end; i2 < il; i2++) {
              const a = index.getX(i2);
              _position$2.fromBufferAttribute(positionAttribute, a);
              testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects2, this);
            }
          } else {
            const start = Math.max(0, drawRange.start);
            const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
            for (let i2 = start, l = end; i2 < l; i2++) {
              _position$2.fromBufferAttribute(positionAttribute, i2);
              testPoint(_position$2, i2, localThresholdSq, matrixWorld, raycaster, intersects2, this);
            }
          }
        } else {
          console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
      }
      updateMorphTargets() {
        const geometry = this.geometry;
        if (geometry.isBufferGeometry) {
          const morphAttributes = geometry.morphAttributes;
          const keys = Object.keys(morphAttributes);
          if (keys.length > 0) {
            const morphAttribute = morphAttributes[keys[0]];
            if (morphAttribute !== void 0) {
              this.morphTargetInfluences = [];
              this.morphTargetDictionary = {};
              for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
                const name = morphAttribute[m].name || String(m);
                this.morphTargetInfluences.push(0);
                this.morphTargetDictionary[name] = m;
              }
            }
          }
        } else {
          const morphTargets = geometry.morphTargets;
          if (morphTargets !== void 0 && morphTargets.length > 0) {
            console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
        }
      }
    };
    Points.prototype.isPoints = true;
    VideoTexture = class extends Texture {
      constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
        this.minFilter = minFilter !== void 0 ? minFilter : LinearFilter;
        this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;
        this.generateMipmaps = false;
        const scope = this;
        function updateVideo() {
          scope.needsUpdate = true;
          video.requestVideoFrameCallback(updateVideo);
        }
        if ("requestVideoFrameCallback" in video) {
          video.requestVideoFrameCallback(updateVideo);
        }
      }
      clone() {
        return new this.constructor(this.image).copy(this);
      }
      update() {
        const video = this.image;
        const hasVideoFrameCallback = "requestVideoFrameCallback" in video;
        if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
          this.needsUpdate = true;
        }
      }
    };
    VideoTexture.prototype.isVideoTexture = true;
    FramebufferTexture = class extends Texture {
      constructor(width, height, format) {
        super({ width, height });
        this.format = format;
        this.magFilter = NearestFilter;
        this.minFilter = NearestFilter;
        this.generateMipmaps = false;
        this.needsUpdate = true;
      }
    };
    FramebufferTexture.prototype.isFramebufferTexture = true;
    CompressedTexture = class extends Texture {
      constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
        super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
        this.image = { width, height };
        this.mipmaps = mipmaps;
        this.flipY = false;
        this.generateMipmaps = false;
      }
    };
    CompressedTexture.prototype.isCompressedTexture = true;
    CanvasTexture = class extends Texture {
      constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
        this.needsUpdate = true;
      }
    };
    CanvasTexture.prototype.isCanvasTexture = true;
    Curve = class {
      constructor() {
        this.type = "Curve";
        this.arcLengthDivisions = 200;
      }
      getPoint() {
        console.warn("THREE.Curve: .getPoint() not implemented.");
        return null;
      }
      getPointAt(u, optionalTarget) {
        const t2 = this.getUtoTmapping(u);
        return this.getPoint(t2, optionalTarget);
      }
      getPoints(divisions = 5) {
        const points = [];
        for (let d2 = 0; d2 <= divisions; d2++) {
          points.push(this.getPoint(d2 / divisions));
        }
        return points;
      }
      getSpacedPoints(divisions = 5) {
        const points = [];
        for (let d2 = 0; d2 <= divisions; d2++) {
          points.push(this.getPointAt(d2 / divisions));
        }
        return points;
      }
      getLength() {
        const lengths = this.getLengths();
        return lengths[lengths.length - 1];
      }
      getLengths(divisions = this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
          return this.cacheArcLengths;
        }
        this.needsUpdate = false;
        const cache = [];
        let current, last = this.getPoint(0);
        let sum = 0;
        cache.push(0);
        for (let p = 1; p <= divisions; p++) {
          current = this.getPoint(p / divisions);
          sum += current.distanceTo(last);
          cache.push(sum);
          last = current;
        }
        this.cacheArcLengths = cache;
        return cache;
      }
      updateArcLengths() {
        this.needsUpdate = true;
        this.getLengths();
      }
      getUtoTmapping(u, distance) {
        const arcLengths = this.getLengths();
        let i2 = 0;
        const il = arcLengths.length;
        let targetArcLength;
        if (distance) {
          targetArcLength = distance;
        } else {
          targetArcLength = u * arcLengths[il - 1];
        }
        let low = 0, high = il - 1, comparison;
        while (low <= high) {
          i2 = Math.floor(low + (high - low) / 2);
          comparison = arcLengths[i2] - targetArcLength;
          if (comparison < 0) {
            low = i2 + 1;
          } else if (comparison > 0) {
            high = i2 - 1;
          } else {
            high = i2;
            break;
          }
        }
        i2 = high;
        if (arcLengths[i2] === targetArcLength) {
          return i2 / (il - 1);
        }
        const lengthBefore = arcLengths[i2];
        const lengthAfter = arcLengths[i2 + 1];
        const segmentLength = lengthAfter - lengthBefore;
        const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
        const t2 = (i2 + segmentFraction) / (il - 1);
        return t2;
      }
      getTangent(t2, optionalTarget) {
        const delta = 1e-4;
        let t1 = t2 - delta;
        let t22 = t2 + delta;
        if (t1 < 0)
          t1 = 0;
        if (t22 > 1)
          t22 = 1;
        const pt1 = this.getPoint(t1);
        const pt2 = this.getPoint(t22);
        const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
        tangent.copy(pt2).sub(pt1).normalize();
        return tangent;
      }
      getTangentAt(u, optionalTarget) {
        const t2 = this.getUtoTmapping(u);
        return this.getTangent(t2, optionalTarget);
      }
      computeFrenetFrames(segments, closed) {
        const normal2 = new Vector3();
        const tangents = [];
        const normals = [];
        const binormals = [];
        const vec = new Vector3();
        const mat = new Matrix4();
        for (let i2 = 0; i2 <= segments; i2++) {
          const u = i2 / segments;
          tangents[i2] = this.getTangentAt(u, new Vector3());
        }
        normals[0] = new Vector3();
        binormals[0] = new Vector3();
        let min = Number.MAX_VALUE;
        const tx = Math.abs(tangents[0].x);
        const ty = Math.abs(tangents[0].y);
        const tz = Math.abs(tangents[0].z);
        if (tx <= min) {
          min = tx;
          normal2.set(1, 0, 0);
        }
        if (ty <= min) {
          min = ty;
          normal2.set(0, 1, 0);
        }
        if (tz <= min) {
          normal2.set(0, 0, 1);
        }
        vec.crossVectors(tangents[0], normal2).normalize();
        normals[0].crossVectors(tangents[0], vec);
        binormals[0].crossVectors(tangents[0], normals[0]);
        for (let i2 = 1; i2 <= segments; i2++) {
          normals[i2] = normals[i2 - 1].clone();
          binormals[i2] = binormals[i2 - 1].clone();
          vec.crossVectors(tangents[i2 - 1], tangents[i2]);
          if (vec.length() > Number.EPSILON) {
            vec.normalize();
            const theta = Math.acos(clamp(tangents[i2 - 1].dot(tangents[i2]), -1, 1));
            normals[i2].applyMatrix4(mat.makeRotationAxis(vec, theta));
          }
          binormals[i2].crossVectors(tangents[i2], normals[i2]);
        }
        if (closed === true) {
          let theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));
          theta /= segments;
          if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
            theta = -theta;
          }
          for (let i2 = 1; i2 <= segments; i2++) {
            normals[i2].applyMatrix4(mat.makeRotationAxis(tangents[i2], theta * i2));
            binormals[i2].crossVectors(tangents[i2], normals[i2]);
          }
        }
        return {
          tangents,
          normals,
          binormals
        };
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(source) {
        this.arcLengthDivisions = source.arcLengthDivisions;
        return this;
      }
      toJSON() {
        const data = {
          metadata: {
            version: 4.5,
            type: "Curve",
            generator: "Curve.toJSON"
          }
        };
        data.arcLengthDivisions = this.arcLengthDivisions;
        data.type = this.type;
        return data;
      }
      fromJSON(json) {
        this.arcLengthDivisions = json.arcLengthDivisions;
        return this;
      }
    };
    EllipseCurve = class extends Curve {
      constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
        super();
        this.type = "EllipseCurve";
        this.aX = aX;
        this.aY = aY;
        this.xRadius = xRadius;
        this.yRadius = yRadius;
        this.aStartAngle = aStartAngle;
        this.aEndAngle = aEndAngle;
        this.aClockwise = aClockwise;
        this.aRotation = aRotation;
      }
      getPoint(t2, optionalTarget) {
        const point = optionalTarget || new Vector2();
        const twoPi = Math.PI * 2;
        let deltaAngle = this.aEndAngle - this.aStartAngle;
        const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
        while (deltaAngle < 0)
          deltaAngle += twoPi;
        while (deltaAngle > twoPi)
          deltaAngle -= twoPi;
        if (deltaAngle < Number.EPSILON) {
          if (samePoints) {
            deltaAngle = 0;
          } else {
            deltaAngle = twoPi;
          }
        }
        if (this.aClockwise === true && !samePoints) {
          if (deltaAngle === twoPi) {
            deltaAngle = -twoPi;
          } else {
            deltaAngle = deltaAngle - twoPi;
          }
        }
        const angle = this.aStartAngle + t2 * deltaAngle;
        let x = this.aX + this.xRadius * Math.cos(angle);
        let y2 = this.aY + this.yRadius * Math.sin(angle);
        if (this.aRotation !== 0) {
          const cos = Math.cos(this.aRotation);
          const sin = Math.sin(this.aRotation);
          const tx = x - this.aX;
          const ty = y2 - this.aY;
          x = tx * cos - ty * sin + this.aX;
          y2 = tx * sin + ty * cos + this.aY;
        }
        return point.set(x, y2);
      }
      copy(source) {
        super.copy(source);
        this.aX = source.aX;
        this.aY = source.aY;
        this.xRadius = source.xRadius;
        this.yRadius = source.yRadius;
        this.aStartAngle = source.aStartAngle;
        this.aEndAngle = source.aEndAngle;
        this.aClockwise = source.aClockwise;
        this.aRotation = source.aRotation;
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.aX = this.aX;
        data.aY = this.aY;
        data.xRadius = this.xRadius;
        data.yRadius = this.yRadius;
        data.aStartAngle = this.aStartAngle;
        data.aEndAngle = this.aEndAngle;
        data.aClockwise = this.aClockwise;
        data.aRotation = this.aRotation;
        return data;
      }
      fromJSON(json) {
        super.fromJSON(json);
        this.aX = json.aX;
        this.aY = json.aY;
        this.xRadius = json.xRadius;
        this.yRadius = json.yRadius;
        this.aStartAngle = json.aStartAngle;
        this.aEndAngle = json.aEndAngle;
        this.aClockwise = json.aClockwise;
        this.aRotation = json.aRotation;
        return this;
      }
    };
    EllipseCurve.prototype.isEllipseCurve = true;
    ArcCurve = class extends EllipseCurve {
      constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
        this.type = "ArcCurve";
      }
    };
    ArcCurve.prototype.isArcCurve = true;
    tmp = new Vector3();
    px = new CubicPoly();
    py = new CubicPoly();
    pz = new CubicPoly();
    CatmullRomCurve3 = class extends Curve {
      constructor(points = [], closed = false, curveType = "centripetal", tension = 0.5) {
        super();
        this.type = "CatmullRomCurve3";
        this.points = points;
        this.closed = closed;
        this.curveType = curveType;
        this.tension = tension;
      }
      getPoint(t2, optionalTarget = new Vector3()) {
        const point = optionalTarget;
        const points = this.points;
        const l = points.length;
        const p = (l - (this.closed ? 0 : 1)) * t2;
        let intPoint = Math.floor(p);
        let weight = p - intPoint;
        if (this.closed) {
          intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
        } else if (weight === 0 && intPoint === l - 1) {
          intPoint = l - 2;
          weight = 1;
        }
        let p0, p3;
        if (this.closed || intPoint > 0) {
          p0 = points[(intPoint - 1) % l];
        } else {
          tmp.subVectors(points[0], points[1]).add(points[0]);
          p0 = tmp;
        }
        const p1 = points[intPoint % l];
        const p2 = points[(intPoint + 1) % l];
        if (this.closed || intPoint + 2 < l) {
          p3 = points[(intPoint + 2) % l];
        } else {
          tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
          p3 = tmp;
        }
        if (this.curveType === "centripetal" || this.curveType === "chordal") {
          const pow = this.curveType === "chordal" ? 0.5 : 0.25;
          let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
          let dt1 = Math.pow(p1.distanceToSquared(p2), pow);
          let dt2 = Math.pow(p2.distanceToSquared(p3), pow);
          if (dt1 < 1e-4)
            dt1 = 1;
          if (dt0 < 1e-4)
            dt0 = dt1;
          if (dt2 < 1e-4)
            dt2 = dt1;
          px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
          py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
          pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
        } else if (this.curveType === "catmullrom") {
          px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
          py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
          pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
        }
        point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
        return point;
      }
      copy(source) {
        super.copy(source);
        this.points = [];
        for (let i2 = 0, l = source.points.length; i2 < l; i2++) {
          const point = source.points[i2];
          this.points.push(point.clone());
        }
        this.closed = source.closed;
        this.curveType = source.curveType;
        this.tension = source.tension;
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.points = [];
        for (let i2 = 0, l = this.points.length; i2 < l; i2++) {
          const point = this.points[i2];
          data.points.push(point.toArray());
        }
        data.closed = this.closed;
        data.curveType = this.curveType;
        data.tension = this.tension;
        return data;
      }
      fromJSON(json) {
        super.fromJSON(json);
        this.points = [];
        for (let i2 = 0, l = json.points.length; i2 < l; i2++) {
          const point = json.points[i2];
          this.points.push(new Vector3().fromArray(point));
        }
        this.closed = json.closed;
        this.curveType = json.curveType;
        this.tension = json.tension;
        return this;
      }
    };
    CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
    CubicBezierCurve = class extends Curve {
      constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {
        super();
        this.type = "CubicBezierCurve";
        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
        this.v3 = v3;
      }
      getPoint(t2, optionalTarget = new Vector2()) {
        const point = optionalTarget;
        const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
        point.set(CubicBezier(t2, v0.x, v1.x, v2.x, v3.x), CubicBezier(t2, v0.y, v1.y, v2.y, v3.y));
        return point;
      }
      copy(source) {
        super.copy(source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        this.v3.copy(source.v3);
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        data.v3 = this.v3.toArray();
        return data;
      }
      fromJSON(json) {
        super.fromJSON(json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        this.v3.fromArray(json.v3);
        return this;
      }
    };
    CubicBezierCurve.prototype.isCubicBezierCurve = true;
    CubicBezierCurve3 = class extends Curve {
      constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {
        super();
        this.type = "CubicBezierCurve3";
        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
        this.v3 = v3;
      }
      getPoint(t2, optionalTarget = new Vector3()) {
        const point = optionalTarget;
        const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
        point.set(CubicBezier(t2, v0.x, v1.x, v2.x, v3.x), CubicBezier(t2, v0.y, v1.y, v2.y, v3.y), CubicBezier(t2, v0.z, v1.z, v2.z, v3.z));
        return point;
      }
      copy(source) {
        super.copy(source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        this.v3.copy(source.v3);
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        data.v3 = this.v3.toArray();
        return data;
      }
      fromJSON(json) {
        super.fromJSON(json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        this.v3.fromArray(json.v3);
        return this;
      }
    };
    CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
    LineCurve = class extends Curve {
      constructor(v1 = new Vector2(), v2 = new Vector2()) {
        super();
        this.type = "LineCurve";
        this.v1 = v1;
        this.v2 = v2;
      }
      getPoint(t2, optionalTarget = new Vector2()) {
        const point = optionalTarget;
        if (t2 === 1) {
          point.copy(this.v2);
        } else {
          point.copy(this.v2).sub(this.v1);
          point.multiplyScalar(t2).add(this.v1);
        }
        return point;
      }
      getPointAt(u, optionalTarget) {
        return this.getPoint(u, optionalTarget);
      }
      getTangent(t2, optionalTarget) {
        const tangent = optionalTarget || new Vector2();
        tangent.copy(this.v2).sub(this.v1).normalize();
        return tangent;
      }
      copy(source) {
        super.copy(source);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
      }
      fromJSON(json) {
        super.fromJSON(json);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
      }
    };
    LineCurve.prototype.isLineCurve = true;
    LineCurve3 = class extends Curve {
      constructor(v1 = new Vector3(), v2 = new Vector3()) {
        super();
        this.type = "LineCurve3";
        this.isLineCurve3 = true;
        this.v1 = v1;
        this.v2 = v2;
      }
      getPoint(t2, optionalTarget = new Vector3()) {
        const point = optionalTarget;
        if (t2 === 1) {
          point.copy(this.v2);
        } else {
          point.copy(this.v2).sub(this.v1);
          point.multiplyScalar(t2).add(this.v1);
        }
        return point;
      }
      getPointAt(u, optionalTarget) {
        return this.getPoint(u, optionalTarget);
      }
      copy(source) {
        super.copy(source);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
      }
      fromJSON(json) {
        super.fromJSON(json);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
      }
    };
    QuadraticBezierCurve = class extends Curve {
      constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {
        super();
        this.type = "QuadraticBezierCurve";
        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
      }
      getPoint(t2, optionalTarget = new Vector2()) {
        const point = optionalTarget;
        const v0 = this.v0, v1 = this.v1, v2 = this.v2;
        point.set(QuadraticBezier(t2, v0.x, v1.x, v2.x), QuadraticBezier(t2, v0.y, v1.y, v2.y));
        return point;
      }
      copy(source) {
        super.copy(source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
      }
      fromJSON(json) {
        super.fromJSON(json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
      }
    };
    QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
    QuadraticBezierCurve3 = class extends Curve {
      constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {
        super();
        this.type = "QuadraticBezierCurve3";
        this.v0 = v0;
        this.v1 = v1;
        this.v2 = v2;
      }
      getPoint(t2, optionalTarget = new Vector3()) {
        const point = optionalTarget;
        const v0 = this.v0, v1 = this.v1, v2 = this.v2;
        point.set(QuadraticBezier(t2, v0.x, v1.x, v2.x), QuadraticBezier(t2, v0.y, v1.y, v2.y), QuadraticBezier(t2, v0.z, v1.z, v2.z));
        return point;
      }
      copy(source) {
        super.copy(source);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
      }
      fromJSON(json) {
        super.fromJSON(json);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
      }
    };
    QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
    SplineCurve = class extends Curve {
      constructor(points = []) {
        super();
        this.type = "SplineCurve";
        this.points = points;
      }
      getPoint(t2, optionalTarget = new Vector2()) {
        const point = optionalTarget;
        const points = this.points;
        const p = (points.length - 1) * t2;
        const intPoint = Math.floor(p);
        const weight = p - intPoint;
        const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
        const p1 = points[intPoint];
        const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
        const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
        point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
        return point;
      }
      copy(source) {
        super.copy(source);
        this.points = [];
        for (let i2 = 0, l = source.points.length; i2 < l; i2++) {
          const point = source.points[i2];
          this.points.push(point.clone());
        }
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.points = [];
        for (let i2 = 0, l = this.points.length; i2 < l; i2++) {
          const point = this.points[i2];
          data.points.push(point.toArray());
        }
        return data;
      }
      fromJSON(json) {
        super.fromJSON(json);
        this.points = [];
        for (let i2 = 0, l = json.points.length; i2 < l; i2++) {
          const point = json.points[i2];
          this.points.push(new Vector2().fromArray(point));
        }
        return this;
      }
    };
    SplineCurve.prototype.isSplineCurve = true;
    Curves = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      ArcCurve,
      CatmullRomCurve3,
      CubicBezierCurve,
      CubicBezierCurve3,
      EllipseCurve,
      LineCurve,
      LineCurve3,
      QuadraticBezierCurve,
      QuadraticBezierCurve3,
      SplineCurve
    });
    CurvePath = class extends Curve {
      constructor() {
        super();
        this.type = "CurvePath";
        this.curves = [];
        this.autoClose = false;
      }
      add(curve) {
        this.curves.push(curve);
      }
      closePath() {
        const startPoint = this.curves[0].getPoint(0);
        const endPoint = this.curves[this.curves.length - 1].getPoint(1);
        if (!startPoint.equals(endPoint)) {
          this.curves.push(new LineCurve(endPoint, startPoint));
        }
      }
      getPoint(t2, optionalTarget) {
        const d2 = t2 * this.getLength();
        const curveLengths = this.getCurveLengths();
        let i2 = 0;
        while (i2 < curveLengths.length) {
          if (curveLengths[i2] >= d2) {
            const diff = curveLengths[i2] - d2;
            const curve = this.curves[i2];
            const segmentLength = curve.getLength();
            const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
            return curve.getPointAt(u, optionalTarget);
          }
          i2++;
        }
        return null;
      }
      getLength() {
        const lens = this.getCurveLengths();
        return lens[lens.length - 1];
      }
      updateArcLengths() {
        this.needsUpdate = true;
        this.cacheLengths = null;
        this.getCurveLengths();
      }
      getCurveLengths() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
          return this.cacheLengths;
        }
        const lengths = [];
        let sums = 0;
        for (let i2 = 0, l = this.curves.length; i2 < l; i2++) {
          sums += this.curves[i2].getLength();
          lengths.push(sums);
        }
        this.cacheLengths = lengths;
        return lengths;
      }
      getSpacedPoints(divisions = 40) {
        const points = [];
        for (let i2 = 0; i2 <= divisions; i2++) {
          points.push(this.getPoint(i2 / divisions));
        }
        if (this.autoClose) {
          points.push(points[0]);
        }
        return points;
      }
      getPoints(divisions = 12) {
        const points = [];
        let last;
        for (let i2 = 0, curves = this.curves; i2 < curves.length; i2++) {
          const curve = curves[i2];
          const resolution = curve.isEllipseCurve ? divisions * 2 : curve.isLineCurve || curve.isLineCurve3 ? 1 : curve.isSplineCurve ? divisions * curve.points.length : divisions;
          const pts = curve.getPoints(resolution);
          for (let j = 0; j < pts.length; j++) {
            const point = pts[j];
            if (last && last.equals(point))
              continue;
            points.push(point);
            last = point;
          }
        }
        if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
          points.push(points[0]);
        }
        return points;
      }
      copy(source) {
        super.copy(source);
        this.curves = [];
        for (let i2 = 0, l = source.curves.length; i2 < l; i2++) {
          const curve = source.curves[i2];
          this.curves.push(curve.clone());
        }
        this.autoClose = source.autoClose;
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.autoClose = this.autoClose;
        data.curves = [];
        for (let i2 = 0, l = this.curves.length; i2 < l; i2++) {
          const curve = this.curves[i2];
          data.curves.push(curve.toJSON());
        }
        return data;
      }
      fromJSON(json) {
        super.fromJSON(json);
        this.autoClose = json.autoClose;
        this.curves = [];
        for (let i2 = 0, l = json.curves.length; i2 < l; i2++) {
          const curve = json.curves[i2];
          this.curves.push(new Curves[curve.type]().fromJSON(curve));
        }
        return this;
      }
    };
    Path = class extends CurvePath {
      constructor(points) {
        super();
        this.type = "Path";
        this.currentPoint = new Vector2();
        if (points) {
          this.setFromPoints(points);
        }
      }
      setFromPoints(points) {
        this.moveTo(points[0].x, points[0].y);
        for (let i2 = 1, l = points.length; i2 < l; i2++) {
          this.lineTo(points[i2].x, points[i2].y);
        }
        return this;
      }
      moveTo(x, y2) {
        this.currentPoint.set(x, y2);
        return this;
      }
      lineTo(x, y2) {
        const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y2));
        this.curves.push(curve);
        this.currentPoint.set(x, y2);
        return this;
      }
      quadraticCurveTo(aCPx, aCPy, aX, aY) {
        const curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
        this.curves.push(curve);
        this.currentPoint.set(aX, aY);
        return this;
      }
      bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        const curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
        this.curves.push(curve);
        this.currentPoint.set(aX, aY);
        return this;
      }
      splineThru(pts) {
        const npts = [this.currentPoint.clone()].concat(pts);
        const curve = new SplineCurve(npts);
        this.curves.push(curve);
        this.currentPoint.copy(pts[pts.length - 1]);
        return this;
      }
      arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        const x0 = this.currentPoint.x;
        const y0 = this.currentPoint.y;
        this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
        return this;
      }
      absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
        return this;
      }
      ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        const x0 = this.currentPoint.x;
        const y0 = this.currentPoint.y;
        this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        return this;
      }
      absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        if (this.curves.length > 0) {
          const firstPoint = curve.getPoint(0);
          if (!firstPoint.equals(this.currentPoint)) {
            this.lineTo(firstPoint.x, firstPoint.y);
          }
        }
        this.curves.push(curve);
        const lastPoint = curve.getPoint(1);
        this.currentPoint.copy(lastPoint);
        return this;
      }
      copy(source) {
        super.copy(source);
        this.currentPoint.copy(source.currentPoint);
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.currentPoint = this.currentPoint.toArray();
        return data;
      }
      fromJSON(json) {
        super.fromJSON(json);
        this.currentPoint.fromArray(json.currentPoint);
        return this;
      }
    };
    LatheGeometry = class extends BufferGeometry {
      constructor(points = [new Vector2(0, 0.5), new Vector2(0.5, 0), new Vector2(0, -0.5)], segments = 12, phiStart = 0, phiLength = Math.PI * 2) {
        super();
        this.type = "LatheGeometry";
        this.parameters = {
          points,
          segments,
          phiStart,
          phiLength
        };
        segments = Math.floor(segments);
        phiLength = clamp(phiLength, 0, Math.PI * 2);
        const indices = [];
        const vertices = [];
        const uvs = [];
        const initNormals = [];
        const normals = [];
        const inverseSegments = 1 / segments;
        const vertex2 = new Vector3();
        const uv = new Vector2();
        const normal2 = new Vector3();
        const curNormal = new Vector3();
        const prevNormal = new Vector3();
        let dx = 0;
        let dy = 0;
        for (let j = 0; j <= points.length - 1; j++) {
          switch (j) {
            case 0:
              dx = points[j + 1].x - points[j].x;
              dy = points[j + 1].y - points[j].y;
              normal2.x = dy * 1;
              normal2.y = -dx;
              normal2.z = dy * 0;
              prevNormal.copy(normal2);
              normal2.normalize();
              initNormals.push(normal2.x, normal2.y, normal2.z);
              break;
            case points.length - 1:
              initNormals.push(prevNormal.x, prevNormal.y, prevNormal.z);
              break;
            default:
              dx = points[j + 1].x - points[j].x;
              dy = points[j + 1].y - points[j].y;
              normal2.x = dy * 1;
              normal2.y = -dx;
              normal2.z = dy * 0;
              curNormal.copy(normal2);
              normal2.x += prevNormal.x;
              normal2.y += prevNormal.y;
              normal2.z += prevNormal.z;
              normal2.normalize();
              initNormals.push(normal2.x, normal2.y, normal2.z);
              prevNormal.copy(curNormal);
          }
        }
        for (let i2 = 0; i2 <= segments; i2++) {
          const phi = phiStart + i2 * inverseSegments * phiLength;
          const sin = Math.sin(phi);
          const cos = Math.cos(phi);
          for (let j = 0; j <= points.length - 1; j++) {
            vertex2.x = points[j].x * sin;
            vertex2.y = points[j].y;
            vertex2.z = points[j].x * cos;
            vertices.push(vertex2.x, vertex2.y, vertex2.z);
            uv.x = i2 / segments;
            uv.y = j / (points.length - 1);
            uvs.push(uv.x, uv.y);
            const x = initNormals[3 * j + 0] * sin;
            const y2 = initNormals[3 * j + 1];
            const z = initNormals[3 * j + 0] * cos;
            normals.push(x, y2, z);
          }
        }
        for (let i2 = 0; i2 < segments; i2++) {
          for (let j = 0; j < points.length - 1; j++) {
            const base = j + i2 * points.length;
            const a = base;
            const b2 = base + points.length;
            const c = base + points.length + 1;
            const d2 = base + 1;
            indices.push(a, b2, d2);
            indices.push(c, d2, b2);
          }
        }
        this.setIndex(indices);
        this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
      }
      static fromJSON(data) {
        return new LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength);
      }
    };
    CapsuleGeometry = class extends LatheGeometry {
      constructor(radius = 1, length = 1, capSegments = 4, radialSegments = 8) {
        const path = new Path();
        path.absarc(0, -length / 2, radius, Math.PI * 1.5, 0);
        path.absarc(0, length / 2, radius, 0, Math.PI * 0.5);
        super(path.getPoints(capSegments), radialSegments);
        this.type = "CapsuleGeometry";
        this.parameters = {
          radius,
          height: length,
          capSegments,
          radialSegments
        };
      }
      static fromJSON(data) {
        return new CapsuleGeometry(data.radius, data.length, data.capSegments, data.radialSegments);
      }
    };
    CircleGeometry = class extends BufferGeometry {
      constructor(radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2) {
        super();
        this.type = "CircleGeometry";
        this.parameters = {
          radius,
          segments,
          thetaStart,
          thetaLength
        };
        segments = Math.max(3, segments);
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        const vertex2 = new Vector3();
        const uv = new Vector2();
        vertices.push(0, 0, 0);
        normals.push(0, 0, 1);
        uvs.push(0.5, 0.5);
        for (let s = 0, i2 = 3; s <= segments; s++, i2 += 3) {
          const segment = thetaStart + s / segments * thetaLength;
          vertex2.x = radius * Math.cos(segment);
          vertex2.y = radius * Math.sin(segment);
          vertices.push(vertex2.x, vertex2.y, vertex2.z);
          normals.push(0, 0, 1);
          uv.x = (vertices[i2] / radius + 1) / 2;
          uv.y = (vertices[i2 + 1] / radius + 1) / 2;
          uvs.push(uv.x, uv.y);
        }
        for (let i2 = 1; i2 <= segments; i2++) {
          indices.push(i2, i2 + 1, 0);
        }
        this.setIndex(indices);
        this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
      }
      static fromJSON(data) {
        return new CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
      }
    };
    CylinderGeometry = class extends BufferGeometry {
      constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
        super();
        this.type = "CylinderGeometry";
        this.parameters = {
          radiusTop,
          radiusBottom,
          height,
          radialSegments,
          heightSegments,
          openEnded,
          thetaStart,
          thetaLength
        };
        const scope = this;
        radialSegments = Math.floor(radialSegments);
        heightSegments = Math.floor(heightSegments);
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        let index = 0;
        const indexArray = [];
        const halfHeight = height / 2;
        let groupStart = 0;
        generateTorso();
        if (openEnded === false) {
          if (radiusTop > 0)
            generateCap(true);
          if (radiusBottom > 0)
            generateCap(false);
        }
        this.setIndex(indices);
        this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        function generateTorso() {
          const normal2 = new Vector3();
          const vertex2 = new Vector3();
          let groupCount = 0;
          const slope = (radiusBottom - radiusTop) / height;
          for (let y2 = 0; y2 <= heightSegments; y2++) {
            const indexRow = [];
            const v = y2 / heightSegments;
            const radius = v * (radiusBottom - radiusTop) + radiusTop;
            for (let x = 0; x <= radialSegments; x++) {
              const u = x / radialSegments;
              const theta = u * thetaLength + thetaStart;
              const sinTheta = Math.sin(theta);
              const cosTheta = Math.cos(theta);
              vertex2.x = radius * sinTheta;
              vertex2.y = -v * height + halfHeight;
              vertex2.z = radius * cosTheta;
              vertices.push(vertex2.x, vertex2.y, vertex2.z);
              normal2.set(sinTheta, slope, cosTheta).normalize();
              normals.push(normal2.x, normal2.y, normal2.z);
              uvs.push(u, 1 - v);
              indexRow.push(index++);
            }
            indexArray.push(indexRow);
          }
          for (let x = 0; x < radialSegments; x++) {
            for (let y2 = 0; y2 < heightSegments; y2++) {
              const a = indexArray[y2][x];
              const b2 = indexArray[y2 + 1][x];
              const c = indexArray[y2 + 1][x + 1];
              const d2 = indexArray[y2][x + 1];
              indices.push(a, b2, d2);
              indices.push(b2, c, d2);
              groupCount += 6;
            }
          }
          scope.addGroup(groupStart, groupCount, 0);
          groupStart += groupCount;
        }
        function generateCap(top) {
          const centerIndexStart = index;
          const uv = new Vector2();
          const vertex2 = new Vector3();
          let groupCount = 0;
          const radius = top === true ? radiusTop : radiusBottom;
          const sign2 = top === true ? 1 : -1;
          for (let x = 1; x <= radialSegments; x++) {
            vertices.push(0, halfHeight * sign2, 0);
            normals.push(0, sign2, 0);
            uvs.push(0.5, 0.5);
            index++;
          }
          const centerIndexEnd = index;
          for (let x = 0; x <= radialSegments; x++) {
            const u = x / radialSegments;
            const theta = u * thetaLength + thetaStart;
            const cosTheta = Math.cos(theta);
            const sinTheta = Math.sin(theta);
            vertex2.x = radius * sinTheta;
            vertex2.y = halfHeight * sign2;
            vertex2.z = radius * cosTheta;
            vertices.push(vertex2.x, vertex2.y, vertex2.z);
            normals.push(0, sign2, 0);
            uv.x = cosTheta * 0.5 + 0.5;
            uv.y = sinTheta * 0.5 * sign2 + 0.5;
            uvs.push(uv.x, uv.y);
            index++;
          }
          for (let x = 0; x < radialSegments; x++) {
            const c = centerIndexStart + x;
            const i2 = centerIndexEnd + x;
            if (top === true) {
              indices.push(i2, i2 + 1, c);
            } else {
              indices.push(i2 + 1, i2, c);
            }
            groupCount += 3;
          }
          scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
          groupStart += groupCount;
        }
      }
      static fromJSON(data) {
        return new CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
      }
    };
    ConeGeometry = class extends CylinderGeometry {
      constructor(radius = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
        super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
        this.type = "ConeGeometry";
        this.parameters = {
          radius,
          height,
          radialSegments,
          heightSegments,
          openEnded,
          thetaStart,
          thetaLength
        };
      }
      static fromJSON(data) {
        return new ConeGeometry(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
      }
    };
    PolyhedronGeometry = class extends BufferGeometry {
      constructor(vertices = [], indices = [], radius = 1, detail = 0) {
        super();
        this.type = "PolyhedronGeometry";
        this.parameters = {
          vertices,
          indices,
          radius,
          detail
        };
        const vertexBuffer = [];
        const uvBuffer = [];
        subdivide(detail);
        applyRadius(radius);
        generateUVs();
        this.setAttribute("position", new Float32BufferAttribute(vertexBuffer, 3));
        this.setAttribute("normal", new Float32BufferAttribute(vertexBuffer.slice(), 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvBuffer, 2));
        if (detail === 0) {
          this.computeVertexNormals();
        } else {
          this.normalizeNormals();
        }
        function subdivide(detail2) {
          const a = new Vector3();
          const b2 = new Vector3();
          const c = new Vector3();
          for (let i2 = 0; i2 < indices.length; i2 += 3) {
            getVertexByIndex(indices[i2 + 0], a);
            getVertexByIndex(indices[i2 + 1], b2);
            getVertexByIndex(indices[i2 + 2], c);
            subdivideFace(a, b2, c, detail2);
          }
        }
        function subdivideFace(a, b2, c, detail2) {
          const cols = detail2 + 1;
          const v = [];
          for (let i2 = 0; i2 <= cols; i2++) {
            v[i2] = [];
            const aj = a.clone().lerp(c, i2 / cols);
            const bj = b2.clone().lerp(c, i2 / cols);
            const rows = cols - i2;
            for (let j = 0; j <= rows; j++) {
              if (j === 0 && i2 === cols) {
                v[i2][j] = aj;
              } else {
                v[i2][j] = aj.clone().lerp(bj, j / rows);
              }
            }
          }
          for (let i2 = 0; i2 < cols; i2++) {
            for (let j = 0; j < 2 * (cols - i2) - 1; j++) {
              const k = Math.floor(j / 2);
              if (j % 2 === 0) {
                pushVertex(v[i2][k + 1]);
                pushVertex(v[i2 + 1][k]);
                pushVertex(v[i2][k]);
              } else {
                pushVertex(v[i2][k + 1]);
                pushVertex(v[i2 + 1][k + 1]);
                pushVertex(v[i2 + 1][k]);
              }
            }
          }
        }
        function applyRadius(radius2) {
          const vertex2 = new Vector3();
          for (let i2 = 0; i2 < vertexBuffer.length; i2 += 3) {
            vertex2.x = vertexBuffer[i2 + 0];
            vertex2.y = vertexBuffer[i2 + 1];
            vertex2.z = vertexBuffer[i2 + 2];
            vertex2.normalize().multiplyScalar(radius2);
            vertexBuffer[i2 + 0] = vertex2.x;
            vertexBuffer[i2 + 1] = vertex2.y;
            vertexBuffer[i2 + 2] = vertex2.z;
          }
        }
        function generateUVs() {
          const vertex2 = new Vector3();
          for (let i2 = 0; i2 < vertexBuffer.length; i2 += 3) {
            vertex2.x = vertexBuffer[i2 + 0];
            vertex2.y = vertexBuffer[i2 + 1];
            vertex2.z = vertexBuffer[i2 + 2];
            const u = azimuth(vertex2) / 2 / Math.PI + 0.5;
            const v = inclination(vertex2) / Math.PI + 0.5;
            uvBuffer.push(u, 1 - v);
          }
          correctUVs();
          correctSeam();
        }
        function correctSeam() {
          for (let i2 = 0; i2 < uvBuffer.length; i2 += 6) {
            const x0 = uvBuffer[i2 + 0];
            const x1 = uvBuffer[i2 + 2];
            const x2 = uvBuffer[i2 + 4];
            const max = Math.max(x0, x1, x2);
            const min = Math.min(x0, x1, x2);
            if (max > 0.9 && min < 0.1) {
              if (x0 < 0.2)
                uvBuffer[i2 + 0] += 1;
              if (x1 < 0.2)
                uvBuffer[i2 + 2] += 1;
              if (x2 < 0.2)
                uvBuffer[i2 + 4] += 1;
            }
          }
        }
        function pushVertex(vertex2) {
          vertexBuffer.push(vertex2.x, vertex2.y, vertex2.z);
        }
        function getVertexByIndex(index, vertex2) {
          const stride = index * 3;
          vertex2.x = vertices[stride + 0];
          vertex2.y = vertices[stride + 1];
          vertex2.z = vertices[stride + 2];
        }
        function correctUVs() {
          const a = new Vector3();
          const b2 = new Vector3();
          const c = new Vector3();
          const centroid = new Vector3();
          const uvA = new Vector2();
          const uvB = new Vector2();
          const uvC = new Vector2();
          for (let i2 = 0, j = 0; i2 < vertexBuffer.length; i2 += 9, j += 6) {
            a.set(vertexBuffer[i2 + 0], vertexBuffer[i2 + 1], vertexBuffer[i2 + 2]);
            b2.set(vertexBuffer[i2 + 3], vertexBuffer[i2 + 4], vertexBuffer[i2 + 5]);
            c.set(vertexBuffer[i2 + 6], vertexBuffer[i2 + 7], vertexBuffer[i2 + 8]);
            uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
            uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
            uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
            centroid.copy(a).add(b2).add(c).divideScalar(3);
            const azi = azimuth(centroid);
            correctUV(uvA, j + 0, a, azi);
            correctUV(uvB, j + 2, b2, azi);
            correctUV(uvC, j + 4, c, azi);
          }
        }
        function correctUV(uv, stride, vector, azimuth2) {
          if (azimuth2 < 0 && uv.x === 1) {
            uvBuffer[stride] = uv.x - 1;
          }
          if (vector.x === 0 && vector.z === 0) {
            uvBuffer[stride] = azimuth2 / 2 / Math.PI + 0.5;
          }
        }
        function azimuth(vector) {
          return Math.atan2(vector.z, -vector.x);
        }
        function inclination(vector) {
          return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
        }
      }
      static fromJSON(data) {
        return new PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details);
      }
    };
    DodecahedronGeometry = class extends PolyhedronGeometry {
      constructor(radius = 1, detail = 0) {
        const t2 = (1 + Math.sqrt(5)) / 2;
        const r3 = 1 / t2;
        const vertices = [
          -1,
          -1,
          -1,
          -1,
          -1,
          1,
          -1,
          1,
          -1,
          -1,
          1,
          1,
          1,
          -1,
          -1,
          1,
          -1,
          1,
          1,
          1,
          -1,
          1,
          1,
          1,
          0,
          -r3,
          -t2,
          0,
          -r3,
          t2,
          0,
          r3,
          -t2,
          0,
          r3,
          t2,
          -r3,
          -t2,
          0,
          -r3,
          t2,
          0,
          r3,
          -t2,
          0,
          r3,
          t2,
          0,
          -t2,
          0,
          -r3,
          t2,
          0,
          -r3,
          -t2,
          0,
          r3,
          t2,
          0,
          r3
        ];
        const indices = [
          3,
          11,
          7,
          3,
          7,
          15,
          3,
          15,
          13,
          7,
          19,
          17,
          7,
          17,
          6,
          7,
          6,
          15,
          17,
          4,
          8,
          17,
          8,
          10,
          17,
          10,
          6,
          8,
          0,
          16,
          8,
          16,
          2,
          8,
          2,
          10,
          0,
          12,
          1,
          0,
          1,
          18,
          0,
          18,
          16,
          6,
          10,
          2,
          6,
          2,
          13,
          6,
          13,
          15,
          2,
          16,
          18,
          2,
          18,
          3,
          2,
          3,
          13,
          18,
          1,
          9,
          18,
          9,
          11,
          18,
          11,
          3,
          4,
          14,
          12,
          4,
          12,
          0,
          4,
          0,
          8,
          11,
          9,
          5,
          11,
          5,
          19,
          11,
          19,
          7,
          19,
          5,
          14,
          19,
          14,
          4,
          19,
          4,
          17,
          1,
          12,
          14,
          1,
          14,
          5,
          1,
          5,
          9
        ];
        super(vertices, indices, radius, detail);
        this.type = "DodecahedronGeometry";
        this.parameters = {
          radius,
          detail
        };
      }
      static fromJSON(data) {
        return new DodecahedronGeometry(data.radius, data.detail);
      }
    };
    _v0 = new Vector3();
    _v1$1 = new Vector3();
    _normal = new Vector3();
    _triangle = new Triangle();
    EdgesGeometry = class extends BufferGeometry {
      constructor(geometry = null, thresholdAngle = 1) {
        super();
        this.type = "EdgesGeometry";
        this.parameters = {
          geometry,
          thresholdAngle
        };
        if (geometry !== null) {
          const precisionPoints = 4;
          const precision = Math.pow(10, precisionPoints);
          const thresholdDot = Math.cos(DEG2RAD * thresholdAngle);
          const indexAttr = geometry.getIndex();
          const positionAttr = geometry.getAttribute("position");
          const indexCount = indexAttr ? indexAttr.count : positionAttr.count;
          const indexArr = [0, 0, 0];
          const vertKeys = ["a", "b", "c"];
          const hashes = new Array(3);
          const edgeData = {};
          const vertices = [];
          for (let i2 = 0; i2 < indexCount; i2 += 3) {
            if (indexAttr) {
              indexArr[0] = indexAttr.getX(i2);
              indexArr[1] = indexAttr.getX(i2 + 1);
              indexArr[2] = indexAttr.getX(i2 + 2);
            } else {
              indexArr[0] = i2;
              indexArr[1] = i2 + 1;
              indexArr[2] = i2 + 2;
            }
            const { a, b: b2, c } = _triangle;
            a.fromBufferAttribute(positionAttr, indexArr[0]);
            b2.fromBufferAttribute(positionAttr, indexArr[1]);
            c.fromBufferAttribute(positionAttr, indexArr[2]);
            _triangle.getNormal(_normal);
            hashes[0] = `${Math.round(a.x * precision)},${Math.round(a.y * precision)},${Math.round(a.z * precision)}`;
            hashes[1] = `${Math.round(b2.x * precision)},${Math.round(b2.y * precision)},${Math.round(b2.z * precision)}`;
            hashes[2] = `${Math.round(c.x * precision)},${Math.round(c.y * precision)},${Math.round(c.z * precision)}`;
            if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
              continue;
            }
            for (let j = 0; j < 3; j++) {
              const jNext = (j + 1) % 3;
              const vecHash0 = hashes[j];
              const vecHash1 = hashes[jNext];
              const v0 = _triangle[vertKeys[j]];
              const v1 = _triangle[vertKeys[jNext]];
              const hash = `${vecHash0}_${vecHash1}`;
              const reverseHash = `${vecHash1}_${vecHash0}`;
              if (reverseHash in edgeData && edgeData[reverseHash]) {
                if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {
                  vertices.push(v0.x, v0.y, v0.z);
                  vertices.push(v1.x, v1.y, v1.z);
                }
                edgeData[reverseHash] = null;
              } else if (!(hash in edgeData)) {
                edgeData[hash] = {
                  index0: indexArr[j],
                  index1: indexArr[jNext],
                  normal: _normal.clone()
                };
              }
            }
          }
          for (const key in edgeData) {
            if (edgeData[key]) {
              const { index0, index1 } = edgeData[key];
              _v0.fromBufferAttribute(positionAttr, index0);
              _v1$1.fromBufferAttribute(positionAttr, index1);
              vertices.push(_v0.x, _v0.y, _v0.z);
              vertices.push(_v1$1.x, _v1$1.y, _v1$1.z);
            }
          }
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        }
      }
    };
    Shape = class extends Path {
      constructor(points) {
        super(points);
        this.uuid = generateUUID();
        this.type = "Shape";
        this.holes = [];
      }
      getPointsHoles(divisions) {
        const holesPts = [];
        for (let i2 = 0, l = this.holes.length; i2 < l; i2++) {
          holesPts[i2] = this.holes[i2].getPoints(divisions);
        }
        return holesPts;
      }
      extractPoints(divisions) {
        return {
          shape: this.getPoints(divisions),
          holes: this.getPointsHoles(divisions)
        };
      }
      copy(source) {
        super.copy(source);
        this.holes = [];
        for (let i2 = 0, l = source.holes.length; i2 < l; i2++) {
          const hole = source.holes[i2];
          this.holes.push(hole.clone());
        }
        return this;
      }
      toJSON() {
        const data = super.toJSON();
        data.uuid = this.uuid;
        data.holes = [];
        for (let i2 = 0, l = this.holes.length; i2 < l; i2++) {
          const hole = this.holes[i2];
          data.holes.push(hole.toJSON());
        }
        return data;
      }
      fromJSON(json) {
        super.fromJSON(json);
        this.uuid = json.uuid;
        this.holes = [];
        for (let i2 = 0, l = json.holes.length; i2 < l; i2++) {
          const hole = json.holes[i2];
          this.holes.push(new Path().fromJSON(hole));
        }
        return this;
      }
    };
    Earcut = {
      triangulate: function(data, holeIndices, dim2 = 2) {
        const hasHoles = holeIndices && holeIndices.length;
        const outerLen = hasHoles ? holeIndices[0] * dim2 : data.length;
        let outerNode = linkedList(data, 0, outerLen, dim2, true);
        const triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev)
          return triangles;
        let minX, minY, maxX, maxY, x, y2, invSize;
        if (hasHoles)
          outerNode = eliminateHoles(data, holeIndices, outerNode, dim2);
        if (data.length > 80 * dim2) {
          minX = maxX = data[0];
          minY = maxY = data[1];
          for (let i2 = dim2; i2 < outerLen; i2 += dim2) {
            x = data[i2];
            y2 = data[i2 + 1];
            if (x < minX)
              minX = x;
            if (y2 < minY)
              minY = y2;
            if (x > maxX)
              maxX = x;
            if (y2 > maxY)
              maxY = y2;
          }
          invSize = Math.max(maxX - minX, maxY - minY);
          invSize = invSize !== 0 ? 1 / invSize : 0;
        }
        earcutLinked(outerNode, triangles, dim2, minX, minY, invSize);
        return triangles;
      }
    };
    ShapeUtils = class {
      static area(contour) {
        const n = contour.length;
        let a = 0;
        for (let p = n - 1, q = 0; q < n; p = q++) {
          a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
        }
        return a * 0.5;
      }
      static isClockWise(pts) {
        return ShapeUtils.area(pts) < 0;
      }
      static triangulateShape(contour, holes) {
        const vertices = [];
        const holeIndices = [];
        const faces = [];
        removeDupEndPts(contour);
        addContour(vertices, contour);
        let holeIndex = contour.length;
        holes.forEach(removeDupEndPts);
        for (let i2 = 0; i2 < holes.length; i2++) {
          holeIndices.push(holeIndex);
          holeIndex += holes[i2].length;
          addContour(vertices, holes[i2]);
        }
        const triangles = Earcut.triangulate(vertices, holeIndices);
        for (let i2 = 0; i2 < triangles.length; i2 += 3) {
          faces.push(triangles.slice(i2, i2 + 3));
        }
        return faces;
      }
    };
    ExtrudeGeometry = class extends BufferGeometry {
      constructor(shapes = new Shape([new Vector2(0.5, 0.5), new Vector2(-0.5, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), options = {}) {
        super();
        this.type = "ExtrudeGeometry";
        this.parameters = {
          shapes,
          options
        };
        shapes = Array.isArray(shapes) ? shapes : [shapes];
        const scope = this;
        const verticesArray = [];
        const uvArray = [];
        for (let i2 = 0, l = shapes.length; i2 < l; i2++) {
          const shape = shapes[i2];
          addShape(shape);
        }
        this.setAttribute("position", new Float32BufferAttribute(verticesArray, 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvArray, 2));
        this.computeVertexNormals();
        function addShape(shape) {
          const placeholder = [];
          const curveSegments = options.curveSegments !== void 0 ? options.curveSegments : 12;
          const steps = options.steps !== void 0 ? options.steps : 1;
          let depth = options.depth !== void 0 ? options.depth : 1;
          let bevelEnabled = options.bevelEnabled !== void 0 ? options.bevelEnabled : true;
          let bevelThickness = options.bevelThickness !== void 0 ? options.bevelThickness : 0.2;
          let bevelSize = options.bevelSize !== void 0 ? options.bevelSize : bevelThickness - 0.1;
          let bevelOffset = options.bevelOffset !== void 0 ? options.bevelOffset : 0;
          let bevelSegments = options.bevelSegments !== void 0 ? options.bevelSegments : 3;
          const extrudePath = options.extrudePath;
          const uvgen = options.UVGenerator !== void 0 ? options.UVGenerator : WorldUVGenerator;
          if (options.amount !== void 0) {
            console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth.");
            depth = options.amount;
          }
          let extrudePts, extrudeByPath = false;
          let splineTube, binormal, normal2, position2;
          if (extrudePath) {
            extrudePts = extrudePath.getSpacedPoints(steps);
            extrudeByPath = true;
            bevelEnabled = false;
            splineTube = extrudePath.computeFrenetFrames(steps, false);
            binormal = new Vector3();
            normal2 = new Vector3();
            position2 = new Vector3();
          }
          if (!bevelEnabled) {
            bevelSegments = 0;
            bevelThickness = 0;
            bevelSize = 0;
            bevelOffset = 0;
          }
          const shapePoints = shape.extractPoints(curveSegments);
          let vertices = shapePoints.shape;
          const holes = shapePoints.holes;
          const reverse2 = !ShapeUtils.isClockWise(vertices);
          if (reverse2) {
            vertices = vertices.reverse();
            for (let h = 0, hl = holes.length; h < hl; h++) {
              const ahole = holes[h];
              if (ShapeUtils.isClockWise(ahole)) {
                holes[h] = ahole.reverse();
              }
            }
          }
          const faces = ShapeUtils.triangulateShape(vertices, holes);
          const contour = vertices;
          for (let h = 0, hl = holes.length; h < hl; h++) {
            const ahole = holes[h];
            vertices = vertices.concat(ahole);
          }
          function scalePt2(pt, vec, size) {
            if (!vec)
              console.error("THREE.ExtrudeGeometry: vec does not exist");
            return vec.clone().multiplyScalar(size).add(pt);
          }
          const vlen = vertices.length, flen = faces.length;
          function getBevelVec(inPt, inPrev, inNext) {
            let v_trans_x, v_trans_y, shrink_by;
            const v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
            const v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
            const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
            const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
            if (Math.abs(collinear0) > Number.EPSILON) {
              const v_prev_len = Math.sqrt(v_prev_lensq);
              const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
              const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
              const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
              const ptNextShift_x = inNext.x - v_next_y / v_next_len;
              const ptNextShift_y = inNext.y + v_next_x / v_next_len;
              const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
              v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
              v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
              const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
              if (v_trans_lensq <= 2) {
                return new Vector2(v_trans_x, v_trans_y);
              } else {
                shrink_by = Math.sqrt(v_trans_lensq / 2);
              }
            } else {
              let direction_eq = false;
              if (v_prev_x > Number.EPSILON) {
                if (v_next_x > Number.EPSILON) {
                  direction_eq = true;
                }
              } else {
                if (v_prev_x < -Number.EPSILON) {
                  if (v_next_x < -Number.EPSILON) {
                    direction_eq = true;
                  }
                } else {
                  if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                    direction_eq = true;
                  }
                }
              }
              if (direction_eq) {
                v_trans_x = -v_prev_y;
                v_trans_y = v_prev_x;
                shrink_by = Math.sqrt(v_prev_lensq);
              } else {
                v_trans_x = v_prev_x;
                v_trans_y = v_prev_y;
                shrink_by = Math.sqrt(v_prev_lensq / 2);
              }
            }
            return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
          }
          const contourMovements = [];
          for (let i2 = 0, il = contour.length, j = il - 1, k = i2 + 1; i2 < il; i2++, j++, k++) {
            if (j === il)
              j = 0;
            if (k === il)
              k = 0;
            contourMovements[i2] = getBevelVec(contour[i2], contour[j], contour[k]);
          }
          const holesMovements = [];
          let oneHoleMovements, verticesMovements = contourMovements.concat();
          for (let h = 0, hl = holes.length; h < hl; h++) {
            const ahole = holes[h];
            oneHoleMovements = [];
            for (let i2 = 0, il = ahole.length, j = il - 1, k = i2 + 1; i2 < il; i2++, j++, k++) {
              if (j === il)
                j = 0;
              if (k === il)
                k = 0;
              oneHoleMovements[i2] = getBevelVec(ahole[i2], ahole[j], ahole[k]);
            }
            holesMovements.push(oneHoleMovements);
            verticesMovements = verticesMovements.concat(oneHoleMovements);
          }
          for (let b2 = 0; b2 < bevelSegments; b2++) {
            const t2 = b2 / bevelSegments;
            const z = bevelThickness * Math.cos(t2 * Math.PI / 2);
            const bs2 = bevelSize * Math.sin(t2 * Math.PI / 2) + bevelOffset;
            for (let i2 = 0, il = contour.length; i2 < il; i2++) {
              const vert = scalePt2(contour[i2], contourMovements[i2], bs2);
              v(vert.x, vert.y, -z);
            }
            for (let h = 0, hl = holes.length; h < hl; h++) {
              const ahole = holes[h];
              oneHoleMovements = holesMovements[h];
              for (let i2 = 0, il = ahole.length; i2 < il; i2++) {
                const vert = scalePt2(ahole[i2], oneHoleMovements[i2], bs2);
                v(vert.x, vert.y, -z);
              }
            }
          }
          const bs = bevelSize + bevelOffset;
          for (let i2 = 0; i2 < vlen; i2++) {
            const vert = bevelEnabled ? scalePt2(vertices[i2], verticesMovements[i2], bs) : vertices[i2];
            if (!extrudeByPath) {
              v(vert.x, vert.y, 0);
            } else {
              normal2.copy(splineTube.normals[0]).multiplyScalar(vert.x);
              binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
              position2.copy(extrudePts[0]).add(normal2).add(binormal);
              v(position2.x, position2.y, position2.z);
            }
          }
          for (let s = 1; s <= steps; s++) {
            for (let i2 = 0; i2 < vlen; i2++) {
              const vert = bevelEnabled ? scalePt2(vertices[i2], verticesMovements[i2], bs) : vertices[i2];
              if (!extrudeByPath) {
                v(vert.x, vert.y, depth / steps * s);
              } else {
                normal2.copy(splineTube.normals[s]).multiplyScalar(vert.x);
                binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
                position2.copy(extrudePts[s]).add(normal2).add(binormal);
                v(position2.x, position2.y, position2.z);
              }
            }
          }
          for (let b2 = bevelSegments - 1; b2 >= 0; b2--) {
            const t2 = b2 / bevelSegments;
            const z = bevelThickness * Math.cos(t2 * Math.PI / 2);
            const bs2 = bevelSize * Math.sin(t2 * Math.PI / 2) + bevelOffset;
            for (let i2 = 0, il = contour.length; i2 < il; i2++) {
              const vert = scalePt2(contour[i2], contourMovements[i2], bs2);
              v(vert.x, vert.y, depth + z);
            }
            for (let h = 0, hl = holes.length; h < hl; h++) {
              const ahole = holes[h];
              oneHoleMovements = holesMovements[h];
              for (let i2 = 0, il = ahole.length; i2 < il; i2++) {
                const vert = scalePt2(ahole[i2], oneHoleMovements[i2], bs2);
                if (!extrudeByPath) {
                  v(vert.x, vert.y, depth + z);
                } else {
                  v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
                }
              }
            }
          }
          buildLidFaces();
          buildSideFaces();
          function buildLidFaces() {
            const start = verticesArray.length / 3;
            if (bevelEnabled) {
              let layer = 0;
              let offset = vlen * layer;
              for (let i2 = 0; i2 < flen; i2++) {
                const face2 = faces[i2];
                f3(face2[2] + offset, face2[1] + offset, face2[0] + offset);
              }
              layer = steps + bevelSegments * 2;
              offset = vlen * layer;
              for (let i2 = 0; i2 < flen; i2++) {
                const face2 = faces[i2];
                f3(face2[0] + offset, face2[1] + offset, face2[2] + offset);
              }
            } else {
              for (let i2 = 0; i2 < flen; i2++) {
                const face2 = faces[i2];
                f3(face2[2], face2[1], face2[0]);
              }
              for (let i2 = 0; i2 < flen; i2++) {
                const face2 = faces[i2];
                f3(face2[0] + vlen * steps, face2[1] + vlen * steps, face2[2] + vlen * steps);
              }
            }
            scope.addGroup(start, verticesArray.length / 3 - start, 0);
          }
          function buildSideFaces() {
            const start = verticesArray.length / 3;
            let layeroffset = 0;
            sidewalls(contour, layeroffset);
            layeroffset += contour.length;
            for (let h = 0, hl = holes.length; h < hl; h++) {
              const ahole = holes[h];
              sidewalls(ahole, layeroffset);
              layeroffset += ahole.length;
            }
            scope.addGroup(start, verticesArray.length / 3 - start, 1);
          }
          function sidewalls(contour2, layeroffset) {
            let i2 = contour2.length;
            while (--i2 >= 0) {
              const j = i2;
              let k = i2 - 1;
              if (k < 0)
                k = contour2.length - 1;
              for (let s = 0, sl = steps + bevelSegments * 2; s < sl; s++) {
                const slen1 = vlen * s;
                const slen2 = vlen * (s + 1);
                const a = layeroffset + j + slen1, b2 = layeroffset + k + slen1, c = layeroffset + k + slen2, d2 = layeroffset + j + slen2;
                f4(a, b2, c, d2);
              }
            }
          }
          function v(x, y2, z) {
            placeholder.push(x);
            placeholder.push(y2);
            placeholder.push(z);
          }
          function f3(a, b2, c) {
            addVertex(a);
            addVertex(b2);
            addVertex(c);
            const nextIndex = verticesArray.length / 3;
            const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
            addUV(uvs[0]);
            addUV(uvs[1]);
            addUV(uvs[2]);
          }
          function f4(a, b2, c, d2) {
            addVertex(a);
            addVertex(b2);
            addVertex(d2);
            addVertex(b2);
            addVertex(c);
            addVertex(d2);
            const nextIndex = verticesArray.length / 3;
            const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
            addUV(uvs[0]);
            addUV(uvs[1]);
            addUV(uvs[3]);
            addUV(uvs[1]);
            addUV(uvs[2]);
            addUV(uvs[3]);
          }
          function addVertex(index) {
            verticesArray.push(placeholder[index * 3 + 0]);
            verticesArray.push(placeholder[index * 3 + 1]);
            verticesArray.push(placeholder[index * 3 + 2]);
          }
          function addUV(vector2) {
            uvArray.push(vector2.x);
            uvArray.push(vector2.y);
          }
        }
      }
      toJSON() {
        const data = super.toJSON();
        const shapes = this.parameters.shapes;
        const options = this.parameters.options;
        return toJSON$1(shapes, options, data);
      }
      static fromJSON(data, shapes) {
        const geometryShapes = [];
        for (let j = 0, jl = data.shapes.length; j < jl; j++) {
          const shape = shapes[data.shapes[j]];
          geometryShapes.push(shape);
        }
        const extrudePath = data.options.extrudePath;
        if (extrudePath !== void 0) {
          data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
        }
        return new ExtrudeGeometry(geometryShapes, data.options);
      }
    };
    WorldUVGenerator = {
      generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
        const a_x = vertices[indexA * 3];
        const a_y = vertices[indexA * 3 + 1];
        const b_x = vertices[indexB * 3];
        const b_y = vertices[indexB * 3 + 1];
        const c_x = vertices[indexC * 3];
        const c_y = vertices[indexC * 3 + 1];
        return [
          new Vector2(a_x, a_y),
          new Vector2(b_x, b_y),
          new Vector2(c_x, c_y)
        ];
      },
      generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
        const a_x = vertices[indexA * 3];
        const a_y = vertices[indexA * 3 + 1];
        const a_z = vertices[indexA * 3 + 2];
        const b_x = vertices[indexB * 3];
        const b_y = vertices[indexB * 3 + 1];
        const b_z = vertices[indexB * 3 + 2];
        const c_x = vertices[indexC * 3];
        const c_y = vertices[indexC * 3 + 1];
        const c_z = vertices[indexC * 3 + 2];
        const d_x = vertices[indexD * 3];
        const d_y = vertices[indexD * 3 + 1];
        const d_z = vertices[indexD * 3 + 2];
        if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
          return [
            new Vector2(a_x, 1 - a_z),
            new Vector2(b_x, 1 - b_z),
            new Vector2(c_x, 1 - c_z),
            new Vector2(d_x, 1 - d_z)
          ];
        } else {
          return [
            new Vector2(a_y, 1 - a_z),
            new Vector2(b_y, 1 - b_z),
            new Vector2(c_y, 1 - c_z),
            new Vector2(d_y, 1 - d_z)
          ];
        }
      }
    };
    IcosahedronGeometry = class extends PolyhedronGeometry {
      constructor(radius = 1, detail = 0) {
        const t2 = (1 + Math.sqrt(5)) / 2;
        const vertices = [
          -1,
          t2,
          0,
          1,
          t2,
          0,
          -1,
          -t2,
          0,
          1,
          -t2,
          0,
          0,
          -1,
          t2,
          0,
          1,
          t2,
          0,
          -1,
          -t2,
          0,
          1,
          -t2,
          t2,
          0,
          -1,
          t2,
          0,
          1,
          -t2,
          0,
          -1,
          -t2,
          0,
          1
        ];
        const indices = [
          0,
          11,
          5,
          0,
          5,
          1,
          0,
          1,
          7,
          0,
          7,
          10,
          0,
          10,
          11,
          1,
          5,
          9,
          5,
          11,
          4,
          11,
          10,
          2,
          10,
          7,
          6,
          7,
          1,
          8,
          3,
          9,
          4,
          3,
          4,
          2,
          3,
          2,
          6,
          3,
          6,
          8,
          3,
          8,
          9,
          4,
          9,
          5,
          2,
          4,
          11,
          6,
          2,
          10,
          8,
          6,
          7,
          9,
          8,
          1
        ];
        super(vertices, indices, radius, detail);
        this.type = "IcosahedronGeometry";
        this.parameters = {
          radius,
          detail
        };
      }
      static fromJSON(data) {
        return new IcosahedronGeometry(data.radius, data.detail);
      }
    };
    OctahedronGeometry = class extends PolyhedronGeometry {
      constructor(radius = 1, detail = 0) {
        const vertices = [
          1,
          0,
          0,
          -1,
          0,
          0,
          0,
          1,
          0,
          0,
          -1,
          0,
          0,
          0,
          1,
          0,
          0,
          -1
        ];
        const indices = [
          0,
          2,
          4,
          0,
          4,
          3,
          0,
          3,
          5,
          0,
          5,
          2,
          1,
          2,
          5,
          1,
          5,
          3,
          1,
          3,
          4,
          1,
          4,
          2
        ];
        super(vertices, indices, radius, detail);
        this.type = "OctahedronGeometry";
        this.parameters = {
          radius,
          detail
        };
      }
      static fromJSON(data) {
        return new OctahedronGeometry(data.radius, data.detail);
      }
    };
    RingGeometry = class extends BufferGeometry {
      constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {
        super();
        this.type = "RingGeometry";
        this.parameters = {
          innerRadius,
          outerRadius,
          thetaSegments,
          phiSegments,
          thetaStart,
          thetaLength
        };
        thetaSegments = Math.max(3, thetaSegments);
        phiSegments = Math.max(1, phiSegments);
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        let radius = innerRadius;
        const radiusStep = (outerRadius - innerRadius) / phiSegments;
        const vertex2 = new Vector3();
        const uv = new Vector2();
        for (let j = 0; j <= phiSegments; j++) {
          for (let i2 = 0; i2 <= thetaSegments; i2++) {
            const segment = thetaStart + i2 / thetaSegments * thetaLength;
            vertex2.x = radius * Math.cos(segment);
            vertex2.y = radius * Math.sin(segment);
            vertices.push(vertex2.x, vertex2.y, vertex2.z);
            normals.push(0, 0, 1);
            uv.x = (vertex2.x / outerRadius + 1) / 2;
            uv.y = (vertex2.y / outerRadius + 1) / 2;
            uvs.push(uv.x, uv.y);
          }
          radius += radiusStep;
        }
        for (let j = 0; j < phiSegments; j++) {
          const thetaSegmentLevel = j * (thetaSegments + 1);
          for (let i2 = 0; i2 < thetaSegments; i2++) {
            const segment = i2 + thetaSegmentLevel;
            const a = segment;
            const b2 = segment + thetaSegments + 1;
            const c = segment + thetaSegments + 2;
            const d2 = segment + 1;
            indices.push(a, b2, d2);
            indices.push(b2, c, d2);
          }
        }
        this.setIndex(indices);
        this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
      }
      static fromJSON(data) {
        return new RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
      }
    };
    ShapeGeometry = class extends BufferGeometry {
      constructor(shapes = new Shape([new Vector2(0, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), curveSegments = 12) {
        super();
        this.type = "ShapeGeometry";
        this.parameters = {
          shapes,
          curveSegments
        };
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        let groupStart = 0;
        let groupCount = 0;
        if (Array.isArray(shapes) === false) {
          addShape(shapes);
        } else {
          for (let i2 = 0; i2 < shapes.length; i2++) {
            addShape(shapes[i2]);
            this.addGroup(groupStart, groupCount, i2);
            groupStart += groupCount;
            groupCount = 0;
          }
        }
        this.setIndex(indices);
        this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        function addShape(shape) {
          const indexOffset = vertices.length / 3;
          const points = shape.extractPoints(curveSegments);
          let shapeVertices = points.shape;
          const shapeHoles = points.holes;
          if (ShapeUtils.isClockWise(shapeVertices) === false) {
            shapeVertices = shapeVertices.reverse();
          }
          for (let i2 = 0, l = shapeHoles.length; i2 < l; i2++) {
            const shapeHole = shapeHoles[i2];
            if (ShapeUtils.isClockWise(shapeHole) === true) {
              shapeHoles[i2] = shapeHole.reverse();
            }
          }
          const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
          for (let i2 = 0, l = shapeHoles.length; i2 < l; i2++) {
            const shapeHole = shapeHoles[i2];
            shapeVertices = shapeVertices.concat(shapeHole);
          }
          for (let i2 = 0, l = shapeVertices.length; i2 < l; i2++) {
            const vertex2 = shapeVertices[i2];
            vertices.push(vertex2.x, vertex2.y, 0);
            normals.push(0, 0, 1);
            uvs.push(vertex2.x, vertex2.y);
          }
          for (let i2 = 0, l = faces.length; i2 < l; i2++) {
            const face2 = faces[i2];
            const a = face2[0] + indexOffset;
            const b2 = face2[1] + indexOffset;
            const c = face2[2] + indexOffset;
            indices.push(a, b2, c);
            groupCount += 3;
          }
        }
      }
      toJSON() {
        const data = super.toJSON();
        const shapes = this.parameters.shapes;
        return toJSON(shapes, data);
      }
      static fromJSON(data, shapes) {
        const geometryShapes = [];
        for (let j = 0, jl = data.shapes.length; j < jl; j++) {
          const shape = shapes[data.shapes[j]];
          geometryShapes.push(shape);
        }
        return new ShapeGeometry(geometryShapes, data.curveSegments);
      }
    };
    SphereGeometry = class extends BufferGeometry {
      constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
        super();
        this.type = "SphereGeometry";
        this.parameters = {
          radius,
          widthSegments,
          heightSegments,
          phiStart,
          phiLength,
          thetaStart,
          thetaLength
        };
        widthSegments = Math.max(3, Math.floor(widthSegments));
        heightSegments = Math.max(2, Math.floor(heightSegments));
        const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
        let index = 0;
        const grid = [];
        const vertex2 = new Vector3();
        const normal2 = new Vector3();
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        for (let iy = 0; iy <= heightSegments; iy++) {
          const verticesRow = [];
          const v = iy / heightSegments;
          let uOffset = 0;
          if (iy == 0 && thetaStart == 0) {
            uOffset = 0.5 / widthSegments;
          } else if (iy == heightSegments && thetaEnd == Math.PI) {
            uOffset = -0.5 / widthSegments;
          }
          for (let ix = 0; ix <= widthSegments; ix++) {
            const u = ix / widthSegments;
            vertex2.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
            vertex2.y = radius * Math.cos(thetaStart + v * thetaLength);
            vertex2.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
            vertices.push(vertex2.x, vertex2.y, vertex2.z);
            normal2.copy(vertex2).normalize();
            normals.push(normal2.x, normal2.y, normal2.z);
            uvs.push(u + uOffset, 1 - v);
            verticesRow.push(index++);
          }
          grid.push(verticesRow);
        }
        for (let iy = 0; iy < heightSegments; iy++) {
          for (let ix = 0; ix < widthSegments; ix++) {
            const a = grid[iy][ix + 1];
            const b2 = grid[iy][ix];
            const c = grid[iy + 1][ix];
            const d2 = grid[iy + 1][ix + 1];
            if (iy !== 0 || thetaStart > 0)
              indices.push(a, b2, d2);
            if (iy !== heightSegments - 1 || thetaEnd < Math.PI)
              indices.push(b2, c, d2);
          }
        }
        this.setIndex(indices);
        this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
      }
      static fromJSON(data) {
        return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
      }
    };
    TetrahedronGeometry = class extends PolyhedronGeometry {
      constructor(radius = 1, detail = 0) {
        const vertices = [
          1,
          1,
          1,
          -1,
          -1,
          1,
          -1,
          1,
          -1,
          1,
          -1,
          -1
        ];
        const indices = [
          2,
          1,
          0,
          0,
          3,
          2,
          1,
          3,
          0,
          2,
          3,
          1
        ];
        super(vertices, indices, radius, detail);
        this.type = "TetrahedronGeometry";
        this.parameters = {
          radius,
          detail
        };
      }
      static fromJSON(data) {
        return new TetrahedronGeometry(data.radius, data.detail);
      }
    };
    TorusGeometry = class extends BufferGeometry {
      constructor(radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2) {
        super();
        this.type = "TorusGeometry";
        this.parameters = {
          radius,
          tube,
          radialSegments,
          tubularSegments,
          arc
        };
        radialSegments = Math.floor(radialSegments);
        tubularSegments = Math.floor(tubularSegments);
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        const center = new Vector3();
        const vertex2 = new Vector3();
        const normal2 = new Vector3();
        for (let j = 0; j <= radialSegments; j++) {
          for (let i2 = 0; i2 <= tubularSegments; i2++) {
            const u = i2 / tubularSegments * arc;
            const v = j / radialSegments * Math.PI * 2;
            vertex2.x = (radius + tube * Math.cos(v)) * Math.cos(u);
            vertex2.y = (radius + tube * Math.cos(v)) * Math.sin(u);
            vertex2.z = tube * Math.sin(v);
            vertices.push(vertex2.x, vertex2.y, vertex2.z);
            center.x = radius * Math.cos(u);
            center.y = radius * Math.sin(u);
            normal2.subVectors(vertex2, center).normalize();
            normals.push(normal2.x, normal2.y, normal2.z);
            uvs.push(i2 / tubularSegments);
            uvs.push(j / radialSegments);
          }
        }
        for (let j = 1; j <= radialSegments; j++) {
          for (let i2 = 1; i2 <= tubularSegments; i2++) {
            const a = (tubularSegments + 1) * j + i2 - 1;
            const b2 = (tubularSegments + 1) * (j - 1) + i2 - 1;
            const c = (tubularSegments + 1) * (j - 1) + i2;
            const d2 = (tubularSegments + 1) * j + i2;
            indices.push(a, b2, d2);
            indices.push(b2, c, d2);
          }
        }
        this.setIndex(indices);
        this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
      }
      static fromJSON(data) {
        return new TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
      }
    };
    TorusKnotGeometry = class extends BufferGeometry {
      constructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3) {
        super();
        this.type = "TorusKnotGeometry";
        this.parameters = {
          radius,
          tube,
          tubularSegments,
          radialSegments,
          p,
          q
        };
        tubularSegments = Math.floor(tubularSegments);
        radialSegments = Math.floor(radialSegments);
        const indices = [];
        const vertices = [];
        const normals = [];
        const uvs = [];
        const vertex2 = new Vector3();
        const normal2 = new Vector3();
        const P1 = new Vector3();
        const P2 = new Vector3();
        const B = new Vector3();
        const T = new Vector3();
        const N = new Vector3();
        for (let i2 = 0; i2 <= tubularSegments; ++i2) {
          const u = i2 / tubularSegments * p * Math.PI * 2;
          calculatePositionOnCurve(u, p, q, radius, P1);
          calculatePositionOnCurve(u + 0.01, p, q, radius, P2);
          T.subVectors(P2, P1);
          N.addVectors(P2, P1);
          B.crossVectors(T, N);
          N.crossVectors(B, T);
          B.normalize();
          N.normalize();
          for (let j = 0; j <= radialSegments; ++j) {
            const v = j / radialSegments * Math.PI * 2;
            const cx = -tube * Math.cos(v);
            const cy = tube * Math.sin(v);
            vertex2.x = P1.x + (cx * N.x + cy * B.x);
            vertex2.y = P1.y + (cx * N.y + cy * B.y);
            vertex2.z = P1.z + (cx * N.z + cy * B.z);
            vertices.push(vertex2.x, vertex2.y, vertex2.z);
            normal2.subVectors(vertex2, P1).normalize();
            normals.push(normal2.x, normal2.y, normal2.z);
            uvs.push(i2 / tubularSegments);
            uvs.push(j / radialSegments);
          }
        }
        for (let j = 1; j <= tubularSegments; j++) {
          for (let i2 = 1; i2 <= radialSegments; i2++) {
            const a = (radialSegments + 1) * (j - 1) + (i2 - 1);
            const b2 = (radialSegments + 1) * j + (i2 - 1);
            const c = (radialSegments + 1) * j + i2;
            const d2 = (radialSegments + 1) * (j - 1) + i2;
            indices.push(a, b2, d2);
            indices.push(b2, c, d2);
          }
        }
        this.setIndex(indices);
        this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        function calculatePositionOnCurve(u, p2, q2, radius2, position) {
          const cu = Math.cos(u);
          const su = Math.sin(u);
          const quOverP = q2 / p2 * u;
          const cs = Math.cos(quOverP);
          position.x = radius2 * (2 + cs) * 0.5 * cu;
          position.y = radius2 * (2 + cs) * su * 0.5;
          position.z = radius2 * Math.sin(quOverP) * 0.5;
        }
      }
      static fromJSON(data) {
        return new TorusKnotGeometry(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
      }
    };
    TubeGeometry = class extends BufferGeometry {
      constructor(path = new QuadraticBezierCurve3(new Vector3(-1, -1, 0), new Vector3(-1, 1, 0), new Vector3(1, 1, 0)), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {
        super();
        this.type = "TubeGeometry";
        this.parameters = {
          path,
          tubularSegments,
          radius,
          radialSegments,
          closed
        };
        const frames = path.computeFrenetFrames(tubularSegments, closed);
        this.tangents = frames.tangents;
        this.normals = frames.normals;
        this.binormals = frames.binormals;
        const vertex2 = new Vector3();
        const normal2 = new Vector3();
        const uv = new Vector2();
        let P = new Vector3();
        const vertices = [];
        const normals = [];
        const uvs = [];
        const indices = [];
        generateBufferData();
        this.setIndex(indices);
        this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
        this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
        function generateBufferData() {
          for (let i2 = 0; i2 < tubularSegments; i2++) {
            generateSegment(i2);
          }
          generateSegment(closed === false ? tubularSegments : 0);
          generateUVs();
          generateIndices();
        }
        function generateSegment(i2) {
          P = path.getPointAt(i2 / tubularSegments, P);
          const N = frames.normals[i2];
          const B = frames.binormals[i2];
          for (let j = 0; j <= radialSegments; j++) {
            const v = j / radialSegments * Math.PI * 2;
            const sin = Math.sin(v);
            const cos = -Math.cos(v);
            normal2.x = cos * N.x + sin * B.x;
            normal2.y = cos * N.y + sin * B.y;
            normal2.z = cos * N.z + sin * B.z;
            normal2.normalize();
            normals.push(normal2.x, normal2.y, normal2.z);
            vertex2.x = P.x + radius * normal2.x;
            vertex2.y = P.y + radius * normal2.y;
            vertex2.z = P.z + radius * normal2.z;
            vertices.push(vertex2.x, vertex2.y, vertex2.z);
          }
        }
        function generateIndices() {
          for (let j = 1; j <= tubularSegments; j++) {
            for (let i2 = 1; i2 <= radialSegments; i2++) {
              const a = (radialSegments + 1) * (j - 1) + (i2 - 1);
              const b2 = (radialSegments + 1) * j + (i2 - 1);
              const c = (radialSegments + 1) * j + i2;
              const d2 = (radialSegments + 1) * (j - 1) + i2;
              indices.push(a, b2, d2);
              indices.push(b2, c, d2);
            }
          }
        }
        function generateUVs() {
          for (let i2 = 0; i2 <= tubularSegments; i2++) {
            for (let j = 0; j <= radialSegments; j++) {
              uv.x = i2 / tubularSegments;
              uv.y = j / radialSegments;
              uvs.push(uv.x, uv.y);
            }
          }
        }
      }
      toJSON() {
        const data = super.toJSON();
        data.path = this.parameters.path.toJSON();
        return data;
      }
      static fromJSON(data) {
        return new TubeGeometry(new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
      }
    };
    WireframeGeometry = class extends BufferGeometry {
      constructor(geometry = null) {
        super();
        this.type = "WireframeGeometry";
        this.parameters = {
          geometry
        };
        if (geometry !== null) {
          const vertices = [];
          const edges = /* @__PURE__ */ new Set();
          const start = new Vector3();
          const end = new Vector3();
          if (geometry.index !== null) {
            const position = geometry.attributes.position;
            const indices = geometry.index;
            let groups = geometry.groups;
            if (groups.length === 0) {
              groups = [{ start: 0, count: indices.count, materialIndex: 0 }];
            }
            for (let o2 = 0, ol = groups.length; o2 < ol; ++o2) {
              const group = groups[o2];
              const groupStart = group.start;
              const groupCount = group.count;
              for (let i2 = groupStart, l = groupStart + groupCount; i2 < l; i2 += 3) {
                for (let j = 0; j < 3; j++) {
                  const index1 = indices.getX(i2 + j);
                  const index2 = indices.getX(i2 + (j + 1) % 3);
                  start.fromBufferAttribute(position, index1);
                  end.fromBufferAttribute(position, index2);
                  if (isUniqueEdge(start, end, edges) === true) {
                    vertices.push(start.x, start.y, start.z);
                    vertices.push(end.x, end.y, end.z);
                  }
                }
              }
            }
          } else {
            const position = geometry.attributes.position;
            for (let i2 = 0, l = position.count / 3; i2 < l; i2++) {
              for (let j = 0; j < 3; j++) {
                const index1 = 3 * i2 + j;
                const index2 = 3 * i2 + (j + 1) % 3;
                start.fromBufferAttribute(position, index1);
                end.fromBufferAttribute(position, index2);
                if (isUniqueEdge(start, end, edges) === true) {
                  vertices.push(start.x, start.y, start.z);
                  vertices.push(end.x, end.y, end.z);
                }
              }
            }
          }
          this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        }
      }
    };
    Geometries = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      BoxGeometry,
      BoxBufferGeometry: BoxGeometry,
      CapsuleGeometry,
      CapsuleBufferGeometry: CapsuleGeometry,
      CircleGeometry,
      CircleBufferGeometry: CircleGeometry,
      ConeGeometry,
      ConeBufferGeometry: ConeGeometry,
      CylinderGeometry,
      CylinderBufferGeometry: CylinderGeometry,
      DodecahedronGeometry,
      DodecahedronBufferGeometry: DodecahedronGeometry,
      EdgesGeometry,
      ExtrudeGeometry,
      ExtrudeBufferGeometry: ExtrudeGeometry,
      IcosahedronGeometry,
      IcosahedronBufferGeometry: IcosahedronGeometry,
      LatheGeometry,
      LatheBufferGeometry: LatheGeometry,
      OctahedronGeometry,
      OctahedronBufferGeometry: OctahedronGeometry,
      PlaneGeometry,
      PlaneBufferGeometry: PlaneGeometry,
      PolyhedronGeometry,
      PolyhedronBufferGeometry: PolyhedronGeometry,
      RingGeometry,
      RingBufferGeometry: RingGeometry,
      ShapeGeometry,
      ShapeBufferGeometry: ShapeGeometry,
      SphereGeometry,
      SphereBufferGeometry: SphereGeometry,
      TetrahedronGeometry,
      TetrahedronBufferGeometry: TetrahedronGeometry,
      TorusGeometry,
      TorusBufferGeometry: TorusGeometry,
      TorusKnotGeometry,
      TorusKnotBufferGeometry: TorusKnotGeometry,
      TubeGeometry,
      TubeBufferGeometry: TubeGeometry,
      WireframeGeometry
    });
    ShadowMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.type = "ShadowMaterial";
        this.color = new Color(0);
        this.transparent = true;
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        return this;
      }
    };
    ShadowMaterial.prototype.isShadowMaterial = true;
    RawShaderMaterial = class extends ShaderMaterial {
      constructor(parameters) {
        super(parameters);
        this.type = "RawShaderMaterial";
      }
    };
    RawShaderMaterial.prototype.isRawShaderMaterial = true;
    MeshStandardMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.defines = { "STANDARD": "" };
        this.type = "MeshStandardMaterial";
        this.color = new Color(16777215);
        this.roughness = 1;
        this.metalness = 0;
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new Color(0);
        this.emissiveIntensity = 1;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.roughnessMap = null;
        this.metalnessMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.envMapIntensity = 1;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = "round";
        this.wireframeLinejoin = "round";
        this.flatShading = false;
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.defines = { "STANDARD": "" };
        this.color.copy(source.color);
        this.roughness = source.roughness;
        this.metalness = source.metalness;
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.roughnessMap = source.roughnessMap;
        this.metalnessMap = source.metalnessMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.envMapIntensity = source.envMapIntensity;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.flatShading = source.flatShading;
        return this;
      }
    };
    MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
    MeshPhysicalMaterial = class extends MeshStandardMaterial {
      constructor(parameters) {
        super();
        this.defines = {
          "STANDARD": "",
          "PHYSICAL": ""
        };
        this.type = "MeshPhysicalMaterial";
        this.clearcoatMap = null;
        this.clearcoatRoughness = 0;
        this.clearcoatRoughnessMap = null;
        this.clearcoatNormalScale = new Vector2(1, 1);
        this.clearcoatNormalMap = null;
        this.ior = 1.5;
        Object.defineProperty(this, "reflectivity", {
          get: function() {
            return clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
          },
          set: function(reflectivity) {
            this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
          }
        });
        this.sheenColor = new Color(0);
        this.sheenColorMap = null;
        this.sheenRoughness = 1;
        this.sheenRoughnessMap = null;
        this.transmissionMap = null;
        this.thickness = 0;
        this.thicknessMap = null;
        this.attenuationDistance = 0;
        this.attenuationColor = new Color(1, 1, 1);
        this.specularIntensity = 1;
        this.specularIntensityMap = null;
        this.specularColor = new Color(1, 1, 1);
        this.specularColorMap = null;
        this._sheen = 0;
        this._clearcoat = 0;
        this._transmission = 0;
        this.setValues(parameters);
      }
      get sheen() {
        return this._sheen;
      }
      set sheen(value) {
        if (this._sheen > 0 !== value > 0) {
          this.version++;
        }
        this._sheen = value;
      }
      get clearcoat() {
        return this._clearcoat;
      }
      set clearcoat(value) {
        if (this._clearcoat > 0 !== value > 0) {
          this.version++;
        }
        this._clearcoat = value;
      }
      get transmission() {
        return this._transmission;
      }
      set transmission(value) {
        if (this._transmission > 0 !== value > 0) {
          this.version++;
        }
        this._transmission = value;
      }
      copy(source) {
        super.copy(source);
        this.defines = {
          "STANDARD": "",
          "PHYSICAL": ""
        };
        this.clearcoat = source.clearcoat;
        this.clearcoatMap = source.clearcoatMap;
        this.clearcoatRoughness = source.clearcoatRoughness;
        this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
        this.clearcoatNormalMap = source.clearcoatNormalMap;
        this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
        this.ior = source.ior;
        this.sheen = source.sheen;
        this.sheenColor.copy(source.sheenColor);
        this.sheenColorMap = source.sheenColorMap;
        this.sheenRoughness = source.sheenRoughness;
        this.sheenRoughnessMap = source.sheenRoughnessMap;
        this.transmission = source.transmission;
        this.transmissionMap = source.transmissionMap;
        this.thickness = source.thickness;
        this.thicknessMap = source.thicknessMap;
        this.attenuationDistance = source.attenuationDistance;
        this.attenuationColor.copy(source.attenuationColor);
        this.specularIntensity = source.specularIntensity;
        this.specularIntensityMap = source.specularIntensityMap;
        this.specularColor.copy(source.specularColor);
        this.specularColorMap = source.specularColorMap;
        return this;
      }
    };
    MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
    MeshPhongMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.type = "MeshPhongMaterial";
        this.color = new Color(16777215);
        this.specular = new Color(1118481);
        this.shininess = 30;
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new Color(0);
        this.emissiveIntensity = 1;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = "round";
        this.wireframeLinejoin = "round";
        this.flatShading = false;
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.specular.copy(source.specular);
        this.shininess = source.shininess;
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.flatShading = source.flatShading;
        return this;
      }
    };
    MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
    MeshToonMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.defines = { "TOON": "" };
        this.type = "MeshToonMaterial";
        this.color = new Color(16777215);
        this.map = null;
        this.gradientMap = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new Color(0);
        this.emissiveIntensity = 1;
        this.emissiveMap = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.alphaMap = null;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = "round";
        this.wireframeLinejoin = "round";
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.map = source.map;
        this.gradientMap = source.gradientMap;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.alphaMap = source.alphaMap;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        return this;
      }
    };
    MeshToonMaterial.prototype.isMeshToonMaterial = true;
    MeshNormalMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.type = "MeshNormalMaterial";
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.fog = false;
        this.flatShading = false;
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.flatShading = source.flatShading;
        return this;
      }
    };
    MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
    MeshLambertMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.type = "MeshLambertMaterial";
        this.color = new Color(16777215);
        this.map = null;
        this.lightMap = null;
        this.lightMapIntensity = 1;
        this.aoMap = null;
        this.aoMapIntensity = 1;
        this.emissive = new Color(0);
        this.emissiveIntensity = 1;
        this.emissiveMap = null;
        this.specularMap = null;
        this.alphaMap = null;
        this.envMap = null;
        this.combine = MultiplyOperation;
        this.reflectivity = 1;
        this.refractionRatio = 0.98;
        this.wireframe = false;
        this.wireframeLinewidth = 1;
        this.wireframeLinecap = "round";
        this.wireframeLinejoin = "round";
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        return this;
      }
    };
    MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
    MeshMatcapMaterial = class extends Material {
      constructor(parameters) {
        super();
        this.defines = { "MATCAP": "" };
        this.type = "MeshMatcapMaterial";
        this.color = new Color(16777215);
        this.matcap = null;
        this.map = null;
        this.bumpMap = null;
        this.bumpScale = 1;
        this.normalMap = null;
        this.normalMapType = TangentSpaceNormalMap;
        this.normalScale = new Vector2(1, 1);
        this.displacementMap = null;
        this.displacementScale = 1;
        this.displacementBias = 0;
        this.alphaMap = null;
        this.flatShading = false;
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.defines = { "MATCAP": "" };
        this.color.copy(source.color);
        this.matcap = source.matcap;
        this.map = source.map;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.alphaMap = source.alphaMap;
        this.flatShading = source.flatShading;
        return this;
      }
    };
    MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
    LineDashedMaterial = class extends LineBasicMaterial {
      constructor(parameters) {
        super();
        this.type = "LineDashedMaterial";
        this.scale = 1;
        this.dashSize = 3;
        this.gapSize = 1;
        this.setValues(parameters);
      }
      copy(source) {
        super.copy(source);
        this.scale = source.scale;
        this.dashSize = source.dashSize;
        this.gapSize = source.gapSize;
        return this;
      }
    };
    LineDashedMaterial.prototype.isLineDashedMaterial = true;
    materialLib = {
      ShadowMaterial,
      SpriteMaterial,
      RawShaderMaterial,
      ShaderMaterial,
      PointsMaterial,
      MeshPhysicalMaterial,
      MeshStandardMaterial,
      MeshPhongMaterial,
      MeshToonMaterial,
      MeshNormalMaterial,
      MeshLambertMaterial,
      MeshDepthMaterial,
      MeshDistanceMaterial,
      MeshBasicMaterial,
      MeshMatcapMaterial,
      LineDashedMaterial,
      LineBasicMaterial,
      Material
    };
    Material.fromType = function(type) {
      return new materialLib[type]();
    };
    AnimationUtils = {
      arraySlice: function(array, from2, to) {
        if (AnimationUtils.isTypedArray(array)) {
          return new array.constructor(array.subarray(from2, to !== void 0 ? to : array.length));
        }
        return array.slice(from2, to);
      },
      convertArray: function(array, type, forceClone) {
        if (!array || !forceClone && array.constructor === type)
          return array;
        if (typeof type.BYTES_PER_ELEMENT === "number") {
          return new type(array);
        }
        return Array.prototype.slice.call(array);
      },
      isTypedArray: function(object) {
        return ArrayBuffer.isView(object) && !(object instanceof DataView);
      },
      getKeyframeOrder: function(times) {
        function compareTime(i2, j) {
          return times[i2] - times[j];
        }
        const n = times.length;
        const result = new Array(n);
        for (let i2 = 0; i2 !== n; ++i2)
          result[i2] = i2;
        result.sort(compareTime);
        return result;
      },
      sortedArray: function(values, stride, order) {
        const nValues = values.length;
        const result = new values.constructor(nValues);
        for (let i2 = 0, dstOffset = 0; dstOffset !== nValues; ++i2) {
          const srcOffset = order[i2] * stride;
          for (let j = 0; j !== stride; ++j) {
            result[dstOffset++] = values[srcOffset + j];
          }
        }
        return result;
      },
      flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
        let i2 = 1, key = jsonKeys[0];
        while (key !== void 0 && key[valuePropertyName] === void 0) {
          key = jsonKeys[i2++];
        }
        if (key === void 0)
          return;
        let value = key[valuePropertyName];
        if (value === void 0)
          return;
        if (Array.isArray(value)) {
          do {
            value = key[valuePropertyName];
            if (value !== void 0) {
              times.push(key.time);
              values.push.apply(values, value);
            }
            key = jsonKeys[i2++];
          } while (key !== void 0);
        } else if (value.toArray !== void 0) {
          do {
            value = key[valuePropertyName];
            if (value !== void 0) {
              times.push(key.time);
              value.toArray(values, values.length);
            }
            key = jsonKeys[i2++];
          } while (key !== void 0);
        } else {
          do {
            value = key[valuePropertyName];
            if (value !== void 0) {
              times.push(key.time);
              values.push(value);
            }
            key = jsonKeys[i2++];
          } while (key !== void 0);
        }
      },
      subclip: function(sourceClip, name, startFrame, endFrame, fps = 30) {
        const clip = sourceClip.clone();
        clip.name = name;
        const tracks = [];
        for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
          const track = clip.tracks[i2];
          const valueSize = track.getValueSize();
          const times = [];
          const values = [];
          for (let j = 0; j < track.times.length; ++j) {
            const frame = track.times[j] * fps;
            if (frame < startFrame || frame >= endFrame)
              continue;
            times.push(track.times[j]);
            for (let k = 0; k < valueSize; ++k) {
              values.push(track.values[j * valueSize + k]);
            }
          }
          if (times.length === 0)
            continue;
          track.times = AnimationUtils.convertArray(times, track.times.constructor);
          track.values = AnimationUtils.convertArray(values, track.values.constructor);
          tracks.push(track);
        }
        clip.tracks = tracks;
        let minStartTime = Infinity;
        for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
          if (minStartTime > clip.tracks[i2].times[0]) {
            minStartTime = clip.tracks[i2].times[0];
          }
        }
        for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
          clip.tracks[i2].shift(-1 * minStartTime);
        }
        clip.resetDuration();
        return clip;
      },
      makeClipAdditive: function(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
        if (fps <= 0)
          fps = 30;
        const numTracks = referenceClip.tracks.length;
        const referenceTime = referenceFrame / fps;
        for (let i2 = 0; i2 < numTracks; ++i2) {
          const referenceTrack = referenceClip.tracks[i2];
          const referenceTrackType = referenceTrack.ValueTypeName;
          if (referenceTrackType === "bool" || referenceTrackType === "string")
            continue;
          const targetTrack = targetClip.tracks.find(function(track) {
            return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
          });
          if (targetTrack === void 0)
            continue;
          let referenceOffset = 0;
          const referenceValueSize = referenceTrack.getValueSize();
          if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
            referenceOffset = referenceValueSize / 3;
          }
          let targetOffset = 0;
          const targetValueSize = targetTrack.getValueSize();
          if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
            targetOffset = targetValueSize / 3;
          }
          const lastIndex = referenceTrack.times.length - 1;
          let referenceValue;
          if (referenceTime <= referenceTrack.times[0]) {
            const startIndex = referenceOffset;
            const endIndex = referenceValueSize - referenceOffset;
            referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
          } else if (referenceTime >= referenceTrack.times[lastIndex]) {
            const startIndex = lastIndex * referenceValueSize + referenceOffset;
            const endIndex = startIndex + referenceValueSize - referenceOffset;
            referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);
          } else {
            const interpolant = referenceTrack.createInterpolant();
            const startIndex = referenceOffset;
            const endIndex = referenceValueSize - referenceOffset;
            interpolant.evaluate(referenceTime);
            referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);
          }
          if (referenceTrackType === "quaternion") {
            const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
            referenceQuat.toArray(referenceValue);
          }
          const numTimes = targetTrack.times.length;
          for (let j = 0; j < numTimes; ++j) {
            const valueStart = j * targetValueSize + targetOffset;
            if (referenceTrackType === "quaternion") {
              Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
            } else {
              const valueEnd = targetValueSize - targetOffset * 2;
              for (let k = 0; k < valueEnd; ++k) {
                targetTrack.values[valueStart + k] -= referenceValue[k];
              }
            }
          }
        }
        targetClip.blendMode = AdditiveAnimationBlendMode;
        return targetClip;
      }
    };
    Interpolant = class {
      constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        this.parameterPositions = parameterPositions;
        this._cachedIndex = 0;
        this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
        this.sampleValues = sampleValues;
        this.valueSize = sampleSize;
        this.settings = null;
        this.DefaultSettings_ = {};
      }
      evaluate(t2) {
        const pp = this.parameterPositions;
        let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
        validate_interval: {
          seek: {
            let right;
            linear_scan: {
              forward_scan:
                if (!(t2 < t1)) {
                  for (let giveUpAt = i1 + 2; ; ) {
                    if (t1 === void 0) {
                      if (t2 < t0)
                        break forward_scan;
                      i1 = pp.length;
                      this._cachedIndex = i1;
                      return this.afterEnd_(i1 - 1, t2, t0);
                    }
                    if (i1 === giveUpAt)
                      break;
                    t0 = t1;
                    t1 = pp[++i1];
                    if (t2 < t1) {
                      break seek;
                    }
                  }
                  right = pp.length;
                  break linear_scan;
                }
              if (!(t2 >= t0)) {
                const t1global = pp[1];
                if (t2 < t1global) {
                  i1 = 2;
                  t0 = t1global;
                }
                for (let giveUpAt = i1 - 2; ; ) {
                  if (t0 === void 0) {
                    this._cachedIndex = 0;
                    return this.beforeStart_(0, t2, t1);
                  }
                  if (i1 === giveUpAt)
                    break;
                  t1 = t0;
                  t0 = pp[--i1 - 1];
                  if (t2 >= t0) {
                    break seek;
                  }
                }
                right = i1;
                i1 = 0;
                break linear_scan;
              }
              break validate_interval;
            }
            while (i1 < right) {
              const mid = i1 + right >>> 1;
              if (t2 < pp[mid]) {
                right = mid;
              } else {
                i1 = mid + 1;
              }
            }
            t1 = pp[i1];
            t0 = pp[i1 - 1];
            if (t0 === void 0) {
              this._cachedIndex = 0;
              return this.beforeStart_(0, t2, t1);
            }
            if (t1 === void 0) {
              i1 = pp.length;
              this._cachedIndex = i1;
              return this.afterEnd_(i1 - 1, t0, t2);
            }
          }
          this._cachedIndex = i1;
          this.intervalChanged_(i1, t0, t1);
        }
        return this.interpolate_(i1, t0, t2, t1);
      }
      getSettings_() {
        return this.settings || this.DefaultSettings_;
      }
      copySampleValue_(index) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
        for (let i2 = 0; i2 !== stride; ++i2) {
          result[i2] = values[offset + i2];
        }
        return result;
      }
      interpolate_() {
        throw new Error("call to abstract method");
      }
      intervalChanged_() {
      }
    };
    Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;
    Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;
    CubicInterpolant = class extends Interpolant {
      constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        super(parameterPositions, sampleValues, sampleSize, resultBuffer);
        this._weightPrev = -0;
        this._offsetPrev = -0;
        this._weightNext = -0;
        this._offsetNext = -0;
        this.DefaultSettings_ = {
          endingStart: ZeroCurvatureEnding,
          endingEnd: ZeroCurvatureEnding
        };
      }
      intervalChanged_(i1, t0, t1) {
        const pp = this.parameterPositions;
        let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
        if (tPrev === void 0) {
          switch (this.getSettings_().endingStart) {
            case ZeroSlopeEnding:
              iPrev = i1;
              tPrev = 2 * t0 - t1;
              break;
            case WrapAroundEnding:
              iPrev = pp.length - 2;
              tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
              break;
            default:
              iPrev = i1;
              tPrev = t1;
          }
        }
        if (tNext === void 0) {
          switch (this.getSettings_().endingEnd) {
            case ZeroSlopeEnding:
              iNext = i1;
              tNext = 2 * t1 - t0;
              break;
            case WrapAroundEnding:
              iNext = 1;
              tNext = t1 + pp[1] - pp[0];
              break;
            default:
              iNext = i1 - 1;
              tNext = t0;
          }
        }
        const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
        this._weightPrev = halfDt / (t0 - tPrev);
        this._weightNext = halfDt / (tNext - t1);
        this._offsetPrev = iPrev * stride;
        this._offsetNext = iNext * stride;
      }
      interpolate_(i1, t0, t2, t1) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t2 - t0) / (t1 - t0), pp = p * p, ppp = pp * p;
        const sP = -wP * ppp + 2 * wP * pp - wP * p;
        const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
        const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
        const sN = wN * ppp - wN * pp;
        for (let i2 = 0; i2 !== stride; ++i2) {
          result[i2] = sP * values[oP + i2] + s0 * values[o0 + i2] + s1 * values[o1 + i2] + sN * values[oN + i2];
        }
        return result;
      }
    };
    LinearInterpolant = class extends Interpolant {
      constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        super(parameterPositions, sampleValues, sampleSize, resultBuffer);
      }
      interpolate_(i1, t0, t2, t1) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t2 - t0) / (t1 - t0), weight0 = 1 - weight1;
        for (let i2 = 0; i2 !== stride; ++i2) {
          result[i2] = values[offset0 + i2] * weight0 + values[offset1 + i2] * weight1;
        }
        return result;
      }
    };
    DiscreteInterpolant = class extends Interpolant {
      constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        super(parameterPositions, sampleValues, sampleSize, resultBuffer);
      }
      interpolate_(i1) {
        return this.copySampleValue_(i1 - 1);
      }
    };
    KeyframeTrack = class {
      constructor(name, times, values, interpolation) {
        if (name === void 0)
          throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (times === void 0 || times.length === 0)
          throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
        this.name = name;
        this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
        this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
        this.setInterpolation(interpolation || this.DefaultInterpolation);
      }
      static toJSON(track) {
        const trackType = track.constructor;
        let json;
        if (trackType.toJSON !== this.toJSON) {
          json = trackType.toJSON(track);
        } else {
          json = {
            "name": track.name,
            "times": AnimationUtils.convertArray(track.times, Array),
            "values": AnimationUtils.convertArray(track.values, Array)
          };
          const interpolation = track.getInterpolation();
          if (interpolation !== track.DefaultInterpolation) {
            json.interpolation = interpolation;
          }
        }
        json.type = track.ValueTypeName;
        return json;
      }
      InterpolantFactoryMethodDiscrete(result) {
        return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
      }
      InterpolantFactoryMethodLinear(result) {
        return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
      }
      InterpolantFactoryMethodSmooth(result) {
        return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
      }
      setInterpolation(interpolation) {
        let factoryMethod;
        switch (interpolation) {
          case InterpolateDiscrete:
            factoryMethod = this.InterpolantFactoryMethodDiscrete;
            break;
          case InterpolateLinear:
            factoryMethod = this.InterpolantFactoryMethodLinear;
            break;
          case InterpolateSmooth:
            factoryMethod = this.InterpolantFactoryMethodSmooth;
            break;
        }
        if (factoryMethod === void 0) {
          const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
          if (this.createInterpolant === void 0) {
            if (interpolation !== this.DefaultInterpolation) {
              this.setInterpolation(this.DefaultInterpolation);
            } else {
              throw new Error(message);
            }
          }
          console.warn("THREE.KeyframeTrack:", message);
          return this;
        }
        this.createInterpolant = factoryMethod;
        return this;
      }
      getInterpolation() {
        switch (this.createInterpolant) {
          case this.InterpolantFactoryMethodDiscrete:
            return InterpolateDiscrete;
          case this.InterpolantFactoryMethodLinear:
            return InterpolateLinear;
          case this.InterpolantFactoryMethodSmooth:
            return InterpolateSmooth;
        }
      }
      getValueSize() {
        return this.values.length / this.times.length;
      }
      shift(timeOffset) {
        if (timeOffset !== 0) {
          const times = this.times;
          for (let i2 = 0, n = times.length; i2 !== n; ++i2) {
            times[i2] += timeOffset;
          }
        }
        return this;
      }
      scale(timeScale) {
        if (timeScale !== 1) {
          const times = this.times;
          for (let i2 = 0, n = times.length; i2 !== n; ++i2) {
            times[i2] *= timeScale;
          }
        }
        return this;
      }
      trim(startTime, endTime) {
        const times = this.times, nKeys = times.length;
        let from2 = 0, to = nKeys - 1;
        while (from2 !== nKeys && times[from2] < startTime) {
          ++from2;
        }
        while (to !== -1 && times[to] > endTime) {
          --to;
        }
        ++to;
        if (from2 !== 0 || to !== nKeys) {
          if (from2 >= to) {
            to = Math.max(to, 1);
            from2 = to - 1;
          }
          const stride = this.getValueSize();
          this.times = AnimationUtils.arraySlice(times, from2, to);
          this.values = AnimationUtils.arraySlice(this.values, from2 * stride, to * stride);
        }
        return this;
      }
      validate() {
        let valid = true;
        const valueSize = this.getValueSize();
        if (valueSize - Math.floor(valueSize) !== 0) {
          console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
          valid = false;
        }
        const times = this.times, values = this.values, nKeys = times.length;
        if (nKeys === 0) {
          console.error("THREE.KeyframeTrack: Track is empty.", this);
          valid = false;
        }
        let prevTime = null;
        for (let i2 = 0; i2 !== nKeys; i2++) {
          const currTime = times[i2];
          if (typeof currTime === "number" && isNaN(currTime)) {
            console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i2, currTime);
            valid = false;
            break;
          }
          if (prevTime !== null && prevTime > currTime) {
            console.error("THREE.KeyframeTrack: Out of order keys.", this, i2, currTime, prevTime);
            valid = false;
            break;
          }
          prevTime = currTime;
        }
        if (values !== void 0) {
          if (AnimationUtils.isTypedArray(values)) {
            for (let i2 = 0, n = values.length; i2 !== n; ++i2) {
              const value = values[i2];
              if (isNaN(value)) {
                console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i2, value);
                valid = false;
                break;
              }
            }
          }
        }
        return valid;
      }
      optimize() {
        const times = AnimationUtils.arraySlice(this.times), values = AnimationUtils.arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
        let writeIndex = 1;
        for (let i2 = 1; i2 < lastIndex; ++i2) {
          let keep = false;
          const time = times[i2];
          const timeNext = times[i2 + 1];
          if (time !== timeNext && (i2 !== 1 || time !== times[0])) {
            if (!smoothInterpolation) {
              const offset = i2 * stride, offsetP = offset - stride, offsetN = offset + stride;
              for (let j = 0; j !== stride; ++j) {
                const value = values[offset + j];
                if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
                  keep = true;
                  break;
                }
              }
            } else {
              keep = true;
            }
          }
          if (keep) {
            if (i2 !== writeIndex) {
              times[writeIndex] = times[i2];
              const readOffset = i2 * stride, writeOffset = writeIndex * stride;
              for (let j = 0; j !== stride; ++j) {
                values[writeOffset + j] = values[readOffset + j];
              }
            }
            ++writeIndex;
          }
        }
        if (lastIndex > 0) {
          times[writeIndex] = times[lastIndex];
          for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
            values[writeOffset + j] = values[readOffset + j];
          }
          ++writeIndex;
        }
        if (writeIndex !== times.length) {
          this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
          this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
        } else {
          this.times = times;
          this.values = values;
        }
        return this;
      }
      clone() {
        const times = AnimationUtils.arraySlice(this.times, 0);
        const values = AnimationUtils.arraySlice(this.values, 0);
        const TypedKeyframeTrack = this.constructor;
        const track = new TypedKeyframeTrack(this.name, times, values);
        track.createInterpolant = this.createInterpolant;
        return track;
      }
    };
    KeyframeTrack.prototype.TimeBufferType = Float32Array;
    KeyframeTrack.prototype.ValueBufferType = Float32Array;
    KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
    BooleanKeyframeTrack = class extends KeyframeTrack {
    };
    BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
    BooleanKeyframeTrack.prototype.ValueBufferType = Array;
    BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
    BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
    BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
    ColorKeyframeTrack = class extends KeyframeTrack {
    };
    ColorKeyframeTrack.prototype.ValueTypeName = "color";
    NumberKeyframeTrack = class extends KeyframeTrack {
    };
    NumberKeyframeTrack.prototype.ValueTypeName = "number";
    QuaternionLinearInterpolant = class extends Interpolant {
      constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
        super(parameterPositions, sampleValues, sampleSize, resultBuffer);
      }
      interpolate_(i1, t0, t2, t1) {
        const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t2 - t0) / (t1 - t0);
        let offset = i1 * stride;
        for (let end = offset + stride; offset !== end; offset += 4) {
          Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
        }
        return result;
      }
    };
    QuaternionKeyframeTrack = class extends KeyframeTrack {
      InterpolantFactoryMethodLinear(result) {
        return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
      }
    };
    QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
    QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
    QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
    StringKeyframeTrack = class extends KeyframeTrack {
    };
    StringKeyframeTrack.prototype.ValueTypeName = "string";
    StringKeyframeTrack.prototype.ValueBufferType = Array;
    StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
    StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
    StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
    VectorKeyframeTrack = class extends KeyframeTrack {
    };
    VectorKeyframeTrack.prototype.ValueTypeName = "vector";
    AnimationClip = class {
      constructor(name, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {
        this.name = name;
        this.tracks = tracks;
        this.duration = duration;
        this.blendMode = blendMode;
        this.uuid = generateUUID();
        if (this.duration < 0) {
          this.resetDuration();
        }
      }
      static parse(json) {
        const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
        for (let i2 = 0, n = jsonTracks.length; i2 !== n; ++i2) {
          tracks.push(parseKeyframeTrack(jsonTracks[i2]).scale(frameTime));
        }
        const clip = new this(json.name, json.duration, tracks, json.blendMode);
        clip.uuid = json.uuid;
        return clip;
      }
      static toJSON(clip) {
        const tracks = [], clipTracks = clip.tracks;
        const json = {
          "name": clip.name,
          "duration": clip.duration,
          "tracks": tracks,
          "uuid": clip.uuid,
          "blendMode": clip.blendMode
        };
        for (let i2 = 0, n = clipTracks.length; i2 !== n; ++i2) {
          tracks.push(KeyframeTrack.toJSON(clipTracks[i2]));
        }
        return json;
      }
      static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
        const numMorphTargets = morphTargetSequence.length;
        const tracks = [];
        for (let i2 = 0; i2 < numMorphTargets; i2++) {
          let times = [];
          let values = [];
          times.push((i2 + numMorphTargets - 1) % numMorphTargets, i2, (i2 + 1) % numMorphTargets);
          values.push(0, 1, 0);
          const order = AnimationUtils.getKeyframeOrder(times);
          times = AnimationUtils.sortedArray(times, 1, order);
          values = AnimationUtils.sortedArray(values, 1, order);
          if (!noLoop && times[0] === 0) {
            times.push(numMorphTargets);
            values.push(values[0]);
          }
          tracks.push(new NumberKeyframeTrack(".morphTargetInfluences[" + morphTargetSequence[i2].name + "]", times, values).scale(1 / fps));
        }
        return new this(name, -1, tracks);
      }
      static findByName(objectOrClipArray, name) {
        let clipArray = objectOrClipArray;
        if (!Array.isArray(objectOrClipArray)) {
          const o2 = objectOrClipArray;
          clipArray = o2.geometry && o2.geometry.animations || o2.animations;
        }
        for (let i2 = 0; i2 < clipArray.length; i2++) {
          if (clipArray[i2].name === name) {
            return clipArray[i2];
          }
        }
        return null;
      }
      static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
        const animationToMorphTargets = {};
        const pattern = /^([\w-]*?)([\d]+)$/;
        for (let i2 = 0, il = morphTargets.length; i2 < il; i2++) {
          const morphTarget = morphTargets[i2];
          const parts = morphTarget.name.match(pattern);
          if (parts && parts.length > 1) {
            const name = parts[1];
            let animationMorphTargets = animationToMorphTargets[name];
            if (!animationMorphTargets) {
              animationToMorphTargets[name] = animationMorphTargets = [];
            }
            animationMorphTargets.push(morphTarget);
          }
        }
        const clips = [];
        for (const name in animationToMorphTargets) {
          clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
        }
        return clips;
      }
      static parseAnimation(animation, bones) {
        if (!animation) {
          console.error("THREE.AnimationClip: No animation in JSONLoader data.");
          return null;
        }
        const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
          if (animationKeys.length !== 0) {
            const times = [];
            const values = [];
            AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
            if (times.length !== 0) {
              destTracks.push(new trackType(trackName, times, values));
            }
          }
        };
        const tracks = [];
        const clipName = animation.name || "default";
        const fps = animation.fps || 30;
        const blendMode = animation.blendMode;
        let duration = animation.length || -1;
        const hierarchyTracks = animation.hierarchy || [];
        for (let h = 0; h < hierarchyTracks.length; h++) {
          const animationKeys = hierarchyTracks[h].keys;
          if (!animationKeys || animationKeys.length === 0)
            continue;
          if (animationKeys[0].morphTargets) {
            const morphTargetNames = {};
            let k;
            for (k = 0; k < animationKeys.length; k++) {
              if (animationKeys[k].morphTargets) {
                for (let m = 0; m < animationKeys[k].morphTargets.length; m++) {
                  morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
                }
              }
            }
            for (const morphTargetName in morphTargetNames) {
              const times = [];
              const values = [];
              for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
                const animationKey = animationKeys[k];
                times.push(animationKey.time);
                values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
              }
              tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
            }
            duration = morphTargetNames.length * fps;
          } else {
            const boneName = ".bones[" + bones[h].name + "]";
            addNonemptyTrack(VectorKeyframeTrack, boneName + ".position", animationKeys, "pos", tracks);
            addNonemptyTrack(QuaternionKeyframeTrack, boneName + ".quaternion", animationKeys, "rot", tracks);
            addNonemptyTrack(VectorKeyframeTrack, boneName + ".scale", animationKeys, "scl", tracks);
          }
        }
        if (tracks.length === 0) {
          return null;
        }
        const clip = new this(clipName, duration, tracks, blendMode);
        return clip;
      }
      resetDuration() {
        const tracks = this.tracks;
        let duration = 0;
        for (let i2 = 0, n = tracks.length; i2 !== n; ++i2) {
          const track = this.tracks[i2];
          duration = Math.max(duration, track.times[track.times.length - 1]);
        }
        this.duration = duration;
        return this;
      }
      trim() {
        for (let i2 = 0; i2 < this.tracks.length; i2++) {
          this.tracks[i2].trim(0, this.duration);
        }
        return this;
      }
      validate() {
        let valid = true;
        for (let i2 = 0; i2 < this.tracks.length; i2++) {
          valid = valid && this.tracks[i2].validate();
        }
        return valid;
      }
      optimize() {
        for (let i2 = 0; i2 < this.tracks.length; i2++) {
          this.tracks[i2].optimize();
        }
        return this;
      }
      clone() {
        const tracks = [];
        for (let i2 = 0; i2 < this.tracks.length; i2++) {
          tracks.push(this.tracks[i2].clone());
        }
        return new this.constructor(this.name, this.duration, tracks, this.blendMode);
      }
      toJSON() {
        return this.constructor.toJSON(this);
      }
    };
    Cache = {
      enabled: false,
      files: {},
      add: function(key, file) {
        if (this.enabled === false)
          return;
        this.files[key] = file;
      },
      get: function(key) {
        if (this.enabled === false)
          return;
        return this.files[key];
      },
      remove: function(key) {
        delete this.files[key];
      },
      clear: function() {
        this.files = {};
      }
    };
    LoadingManager = class {
      constructor(onLoad, onProgress, onError) {
        const scope = this;
        let isLoading = false;
        let itemsLoaded = 0;
        let itemsTotal = 0;
        let urlModifier = void 0;
        const handlers = [];
        this.onStart = void 0;
        this.onLoad = onLoad;
        this.onProgress = onProgress;
        this.onError = onError;
        this.itemStart = function(url) {
          itemsTotal++;
          if (isLoading === false) {
            if (scope.onStart !== void 0) {
              scope.onStart(url, itemsLoaded, itemsTotal);
            }
          }
          isLoading = true;
        };
        this.itemEnd = function(url) {
          itemsLoaded++;
          if (scope.onProgress !== void 0) {
            scope.onProgress(url, itemsLoaded, itemsTotal);
          }
          if (itemsLoaded === itemsTotal) {
            isLoading = false;
            if (scope.onLoad !== void 0) {
              scope.onLoad();
            }
          }
        };
        this.itemError = function(url) {
          if (scope.onError !== void 0) {
            scope.onError(url);
          }
        };
        this.resolveURL = function(url) {
          if (urlModifier) {
            return urlModifier(url);
          }
          return url;
        };
        this.setURLModifier = function(transform) {
          urlModifier = transform;
          return this;
        };
        this.addHandler = function(regex, loader2) {
          handlers.push(regex, loader2);
          return this;
        };
        this.removeHandler = function(regex) {
          const index = handlers.indexOf(regex);
          if (index !== -1) {
            handlers.splice(index, 2);
          }
          return this;
        };
        this.getHandler = function(file) {
          for (let i2 = 0, l = handlers.length; i2 < l; i2 += 2) {
            const regex = handlers[i2];
            const loader2 = handlers[i2 + 1];
            if (regex.global)
              regex.lastIndex = 0;
            if (regex.test(file)) {
              return loader2;
            }
          }
          return null;
        };
      }
    };
    DefaultLoadingManager = new LoadingManager();
    Loader = class {
      constructor(manager) {
        this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
        this.crossOrigin = "anonymous";
        this.withCredentials = false;
        this.path = "";
        this.resourcePath = "";
        this.requestHeader = {};
      }
      load() {
      }
      loadAsync(url, onProgress) {
        const scope = this;
        return new Promise(function(resolve, reject) {
          scope.load(url, resolve, onProgress, reject);
        });
      }
      parse() {
      }
      setCrossOrigin(crossOrigin) {
        this.crossOrigin = crossOrigin;
        return this;
      }
      setWithCredentials(value) {
        this.withCredentials = value;
        return this;
      }
      setPath(path) {
        this.path = path;
        return this;
      }
      setResourcePath(resourcePath) {
        this.resourcePath = resourcePath;
        return this;
      }
      setRequestHeader(requestHeader) {
        this.requestHeader = requestHeader;
        return this;
      }
    };
    loading = {};
    FileLoader = class extends Loader {
      constructor(manager) {
        super(manager);
      }
      load(url, onLoad, onProgress, onError) {
        if (url === void 0)
          url = "";
        if (this.path !== void 0)
          url = this.path + url;
        url = this.manager.resolveURL(url);
        const cached = Cache.get(url);
        if (cached !== void 0) {
          this.manager.itemStart(url);
          setTimeout(() => {
            if (onLoad)
              onLoad(cached);
            this.manager.itemEnd(url);
          }, 0);
          return cached;
        }
        if (loading[url] !== void 0) {
          loading[url].push({
            onLoad,
            onProgress,
            onError
          });
          return;
        }
        loading[url] = [];
        loading[url].push({
          onLoad,
          onProgress,
          onError
        });
        const req = new Request(url, {
          headers: new Headers(this.requestHeader),
          credentials: this.withCredentials ? "include" : "same-origin"
        });
        const mimeType = this.mimeType;
        const responseType = this.responseType;
        fetch(req).then((response) => {
          if (response.status === 200 || response.status === 0) {
            if (response.status === 0) {
              console.warn("THREE.FileLoader: HTTP Status 0 received.");
            }
            if (typeof ReadableStream === "undefined" || response.body === void 0 || response.body.getReader === void 0) {
              return response;
            }
            const callbacks = loading[url];
            const reader = response.body.getReader();
            const contentLength = response.headers.get("Content-Length");
            const total = contentLength ? parseInt(contentLength) : 0;
            const lengthComputable = total !== 0;
            let loaded = 0;
            const stream = new ReadableStream({
              start(controller) {
                readData();
                function readData() {
                  reader.read().then(({ done, value }) => {
                    if (done) {
                      controller.close();
                    } else {
                      loaded += value.byteLength;
                      const event = new ProgressEvent("progress", { lengthComputable, loaded, total });
                      for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
                        const callback = callbacks[i2];
                        if (callback.onProgress)
                          callback.onProgress(event);
                      }
                      controller.enqueue(value);
                      readData();
                    }
                  });
                }
              }
            });
            return new Response(stream);
          } else {
            throw Error(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`);
          }
        }).then((response) => {
          switch (responseType) {
            case "arraybuffer":
              return response.arrayBuffer();
            case "blob":
              return response.blob();
            case "document":
              return response.text().then((text) => {
                const parser = new DOMParser();
                return parser.parseFromString(text, mimeType);
              });
            case "json":
              return response.json();
            default:
              if (mimeType === void 0) {
                return response.text();
              } else {
                const re = /charset="?([^;"\s]*)"?/i;
                const exec = re.exec(mimeType);
                const label = exec && exec[1] ? exec[1].toLowerCase() : void 0;
                const decoder = new TextDecoder(label);
                return response.arrayBuffer().then((ab) => decoder.decode(ab));
              }
          }
        }).then((data) => {
          Cache.add(url, data);
          const callbacks = loading[url];
          delete loading[url];
          for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
            const callback = callbacks[i2];
            if (callback.onLoad)
              callback.onLoad(data);
          }
        }).catch((err2) => {
          const callbacks = loading[url];
          if (callbacks === void 0) {
            this.manager.itemError(url);
            throw err2;
          }
          delete loading[url];
          for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
            const callback = callbacks[i2];
            if (callback.onError)
              callback.onError(err2);
          }
          this.manager.itemError(url);
        }).finally(() => {
          this.manager.itemEnd(url);
        });
        this.manager.itemStart(url);
      }
      setResponseType(value) {
        this.responseType = value;
        return this;
      }
      setMimeType(value) {
        this.mimeType = value;
        return this;
      }
    };
    AnimationLoader = class extends Loader {
      constructor(manager) {
        super(manager);
      }
      load(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader2 = new FileLoader(this.manager);
        loader2.setPath(this.path);
        loader2.setRequestHeader(this.requestHeader);
        loader2.setWithCredentials(this.withCredentials);
        loader2.load(url, function(text) {
          try {
            onLoad(scope.parse(JSON.parse(text)));
          } catch (e) {
            if (onError) {
              onError(e);
            } else {
              console.error(e);
            }
            scope.manager.itemError(url);
          }
        }, onProgress, onError);
      }
      parse(json) {
        const animations = [];
        for (let i2 = 0; i2 < json.length; i2++) {
          const clip = AnimationClip.parse(json[i2]);
          animations.push(clip);
        }
        return animations;
      }
    };
    CompressedTextureLoader = class extends Loader {
      constructor(manager) {
        super(manager);
      }
      load(url, onLoad, onProgress, onError) {
        const scope = this;
        const images = [];
        const texture = new CompressedTexture();
        const loader2 = new FileLoader(this.manager);
        loader2.setPath(this.path);
        loader2.setResponseType("arraybuffer");
        loader2.setRequestHeader(this.requestHeader);
        loader2.setWithCredentials(scope.withCredentials);
        let loaded = 0;
        function loadTexture(i2) {
          loader2.load(url[i2], function(buffer) {
            const texDatas = scope.parse(buffer, true);
            images[i2] = {
              width: texDatas.width,
              height: texDatas.height,
              format: texDatas.format,
              mipmaps: texDatas.mipmaps
            };
            loaded += 1;
            if (loaded === 6) {
              if (texDatas.mipmapCount === 1)
                texture.minFilter = LinearFilter;
              texture.image = images;
              texture.format = texDatas.format;
              texture.needsUpdate = true;
              if (onLoad)
                onLoad(texture);
            }
          }, onProgress, onError);
        }
        if (Array.isArray(url)) {
          for (let i2 = 0, il = url.length; i2 < il; ++i2) {
            loadTexture(i2);
          }
        } else {
          loader2.load(url, function(buffer) {
            const texDatas = scope.parse(buffer, true);
            if (texDatas.isCubemap) {
              const faces = texDatas.mipmaps.length / texDatas.mipmapCount;
              for (let f = 0; f < faces; f++) {
                images[f] = { mipmaps: [] };
                for (let i2 = 0; i2 < texDatas.mipmapCount; i2++) {
                  images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i2]);
                  images[f].format = texDatas.format;
                  images[f].width = texDatas.width;
                  images[f].height = texDatas.height;
                }
              }
              texture.image = images;
            } else {
              texture.image.width = texDatas.width;
              texture.image.height = texDatas.height;
              texture.mipmaps = texDatas.mipmaps;
            }
            if (texDatas.mipmapCount === 1) {
              texture.minFilter = LinearFilter;
            }
            texture.format = texDatas.format;
            texture.needsUpdate = true;
            if (onLoad)
              onLoad(texture);
          }, onProgress, onError);
        }
        return texture;
      }
    };
    ImageLoader = class extends Loader {
      constructor(manager) {
        super(manager);
      }
      load(url, onLoad, onProgress, onError) {
        if (this.path !== void 0)
          url = this.path + url;
        url = this.manager.resolveURL(url);
        const scope = this;
        const cached = Cache.get(url);
        if (cached !== void 0) {
          scope.manager.itemStart(url);
          setTimeout(function() {
            if (onLoad)
              onLoad(cached);
            scope.manager.itemEnd(url);
          }, 0);
          return cached;
        }
        const image = createElementNS("img");
        function onImageLoad() {
          removeEventListeners();
          Cache.add(url, this);
          if (onLoad)
            onLoad(this);
          scope.manager.itemEnd(url);
        }
        function onImageError(event) {
          removeEventListeners();
          if (onError)
            onError(event);
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }
        function removeEventListeners() {
          image.removeEventListener("load", onImageLoad, false);
          image.removeEventListener("error", onImageError, false);
        }
        image.addEventListener("load", onImageLoad, false);
        image.addEventListener("error", onImageError, false);
        if (url.slice(0, 5) !== "data:") {
          if (this.crossOrigin !== void 0)
            image.crossOrigin = this.crossOrigin;
        }
        scope.manager.itemStart(url);
        image.src = url;
        return image;
      }
    };
    CubeTextureLoader = class extends Loader {
      constructor(manager) {
        super(manager);
      }
      load(urls, onLoad, onProgress, onError) {
        const texture = new CubeTexture();
        const loader2 = new ImageLoader(this.manager);
        loader2.setCrossOrigin(this.crossOrigin);
        loader2.setPath(this.path);
        let loaded = 0;
        function loadTexture(i2) {
          loader2.load(urls[i2], function(image) {
            texture.images[i2] = image;
            loaded++;
            if (loaded === 6) {
              texture.needsUpdate = true;
              if (onLoad)
                onLoad(texture);
            }
          }, void 0, onError);
        }
        for (let i2 = 0; i2 < urls.length; ++i2) {
          loadTexture(i2);
        }
        return texture;
      }
    };
    DataTextureLoader = class extends Loader {
      constructor(manager) {
        super(manager);
      }
      load(url, onLoad, onProgress, onError) {
        const scope = this;
        const texture = new DataTexture();
        const loader2 = new FileLoader(this.manager);
        loader2.setResponseType("arraybuffer");
        loader2.setRequestHeader(this.requestHeader);
        loader2.setPath(this.path);
        loader2.setWithCredentials(scope.withCredentials);
        loader2.load(url, function(buffer) {
          const texData = scope.parse(buffer);
          if (!texData)
            return;
          if (texData.image !== void 0) {
            texture.image = texData.image;
          } else if (texData.data !== void 0) {
            texture.image.width = texData.width;
            texture.image.height = texData.height;
            texture.image.data = texData.data;
          }
          texture.wrapS = texData.wrapS !== void 0 ? texData.wrapS : ClampToEdgeWrapping;
          texture.wrapT = texData.wrapT !== void 0 ? texData.wrapT : ClampToEdgeWrapping;
          texture.magFilter = texData.magFilter !== void 0 ? texData.magFilter : LinearFilter;
          texture.minFilter = texData.minFilter !== void 0 ? texData.minFilter : LinearFilter;
          texture.anisotropy = texData.anisotropy !== void 0 ? texData.anisotropy : 1;
          if (texData.encoding !== void 0) {
            texture.encoding = texData.encoding;
          }
          if (texData.flipY !== void 0) {
            texture.flipY = texData.flipY;
          }
          if (texData.format !== void 0) {
            texture.format = texData.format;
          }
          if (texData.type !== void 0) {
            texture.type = texData.type;
          }
          if (texData.mipmaps !== void 0) {
            texture.mipmaps = texData.mipmaps;
            texture.minFilter = LinearMipmapLinearFilter;
          }
          if (texData.mipmapCount === 1) {
            texture.minFilter = LinearFilter;
          }
          if (texData.generateMipmaps !== void 0) {
            texture.generateMipmaps = texData.generateMipmaps;
          }
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture, texData);
        }, onProgress, onError);
        return texture;
      }
    };
    TextureLoader = class extends Loader {
      constructor(manager) {
        super(manager);
      }
      load(url, onLoad, onProgress, onError) {
        const texture = new Texture();
        const loader2 = new ImageLoader(this.manager);
        loader2.setCrossOrigin(this.crossOrigin);
        loader2.setPath(this.path);
        loader2.load(url, function(image) {
          texture.image = image;
          texture.needsUpdate = true;
          if (onLoad !== void 0) {
            onLoad(texture);
          }
        }, onProgress, onError);
        return texture;
      }
    };
    Light = class extends Object3D {
      constructor(color, intensity = 1) {
        super();
        this.type = "Light";
        this.color = new Color(color);
        this.intensity = intensity;
      }
      dispose() {
      }
      copy(source) {
        super.copy(source);
        this.color.copy(source.color);
        this.intensity = source.intensity;
        return this;
      }
      toJSON(meta) {
        const data = super.toJSON(meta);
        data.object.color = this.color.getHex();
        data.object.intensity = this.intensity;
        if (this.groundColor !== void 0)
          data.object.groundColor = this.groundColor.getHex();
        if (this.distance !== void 0)
          data.object.distance = this.distance;
        if (this.angle !== void 0)
          data.object.angle = this.angle;
        if (this.decay !== void 0)
          data.object.decay = this.decay;
        if (this.penumbra !== void 0)
          data.object.penumbra = this.penumbra;
        if (this.shadow !== void 0)
          data.object.shadow = this.shadow.toJSON();
        return data;
      }
    };
    Light.prototype.isLight = true;
    HemisphereLight = class extends Light {
      constructor(skyColor, groundColor, intensity) {
        super(skyColor, intensity);
        this.type = "HemisphereLight";
        this.position.copy(Object3D.DefaultUp);
        this.updateMatrix();
        this.groundColor = new Color(groundColor);
      }
      copy(source) {
        Light.prototype.copy.call(this, source);
        this.groundColor.copy(source.groundColor);
        return this;
      }
    };
    HemisphereLight.prototype.isHemisphereLight = true;
    _projScreenMatrix$1 = /* @__PURE__ */ new Matrix4();
    _lightPositionWorld$1 = /* @__PURE__ */ new Vector3();
    _lookTarget$1 = /* @__PURE__ */ new Vector3();
    LightShadow = class {
      constructor(camera) {
        this.camera = camera;
        this.bias = 0;
        this.normalBias = 0;
        this.radius = 1;
        this.blurSamples = 8;
        this.mapSize = new Vector2(512, 512);
        this.map = null;
        this.mapPass = null;
        this.matrix = new Matrix4();
        this.autoUpdate = true;
        this.needsUpdate = false;
        this._frustum = new Frustum();
        this._frameExtents = new Vector2(1, 1);
        this._viewportCount = 1;
        this._viewports = [
          new Vector4(0, 0, 1, 1)
        ];
      }
      getViewportCount() {
        return this._viewportCount;
      }
      getFrustum() {
        return this._frustum;
      }
      updateMatrices(light) {
        const shadowCamera = this.camera;
        const shadowMatrix = this.matrix;
        _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
        shadowCamera.position.copy(_lightPositionWorld$1);
        _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
        shadowCamera.lookAt(_lookTarget$1);
        shadowCamera.updateMatrixWorld();
        _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
        this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
        shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
        shadowMatrix.multiply(shadowCamera.projectionMatrix);
        shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
      }
      getViewport(viewportIndex) {
        return this._viewports[viewportIndex];
      }
      getFrameExtents() {
        return this._frameExtents;
      }
      dispose() {
        if (this.map) {
          this.map.dispose();
        }
        if (this.mapPass) {
          this.mapPass.dispose();
        }
      }
      copy(source) {
        this.camera = source.camera.clone();
        this.bias = source.bias;
        this.radius = source.radius;
        this.mapSize.copy(source.mapSize);
        return this;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      toJSON() {
        const object = {};
        if (this.bias !== 0)
          object.bias = this.bias;
        if (this.normalBias !== 0)
          object.normalBias = this.normalBias;
        if (this.radius !== 1)
          object.radius = this.radius;
        if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
          object.mapSize = this.mapSize.toArray();
        object.camera = this.camera.toJSON(false).object;
        delete object.camera.matrix;
        return object;
      }
    };
    SpotLightShadow = class extends LightShadow {
      constructor() {
        super(new PerspectiveCamera(50, 1, 0.5, 500));
        this.focus = 1;
      }
      updateMatrices(light) {
        const camera = this.camera;
        const fov2 = RAD2DEG * 2 * light.angle * this.focus;
        const aspect2 = this.mapSize.width / this.mapSize.height;
        const far = light.distance || camera.far;
        if (fov2 !== camera.fov || aspect2 !== camera.aspect || far !== camera.far) {
          camera.fov = fov2;
          camera.aspect = aspect2;
          camera.far = far;
          camera.updateProjectionMatrix();
        }
        super.updateMatrices(light);
      }
      copy(source) {
        super.copy(source);
        this.focus = source.focus;
        return this;
      }
    };
    SpotLightShadow.prototype.isSpotLightShadow = true;
    SpotLight = class extends Light {
      constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1) {
        super(color, intensity);
        this.type = "SpotLight";
        this.position.copy(Object3D.DefaultUp);
        this.updateMatrix();
        this.target = new Object3D();
        this.distance = distance;
        this.angle = angle;
        this.penumbra = penumbra;
        this.decay = decay;
        this.shadow = new SpotLightShadow();
      }
      get power() {
        return this.intensity * Math.PI;
      }
      set power(power) {
        this.intensity = power / Math.PI;
      }
      dispose() {
        this.shadow.dispose();
      }
      copy(source) {
        super.copy(source);
        this.distance = source.distance;
        this.angle = source.angle;
        this.penumbra = source.penumbra;
        this.decay = source.decay;
        this.target = source.target.clone();
        this.shadow = source.shadow.clone();
        return this;
      }
    };
    SpotLight.prototype.isSpotLight = true;
    _projScreenMatrix = /* @__PURE__ */ new Matrix4();
    _lightPositionWorld = /* @__PURE__ */ new Vector3();
    _lookTarget = /* @__PURE__ */ new Vector3();
    PointLightShadow = class extends LightShadow {
      constructor() {
        super(new PerspectiveCamera(90, 1, 0.5, 500));
        this._frameExtents = new Vector2(4, 2);
        this._viewportCount = 6;
        this._viewports = [
          new Vector4(2, 1, 1, 1),
          new Vector4(0, 1, 1, 1),
          new Vector4(3, 1, 1, 1),
          new Vector4(1, 1, 1, 1),
          new Vector4(3, 0, 1, 1),
          new Vector4(1, 0, 1, 1)
        ];
        this._cubeDirections = [
          new Vector3(1, 0, 0),
          new Vector3(-1, 0, 0),
          new Vector3(0, 0, 1),
          new Vector3(0, 0, -1),
          new Vector3(0, 1, 0),
          new Vector3(0, -1, 0)
        ];
        this._cubeUps = [
          new Vector3(0, 1, 0),
          new Vector3(0, 1, 0),
          new Vector3(0, 1, 0),
          new Vector3(0, 1, 0),
          new Vector3(0, 0, 1),
          new Vector3(0, 0, -1)
        ];
      }
      updateMatrices(light, viewportIndex = 0) {
        const camera = this.camera;
        const shadowMatrix = this.matrix;
        const far = light.distance || camera.far;
        if (far !== camera.far) {
          camera.far = far;
          camera.updateProjectionMatrix();
        }
        _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
        camera.position.copy(_lightPositionWorld);
        _lookTarget.copy(camera.position);
        _lookTarget.add(this._cubeDirections[viewportIndex]);
        camera.up.copy(this._cubeUps[viewportIndex]);
        camera.lookAt(_lookTarget);
        camera.updateMatrixWorld();
        shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
        _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        this._frustum.setFromProjectionMatrix(_projScreenMatrix);
      }
    };
    PointLightShadow.prototype.isPointLightShadow = true;
    PointLight = class extends Light {
      constructor(color, intensity, distance = 0, decay = 1) {
        super(color, intensity);
        this.type = "PointLight";
        this.distance = distance;
        this.decay = decay;
        this.shadow = new PointLightShadow();
      }
      get power() {
        return this.intensity * 4 * Math.PI;
      }
      set power(power) {
        this.intensity = power / (4 * Math.PI);
      }
      dispose() {
        this.shadow.dispose();
      }
      copy(source) {
        super.copy(source);
        this.distance = source.distance;
        this.decay = source.decay;
        this.shadow = source.shadow.clone();
        return this;
      }
    };
    PointLight.prototype.isPointLight = true;
    DirectionalLightShadow = class extends LightShadow {
      constructor() {
        super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
      }
    };
    DirectionalLightShadow.prototype.isDirectionalLightShadow = true;
    DirectionalLight = class extends Light {
      constructor(color, intensity) {
        super(color, intensity);
        this.type = "DirectionalLight";
        this.position.copy(Object3D.DefaultUp);
        this.updateMatrix();
        this.target = new Object3D();
        this.shadow = new DirectionalLightShadow();
      }
      dispose() {
        this.shadow.dispose();
      }
      copy(source) {
        super.copy(source);
        this.target = source.target.clone();
        this.shadow = source.shadow.clone();
        return this;
      }
    };
    DirectionalLight.prototype.isDirectionalLight = true;
    AmbientLight = class extends Light {
      constructor(color, intensity) {
        super(color, intensity);
        this.type = "AmbientLight";
      }
    };
    AmbientLight.prototype.isAmbientLight = true;
    RectAreaLight = class extends Light {
      constructor(color, intensity, width = 10, height = 10) {
        super(color, intensity);
        this.type = "RectAreaLight";
        this.width = width;
        this.height = height;
      }
      get power() {
        return this.intensity * this.width * this.height * Math.PI;
      }
      set power(power) {
        this.intensity = power / (this.width * this.height * Math.PI);
      }
      copy(source) {
        super.copy(source);
        this.width = source.width;
        this.height = source.height;
        return this;
      }
      toJSON(meta) {
        const data = super.toJSON(meta);
        data.object.width = this.width;
        data.object.height = this.height;
        return data;
      }
    };
    RectAreaLight.prototype.isRectAreaLight = true;
    SphericalHarmonics3 = class {
      constructor() {
        this.coefficients = [];
        for (let i2 = 0; i2 < 9; i2++) {
          this.coefficients.push(new Vector3());
        }
      }
      set(coefficients) {
        for (let i2 = 0; i2 < 9; i2++) {
          this.coefficients[i2].copy(coefficients[i2]);
        }
        return this;
      }
      zero() {
        for (let i2 = 0; i2 < 9; i2++) {
          this.coefficients[i2].set(0, 0, 0);
        }
        return this;
      }
      getAt(normal2, target) {
        const x = normal2.x, y2 = normal2.y, z = normal2.z;
        const coeff = this.coefficients;
        target.copy(coeff[0]).multiplyScalar(0.282095);
        target.addScaledVector(coeff[1], 0.488603 * y2);
        target.addScaledVector(coeff[2], 0.488603 * z);
        target.addScaledVector(coeff[3], 0.488603 * x);
        target.addScaledVector(coeff[4], 1.092548 * (x * y2));
        target.addScaledVector(coeff[5], 1.092548 * (y2 * z));
        target.addScaledVector(coeff[6], 0.315392 * (3 * z * z - 1));
        target.addScaledVector(coeff[7], 1.092548 * (x * z));
        target.addScaledVector(coeff[8], 0.546274 * (x * x - y2 * y2));
        return target;
      }
      getIrradianceAt(normal2, target) {
        const x = normal2.x, y2 = normal2.y, z = normal2.z;
        const coeff = this.coefficients;
        target.copy(coeff[0]).multiplyScalar(0.886227);
        target.addScaledVector(coeff[1], 2 * 0.511664 * y2);
        target.addScaledVector(coeff[2], 2 * 0.511664 * z);
        target.addScaledVector(coeff[3], 2 * 0.511664 * x);
        target.addScaledVector(coeff[4], 2 * 0.429043 * x * y2);
        target.addScaledVector(coeff[5], 2 * 0.429043 * y2 * z);
        target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708);
        target.addScaledVector(coeff[7], 2 * 0.429043 * x * z);
        target.addScaledVector(coeff[8], 0.429043 * (x * x - y2 * y2));
        return target;
      }
      add(sh) {
        for (let i2 = 0; i2 < 9; i2++) {
          this.coefficients[i2].add(sh.coefficients[i2]);
        }
        return this;
      }
      addScaledSH(sh, s) {
        for (let i2 = 0; i2 < 9; i2++) {
          this.coefficients[i2].addScaledVector(sh.coefficients[i2], s);
        }
        return this;
      }
      scale(s) {
        for (let i2 = 0; i2 < 9; i2++) {
          this.coefficients[i2].multiplyScalar(s);
        }
        return this;
      }
      lerp(sh, alpha) {
        for (let i2 = 0; i2 < 9; i2++) {
          this.coefficients[i2].lerp(sh.coefficients[i2], alpha);
        }
        return this;
      }
      equals(sh) {
        for (let i2 = 0; i2 < 9; i2++) {
          if (!this.coefficients[i2].equals(sh.coefficients[i2])) {
            return false;
          }
        }
        return true;
      }
      copy(sh) {
        return this.set(sh.coefficients);
      }
      clone() {
        return new this.constructor().copy(this);
      }
      fromArray(array, offset = 0) {
        const coefficients = this.coefficients;
        for (let i2 = 0; i2 < 9; i2++) {
          coefficients[i2].fromArray(array, offset + i2 * 3);
        }
        return this;
      }
      toArray(array = [], offset = 0) {
        const coefficients = this.coefficients;
        for (let i2 = 0; i2 < 9; i2++) {
          coefficients[i2].toArray(array, offset + i2 * 3);
        }
        return array;
      }
      static getBasisAt(normal2, shBasis) {
        const x = normal2.x, y2 = normal2.y, z = normal2.z;
        shBasis[0] = 0.282095;
        shBasis[1] = 0.488603 * y2;
        shBasis[2] = 0.488603 * z;
        shBasis[3] = 0.488603 * x;
        shBasis[4] = 1.092548 * x * y2;
        shBasis[5] = 1.092548 * y2 * z;
        shBasis[6] = 0.315392 * (3 * z * z - 1);
        shBasis[7] = 1.092548 * x * z;
        shBasis[8] = 0.546274 * (x * x - y2 * y2);
      }
    };
    SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;
    LightProbe = class extends Light {
      constructor(sh = new SphericalHarmonics3(), intensity = 1) {
        super(void 0, intensity);
        this.sh = sh;
      }
      copy(source) {
        super.copy(source);
        this.sh.copy(source.sh);
        return this;
      }
      fromJSON(json) {
        this.intensity = json.intensity;
        this.sh.fromArray(json.sh);
        return this;
      }
      toJSON(meta) {
        const data = super.toJSON(meta);
        data.object.sh = this.sh.toArray();
        return data;
      }
    };
    LightProbe.prototype.isLightProbe = true;
    MaterialLoader = class extends Loader {
      constructor(manager) {
        super(manager);
        this.textures = {};
      }
      load(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader2 = new FileLoader(scope.manager);
        loader2.setPath(scope.path);
        loader2.setRequestHeader(scope.requestHeader);
        loader2.setWithCredentials(scope.withCredentials);
        loader2.load(url, function(text) {
          try {
            onLoad(scope.parse(JSON.parse(text)));
          } catch (e) {
            if (onError) {
              onError(e);
            } else {
              console.error(e);
            }
            scope.manager.itemError(url);
          }
        }, onProgress, onError);
      }
      parse(json) {
        const textures = this.textures;
        function getTexture(name) {
          if (textures[name] === void 0) {
            console.warn("THREE.MaterialLoader: Undefined texture", name);
          }
          return textures[name];
        }
        const material = Material.fromType(json.type);
        if (json.uuid !== void 0)
          material.uuid = json.uuid;
        if (json.name !== void 0)
          material.name = json.name;
        if (json.color !== void 0 && material.color !== void 0)
          material.color.setHex(json.color);
        if (json.roughness !== void 0)
          material.roughness = json.roughness;
        if (json.metalness !== void 0)
          material.metalness = json.metalness;
        if (json.sheen !== void 0)
          material.sheen = json.sheen;
        if (json.sheenColor !== void 0)
          material.sheenColor = new Color().setHex(json.sheenColor);
        if (json.sheenRoughness !== void 0)
          material.sheenRoughness = json.sheenRoughness;
        if (json.emissive !== void 0 && material.emissive !== void 0)
          material.emissive.setHex(json.emissive);
        if (json.specular !== void 0 && material.specular !== void 0)
          material.specular.setHex(json.specular);
        if (json.specularIntensity !== void 0)
          material.specularIntensity = json.specularIntensity;
        if (json.specularColor !== void 0 && material.specularColor !== void 0)
          material.specularColor.setHex(json.specularColor);
        if (json.shininess !== void 0)
          material.shininess = json.shininess;
        if (json.clearcoat !== void 0)
          material.clearcoat = json.clearcoat;
        if (json.clearcoatRoughness !== void 0)
          material.clearcoatRoughness = json.clearcoatRoughness;
        if (json.transmission !== void 0)
          material.transmission = json.transmission;
        if (json.thickness !== void 0)
          material.thickness = json.thickness;
        if (json.attenuationDistance !== void 0)
          material.attenuationDistance = json.attenuationDistance;
        if (json.attenuationColor !== void 0 && material.attenuationColor !== void 0)
          material.attenuationColor.setHex(json.attenuationColor);
        if (json.fog !== void 0)
          material.fog = json.fog;
        if (json.flatShading !== void 0)
          material.flatShading = json.flatShading;
        if (json.blending !== void 0)
          material.blending = json.blending;
        if (json.combine !== void 0)
          material.combine = json.combine;
        if (json.side !== void 0)
          material.side = json.side;
        if (json.shadowSide !== void 0)
          material.shadowSide = json.shadowSide;
        if (json.opacity !== void 0)
          material.opacity = json.opacity;
        if (json.transparent !== void 0)
          material.transparent = json.transparent;
        if (json.alphaTest !== void 0)
          material.alphaTest = json.alphaTest;
        if (json.depthTest !== void 0)
          material.depthTest = json.depthTest;
        if (json.depthWrite !== void 0)
          material.depthWrite = json.depthWrite;
        if (json.colorWrite !== void 0)
          material.colorWrite = json.colorWrite;
        if (json.stencilWrite !== void 0)
          material.stencilWrite = json.stencilWrite;
        if (json.stencilWriteMask !== void 0)
          material.stencilWriteMask = json.stencilWriteMask;
        if (json.stencilFunc !== void 0)
          material.stencilFunc = json.stencilFunc;
        if (json.stencilRef !== void 0)
          material.stencilRef = json.stencilRef;
        if (json.stencilFuncMask !== void 0)
          material.stencilFuncMask = json.stencilFuncMask;
        if (json.stencilFail !== void 0)
          material.stencilFail = json.stencilFail;
        if (json.stencilZFail !== void 0)
          material.stencilZFail = json.stencilZFail;
        if (json.stencilZPass !== void 0)
          material.stencilZPass = json.stencilZPass;
        if (json.wireframe !== void 0)
          material.wireframe = json.wireframe;
        if (json.wireframeLinewidth !== void 0)
          material.wireframeLinewidth = json.wireframeLinewidth;
        if (json.wireframeLinecap !== void 0)
          material.wireframeLinecap = json.wireframeLinecap;
        if (json.wireframeLinejoin !== void 0)
          material.wireframeLinejoin = json.wireframeLinejoin;
        if (json.rotation !== void 0)
          material.rotation = json.rotation;
        if (json.linewidth !== 1)
          material.linewidth = json.linewidth;
        if (json.dashSize !== void 0)
          material.dashSize = json.dashSize;
        if (json.gapSize !== void 0)
          material.gapSize = json.gapSize;
        if (json.scale !== void 0)
          material.scale = json.scale;
        if (json.polygonOffset !== void 0)
          material.polygonOffset = json.polygonOffset;
        if (json.polygonOffsetFactor !== void 0)
          material.polygonOffsetFactor = json.polygonOffsetFactor;
        if (json.polygonOffsetUnits !== void 0)
          material.polygonOffsetUnits = json.polygonOffsetUnits;
        if (json.dithering !== void 0)
          material.dithering = json.dithering;
        if (json.alphaToCoverage !== void 0)
          material.alphaToCoverage = json.alphaToCoverage;
        if (json.premultipliedAlpha !== void 0)
          material.premultipliedAlpha = json.premultipliedAlpha;
        if (json.visible !== void 0)
          material.visible = json.visible;
        if (json.toneMapped !== void 0)
          material.toneMapped = json.toneMapped;
        if (json.userData !== void 0)
          material.userData = json.userData;
        if (json.vertexColors !== void 0) {
          if (typeof json.vertexColors === "number") {
            material.vertexColors = json.vertexColors > 0 ? true : false;
          } else {
            material.vertexColors = json.vertexColors;
          }
        }
        if (json.uniforms !== void 0) {
          for (const name in json.uniforms) {
            const uniform = json.uniforms[name];
            material.uniforms[name] = {};
            switch (uniform.type) {
              case "t":
                material.uniforms[name].value = getTexture(uniform.value);
                break;
              case "c":
                material.uniforms[name].value = new Color().setHex(uniform.value);
                break;
              case "v2":
                material.uniforms[name].value = new Vector2().fromArray(uniform.value);
                break;
              case "v3":
                material.uniforms[name].value = new Vector3().fromArray(uniform.value);
                break;
              case "v4":
                material.uniforms[name].value = new Vector4().fromArray(uniform.value);
                break;
              case "m3":
                material.uniforms[name].value = new Matrix3().fromArray(uniform.value);
                break;
              case "m4":
                material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
                break;
              default:
                material.uniforms[name].value = uniform.value;
            }
          }
        }
        if (json.defines !== void 0)
          material.defines = json.defines;
        if (json.vertexShader !== void 0)
          material.vertexShader = json.vertexShader;
        if (json.fragmentShader !== void 0)
          material.fragmentShader = json.fragmentShader;
        if (json.extensions !== void 0) {
          for (const key in json.extensions) {
            material.extensions[key] = json.extensions[key];
          }
        }
        if (json.shading !== void 0)
          material.flatShading = json.shading === 1;
        if (json.size !== void 0)
          material.size = json.size;
        if (json.sizeAttenuation !== void 0)
          material.sizeAttenuation = json.sizeAttenuation;
        if (json.map !== void 0)
          material.map = getTexture(json.map);
        if (json.matcap !== void 0)
          material.matcap = getTexture(json.matcap);
        if (json.alphaMap !== void 0)
          material.alphaMap = getTexture(json.alphaMap);
        if (json.bumpMap !== void 0)
          material.bumpMap = getTexture(json.bumpMap);
        if (json.bumpScale !== void 0)
          material.bumpScale = json.bumpScale;
        if (json.normalMap !== void 0)
          material.normalMap = getTexture(json.normalMap);
        if (json.normalMapType !== void 0)
          material.normalMapType = json.normalMapType;
        if (json.normalScale !== void 0) {
          let normalScale = json.normalScale;
          if (Array.isArray(normalScale) === false) {
            normalScale = [normalScale, normalScale];
          }
          material.normalScale = new Vector2().fromArray(normalScale);
        }
        if (json.displacementMap !== void 0)
          material.displacementMap = getTexture(json.displacementMap);
        if (json.displacementScale !== void 0)
          material.displacementScale = json.displacementScale;
        if (json.displacementBias !== void 0)
          material.displacementBias = json.displacementBias;
        if (json.roughnessMap !== void 0)
          material.roughnessMap = getTexture(json.roughnessMap);
        if (json.metalnessMap !== void 0)
          material.metalnessMap = getTexture(json.metalnessMap);
        if (json.emissiveMap !== void 0)
          material.emissiveMap = getTexture(json.emissiveMap);
        if (json.emissiveIntensity !== void 0)
          material.emissiveIntensity = json.emissiveIntensity;
        if (json.specularMap !== void 0)
          material.specularMap = getTexture(json.specularMap);
        if (json.specularIntensityMap !== void 0)
          material.specularIntensityMap = getTexture(json.specularIntensityMap);
        if (json.specularColorMap !== void 0)
          material.specularColorMap = getTexture(json.specularColorMap);
        if (json.envMap !== void 0)
          material.envMap = getTexture(json.envMap);
        if (json.envMapIntensity !== void 0)
          material.envMapIntensity = json.envMapIntensity;
        if (json.reflectivity !== void 0)
          material.reflectivity = json.reflectivity;
        if (json.refractionRatio !== void 0)
          material.refractionRatio = json.refractionRatio;
        if (json.lightMap !== void 0)
          material.lightMap = getTexture(json.lightMap);
        if (json.lightMapIntensity !== void 0)
          material.lightMapIntensity = json.lightMapIntensity;
        if (json.aoMap !== void 0)
          material.aoMap = getTexture(json.aoMap);
        if (json.aoMapIntensity !== void 0)
          material.aoMapIntensity = json.aoMapIntensity;
        if (json.gradientMap !== void 0)
          material.gradientMap = getTexture(json.gradientMap);
        if (json.clearcoatMap !== void 0)
          material.clearcoatMap = getTexture(json.clearcoatMap);
        if (json.clearcoatRoughnessMap !== void 0)
          material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
        if (json.clearcoatNormalMap !== void 0)
          material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
        if (json.clearcoatNormalScale !== void 0)
          material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
        if (json.transmissionMap !== void 0)
          material.transmissionMap = getTexture(json.transmissionMap);
        if (json.thicknessMap !== void 0)
          material.thicknessMap = getTexture(json.thicknessMap);
        if (json.sheenColorMap !== void 0)
          material.sheenColorMap = getTexture(json.sheenColorMap);
        if (json.sheenRoughnessMap !== void 0)
          material.sheenRoughnessMap = getTexture(json.sheenRoughnessMap);
        return material;
      }
      setTextures(value) {
        this.textures = value;
        return this;
      }
    };
    LoaderUtils = class {
      static decodeText(array) {
        if (typeof TextDecoder !== "undefined") {
          return new TextDecoder().decode(array);
        }
        let s = "";
        for (let i2 = 0, il = array.length; i2 < il; i2++) {
          s += String.fromCharCode(array[i2]);
        }
        try {
          return decodeURIComponent(escape(s));
        } catch (e) {
          return s;
        }
      }
      static extractUrlBase(url) {
        const index = url.lastIndexOf("/");
        if (index === -1)
          return "./";
        return url.slice(0, index + 1);
      }
      static resolveURL(url, path) {
        if (typeof url !== "string" || url === "")
          return "";
        if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
          path = path.replace(/(^https?:\/\/[^\/]+).*/i, "$1");
        }
        if (/^(https?:)?\/\//i.test(url))
          return url;
        if (/^data:.*,.*$/i.test(url))
          return url;
        if (/^blob:.*$/i.test(url))
          return url;
        return path + url;
      }
    };
    InstancedBufferGeometry = class extends BufferGeometry {
      constructor() {
        super();
        this.type = "InstancedBufferGeometry";
        this.instanceCount = Infinity;
      }
      copy(source) {
        super.copy(source);
        this.instanceCount = source.instanceCount;
        return this;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      toJSON() {
        const data = super.toJSON(this);
        data.instanceCount = this.instanceCount;
        data.isInstancedBufferGeometry = true;
        return data;
      }
    };
    InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;
    BufferGeometryLoader = class extends Loader {
      constructor(manager) {
        super(manager);
      }
      load(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader2 = new FileLoader(scope.manager);
        loader2.setPath(scope.path);
        loader2.setRequestHeader(scope.requestHeader);
        loader2.setWithCredentials(scope.withCredentials);
        loader2.load(url, function(text) {
          try {
            onLoad(scope.parse(JSON.parse(text)));
          } catch (e) {
            if (onError) {
              onError(e);
            } else {
              console.error(e);
            }
            scope.manager.itemError(url);
          }
        }, onProgress, onError);
      }
      parse(json) {
        const interleavedBufferMap = {};
        const arrayBufferMap = {};
        function getInterleavedBuffer(json2, uuid) {
          if (interleavedBufferMap[uuid] !== void 0)
            return interleavedBufferMap[uuid];
          const interleavedBuffers = json2.interleavedBuffers;
          const interleavedBuffer = interleavedBuffers[uuid];
          const buffer = getArrayBuffer(json2, interleavedBuffer.buffer);
          const array = getTypedArray(interleavedBuffer.type, buffer);
          const ib = new InterleavedBuffer(array, interleavedBuffer.stride);
          ib.uuid = interleavedBuffer.uuid;
          interleavedBufferMap[uuid] = ib;
          return ib;
        }
        function getArrayBuffer(json2, uuid) {
          if (arrayBufferMap[uuid] !== void 0)
            return arrayBufferMap[uuid];
          const arrayBuffers = json2.arrayBuffers;
          const arrayBuffer = arrayBuffers[uuid];
          const ab = new Uint32Array(arrayBuffer).buffer;
          arrayBufferMap[uuid] = ab;
          return ab;
        }
        const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
        const index = json.data.index;
        if (index !== void 0) {
          const typedArray = getTypedArray(index.type, index.array);
          geometry.setIndex(new BufferAttribute(typedArray, 1));
        }
        const attributes = json.data.attributes;
        for (const key in attributes) {
          const attribute = attributes[key];
          let bufferAttribute;
          if (attribute.isInterleavedBufferAttribute) {
            const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
            bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
          } else {
            const typedArray = getTypedArray(attribute.type, attribute.array);
            const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
            bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
          }
          if (attribute.name !== void 0)
            bufferAttribute.name = attribute.name;
          if (attribute.usage !== void 0)
            bufferAttribute.setUsage(attribute.usage);
          if (attribute.updateRange !== void 0) {
            bufferAttribute.updateRange.offset = attribute.updateRange.offset;
            bufferAttribute.updateRange.count = attribute.updateRange.count;
          }
          geometry.setAttribute(key, bufferAttribute);
        }
        const morphAttributes = json.data.morphAttributes;
        if (morphAttributes) {
          for (const key in morphAttributes) {
            const attributeArray = morphAttributes[key];
            const array = [];
            for (let i2 = 0, il = attributeArray.length; i2 < il; i2++) {
              const attribute = attributeArray[i2];
              let bufferAttribute;
              if (attribute.isInterleavedBufferAttribute) {
                const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
                bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
              } else {
                const typedArray = getTypedArray(attribute.type, attribute.array);
                bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
              }
              if (attribute.name !== void 0)
                bufferAttribute.name = attribute.name;
              array.push(bufferAttribute);
            }
            geometry.morphAttributes[key] = array;
          }
        }
        const morphTargetsRelative = json.data.morphTargetsRelative;
        if (morphTargetsRelative) {
          geometry.morphTargetsRelative = true;
        }
        const groups = json.data.groups || json.data.drawcalls || json.data.offsets;
        if (groups !== void 0) {
          for (let i2 = 0, n = groups.length; i2 !== n; ++i2) {
            const group = groups[i2];
            geometry.addGroup(group.start, group.count, group.materialIndex);
          }
        }
        const boundingSphere = json.data.boundingSphere;
        if (boundingSphere !== void 0) {
          const center = new Vector3();
          if (boundingSphere.center !== void 0) {
            center.fromArray(boundingSphere.center);
          }
          geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
        }
        if (json.name)
          geometry.name = json.name;
        if (json.userData)
          geometry.userData = json.userData;
        return geometry;
      }
    };
    ObjectLoader = class extends Loader {
      constructor(manager) {
        super(manager);
      }
      load(url, onLoad, onProgress, onError) {
        const scope = this;
        const path = this.path === "" ? LoaderUtils.extractUrlBase(url) : this.path;
        this.resourcePath = this.resourcePath || path;
        const loader2 = new FileLoader(this.manager);
        loader2.setPath(this.path);
        loader2.setRequestHeader(this.requestHeader);
        loader2.setWithCredentials(this.withCredentials);
        loader2.load(url, function(text) {
          let json = null;
          try {
            json = JSON.parse(text);
          } catch (error) {
            if (onError !== void 0)
              onError(error);
            console.error("THREE:ObjectLoader: Can't parse " + url + ".", error.message);
            return;
          }
          const metadata = json.metadata;
          if (metadata === void 0 || metadata.type === void 0 || metadata.type.toLowerCase() === "geometry") {
            console.error("THREE.ObjectLoader: Can't load " + url);
            return;
          }
          scope.parse(json, onLoad);
        }, onProgress, onError);
      }
      async loadAsync(url, onProgress) {
        const scope = this;
        const path = this.path === "" ? LoaderUtils.extractUrlBase(url) : this.path;
        this.resourcePath = this.resourcePath || path;
        const loader2 = new FileLoader(this.manager);
        loader2.setPath(this.path);
        loader2.setRequestHeader(this.requestHeader);
        loader2.setWithCredentials(this.withCredentials);
        const text = await loader2.loadAsync(url, onProgress);
        const json = JSON.parse(text);
        const metadata = json.metadata;
        if (metadata === void 0 || metadata.type === void 0 || metadata.type.toLowerCase() === "geometry") {
          throw new Error("THREE.ObjectLoader: Can't load " + url);
        }
        return await scope.parseAsync(json);
      }
      parse(json, onLoad) {
        const animations = this.parseAnimations(json.animations);
        const shapes = this.parseShapes(json.shapes);
        const geometries = this.parseGeometries(json.geometries, shapes);
        const images = this.parseImages(json.images, function() {
          if (onLoad !== void 0)
            onLoad(object);
        });
        const textures = this.parseTextures(json.textures, images);
        const materials = this.parseMaterials(json.materials, textures);
        const object = this.parseObject(json.object, geometries, materials, textures, animations);
        const skeletons = this.parseSkeletons(json.skeletons, object);
        this.bindSkeletons(object, skeletons);
        if (onLoad !== void 0) {
          let hasImages = false;
          for (const uuid in images) {
            if (images[uuid] instanceof HTMLImageElement) {
              hasImages = true;
              break;
            }
          }
          if (hasImages === false)
            onLoad(object);
        }
        return object;
      }
      async parseAsync(json) {
        const animations = this.parseAnimations(json.animations);
        const shapes = this.parseShapes(json.shapes);
        const geometries = this.parseGeometries(json.geometries, shapes);
        const images = await this.parseImagesAsync(json.images);
        const textures = this.parseTextures(json.textures, images);
        const materials = this.parseMaterials(json.materials, textures);
        const object = this.parseObject(json.object, geometries, materials, textures, animations);
        const skeletons = this.parseSkeletons(json.skeletons, object);
        this.bindSkeletons(object, skeletons);
        return object;
      }
      parseShapes(json) {
        const shapes = {};
        if (json !== void 0) {
          for (let i2 = 0, l = json.length; i2 < l; i2++) {
            const shape = new Shape().fromJSON(json[i2]);
            shapes[shape.uuid] = shape;
          }
        }
        return shapes;
      }
      parseSkeletons(json, object) {
        const skeletons = {};
        const bones = {};
        object.traverse(function(child) {
          if (child.isBone)
            bones[child.uuid] = child;
        });
        if (json !== void 0) {
          for (let i2 = 0, l = json.length; i2 < l; i2++) {
            const skeleton = new Skeleton().fromJSON(json[i2], bones);
            skeletons[skeleton.uuid] = skeleton;
          }
        }
        return skeletons;
      }
      parseGeometries(json, shapes) {
        const geometries = {};
        if (json !== void 0) {
          const bufferGeometryLoader = new BufferGeometryLoader();
          for (let i2 = 0, l = json.length; i2 < l; i2++) {
            let geometry;
            const data = json[i2];
            switch (data.type) {
              case "BufferGeometry":
              case "InstancedBufferGeometry":
                geometry = bufferGeometryLoader.parse(data);
                break;
              case "Geometry":
                console.error("THREE.ObjectLoader: The legacy Geometry type is no longer supported.");
                break;
              default:
                if (data.type in Geometries) {
                  geometry = Geometries[data.type].fromJSON(data, shapes);
                } else {
                  console.warn(`THREE.ObjectLoader: Unsupported geometry type "${data.type}"`);
                }
            }
            geometry.uuid = data.uuid;
            if (data.name !== void 0)
              geometry.name = data.name;
            if (geometry.isBufferGeometry === true && data.userData !== void 0)
              geometry.userData = data.userData;
            geometries[data.uuid] = geometry;
          }
        }
        return geometries;
      }
      parseMaterials(json, textures) {
        const cache = {};
        const materials = {};
        if (json !== void 0) {
          const loader2 = new MaterialLoader();
          loader2.setTextures(textures);
          for (let i2 = 0, l = json.length; i2 < l; i2++) {
            const data = json[i2];
            if (data.type === "MultiMaterial") {
              const array = [];
              for (let j = 0; j < data.materials.length; j++) {
                const material = data.materials[j];
                if (cache[material.uuid] === void 0) {
                  cache[material.uuid] = loader2.parse(material);
                }
                array.push(cache[material.uuid]);
              }
              materials[data.uuid] = array;
            } else {
              if (cache[data.uuid] === void 0) {
                cache[data.uuid] = loader2.parse(data);
              }
              materials[data.uuid] = cache[data.uuid];
            }
          }
        }
        return materials;
      }
      parseAnimations(json) {
        const animations = {};
        if (json !== void 0) {
          for (let i2 = 0; i2 < json.length; i2++) {
            const data = json[i2];
            const clip = AnimationClip.parse(data);
            animations[clip.uuid] = clip;
          }
        }
        return animations;
      }
      parseImages(json, onLoad) {
        const scope = this;
        const images = {};
        let loader2;
        function loadImage(url) {
          scope.manager.itemStart(url);
          return loader2.load(url, function() {
            scope.manager.itemEnd(url);
          }, void 0, function() {
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
          });
        }
        function deserializeImage(image) {
          if (typeof image === "string") {
            const url = image;
            const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
            return loadImage(path);
          } else {
            if (image.data) {
              return {
                data: getTypedArray(image.type, image.data),
                width: image.width,
                height: image.height
              };
            } else {
              return null;
            }
          }
        }
        if (json !== void 0 && json.length > 0) {
          const manager = new LoadingManager(onLoad);
          loader2 = new ImageLoader(manager);
          loader2.setCrossOrigin(this.crossOrigin);
          for (let i2 = 0, il = json.length; i2 < il; i2++) {
            const image = json[i2];
            const url = image.url;
            if (Array.isArray(url)) {
              const imageArray = [];
              for (let j = 0, jl = url.length; j < jl; j++) {
                const currentUrl = url[j];
                const deserializedImage = deserializeImage(currentUrl);
                if (deserializedImage !== null) {
                  if (deserializedImage instanceof HTMLImageElement) {
                    imageArray.push(deserializedImage);
                  } else {
                    imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
                  }
                }
              }
              images[image.uuid] = new Source(imageArray);
            } else {
              const deserializedImage = deserializeImage(image.url);
              images[image.uuid] = new Source(deserializedImage);
            }
          }
        }
        return images;
      }
      async parseImagesAsync(json) {
        const scope = this;
        const images = {};
        let loader2;
        async function deserializeImage(image) {
          if (typeof image === "string") {
            const url = image;
            const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
            return await loader2.loadAsync(path);
          } else {
            if (image.data) {
              return {
                data: getTypedArray(image.type, image.data),
                width: image.width,
                height: image.height
              };
            } else {
              return null;
            }
          }
        }
        if (json !== void 0 && json.length > 0) {
          loader2 = new ImageLoader(this.manager);
          loader2.setCrossOrigin(this.crossOrigin);
          for (let i2 = 0, il = json.length; i2 < il; i2++) {
            const image = json[i2];
            const url = image.url;
            if (Array.isArray(url)) {
              const imageArray = [];
              for (let j = 0, jl = url.length; j < jl; j++) {
                const currentUrl = url[j];
                const deserializedImage = await deserializeImage(currentUrl);
                if (deserializedImage !== null) {
                  if (deserializedImage instanceof HTMLImageElement) {
                    imageArray.push(deserializedImage);
                  } else {
                    imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
                  }
                }
              }
              images[image.uuid] = new Source(imageArray);
            } else {
              const deserializedImage = await deserializeImage(image.url);
              images[image.uuid] = new Source(deserializedImage);
            }
          }
        }
        return images;
      }
      parseTextures(json, images) {
        function parseConstant(value, type) {
          if (typeof value === "number")
            return value;
          console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", value);
          return type[value];
        }
        const textures = {};
        if (json !== void 0) {
          for (let i2 = 0, l = json.length; i2 < l; i2++) {
            const data = json[i2];
            if (data.image === void 0) {
              console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
            }
            if (images[data.image] === void 0) {
              console.warn("THREE.ObjectLoader: Undefined image", data.image);
            }
            const source = images[data.image];
            const image = source.data;
            let texture;
            if (Array.isArray(image)) {
              texture = new CubeTexture();
              if (image.length === 6)
                texture.needsUpdate = true;
            } else {
              if (image && image.data) {
                texture = new DataTexture();
              } else {
                texture = new Texture();
              }
              if (image)
                texture.needsUpdate = true;
            }
            texture.source = source;
            texture.uuid = data.uuid;
            if (data.name !== void 0)
              texture.name = data.name;
            if (data.mapping !== void 0)
              texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
            if (data.offset !== void 0)
              texture.offset.fromArray(data.offset);
            if (data.repeat !== void 0)
              texture.repeat.fromArray(data.repeat);
            if (data.center !== void 0)
              texture.center.fromArray(data.center);
            if (data.rotation !== void 0)
              texture.rotation = data.rotation;
            if (data.wrap !== void 0) {
              texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
              texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
            }
            if (data.format !== void 0)
              texture.format = data.format;
            if (data.type !== void 0)
              texture.type = data.type;
            if (data.encoding !== void 0)
              texture.encoding = data.encoding;
            if (data.minFilter !== void 0)
              texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
            if (data.magFilter !== void 0)
              texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
            if (data.anisotropy !== void 0)
              texture.anisotropy = data.anisotropy;
            if (data.flipY !== void 0)
              texture.flipY = data.flipY;
            if (data.premultiplyAlpha !== void 0)
              texture.premultiplyAlpha = data.premultiplyAlpha;
            if (data.unpackAlignment !== void 0)
              texture.unpackAlignment = data.unpackAlignment;
            if (data.userData !== void 0)
              texture.userData = data.userData;
            textures[data.uuid] = texture;
          }
        }
        return textures;
      }
      parseObject(data, geometries, materials, textures, animations) {
        let object;
        function getGeometry(name) {
          if (geometries[name] === void 0) {
            console.warn("THREE.ObjectLoader: Undefined geometry", name);
          }
          return geometries[name];
        }
        function getMaterial(name) {
          if (name === void 0)
            return void 0;
          if (Array.isArray(name)) {
            const array = [];
            for (let i2 = 0, l = name.length; i2 < l; i2++) {
              const uuid = name[i2];
              if (materials[uuid] === void 0) {
                console.warn("THREE.ObjectLoader: Undefined material", uuid);
              }
              array.push(materials[uuid]);
            }
            return array;
          }
          if (materials[name] === void 0) {
            console.warn("THREE.ObjectLoader: Undefined material", name);
          }
          return materials[name];
        }
        function getTexture(uuid) {
          if (textures[uuid] === void 0) {
            console.warn("THREE.ObjectLoader: Undefined texture", uuid);
          }
          return textures[uuid];
        }
        let geometry, material;
        switch (data.type) {
          case "Scene":
            object = new Scene();
            if (data.background !== void 0) {
              if (Number.isInteger(data.background)) {
                object.background = new Color(data.background);
              } else {
                object.background = getTexture(data.background);
              }
            }
            if (data.environment !== void 0) {
              object.environment = getTexture(data.environment);
            }
            if (data.fog !== void 0) {
              if (data.fog.type === "Fog") {
                object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
              } else if (data.fog.type === "FogExp2") {
                object.fog = new FogExp2(data.fog.color, data.fog.density);
              }
            }
            break;
          case "PerspectiveCamera":
            object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
            if (data.focus !== void 0)
              object.focus = data.focus;
            if (data.zoom !== void 0)
              object.zoom = data.zoom;
            if (data.filmGauge !== void 0)
              object.filmGauge = data.filmGauge;
            if (data.filmOffset !== void 0)
              object.filmOffset = data.filmOffset;
            if (data.view !== void 0)
              object.view = Object.assign({}, data.view);
            break;
          case "OrthographicCamera":
            object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
            if (data.zoom !== void 0)
              object.zoom = data.zoom;
            if (data.view !== void 0)
              object.view = Object.assign({}, data.view);
            break;
          case "AmbientLight":
            object = new AmbientLight(data.color, data.intensity);
            break;
          case "DirectionalLight":
            object = new DirectionalLight(data.color, data.intensity);
            break;
          case "PointLight":
            object = new PointLight(data.color, data.intensity, data.distance, data.decay);
            break;
          case "RectAreaLight":
            object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
            break;
          case "SpotLight":
            object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
            break;
          case "HemisphereLight":
            object = new HemisphereLight(data.color, data.groundColor, data.intensity);
            break;
          case "LightProbe":
            object = new LightProbe().fromJSON(data);
            break;
          case "SkinnedMesh":
            geometry = getGeometry(data.geometry);
            material = getMaterial(data.material);
            object = new SkinnedMesh(geometry, material);
            if (data.bindMode !== void 0)
              object.bindMode = data.bindMode;
            if (data.bindMatrix !== void 0)
              object.bindMatrix.fromArray(data.bindMatrix);
            if (data.skeleton !== void 0)
              object.skeleton = data.skeleton;
            break;
          case "Mesh":
            geometry = getGeometry(data.geometry);
            material = getMaterial(data.material);
            object = new Mesh(geometry, material);
            break;
          case "InstancedMesh":
            geometry = getGeometry(data.geometry);
            material = getMaterial(data.material);
            const count = data.count;
            const instanceMatrix = data.instanceMatrix;
            const instanceColor = data.instanceColor;
            object = new InstancedMesh(geometry, material, count);
            object.instanceMatrix = new InstancedBufferAttribute(new Float32Array(instanceMatrix.array), 16);
            if (instanceColor !== void 0)
              object.instanceColor = new InstancedBufferAttribute(new Float32Array(instanceColor.array), instanceColor.itemSize);
            break;
          case "LOD":
            object = new LOD();
            break;
          case "Line":
            object = new Line(getGeometry(data.geometry), getMaterial(data.material));
            break;
          case "LineLoop":
            object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
            break;
          case "LineSegments":
            object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
            break;
          case "PointCloud":
          case "Points":
            object = new Points(getGeometry(data.geometry), getMaterial(data.material));
            break;
          case "Sprite":
            object = new Sprite(getMaterial(data.material));
            break;
          case "Group":
            object = new Group();
            break;
          case "Bone":
            object = new Bone();
            break;
          default:
            object = new Object3D();
        }
        object.uuid = data.uuid;
        if (data.name !== void 0)
          object.name = data.name;
        if (data.matrix !== void 0) {
          object.matrix.fromArray(data.matrix);
          if (data.matrixAutoUpdate !== void 0)
            object.matrixAutoUpdate = data.matrixAutoUpdate;
          if (object.matrixAutoUpdate)
            object.matrix.decompose(object.position, object.quaternion, object.scale);
        } else {
          if (data.position !== void 0)
            object.position.fromArray(data.position);
          if (data.rotation !== void 0)
            object.rotation.fromArray(data.rotation);
          if (data.quaternion !== void 0)
            object.quaternion.fromArray(data.quaternion);
          if (data.scale !== void 0)
            object.scale.fromArray(data.scale);
        }
        if (data.castShadow !== void 0)
          object.castShadow = data.castShadow;
        if (data.receiveShadow !== void 0)
          object.receiveShadow = data.receiveShadow;
        if (data.shadow) {
          if (data.shadow.bias !== void 0)
            object.shadow.bias = data.shadow.bias;
          if (data.shadow.normalBias !== void 0)
            object.shadow.normalBias = data.shadow.normalBias;
          if (data.shadow.radius !== void 0)
            object.shadow.radius = data.shadow.radius;
          if (data.shadow.mapSize !== void 0)
            object.shadow.mapSize.fromArray(data.shadow.mapSize);
          if (data.shadow.camera !== void 0)
            object.shadow.camera = this.parseObject(data.shadow.camera);
        }
        if (data.visible !== void 0)
          object.visible = data.visible;
        if (data.frustumCulled !== void 0)
          object.frustumCulled = data.frustumCulled;
        if (data.renderOrder !== void 0)
          object.renderOrder = data.renderOrder;
        if (data.userData !== void 0)
          object.userData = data.userData;
        if (data.layers !== void 0)
          object.layers.mask = data.layers;
        if (data.children !== void 0) {
          const children = data.children;
          for (let i2 = 0; i2 < children.length; i2++) {
            object.add(this.parseObject(children[i2], geometries, materials, textures, animations));
          }
        }
        if (data.animations !== void 0) {
          const objectAnimations = data.animations;
          for (let i2 = 0; i2 < objectAnimations.length; i2++) {
            const uuid = objectAnimations[i2];
            object.animations.push(animations[uuid]);
          }
        }
        if (data.type === "LOD") {
          if (data.autoUpdate !== void 0)
            object.autoUpdate = data.autoUpdate;
          const levels = data.levels;
          for (let l = 0; l < levels.length; l++) {
            const level = levels[l];
            const child = object.getObjectByProperty("uuid", level.object);
            if (child !== void 0) {
              object.addLevel(child, level.distance);
            }
          }
        }
        return object;
      }
      bindSkeletons(object, skeletons) {
        if (Object.keys(skeletons).length === 0)
          return;
        object.traverse(function(child) {
          if (child.isSkinnedMesh === true && child.skeleton !== void 0) {
            const skeleton = skeletons[child.skeleton];
            if (skeleton === void 0) {
              console.warn("THREE.ObjectLoader: No skeleton found with UUID:", child.skeleton);
            } else {
              child.bind(skeleton, child.bindMatrix);
            }
          }
        });
      }
      setTexturePath(value) {
        console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().");
        return this.setResourcePath(value);
      }
    };
    TEXTURE_MAPPING = {
      UVMapping,
      CubeReflectionMapping,
      CubeRefractionMapping,
      EquirectangularReflectionMapping,
      EquirectangularRefractionMapping,
      CubeUVReflectionMapping
    };
    TEXTURE_WRAPPING = {
      RepeatWrapping,
      ClampToEdgeWrapping,
      MirroredRepeatWrapping
    };
    TEXTURE_FILTER = {
      NearestFilter,
      NearestMipmapNearestFilter,
      NearestMipmapLinearFilter,
      LinearFilter,
      LinearMipmapNearestFilter,
      LinearMipmapLinearFilter
    };
    ImageBitmapLoader = class extends Loader {
      constructor(manager) {
        super(manager);
        if (typeof createImageBitmap === "undefined") {
          console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
        }
        if (typeof fetch === "undefined") {
          console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
        }
        this.options = { premultiplyAlpha: "none" };
      }
      setOptions(options) {
        this.options = options;
        return this;
      }
      load(url, onLoad, onProgress, onError) {
        if (url === void 0)
          url = "";
        if (this.path !== void 0)
          url = this.path + url;
        url = this.manager.resolveURL(url);
        const scope = this;
        const cached = Cache.get(url);
        if (cached !== void 0) {
          scope.manager.itemStart(url);
          setTimeout(function() {
            if (onLoad)
              onLoad(cached);
            scope.manager.itemEnd(url);
          }, 0);
          return cached;
        }
        const fetchOptions = {};
        fetchOptions.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include";
        fetchOptions.headers = this.requestHeader;
        fetch(url, fetchOptions).then(function(res) {
          return res.blob();
        }).then(function(blob) {
          return createImageBitmap(blob, Object.assign(scope.options, { colorSpaceConversion: "none" }));
        }).then(function(imageBitmap) {
          Cache.add(url, imageBitmap);
          if (onLoad)
            onLoad(imageBitmap);
          scope.manager.itemEnd(url);
        }).catch(function(e) {
          if (onError)
            onError(e);
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        });
        scope.manager.itemStart(url);
      }
    };
    ImageBitmapLoader.prototype.isImageBitmapLoader = true;
    AudioContext = {
      getContext: function() {
        if (_context === void 0) {
          _context = new (window.AudioContext || window.webkitAudioContext)();
        }
        return _context;
      },
      setContext: function(value) {
        _context = value;
      }
    };
    AudioLoader = class extends Loader {
      constructor(manager) {
        super(manager);
      }
      load(url, onLoad, onProgress, onError) {
        const scope = this;
        const loader2 = new FileLoader(this.manager);
        loader2.setResponseType("arraybuffer");
        loader2.setPath(this.path);
        loader2.setRequestHeader(this.requestHeader);
        loader2.setWithCredentials(this.withCredentials);
        loader2.load(url, function(buffer) {
          try {
            const bufferCopy = buffer.slice(0);
            const context = AudioContext.getContext();
            context.decodeAudioData(bufferCopy, function(audioBuffer) {
              onLoad(audioBuffer);
            });
          } catch (e) {
            if (onError) {
              onError(e);
            } else {
              console.error(e);
            }
            scope.manager.itemError(url);
          }
        }, onProgress, onError);
      }
    };
    HemisphereLightProbe = class extends LightProbe {
      constructor(skyColor, groundColor, intensity = 1) {
        super(void 0, intensity);
        const color1 = new Color().set(skyColor);
        const color2 = new Color().set(groundColor);
        const sky = new Vector3(color1.r, color1.g, color1.b);
        const ground = new Vector3(color2.r, color2.g, color2.b);
        const c0 = Math.sqrt(Math.PI);
        const c1 = c0 * Math.sqrt(0.75);
        this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
        this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
      }
    };
    HemisphereLightProbe.prototype.isHemisphereLightProbe = true;
    AmbientLightProbe = class extends LightProbe {
      constructor(color, intensity = 1) {
        super(void 0, intensity);
        const color1 = new Color().set(color);
        this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
      }
    };
    AmbientLightProbe.prototype.isAmbientLightProbe = true;
    _eyeRight = /* @__PURE__ */ new Matrix4();
    _eyeLeft = /* @__PURE__ */ new Matrix4();
    _projectionMatrix = /* @__PURE__ */ new Matrix4();
    StereoCamera = class {
      constructor() {
        this.type = "StereoCamera";
        this.aspect = 1;
        this.eyeSep = 0.064;
        this.cameraL = new PerspectiveCamera();
        this.cameraL.layers.enable(1);
        this.cameraL.matrixAutoUpdate = false;
        this.cameraR = new PerspectiveCamera();
        this.cameraR.layers.enable(2);
        this.cameraR.matrixAutoUpdate = false;
        this._cache = {
          focus: null,
          fov: null,
          aspect: null,
          near: null,
          far: null,
          zoom: null,
          eyeSep: null
        };
      }
      update(camera) {
        const cache = this._cache;
        const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;
        if (needsUpdate) {
          cache.focus = camera.focus;
          cache.fov = camera.fov;
          cache.aspect = camera.aspect * this.aspect;
          cache.near = camera.near;
          cache.far = camera.far;
          cache.zoom = camera.zoom;
          cache.eyeSep = this.eyeSep;
          _projectionMatrix.copy(camera.projectionMatrix);
          const eyeSepHalf = cache.eyeSep / 2;
          const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
          const ymax = cache.near * Math.tan(DEG2RAD * cache.fov * 0.5) / cache.zoom;
          let xmin, xmax;
          _eyeLeft.elements[12] = -eyeSepHalf;
          _eyeRight.elements[12] = eyeSepHalf;
          xmin = -ymax * cache.aspect + eyeSepOnProjection;
          xmax = ymax * cache.aspect + eyeSepOnProjection;
          _projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
          _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
          this.cameraL.projectionMatrix.copy(_projectionMatrix);
          xmin = -ymax * cache.aspect - eyeSepOnProjection;
          xmax = ymax * cache.aspect - eyeSepOnProjection;
          _projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
          _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
          this.cameraR.projectionMatrix.copy(_projectionMatrix);
        }
        this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
        this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
      }
    };
    Clock = class {
      constructor(autoStart = true) {
        this.autoStart = autoStart;
        this.startTime = 0;
        this.oldTime = 0;
        this.elapsedTime = 0;
        this.running = false;
      }
      start() {
        this.startTime = now();
        this.oldTime = this.startTime;
        this.elapsedTime = 0;
        this.running = true;
      }
      stop() {
        this.getElapsedTime();
        this.running = false;
        this.autoStart = false;
      }
      getElapsedTime() {
        this.getDelta();
        return this.elapsedTime;
      }
      getDelta() {
        let diff = 0;
        if (this.autoStart && !this.running) {
          this.start();
          return 0;
        }
        if (this.running) {
          const newTime = now();
          diff = (newTime - this.oldTime) / 1e3;
          this.oldTime = newTime;
          this.elapsedTime += diff;
        }
        return diff;
      }
    };
    _position$1 = /* @__PURE__ */ new Vector3();
    _quaternion$1 = /* @__PURE__ */ new Quaternion();
    _scale$1 = /* @__PURE__ */ new Vector3();
    _orientation$1 = /* @__PURE__ */ new Vector3();
    AudioListener = class extends Object3D {
      constructor() {
        super();
        this.type = "AudioListener";
        this.context = AudioContext.getContext();
        this.gain = this.context.createGain();
        this.gain.connect(this.context.destination);
        this.filter = null;
        this.timeDelta = 0;
        this._clock = new Clock();
      }
      getInput() {
        return this.gain;
      }
      removeFilter() {
        if (this.filter !== null) {
          this.gain.disconnect(this.filter);
          this.filter.disconnect(this.context.destination);
          this.gain.connect(this.context.destination);
          this.filter = null;
        }
        return this;
      }
      getFilter() {
        return this.filter;
      }
      setFilter(value) {
        if (this.filter !== null) {
          this.gain.disconnect(this.filter);
          this.filter.disconnect(this.context.destination);
        } else {
          this.gain.disconnect(this.context.destination);
        }
        this.filter = value;
        this.gain.connect(this.filter);
        this.filter.connect(this.context.destination);
        return this;
      }
      getMasterVolume() {
        return this.gain.gain.value;
      }
      setMasterVolume(value) {
        this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
        return this;
      }
      updateMatrixWorld(force) {
        super.updateMatrixWorld(force);
        const listener = this.context.listener;
        const up = this.up;
        this.timeDelta = this._clock.getDelta();
        this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1);
        _orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1);
        if (listener.positionX) {
          const endTime = this.context.currentTime + this.timeDelta;
          listener.positionX.linearRampToValueAtTime(_position$1.x, endTime);
          listener.positionY.linearRampToValueAtTime(_position$1.y, endTime);
          listener.positionZ.linearRampToValueAtTime(_position$1.z, endTime);
          listener.forwardX.linearRampToValueAtTime(_orientation$1.x, endTime);
          listener.forwardY.linearRampToValueAtTime(_orientation$1.y, endTime);
          listener.forwardZ.linearRampToValueAtTime(_orientation$1.z, endTime);
          listener.upX.linearRampToValueAtTime(up.x, endTime);
          listener.upY.linearRampToValueAtTime(up.y, endTime);
          listener.upZ.linearRampToValueAtTime(up.z, endTime);
        } else {
          listener.setPosition(_position$1.x, _position$1.y, _position$1.z);
          listener.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z);
        }
      }
    };
    Audio = class extends Object3D {
      constructor(listener) {
        super();
        this.type = "Audio";
        this.listener = listener;
        this.context = listener.context;
        this.gain = this.context.createGain();
        this.gain.connect(listener.getInput());
        this.autoplay = false;
        this.buffer = null;
        this.detune = 0;
        this.loop = false;
        this.loopStart = 0;
        this.loopEnd = 0;
        this.offset = 0;
        this.duration = void 0;
        this.playbackRate = 1;
        this.isPlaying = false;
        this.hasPlaybackControl = true;
        this.source = null;
        this.sourceType = "empty";
        this._startedAt = 0;
        this._progress = 0;
        this._connected = false;
        this.filters = [];
      }
      getOutput() {
        return this.gain;
      }
      setNodeSource(audioNode) {
        this.hasPlaybackControl = false;
        this.sourceType = "audioNode";
        this.source = audioNode;
        this.connect();
        return this;
      }
      setMediaElementSource(mediaElement) {
        this.hasPlaybackControl = false;
        this.sourceType = "mediaNode";
        this.source = this.context.createMediaElementSource(mediaElement);
        this.connect();
        return this;
      }
      setMediaStreamSource(mediaStream) {
        this.hasPlaybackControl = false;
        this.sourceType = "mediaStreamNode";
        this.source = this.context.createMediaStreamSource(mediaStream);
        this.connect();
        return this;
      }
      setBuffer(audioBuffer) {
        this.buffer = audioBuffer;
        this.sourceType = "buffer";
        if (this.autoplay)
          this.play();
        return this;
      }
      play(delay = 0) {
        if (this.isPlaying === true) {
          console.warn("THREE.Audio: Audio is already playing.");
          return;
        }
        if (this.hasPlaybackControl === false) {
          console.warn("THREE.Audio: this Audio has no playback control.");
          return;
        }
        this._startedAt = this.context.currentTime + delay;
        const source = this.context.createBufferSource();
        source.buffer = this.buffer;
        source.loop = this.loop;
        source.loopStart = this.loopStart;
        source.loopEnd = this.loopEnd;
        source.onended = this.onEnded.bind(this);
        source.start(this._startedAt, this._progress + this.offset, this.duration);
        this.isPlaying = true;
        this.source = source;
        this.setDetune(this.detune);
        this.setPlaybackRate(this.playbackRate);
        return this.connect();
      }
      pause() {
        if (this.hasPlaybackControl === false) {
          console.warn("THREE.Audio: this Audio has no playback control.");
          return;
        }
        if (this.isPlaying === true) {
          this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
          if (this.loop === true) {
            this._progress = this._progress % (this.duration || this.buffer.duration);
          }
          this.source.stop();
          this.source.onended = null;
          this.isPlaying = false;
        }
        return this;
      }
      stop() {
        if (this.hasPlaybackControl === false) {
          console.warn("THREE.Audio: this Audio has no playback control.");
          return;
        }
        this._progress = 0;
        this.source.stop();
        this.source.onended = null;
        this.isPlaying = false;
        return this;
      }
      connect() {
        if (this.filters.length > 0) {
          this.source.connect(this.filters[0]);
          for (let i2 = 1, l = this.filters.length; i2 < l; i2++) {
            this.filters[i2 - 1].connect(this.filters[i2]);
          }
          this.filters[this.filters.length - 1].connect(this.getOutput());
        } else {
          this.source.connect(this.getOutput());
        }
        this._connected = true;
        return this;
      }
      disconnect() {
        if (this.filters.length > 0) {
          this.source.disconnect(this.filters[0]);
          for (let i2 = 1, l = this.filters.length; i2 < l; i2++) {
            this.filters[i2 - 1].disconnect(this.filters[i2]);
          }
          this.filters[this.filters.length - 1].disconnect(this.getOutput());
        } else {
          this.source.disconnect(this.getOutput());
        }
        this._connected = false;
        return this;
      }
      getFilters() {
        return this.filters;
      }
      setFilters(value) {
        if (!value)
          value = [];
        if (this._connected === true) {
          this.disconnect();
          this.filters = value.slice();
          this.connect();
        } else {
          this.filters = value.slice();
        }
        return this;
      }
      setDetune(value) {
        this.detune = value;
        if (this.source.detune === void 0)
          return;
        if (this.isPlaying === true) {
          this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
        }
        return this;
      }
      getDetune() {
        return this.detune;
      }
      getFilter() {
        return this.getFilters()[0];
      }
      setFilter(filter) {
        return this.setFilters(filter ? [filter] : []);
      }
      setPlaybackRate(value) {
        if (this.hasPlaybackControl === false) {
          console.warn("THREE.Audio: this Audio has no playback control.");
          return;
        }
        this.playbackRate = value;
        if (this.isPlaying === true) {
          this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
        }
        return this;
      }
      getPlaybackRate() {
        return this.playbackRate;
      }
      onEnded() {
        this.isPlaying = false;
      }
      getLoop() {
        if (this.hasPlaybackControl === false) {
          console.warn("THREE.Audio: this Audio has no playback control.");
          return false;
        }
        return this.loop;
      }
      setLoop(value) {
        if (this.hasPlaybackControl === false) {
          console.warn("THREE.Audio: this Audio has no playback control.");
          return;
        }
        this.loop = value;
        if (this.isPlaying === true) {
          this.source.loop = this.loop;
        }
        return this;
      }
      setLoopStart(value) {
        this.loopStart = value;
        return this;
      }
      setLoopEnd(value) {
        this.loopEnd = value;
        return this;
      }
      getVolume() {
        return this.gain.gain.value;
      }
      setVolume(value) {
        this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
        return this;
      }
    };
    _position = /* @__PURE__ */ new Vector3();
    _quaternion = /* @__PURE__ */ new Quaternion();
    _scale = /* @__PURE__ */ new Vector3();
    _orientation = /* @__PURE__ */ new Vector3();
    PositionalAudio = class extends Audio {
      constructor(listener) {
        super(listener);
        this.panner = this.context.createPanner();
        this.panner.panningModel = "HRTF";
        this.panner.connect(this.gain);
      }
      disconnect() {
        super.disconnect();
        this.panner.disconnect(this.gain);
      }
      getOutput() {
        return this.panner;
      }
      getRefDistance() {
        return this.panner.refDistance;
      }
      setRefDistance(value) {
        this.panner.refDistance = value;
        return this;
      }
      getRolloffFactor() {
        return this.panner.rolloffFactor;
      }
      setRolloffFactor(value) {
        this.panner.rolloffFactor = value;
        return this;
      }
      getDistanceModel() {
        return this.panner.distanceModel;
      }
      setDistanceModel(value) {
        this.panner.distanceModel = value;
        return this;
      }
      getMaxDistance() {
        return this.panner.maxDistance;
      }
      setMaxDistance(value) {
        this.panner.maxDistance = value;
        return this;
      }
      setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
        this.panner.coneInnerAngle = coneInnerAngle;
        this.panner.coneOuterAngle = coneOuterAngle;
        this.panner.coneOuterGain = coneOuterGain;
        return this;
      }
      updateMatrixWorld(force) {
        super.updateMatrixWorld(force);
        if (this.hasPlaybackControl === true && this.isPlaying === false)
          return;
        this.matrixWorld.decompose(_position, _quaternion, _scale);
        _orientation.set(0, 0, 1).applyQuaternion(_quaternion);
        const panner = this.panner;
        if (panner.positionX) {
          const endTime = this.context.currentTime + this.listener.timeDelta;
          panner.positionX.linearRampToValueAtTime(_position.x, endTime);
          panner.positionY.linearRampToValueAtTime(_position.y, endTime);
          panner.positionZ.linearRampToValueAtTime(_position.z, endTime);
          panner.orientationX.linearRampToValueAtTime(_orientation.x, endTime);
          panner.orientationY.linearRampToValueAtTime(_orientation.y, endTime);
          panner.orientationZ.linearRampToValueAtTime(_orientation.z, endTime);
        } else {
          panner.setPosition(_position.x, _position.y, _position.z);
          panner.setOrientation(_orientation.x, _orientation.y, _orientation.z);
        }
      }
    };
    AudioAnalyser = class {
      constructor(audio, fftSize = 2048) {
        this.analyser = audio.context.createAnalyser();
        this.analyser.fftSize = fftSize;
        this.data = new Uint8Array(this.analyser.frequencyBinCount);
        audio.getOutput().connect(this.analyser);
      }
      getFrequencyData() {
        this.analyser.getByteFrequencyData(this.data);
        return this.data;
      }
      getAverageFrequency() {
        let value = 0;
        const data = this.getFrequencyData();
        for (let i2 = 0; i2 < data.length; i2++) {
          value += data[i2];
        }
        return value / data.length;
      }
    };
    PropertyMixer = class {
      constructor(binding, typeName, valueSize) {
        this.binding = binding;
        this.valueSize = valueSize;
        let mixFunction, mixFunctionAdditive, setIdentity;
        switch (typeName) {
          case "quaternion":
            mixFunction = this._slerp;
            mixFunctionAdditive = this._slerpAdditive;
            setIdentity = this._setAdditiveIdentityQuaternion;
            this.buffer = new Float64Array(valueSize * 6);
            this._workIndex = 5;
            break;
          case "string":
          case "bool":
            mixFunction = this._select;
            mixFunctionAdditive = this._select;
            setIdentity = this._setAdditiveIdentityOther;
            this.buffer = new Array(valueSize * 5);
            break;
          default:
            mixFunction = this._lerp;
            mixFunctionAdditive = this._lerpAdditive;
            setIdentity = this._setAdditiveIdentityNumeric;
            this.buffer = new Float64Array(valueSize * 5);
        }
        this._mixBufferRegion = mixFunction;
        this._mixBufferRegionAdditive = mixFunctionAdditive;
        this._setIdentity = setIdentity;
        this._origIndex = 3;
        this._addIndex = 4;
        this.cumulativeWeight = 0;
        this.cumulativeWeightAdditive = 0;
        this.useCount = 0;
        this.referenceCount = 0;
      }
      accumulate(accuIndex, weight) {
        const buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;
        let currentWeight = this.cumulativeWeight;
        if (currentWeight === 0) {
          for (let i2 = 0; i2 !== stride; ++i2) {
            buffer[offset + i2] = buffer[i2];
          }
          currentWeight = weight;
        } else {
          currentWeight += weight;
          const mix = weight / currentWeight;
          this._mixBufferRegion(buffer, offset, 0, mix, stride);
        }
        this.cumulativeWeight = currentWeight;
      }
      accumulateAdditive(weight) {
        const buffer = this.buffer, stride = this.valueSize, offset = stride * this._addIndex;
        if (this.cumulativeWeightAdditive === 0) {
          this._setIdentity();
        }
        this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
        this.cumulativeWeightAdditive += weight;
      }
      apply(accuIndex) {
        const stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
        this.cumulativeWeight = 0;
        this.cumulativeWeightAdditive = 0;
        if (weight < 1) {
          const originalValueOffset = stride * this._origIndex;
          this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
        }
        if (weightAdditive > 0) {
          this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
        }
        for (let i2 = stride, e = stride + stride; i2 !== e; ++i2) {
          if (buffer[i2] !== buffer[i2 + stride]) {
            binding.setValue(buffer, offset);
            break;
          }
        }
      }
      saveOriginalState() {
        const binding = this.binding;
        const buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
        binding.getValue(buffer, originalValueOffset);
        for (let i2 = stride, e = originalValueOffset; i2 !== e; ++i2) {
          buffer[i2] = buffer[originalValueOffset + i2 % stride];
        }
        this._setIdentity();
        this.cumulativeWeight = 0;
        this.cumulativeWeightAdditive = 0;
      }
      restoreOriginalState() {
        const originalValueOffset = this.valueSize * 3;
        this.binding.setValue(this.buffer, originalValueOffset);
      }
      _setAdditiveIdentityNumeric() {
        const startIndex = this._addIndex * this.valueSize;
        const endIndex = startIndex + this.valueSize;
        for (let i2 = startIndex; i2 < endIndex; i2++) {
          this.buffer[i2] = 0;
        }
      }
      _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric();
        this.buffer[this._addIndex * this.valueSize + 3] = 1;
      }
      _setAdditiveIdentityOther() {
        const startIndex = this._origIndex * this.valueSize;
        const targetIndex = this._addIndex * this.valueSize;
        for (let i2 = 0; i2 < this.valueSize; i2++) {
          this.buffer[targetIndex + i2] = this.buffer[startIndex + i2];
        }
      }
      _select(buffer, dstOffset, srcOffset, t2, stride) {
        if (t2 >= 0.5) {
          for (let i2 = 0; i2 !== stride; ++i2) {
            buffer[dstOffset + i2] = buffer[srcOffset + i2];
          }
        }
      }
      _slerp(buffer, dstOffset, srcOffset, t2) {
        Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t2);
      }
      _slerpAdditive(buffer, dstOffset, srcOffset, t2, stride) {
        const workOffset = this._workIndex * stride;
        Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
        Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t2);
      }
      _lerp(buffer, dstOffset, srcOffset, t2, stride) {
        const s = 1 - t2;
        for (let i2 = 0; i2 !== stride; ++i2) {
          const j = dstOffset + i2;
          buffer[j] = buffer[j] * s + buffer[srcOffset + i2] * t2;
        }
      }
      _lerpAdditive(buffer, dstOffset, srcOffset, t2, stride) {
        for (let i2 = 0; i2 !== stride; ++i2) {
          const j = dstOffset + i2;
          buffer[j] = buffer[j] + buffer[srcOffset + i2] * t2;
        }
      }
    };
    _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
    _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
    _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
    _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
    _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
    _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
    _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
    _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
    _trackRe = new RegExp("^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$");
    _supportedObjectNames = ["material", "materials", "bones"];
    Composite = class {
      constructor(targetGroup, path, optionalParsedPath) {
        const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
        this._targetGroup = targetGroup;
        this._bindings = targetGroup.subscribe_(path, parsedPath);
      }
      getValue(array, offset) {
        this.bind();
        const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
        if (binding !== void 0)
          binding.getValue(array, offset);
      }
      setValue(array, offset) {
        const bindings = this._bindings;
        for (let i2 = this._targetGroup.nCachedObjects_, n = bindings.length; i2 !== n; ++i2) {
          bindings[i2].setValue(array, offset);
        }
      }
      bind() {
        const bindings = this._bindings;
        for (let i2 = this._targetGroup.nCachedObjects_, n = bindings.length; i2 !== n; ++i2) {
          bindings[i2].bind();
        }
      }
      unbind() {
        const bindings = this._bindings;
        for (let i2 = this._targetGroup.nCachedObjects_, n = bindings.length; i2 !== n; ++i2) {
          bindings[i2].unbind();
        }
      }
    };
    PropertyBinding = class {
      constructor(rootNode, path, parsedPath) {
        this.path = path;
        this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
        this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
        this.rootNode = rootNode;
        this.getValue = this._getValue_unbound;
        this.setValue = this._setValue_unbound;
      }
      static create(root, path, parsedPath) {
        if (!(root && root.isAnimationObjectGroup)) {
          return new PropertyBinding(root, path, parsedPath);
        } else {
          return new PropertyBinding.Composite(root, path, parsedPath);
        }
      }
      static sanitizeNodeName(name) {
        return name.replace(/\s/g, "_").replace(_reservedRe, "");
      }
      static parseTrackName(trackName) {
        const matches = _trackRe.exec(trackName);
        if (matches === null) {
          throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
        }
        const results = {
          nodeName: matches[2],
          objectName: matches[3],
          objectIndex: matches[4],
          propertyName: matches[5],
          propertyIndex: matches[6]
        };
        const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
        if (lastDot !== void 0 && lastDot !== -1) {
          const objectName = results.nodeName.substring(lastDot + 1);
          if (_supportedObjectNames.indexOf(objectName) !== -1) {
            results.nodeName = results.nodeName.substring(0, lastDot);
            results.objectName = objectName;
          }
        }
        if (results.propertyName === null || results.propertyName.length === 0) {
          throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
        }
        return results;
      }
      static findNode(root, nodeName) {
        if (nodeName === void 0 || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
          return root;
        }
        if (root.skeleton) {
          const bone = root.skeleton.getBoneByName(nodeName);
          if (bone !== void 0) {
            return bone;
          }
        }
        if (root.children) {
          const searchNodeSubtree = function(children) {
            for (let i2 = 0; i2 < children.length; i2++) {
              const childNode = children[i2];
              if (childNode.name === nodeName || childNode.uuid === nodeName) {
                return childNode;
              }
              const result = searchNodeSubtree(childNode.children);
              if (result)
                return result;
            }
            return null;
          };
          const subTreeNode = searchNodeSubtree(root.children);
          if (subTreeNode) {
            return subTreeNode;
          }
        }
        return null;
      }
      _getValue_unavailable() {
      }
      _setValue_unavailable() {
      }
      _getValue_direct(buffer, offset) {
        buffer[offset] = this.targetObject[this.propertyName];
      }
      _getValue_array(buffer, offset) {
        const source = this.resolvedProperty;
        for (let i2 = 0, n = source.length; i2 !== n; ++i2) {
          buffer[offset++] = source[i2];
        }
      }
      _getValue_arrayElement(buffer, offset) {
        buffer[offset] = this.resolvedProperty[this.propertyIndex];
      }
      _getValue_toArray(buffer, offset) {
        this.resolvedProperty.toArray(buffer, offset);
      }
      _setValue_direct(buffer, offset) {
        this.targetObject[this.propertyName] = buffer[offset];
      }
      _setValue_direct_setNeedsUpdate(buffer, offset) {
        this.targetObject[this.propertyName] = buffer[offset];
        this.targetObject.needsUpdate = true;
      }
      _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
        this.targetObject[this.propertyName] = buffer[offset];
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
      _setValue_array(buffer, offset) {
        const dest = this.resolvedProperty;
        for (let i2 = 0, n = dest.length; i2 !== n; ++i2) {
          dest[i2] = buffer[offset++];
        }
      }
      _setValue_array_setNeedsUpdate(buffer, offset) {
        const dest = this.resolvedProperty;
        for (let i2 = 0, n = dest.length; i2 !== n; ++i2) {
          dest[i2] = buffer[offset++];
        }
        this.targetObject.needsUpdate = true;
      }
      _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
        const dest = this.resolvedProperty;
        for (let i2 = 0, n = dest.length; i2 !== n; ++i2) {
          dest[i2] = buffer[offset++];
        }
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
      _setValue_arrayElement(buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
      }
      _setValue_arrayElement_setNeedsUpdate(buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
        this.targetObject.needsUpdate = true;
      }
      _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
      _setValue_fromArray(buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
      }
      _setValue_fromArray_setNeedsUpdate(buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
        this.targetObject.needsUpdate = true;
      }
      _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
      _getValue_unbound(targetArray, offset) {
        this.bind();
        this.getValue(targetArray, offset);
      }
      _setValue_unbound(sourceArray, offset) {
        this.bind();
        this.setValue(sourceArray, offset);
      }
      bind() {
        let targetObject = this.node;
        const parsedPath = this.parsedPath;
        const objectName = parsedPath.objectName;
        const propertyName = parsedPath.propertyName;
        let propertyIndex = parsedPath.propertyIndex;
        if (!targetObject) {
          targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
          this.node = targetObject;
        }
        this.getValue = this._getValue_unavailable;
        this.setValue = this._setValue_unavailable;
        if (!targetObject) {
          console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
          return;
        }
        if (objectName) {
          let objectIndex = parsedPath.objectIndex;
          switch (objectName) {
            case "materials":
              if (!targetObject.material) {
                console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                return;
              }
              if (!targetObject.material.materials) {
                console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                return;
              }
              targetObject = targetObject.material.materials;
              break;
            case "bones":
              if (!targetObject.skeleton) {
                console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                return;
              }
              targetObject = targetObject.skeleton.bones;
              for (let i2 = 0; i2 < targetObject.length; i2++) {
                if (targetObject[i2].name === objectIndex) {
                  objectIndex = i2;
                  break;
                }
              }
              break;
            default:
              if (targetObject[objectName] === void 0) {
                console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                return;
              }
              targetObject = targetObject[objectName];
          }
          if (objectIndex !== void 0) {
            if (targetObject[objectIndex] === void 0) {
              console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
              return;
            }
            targetObject = targetObject[objectIndex];
          }
        }
        const nodeProperty = targetObject[propertyName];
        if (nodeProperty === void 0) {
          const nodeName = parsedPath.nodeName;
          console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
          return;
        }
        let versioning = this.Versioning.None;
        this.targetObject = targetObject;
        if (targetObject.needsUpdate !== void 0) {
          versioning = this.Versioning.NeedsUpdate;
        } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
          versioning = this.Versioning.MatrixWorldNeedsUpdate;
        }
        let bindingType = this.BindingType.Direct;
        if (propertyIndex !== void 0) {
          if (propertyName === "morphTargetInfluences") {
            if (!targetObject.geometry) {
              console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
              return;
            }
            if (targetObject.geometry.isBufferGeometry) {
              if (!targetObject.geometry.morphAttributes) {
                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                return;
              }
              if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
                propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
              }
            } else {
              console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
              return;
            }
          }
          bindingType = this.BindingType.ArrayElement;
          this.resolvedProperty = nodeProperty;
          this.propertyIndex = propertyIndex;
        } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
          bindingType = this.BindingType.HasFromToArray;
          this.resolvedProperty = nodeProperty;
        } else if (Array.isArray(nodeProperty)) {
          bindingType = this.BindingType.EntireArray;
          this.resolvedProperty = nodeProperty;
        } else {
          this.propertyName = propertyName;
        }
        this.getValue = this.GetterByBindingType[bindingType];
        this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
      }
      unbind() {
        this.node = null;
        this.getValue = this._getValue_unbound;
        this.setValue = this._setValue_unbound;
      }
    };
    PropertyBinding.Composite = Composite;
    PropertyBinding.prototype.BindingType = {
      Direct: 0,
      EntireArray: 1,
      ArrayElement: 2,
      HasFromToArray: 3
    };
    PropertyBinding.prototype.Versioning = {
      None: 0,
      NeedsUpdate: 1,
      MatrixWorldNeedsUpdate: 2
    };
    PropertyBinding.prototype.GetterByBindingType = [
      PropertyBinding.prototype._getValue_direct,
      PropertyBinding.prototype._getValue_array,
      PropertyBinding.prototype._getValue_arrayElement,
      PropertyBinding.prototype._getValue_toArray
    ];
    PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
      [
        PropertyBinding.prototype._setValue_direct,
        PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
        PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate
      ],
      [
        PropertyBinding.prototype._setValue_array,
        PropertyBinding.prototype._setValue_array_setNeedsUpdate,
        PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate
      ],
      [
        PropertyBinding.prototype._setValue_arrayElement,
        PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
        PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
      ],
      [
        PropertyBinding.prototype._setValue_fromArray,
        PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
        PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
      ]
    ];
    AnimationObjectGroup = class {
      constructor() {
        this.uuid = generateUUID();
        this._objects = Array.prototype.slice.call(arguments);
        this.nCachedObjects_ = 0;
        const indices = {};
        this._indicesByUUID = indices;
        for (let i2 = 0, n = arguments.length; i2 !== n; ++i2) {
          indices[arguments[i2].uuid] = i2;
        }
        this._paths = [];
        this._parsedPaths = [];
        this._bindings = [];
        this._bindingsIndicesByPath = {};
        const scope = this;
        this.stats = {
          objects: {
            get total() {
              return scope._objects.length;
            },
            get inUse() {
              return this.total - scope.nCachedObjects_;
            }
          },
          get bindingsPerObject() {
            return scope._bindings.length;
          }
        };
      }
      add() {
        const objects = this._objects, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length;
        let knownObject = void 0, nObjects = objects.length, nCachedObjects = this.nCachedObjects_;
        for (let i2 = 0, n = arguments.length; i2 !== n; ++i2) {
          const object = arguments[i2], uuid = object.uuid;
          let index = indicesByUUID[uuid];
          if (index === void 0) {
            index = nObjects++;
            indicesByUUID[uuid] = index;
            objects.push(object);
            for (let j = 0, m = nBindings; j !== m; ++j) {
              bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
            }
          } else if (index < nCachedObjects) {
            knownObject = objects[index];
            const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
            indicesByUUID[lastCachedObject.uuid] = index;
            objects[index] = lastCachedObject;
            indicesByUUID[uuid] = firstActiveIndex;
            objects[firstActiveIndex] = object;
            for (let j = 0, m = nBindings; j !== m; ++j) {
              const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex];
              let binding = bindingsForPath[index];
              bindingsForPath[index] = lastCached;
              if (binding === void 0) {
                binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
              }
              bindingsForPath[firstActiveIndex] = binding;
            }
          } else if (objects[index] !== knownObject) {
            console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
          }
        }
        this.nCachedObjects_ = nCachedObjects;
      }
      remove() {
        const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
        let nCachedObjects = this.nCachedObjects_;
        for (let i2 = 0, n = arguments.length; i2 !== n; ++i2) {
          const object = arguments[i2], uuid = object.uuid, index = indicesByUUID[uuid];
          if (index !== void 0 && index >= nCachedObjects) {
            const lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
            indicesByUUID[firstActiveObject.uuid] = index;
            objects[index] = firstActiveObject;
            indicesByUUID[uuid] = lastCachedIndex;
            objects[lastCachedIndex] = object;
            for (let j = 0, m = nBindings; j !== m; ++j) {
              const bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
              bindingsForPath[index] = firstActive;
              bindingsForPath[lastCachedIndex] = binding;
            }
          }
        }
        this.nCachedObjects_ = nCachedObjects;
      }
      uncache() {
        const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
        let nCachedObjects = this.nCachedObjects_, nObjects = objects.length;
        for (let i2 = 0, n = arguments.length; i2 !== n; ++i2) {
          const object = arguments[i2], uuid = object.uuid, index = indicesByUUID[uuid];
          if (index !== void 0) {
            delete indicesByUUID[uuid];
            if (index < nCachedObjects) {
              const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
              indicesByUUID[lastCachedObject.uuid] = index;
              objects[index] = lastCachedObject;
              indicesByUUID[lastObject.uuid] = firstActiveIndex;
              objects[firstActiveIndex] = lastObject;
              objects.pop();
              for (let j = 0, m = nBindings; j !== m; ++j) {
                const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
                bindingsForPath[index] = lastCached;
                bindingsForPath[firstActiveIndex] = last;
                bindingsForPath.pop();
              }
            } else {
              const lastIndex = --nObjects, lastObject = objects[lastIndex];
              if (lastIndex > 0) {
                indicesByUUID[lastObject.uuid] = index;
              }
              objects[index] = lastObject;
              objects.pop();
              for (let j = 0, m = nBindings; j !== m; ++j) {
                const bindingsForPath = bindings[j];
                bindingsForPath[index] = bindingsForPath[lastIndex];
                bindingsForPath.pop();
              }
            }
          }
        }
        this.nCachedObjects_ = nCachedObjects;
      }
      subscribe_(path, parsedPath) {
        const indicesByPath = this._bindingsIndicesByPath;
        let index = indicesByPath[path];
        const bindings = this._bindings;
        if (index !== void 0)
          return bindings[index];
        const paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
        index = bindings.length;
        indicesByPath[path] = index;
        paths.push(path);
        parsedPaths.push(parsedPath);
        bindings.push(bindingsForPath);
        for (let i2 = nCachedObjects, n = objects.length; i2 !== n; ++i2) {
          const object = objects[i2];
          bindingsForPath[i2] = new PropertyBinding(object, path, parsedPath);
        }
        return bindingsForPath;
      }
      unsubscribe_(path) {
        const indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
        if (index !== void 0) {
          const paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
          indicesByPath[lastBindingsPath] = index;
          bindings[index] = lastBindings;
          bindings.pop();
          parsedPaths[index] = parsedPaths[lastBindingsIndex];
          parsedPaths.pop();
          paths[index] = paths[lastBindingsIndex];
          paths.pop();
        }
      }
    };
    AnimationObjectGroup.prototype.isAnimationObjectGroup = true;
    AnimationAction = class {
      constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
        this._mixer = mixer;
        this._clip = clip;
        this._localRoot = localRoot;
        this.blendMode = blendMode;
        const tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
        const interpolantSettings = {
          endingStart: ZeroCurvatureEnding,
          endingEnd: ZeroCurvatureEnding
        };
        for (let i2 = 0; i2 !== nTracks; ++i2) {
          const interpolant = tracks[i2].createInterpolant(null);
          interpolants[i2] = interpolant;
          interpolant.settings = interpolantSettings;
        }
        this._interpolantSettings = interpolantSettings;
        this._interpolants = interpolants;
        this._propertyBindings = new Array(nTracks);
        this._cacheIndex = null;
        this._byClipCacheIndex = null;
        this._timeScaleInterpolant = null;
        this._weightInterpolant = null;
        this.loop = LoopRepeat;
        this._loopCount = -1;
        this._startTime = null;
        this.time = 0;
        this.timeScale = 1;
        this._effectiveTimeScale = 1;
        this.weight = 1;
        this._effectiveWeight = 1;
        this.repetitions = Infinity;
        this.paused = false;
        this.enabled = true;
        this.clampWhenFinished = false;
        this.zeroSlopeAtStart = true;
        this.zeroSlopeAtEnd = true;
      }
      play() {
        this._mixer._activateAction(this);
        return this;
      }
      stop() {
        this._mixer._deactivateAction(this);
        return this.reset();
      }
      reset() {
        this.paused = false;
        this.enabled = true;
        this.time = 0;
        this._loopCount = -1;
        this._startTime = null;
        return this.stopFading().stopWarping();
      }
      isRunning() {
        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
      }
      isScheduled() {
        return this._mixer._isActiveAction(this);
      }
      startAt(time) {
        this._startTime = time;
        return this;
      }
      setLoop(mode, repetitions) {
        this.loop = mode;
        this.repetitions = repetitions;
        return this;
      }
      setEffectiveWeight(weight) {
        this.weight = weight;
        this._effectiveWeight = this.enabled ? weight : 0;
        return this.stopFading();
      }
      getEffectiveWeight() {
        return this._effectiveWeight;
      }
      fadeIn(duration) {
        return this._scheduleFading(duration, 0, 1);
      }
      fadeOut(duration) {
        return this._scheduleFading(duration, 1, 0);
      }
      crossFadeFrom(fadeOutAction, duration, warp) {
        fadeOutAction.fadeOut(duration);
        this.fadeIn(duration);
        if (warp) {
          const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
          fadeOutAction.warp(1, startEndRatio, duration);
          this.warp(endStartRatio, 1, duration);
        }
        return this;
      }
      crossFadeTo(fadeInAction, duration, warp) {
        return fadeInAction.crossFadeFrom(this, duration, warp);
      }
      stopFading() {
        const weightInterpolant = this._weightInterpolant;
        if (weightInterpolant !== null) {
          this._weightInterpolant = null;
          this._mixer._takeBackControlInterpolant(weightInterpolant);
        }
        return this;
      }
      setEffectiveTimeScale(timeScale) {
        this.timeScale = timeScale;
        this._effectiveTimeScale = this.paused ? 0 : timeScale;
        return this.stopWarping();
      }
      getEffectiveTimeScale() {
        return this._effectiveTimeScale;
      }
      setDuration(duration) {
        this.timeScale = this._clip.duration / duration;
        return this.stopWarping();
      }
      syncWith(action) {
        this.time = action.time;
        this.timeScale = action.timeScale;
        return this.stopWarping();
      }
      halt(duration) {
        return this.warp(this._effectiveTimeScale, 0, duration);
      }
      warp(startTimeScale, endTimeScale, duration) {
        const mixer = this._mixer, now2 = mixer.time, timeScale = this.timeScale;
        let interpolant = this._timeScaleInterpolant;
        if (interpolant === null) {
          interpolant = mixer._lendControlInterpolant();
          this._timeScaleInterpolant = interpolant;
        }
        const times = interpolant.parameterPositions, values = interpolant.sampleValues;
        times[0] = now2;
        times[1] = now2 + duration;
        values[0] = startTimeScale / timeScale;
        values[1] = endTimeScale / timeScale;
        return this;
      }
      stopWarping() {
        const timeScaleInterpolant = this._timeScaleInterpolant;
        if (timeScaleInterpolant !== null) {
          this._timeScaleInterpolant = null;
          this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
        }
        return this;
      }
      getMixer() {
        return this._mixer;
      }
      getClip() {
        return this._clip;
      }
      getRoot() {
        return this._localRoot || this._mixer._root;
      }
      _update(time, deltaTime, timeDirection, accuIndex) {
        if (!this.enabled) {
          this._updateWeight(time);
          return;
        }
        const startTime = this._startTime;
        if (startTime !== null) {
          const timeRunning = (time - startTime) * timeDirection;
          if (timeRunning < 0 || timeDirection === 0) {
            return;
          }
          this._startTime = null;
          deltaTime = timeDirection * timeRunning;
        }
        deltaTime *= this._updateTimeScale(time);
        const clipTime = this._updateTime(deltaTime);
        const weight = this._updateWeight(time);
        if (weight > 0) {
          const interpolants = this._interpolants;
          const propertyMixers = this._propertyBindings;
          switch (this.blendMode) {
            case AdditiveAnimationBlendMode:
              for (let j = 0, m = interpolants.length; j !== m; ++j) {
                interpolants[j].evaluate(clipTime);
                propertyMixers[j].accumulateAdditive(weight);
              }
              break;
            case NormalAnimationBlendMode:
            default:
              for (let j = 0, m = interpolants.length; j !== m; ++j) {
                interpolants[j].evaluate(clipTime);
                propertyMixers[j].accumulate(accuIndex, weight);
              }
          }
        }
      }
      _updateWeight(time) {
        let weight = 0;
        if (this.enabled) {
          weight = this.weight;
          const interpolant = this._weightInterpolant;
          if (interpolant !== null) {
            const interpolantValue = interpolant.evaluate(time)[0];
            weight *= interpolantValue;
            if (time > interpolant.parameterPositions[1]) {
              this.stopFading();
              if (interpolantValue === 0) {
                this.enabled = false;
              }
            }
          }
        }
        this._effectiveWeight = weight;
        return weight;
      }
      _updateTimeScale(time) {
        let timeScale = 0;
        if (!this.paused) {
          timeScale = this.timeScale;
          const interpolant = this._timeScaleInterpolant;
          if (interpolant !== null) {
            const interpolantValue = interpolant.evaluate(time)[0];
            timeScale *= interpolantValue;
            if (time > interpolant.parameterPositions[1]) {
              this.stopWarping();
              if (timeScale === 0) {
                this.paused = true;
              } else {
                this.timeScale = timeScale;
              }
            }
          }
        }
        this._effectiveTimeScale = timeScale;
        return timeScale;
      }
      _updateTime(deltaTime) {
        const duration = this._clip.duration;
        const loop = this.loop;
        let time = this.time + deltaTime;
        let loopCount = this._loopCount;
        const pingPong = loop === LoopPingPong;
        if (deltaTime === 0) {
          if (loopCount === -1)
            return time;
          return pingPong && (loopCount & 1) === 1 ? duration - time : time;
        }
        if (loop === LoopOnce) {
          if (loopCount === -1) {
            this._loopCount = 0;
            this._setEndings(true, true, false);
          }
          handle_stop: {
            if (time >= duration) {
              time = duration;
            } else if (time < 0) {
              time = 0;
            } else {
              this.time = time;
              break handle_stop;
            }
            if (this.clampWhenFinished)
              this.paused = true;
            else
              this.enabled = false;
            this.time = time;
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: deltaTime < 0 ? -1 : 1
            });
          }
        } else {
          if (loopCount === -1) {
            if (deltaTime >= 0) {
              loopCount = 0;
              this._setEndings(true, this.repetitions === 0, pingPong);
            } else {
              this._setEndings(this.repetitions === 0, true, pingPong);
            }
          }
          if (time >= duration || time < 0) {
            const loopDelta = Math.floor(time / duration);
            time -= duration * loopDelta;
            loopCount += Math.abs(loopDelta);
            const pending = this.repetitions - loopCount;
            if (pending <= 0) {
              if (this.clampWhenFinished)
                this.paused = true;
              else
                this.enabled = false;
              time = deltaTime > 0 ? duration : 0;
              this.time = time;
              this._mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: deltaTime > 0 ? 1 : -1
              });
            } else {
              if (pending === 1) {
                const atStart = deltaTime < 0;
                this._setEndings(atStart, !atStart, pingPong);
              } else {
                this._setEndings(false, false, pingPong);
              }
              this._loopCount = loopCount;
              this.time = time;
              this._mixer.dispatchEvent({
                type: "loop",
                action: this,
                loopDelta
              });
            }
          } else {
            this.time = time;
          }
          if (pingPong && (loopCount & 1) === 1) {
            return duration - time;
          }
        }
        return time;
      }
      _setEndings(atStart, atEnd, pingPong) {
        const settings = this._interpolantSettings;
        if (pingPong) {
          settings.endingStart = ZeroSlopeEnding;
          settings.endingEnd = ZeroSlopeEnding;
        } else {
          if (atStart) {
            settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
          } else {
            settings.endingStart = WrapAroundEnding;
          }
          if (atEnd) {
            settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
          } else {
            settings.endingEnd = WrapAroundEnding;
          }
        }
      }
      _scheduleFading(duration, weightNow, weightThen) {
        const mixer = this._mixer, now2 = mixer.time;
        let interpolant = this._weightInterpolant;
        if (interpolant === null) {
          interpolant = mixer._lendControlInterpolant();
          this._weightInterpolant = interpolant;
        }
        const times = interpolant.parameterPositions, values = interpolant.sampleValues;
        times[0] = now2;
        values[0] = weightNow;
        times[1] = now2 + duration;
        values[1] = weightThen;
        return this;
      }
    };
    AnimationMixer = class extends EventDispatcher {
      constructor(root) {
        super();
        this._root = root;
        this._initMemoryManager();
        this._accuIndex = 0;
        this.time = 0;
        this.timeScale = 1;
      }
      _bindAction(action, prototypeAction) {
        const root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;
        let bindingsByName = bindingsByRoot[rootUuid];
        if (bindingsByName === void 0) {
          bindingsByName = {};
          bindingsByRoot[rootUuid] = bindingsByName;
        }
        for (let i2 = 0; i2 !== nTracks; ++i2) {
          const track = tracks[i2], trackName = track.name;
          let binding = bindingsByName[trackName];
          if (binding !== void 0) {
            ++binding.referenceCount;
            bindings[i2] = binding;
          } else {
            binding = bindings[i2];
            if (binding !== void 0) {
              if (binding._cacheIndex === null) {
                ++binding.referenceCount;
                this._addInactiveBinding(binding, rootUuid, trackName);
              }
              continue;
            }
            const path = prototypeAction && prototypeAction._propertyBindings[i2].binding.parsedPath;
            binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
            ++binding.referenceCount;
            this._addInactiveBinding(binding, rootUuid, trackName);
            bindings[i2] = binding;
          }
          interpolants[i2].resultBuffer = binding.buffer;
        }
      }
      _activateAction(action) {
        if (!this._isActiveAction(action)) {
          if (action._cacheIndex === null) {
            const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
            this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
            this._addInactiveAction(action, clipUuid, rootUuid);
          }
          const bindings = action._propertyBindings;
          for (let i2 = 0, n = bindings.length; i2 !== n; ++i2) {
            const binding = bindings[i2];
            if (binding.useCount++ === 0) {
              this._lendBinding(binding);
              binding.saveOriginalState();
            }
          }
          this._lendAction(action);
        }
      }
      _deactivateAction(action) {
        if (this._isActiveAction(action)) {
          const bindings = action._propertyBindings;
          for (let i2 = 0, n = bindings.length; i2 !== n; ++i2) {
            const binding = bindings[i2];
            if (--binding.useCount === 0) {
              binding.restoreOriginalState();
              this._takeBackBinding(binding);
            }
          }
          this._takeBackAction(action);
        }
      }
      _initMemoryManager() {
        this._actions = [];
        this._nActiveActions = 0;
        this._actionsByClip = {};
        this._bindings = [];
        this._nActiveBindings = 0;
        this._bindingsByRootAndName = {};
        this._controlInterpolants = [];
        this._nActiveControlInterpolants = 0;
        const scope = this;
        this.stats = {
          actions: {
            get total() {
              return scope._actions.length;
            },
            get inUse() {
              return scope._nActiveActions;
            }
          },
          bindings: {
            get total() {
              return scope._bindings.length;
            },
            get inUse() {
              return scope._nActiveBindings;
            }
          },
          controlInterpolants: {
            get total() {
              return scope._controlInterpolants.length;
            },
            get inUse() {
              return scope._nActiveControlInterpolants;
            }
          }
        };
      }
      _isActiveAction(action) {
        const index = action._cacheIndex;
        return index !== null && index < this._nActiveActions;
      }
      _addInactiveAction(action, clipUuid, rootUuid) {
        const actions = this._actions, actionsByClip = this._actionsByClip;
        let actionsForClip = actionsByClip[clipUuid];
        if (actionsForClip === void 0) {
          actionsForClip = {
            knownActions: [action],
            actionByRoot: {}
          };
          action._byClipCacheIndex = 0;
          actionsByClip[clipUuid] = actionsForClip;
        } else {
          const knownActions = actionsForClip.knownActions;
          action._byClipCacheIndex = knownActions.length;
          knownActions.push(action);
        }
        action._cacheIndex = actions.length;
        actions.push(action);
        actionsForClip.actionByRoot[rootUuid] = action;
      }
      _removeInactiveAction(action) {
        const actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();
        action._cacheIndex = null;
        const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
        lastKnownAction._byClipCacheIndex = byClipCacheIndex;
        knownActionsForClip[byClipCacheIndex] = lastKnownAction;
        knownActionsForClip.pop();
        action._byClipCacheIndex = null;
        const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
        delete actionByRoot[rootUuid];
        if (knownActionsForClip.length === 0) {
          delete actionsByClip[clipUuid];
        }
        this._removeInactiveBindingsForAction(action);
      }
      _removeInactiveBindingsForAction(action) {
        const bindings = action._propertyBindings;
        for (let i2 = 0, n = bindings.length; i2 !== n; ++i2) {
          const binding = bindings[i2];
          if (--binding.referenceCount === 0) {
            this._removeInactiveBinding(binding);
          }
        }
      }
      _lendAction(action) {
        const actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
        action._cacheIndex = lastActiveIndex;
        actions[lastActiveIndex] = action;
        firstInactiveAction._cacheIndex = prevIndex;
        actions[prevIndex] = firstInactiveAction;
      }
      _takeBackAction(action) {
        const actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
        action._cacheIndex = firstInactiveIndex;
        actions[firstInactiveIndex] = action;
        lastActiveAction._cacheIndex = prevIndex;
        actions[prevIndex] = lastActiveAction;
      }
      _addInactiveBinding(binding, rootUuid, trackName) {
        const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
        let bindingByName = bindingsByRoot[rootUuid];
        if (bindingByName === void 0) {
          bindingByName = {};
          bindingsByRoot[rootUuid] = bindingByName;
        }
        bindingByName[trackName] = binding;
        binding._cacheIndex = bindings.length;
        bindings.push(binding);
      }
      _removeInactiveBinding(binding) {
        const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
        lastInactiveBinding._cacheIndex = cacheIndex;
        bindings[cacheIndex] = lastInactiveBinding;
        bindings.pop();
        delete bindingByName[trackName];
        if (Object.keys(bindingByName).length === 0) {
          delete bindingsByRoot[rootUuid];
        }
      }
      _lendBinding(binding) {
        const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
        binding._cacheIndex = lastActiveIndex;
        bindings[lastActiveIndex] = binding;
        firstInactiveBinding._cacheIndex = prevIndex;
        bindings[prevIndex] = firstInactiveBinding;
      }
      _takeBackBinding(binding) {
        const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
        binding._cacheIndex = firstInactiveIndex;
        bindings[firstInactiveIndex] = binding;
        lastActiveBinding._cacheIndex = prevIndex;
        bindings[prevIndex] = lastActiveBinding;
      }
      _lendControlInterpolant() {
        const interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
        let interpolant = interpolants[lastActiveIndex];
        if (interpolant === void 0) {
          interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
          interpolant.__cacheIndex = lastActiveIndex;
          interpolants[lastActiveIndex] = interpolant;
        }
        return interpolant;
      }
      _takeBackControlInterpolant(interpolant) {
        const interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
        interpolant.__cacheIndex = firstInactiveIndex;
        interpolants[firstInactiveIndex] = interpolant;
        lastActiveInterpolant.__cacheIndex = prevIndex;
        interpolants[prevIndex] = lastActiveInterpolant;
      }
      clipAction(clip, optionalRoot, blendMode) {
        const root = optionalRoot || this._root, rootUuid = root.uuid;
        let clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip;
        const clipUuid = clipObject !== null ? clipObject.uuid : clip;
        const actionsForClip = this._actionsByClip[clipUuid];
        let prototypeAction = null;
        if (blendMode === void 0) {
          if (clipObject !== null) {
            blendMode = clipObject.blendMode;
          } else {
            blendMode = NormalAnimationBlendMode;
          }
        }
        if (actionsForClip !== void 0) {
          const existingAction = actionsForClip.actionByRoot[rootUuid];
          if (existingAction !== void 0 && existingAction.blendMode === blendMode) {
            return existingAction;
          }
          prototypeAction = actionsForClip.knownActions[0];
          if (clipObject === null)
            clipObject = prototypeAction._clip;
        }
        if (clipObject === null)
          return null;
        const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
        this._bindAction(newAction, prototypeAction);
        this._addInactiveAction(newAction, clipUuid, rootUuid);
        return newAction;
      }
      existingAction(clip, optionalRoot) {
        const root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
        if (actionsForClip !== void 0) {
          return actionsForClip.actionByRoot[rootUuid] || null;
        }
        return null;
      }
      stopAllAction() {
        const actions = this._actions, nActions = this._nActiveActions;
        for (let i2 = nActions - 1; i2 >= 0; --i2) {
          actions[i2].stop();
        }
        return this;
      }
      update(deltaTime) {
        deltaTime *= this.timeScale;
        const actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
        for (let i2 = 0; i2 !== nActions; ++i2) {
          const action = actions[i2];
          action._update(time, deltaTime, timeDirection, accuIndex);
        }
        const bindings = this._bindings, nBindings = this._nActiveBindings;
        for (let i2 = 0; i2 !== nBindings; ++i2) {
          bindings[i2].apply(accuIndex);
        }
        return this;
      }
      setTime(timeInSeconds) {
        this.time = 0;
        for (let i2 = 0; i2 < this._actions.length; i2++) {
          this._actions[i2].time = 0;
        }
        return this.update(timeInSeconds);
      }
      getRoot() {
        return this._root;
      }
      uncacheClip(clip) {
        const actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
        if (actionsForClip !== void 0) {
          const actionsToRemove = actionsForClip.knownActions;
          for (let i2 = 0, n = actionsToRemove.length; i2 !== n; ++i2) {
            const action = actionsToRemove[i2];
            this._deactivateAction(action);
            const cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
            action._cacheIndex = null;
            action._byClipCacheIndex = null;
            lastInactiveAction._cacheIndex = cacheIndex;
            actions[cacheIndex] = lastInactiveAction;
            actions.pop();
            this._removeInactiveBindingsForAction(action);
          }
          delete actionsByClip[clipUuid];
        }
      }
      uncacheRoot(root) {
        const rootUuid = root.uuid, actionsByClip = this._actionsByClip;
        for (const clipUuid in actionsByClip) {
          const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
          if (action !== void 0) {
            this._deactivateAction(action);
            this._removeInactiveAction(action);
          }
        }
        const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
        if (bindingByName !== void 0) {
          for (const trackName in bindingByName) {
            const binding = bindingByName[trackName];
            binding.restoreOriginalState();
            this._removeInactiveBinding(binding);
          }
        }
      }
      uncacheAction(clip, optionalRoot) {
        const action = this.existingAction(clip, optionalRoot);
        if (action !== null) {
          this._deactivateAction(action);
          this._removeInactiveAction(action);
        }
      }
    };
    AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
    Uniform = class {
      constructor(value) {
        if (typeof value === "string") {
          console.warn("THREE.Uniform: Type parameter is no longer needed.");
          value = arguments[1];
        }
        this.value = value;
      }
      clone() {
        return new Uniform(this.value.clone === void 0 ? this.value : this.value.clone());
      }
    };
    InstancedInterleavedBuffer = class extends InterleavedBuffer {
      constructor(array, stride, meshPerAttribute = 1) {
        super(array, stride);
        this.meshPerAttribute = meshPerAttribute;
      }
      copy(source) {
        super.copy(source);
        this.meshPerAttribute = source.meshPerAttribute;
        return this;
      }
      clone(data) {
        const ib = super.clone(data);
        ib.meshPerAttribute = this.meshPerAttribute;
        return ib;
      }
      toJSON(data) {
        const json = super.toJSON(data);
        json.isInstancedInterleavedBuffer = true;
        json.meshPerAttribute = this.meshPerAttribute;
        return json;
      }
    };
    InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;
    GLBufferAttribute = class {
      constructor(buffer, type, itemSize, elementSize, count) {
        this.buffer = buffer;
        this.type = type;
        this.itemSize = itemSize;
        this.elementSize = elementSize;
        this.count = count;
        this.version = 0;
      }
      set needsUpdate(value) {
        if (value === true)
          this.version++;
      }
      setBuffer(buffer) {
        this.buffer = buffer;
        return this;
      }
      setType(type, elementSize) {
        this.type = type;
        this.elementSize = elementSize;
        return this;
      }
      setItemSize(itemSize) {
        this.itemSize = itemSize;
        return this;
      }
      setCount(count) {
        this.count = count;
        return this;
      }
    };
    GLBufferAttribute.prototype.isGLBufferAttribute = true;
    Raycaster = class {
      constructor(origin, direction, near = 0, far = Infinity) {
        this.ray = new Ray(origin, direction);
        this.near = near;
        this.far = far;
        this.camera = null;
        this.layers = new Layers();
        this.params = {
          Mesh: {},
          Line: { threshold: 1 },
          LOD: {},
          Points: { threshold: 1 },
          Sprite: {}
        };
      }
      set(origin, direction) {
        this.ray.set(origin, direction);
      }
      setFromCamera(coords, camera) {
        if (camera.isPerspectiveCamera) {
          this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
          this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
          this.camera = camera;
        } else if (camera.isOrthographicCamera) {
          this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
          this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
          this.camera = camera;
        } else {
          console.error("THREE.Raycaster: Unsupported camera type: " + camera.type);
        }
      }
      intersectObject(object, recursive = true, intersects2 = []) {
        intersectObject(object, this, intersects2, recursive);
        intersects2.sort(ascSort);
        return intersects2;
      }
      intersectObjects(objects, recursive = true, intersects2 = []) {
        for (let i2 = 0, l = objects.length; i2 < l; i2++) {
          intersectObject(objects[i2], this, intersects2, recursive);
        }
        intersects2.sort(ascSort);
        return intersects2;
      }
    };
    Spherical = class {
      constructor(radius = 1, phi = 0, theta = 0) {
        this.radius = radius;
        this.phi = phi;
        this.theta = theta;
        return this;
      }
      set(radius, phi, theta) {
        this.radius = radius;
        this.phi = phi;
        this.theta = theta;
        return this;
      }
      copy(other) {
        this.radius = other.radius;
        this.phi = other.phi;
        this.theta = other.theta;
        return this;
      }
      makeSafe() {
        const EPS = 1e-6;
        this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
        return this;
      }
      setFromVector3(v) {
        return this.setFromCartesianCoords(v.x, v.y, v.z);
      }
      setFromCartesianCoords(x, y2, z) {
        this.radius = Math.sqrt(x * x + y2 * y2 + z * z);
        if (this.radius === 0) {
          this.theta = 0;
          this.phi = 0;
        } else {
          this.theta = Math.atan2(x, z);
          this.phi = Math.acos(clamp(y2 / this.radius, -1, 1));
        }
        return this;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    };
    Cylindrical = class {
      constructor(radius = 1, theta = 0, y2 = 0) {
        this.radius = radius;
        this.theta = theta;
        this.y = y2;
        return this;
      }
      set(radius, theta, y2) {
        this.radius = radius;
        this.theta = theta;
        this.y = y2;
        return this;
      }
      copy(other) {
        this.radius = other.radius;
        this.theta = other.theta;
        this.y = other.y;
        return this;
      }
      setFromVector3(v) {
        return this.setFromCartesianCoords(v.x, v.y, v.z);
      }
      setFromCartesianCoords(x, y2, z) {
        this.radius = Math.sqrt(x * x + z * z);
        this.theta = Math.atan2(x, z);
        this.y = y2;
        return this;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    };
    _vector$4 = /* @__PURE__ */ new Vector2();
    Box2 = class {
      constructor(min = new Vector2(Infinity, Infinity), max = new Vector2(-Infinity, -Infinity)) {
        this.min = min;
        this.max = max;
      }
      set(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
      }
      setFromPoints(points) {
        this.makeEmpty();
        for (let i2 = 0, il = points.length; i2 < il; i2++) {
          this.expandByPoint(points[i2]);
        }
        return this;
      }
      setFromCenterAndSize(center, size) {
        const halfSize = _vector$4.copy(size).multiplyScalar(0.5);
        this.min.copy(center).sub(halfSize);
        this.max.copy(center).add(halfSize);
        return this;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
      }
      makeEmpty() {
        this.min.x = this.min.y = Infinity;
        this.max.x = this.max.y = -Infinity;
        return this;
      }
      isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y;
      }
      getCenter(target) {
        return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
      }
      getSize(target) {
        return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
      }
      expandByPoint(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
      }
      expandByVector(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
      }
      expandByScalar(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
      }
      containsPoint(point) {
        return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
      }
      containsBox(box) {
        return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
      }
      getParameter(point, target) {
        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
      }
      intersectsBox(box) {
        return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
      }
      clampPoint(point, target) {
        return target.copy(point).clamp(this.min, this.max);
      }
      distanceToPoint(point) {
        const clampedPoint = _vector$4.copy(point).clamp(this.min, this.max);
        return clampedPoint.sub(point).length();
      }
      intersect(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        return this;
      }
      union(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
      }
      translate(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
      }
      equals(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
      }
    };
    Box2.prototype.isBox2 = true;
    _startP = /* @__PURE__ */ new Vector3();
    _startEnd = /* @__PURE__ */ new Vector3();
    Line3 = class {
      constructor(start = new Vector3(), end = new Vector3()) {
        this.start = start;
        this.end = end;
      }
      set(start, end) {
        this.start.copy(start);
        this.end.copy(end);
        return this;
      }
      copy(line) {
        this.start.copy(line.start);
        this.end.copy(line.end);
        return this;
      }
      getCenter(target) {
        return target.addVectors(this.start, this.end).multiplyScalar(0.5);
      }
      delta(target) {
        return target.subVectors(this.end, this.start);
      }
      distanceSq() {
        return this.start.distanceToSquared(this.end);
      }
      distance() {
        return this.start.distanceTo(this.end);
      }
      at(t2, target) {
        return this.delta(target).multiplyScalar(t2).add(this.start);
      }
      closestPointToPointParameter(point, clampToLine) {
        _startP.subVectors(point, this.start);
        _startEnd.subVectors(this.end, this.start);
        const startEnd2 = _startEnd.dot(_startEnd);
        const startEnd_startP = _startEnd.dot(_startP);
        let t2 = startEnd_startP / startEnd2;
        if (clampToLine) {
          t2 = clamp(t2, 0, 1);
        }
        return t2;
      }
      closestPointToPoint(point, clampToLine, target) {
        const t2 = this.closestPointToPointParameter(point, clampToLine);
        return this.delta(target).multiplyScalar(t2).add(this.start);
      }
      applyMatrix4(matrix) {
        this.start.applyMatrix4(matrix);
        this.end.applyMatrix4(matrix);
        return this;
      }
      equals(line) {
        return line.start.equals(this.start) && line.end.equals(this.end);
      }
      clone() {
        return new this.constructor().copy(this);
      }
    };
    _vector$3 = /* @__PURE__ */ new Vector3();
    SpotLightHelper = class extends Object3D {
      constructor(light, color) {
        super();
        this.light = light;
        this.light.updateMatrixWorld();
        this.matrix = light.matrixWorld;
        this.matrixAutoUpdate = false;
        this.color = color;
        const geometry = new BufferGeometry();
        const positions = [
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          -1,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          1,
          0,
          0,
          0,
          0,
          -1,
          1
        ];
        for (let i2 = 0, j = 1, l = 32; i2 < l; i2++, j++) {
          const p1 = i2 / l * Math.PI * 2;
          const p2 = j / l * Math.PI * 2;
          positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
        }
        geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
        const material = new LineBasicMaterial({ fog: false, toneMapped: false });
        this.cone = new LineSegments(geometry, material);
        this.add(this.cone);
        this.update();
      }
      dispose() {
        this.cone.geometry.dispose();
        this.cone.material.dispose();
      }
      update() {
        this.light.updateMatrixWorld();
        const coneLength = this.light.distance ? this.light.distance : 1e3;
        const coneWidth = coneLength * Math.tan(this.light.angle);
        this.cone.scale.set(coneWidth, coneWidth, coneLength);
        _vector$3.setFromMatrixPosition(this.light.target.matrixWorld);
        this.cone.lookAt(_vector$3);
        if (this.color !== void 0) {
          this.cone.material.color.set(this.color);
        } else {
          this.cone.material.color.copy(this.light.color);
        }
      }
    };
    _vector$2 = /* @__PURE__ */ new Vector3();
    _boneMatrix = /* @__PURE__ */ new Matrix4();
    _matrixWorldInv = /* @__PURE__ */ new Matrix4();
    SkeletonHelper = class extends LineSegments {
      constructor(object) {
        const bones = getBoneList(object);
        const geometry = new BufferGeometry();
        const vertices = [];
        const colors = [];
        const color1 = new Color(0, 0, 1);
        const color2 = new Color(0, 1, 0);
        for (let i2 = 0; i2 < bones.length; i2++) {
          const bone = bones[i2];
          if (bone.parent && bone.parent.isBone) {
            vertices.push(0, 0, 0);
            vertices.push(0, 0, 0);
            colors.push(color1.r, color1.g, color1.b);
            colors.push(color2.r, color2.g, color2.b);
          }
        }
        geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
        const material = new LineBasicMaterial({ vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true });
        super(geometry, material);
        this.type = "SkeletonHelper";
        this.isSkeletonHelper = true;
        this.root = object;
        this.bones = bones;
        this.matrix = object.matrixWorld;
        this.matrixAutoUpdate = false;
      }
      updateMatrixWorld(force) {
        const bones = this.bones;
        const geometry = this.geometry;
        const position = geometry.getAttribute("position");
        _matrixWorldInv.copy(this.root.matrixWorld).invert();
        for (let i2 = 0, j = 0; i2 < bones.length; i2++) {
          const bone = bones[i2];
          if (bone.parent && bone.parent.isBone) {
            _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
            _vector$2.setFromMatrixPosition(_boneMatrix);
            position.setXYZ(j, _vector$2.x, _vector$2.y, _vector$2.z);
            _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
            _vector$2.setFromMatrixPosition(_boneMatrix);
            position.setXYZ(j + 1, _vector$2.x, _vector$2.y, _vector$2.z);
            j += 2;
          }
        }
        geometry.getAttribute("position").needsUpdate = true;
        super.updateMatrixWorld(force);
      }
    };
    PointLightHelper = class extends Mesh {
      constructor(light, sphereSize, color) {
        const geometry = new SphereGeometry(sphereSize, 4, 2);
        const material = new MeshBasicMaterial({ wireframe: true, fog: false, toneMapped: false });
        super(geometry, material);
        this.light = light;
        this.light.updateMatrixWorld();
        this.color = color;
        this.type = "PointLightHelper";
        this.matrix = this.light.matrixWorld;
        this.matrixAutoUpdate = false;
        this.update();
      }
      dispose() {
        this.geometry.dispose();
        this.material.dispose();
      }
      update() {
        if (this.color !== void 0) {
          this.material.color.set(this.color);
        } else {
          this.material.color.copy(this.light.color);
        }
      }
    };
    _vector$1 = /* @__PURE__ */ new Vector3();
    _color1 = /* @__PURE__ */ new Color();
    _color2 = /* @__PURE__ */ new Color();
    HemisphereLightHelper = class extends Object3D {
      constructor(light, size, color) {
        super();
        this.light = light;
        this.light.updateMatrixWorld();
        this.matrix = light.matrixWorld;
        this.matrixAutoUpdate = false;
        this.color = color;
        const geometry = new OctahedronGeometry(size);
        geometry.rotateY(Math.PI * 0.5);
        this.material = new MeshBasicMaterial({ wireframe: true, fog: false, toneMapped: false });
        if (this.color === void 0)
          this.material.vertexColors = true;
        const position = geometry.getAttribute("position");
        const colors = new Float32Array(position.count * 3);
        geometry.setAttribute("color", new BufferAttribute(colors, 3));
        this.add(new Mesh(geometry, this.material));
        this.update();
      }
      dispose() {
        this.children[0].geometry.dispose();
        this.children[0].material.dispose();
      }
      update() {
        const mesh = this.children[0];
        if (this.color !== void 0) {
          this.material.color.set(this.color);
        } else {
          const colors = mesh.geometry.getAttribute("color");
          _color1.copy(this.light.color);
          _color2.copy(this.light.groundColor);
          for (let i2 = 0, l = colors.count; i2 < l; i2++) {
            const color = i2 < l / 2 ? _color1 : _color2;
            colors.setXYZ(i2, color.r, color.g, color.b);
          }
          colors.needsUpdate = true;
        }
        mesh.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate());
      }
    };
    GridHelper = class extends LineSegments {
      constructor(size = 10, divisions = 10, color1 = 4473924, color2 = 8947848) {
        color1 = new Color(color1);
        color2 = new Color(color2);
        const center = divisions / 2;
        const step = size / divisions;
        const halfSize = size / 2;
        const vertices = [], colors = [];
        for (let i2 = 0, j = 0, k = -halfSize; i2 <= divisions; i2++, k += step) {
          vertices.push(-halfSize, 0, k, halfSize, 0, k);
          vertices.push(k, 0, -halfSize, k, 0, halfSize);
          const color = i2 === center ? color1 : color2;
          color.toArray(colors, j);
          j += 3;
          color.toArray(colors, j);
          j += 3;
          color.toArray(colors, j);
          j += 3;
          color.toArray(colors, j);
          j += 3;
        }
        const geometry = new BufferGeometry();
        geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
        const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
        super(geometry, material);
        this.type = "GridHelper";
      }
    };
    PolarGridHelper = class extends LineSegments {
      constructor(radius = 10, radials = 16, circles = 8, divisions = 64, color1 = 4473924, color2 = 8947848) {
        color1 = new Color(color1);
        color2 = new Color(color2);
        const vertices = [];
        const colors = [];
        for (let i2 = 0; i2 <= radials; i2++) {
          const v = i2 / radials * (Math.PI * 2);
          const x = Math.sin(v) * radius;
          const z = Math.cos(v) * radius;
          vertices.push(0, 0, 0);
          vertices.push(x, 0, z);
          const color = i2 & 1 ? color1 : color2;
          colors.push(color.r, color.g, color.b);
          colors.push(color.r, color.g, color.b);
        }
        for (let i2 = 0; i2 <= circles; i2++) {
          const color = i2 & 1 ? color1 : color2;
          const r3 = radius - radius / circles * i2;
          for (let j = 0; j < divisions; j++) {
            let v = j / divisions * (Math.PI * 2);
            let x = Math.sin(v) * r3;
            let z = Math.cos(v) * r3;
            vertices.push(x, 0, z);
            colors.push(color.r, color.g, color.b);
            v = (j + 1) / divisions * (Math.PI * 2);
            x = Math.sin(v) * r3;
            z = Math.cos(v) * r3;
            vertices.push(x, 0, z);
            colors.push(color.r, color.g, color.b);
          }
        }
        const geometry = new BufferGeometry();
        geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
        const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
        super(geometry, material);
        this.type = "PolarGridHelper";
      }
    };
    _v1 = /* @__PURE__ */ new Vector3();
    _v2 = /* @__PURE__ */ new Vector3();
    _v3 = /* @__PURE__ */ new Vector3();
    DirectionalLightHelper = class extends Object3D {
      constructor(light, size, color) {
        super();
        this.light = light;
        this.light.updateMatrixWorld();
        this.matrix = light.matrixWorld;
        this.matrixAutoUpdate = false;
        this.color = color;
        if (size === void 0)
          size = 1;
        let geometry = new BufferGeometry();
        geometry.setAttribute("position", new Float32BufferAttribute([
          -size,
          size,
          0,
          size,
          size,
          0,
          size,
          -size,
          0,
          -size,
          -size,
          0,
          -size,
          size,
          0
        ], 3));
        const material = new LineBasicMaterial({ fog: false, toneMapped: false });
        this.lightPlane = new Line(geometry, material);
        this.add(this.lightPlane);
        geometry = new BufferGeometry();
        geometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
        this.targetLine = new Line(geometry, material);
        this.add(this.targetLine);
        this.update();
      }
      dispose() {
        this.lightPlane.geometry.dispose();
        this.lightPlane.material.dispose();
        this.targetLine.geometry.dispose();
        this.targetLine.material.dispose();
      }
      update() {
        _v1.setFromMatrixPosition(this.light.matrixWorld);
        _v2.setFromMatrixPosition(this.light.target.matrixWorld);
        _v3.subVectors(_v2, _v1);
        this.lightPlane.lookAt(_v2);
        if (this.color !== void 0) {
          this.lightPlane.material.color.set(this.color);
          this.targetLine.material.color.set(this.color);
        } else {
          this.lightPlane.material.color.copy(this.light.color);
          this.targetLine.material.color.copy(this.light.color);
        }
        this.targetLine.lookAt(_v2);
        this.targetLine.scale.z = _v3.length();
      }
    };
    _vector = /* @__PURE__ */ new Vector3();
    _camera = /* @__PURE__ */ new Camera();
    CameraHelper = class extends LineSegments {
      constructor(camera) {
        const geometry = new BufferGeometry();
        const material = new LineBasicMaterial({ color: 16777215, vertexColors: true, toneMapped: false });
        const vertices = [];
        const colors = [];
        const pointMap = {};
        const colorFrustum = new Color(16755200);
        const colorCone = new Color(16711680);
        const colorUp = new Color(43775);
        const colorTarget = new Color(16777215);
        const colorCross = new Color(3355443);
        addLine("n1", "n2", colorFrustum);
        addLine("n2", "n4", colorFrustum);
        addLine("n4", "n3", colorFrustum);
        addLine("n3", "n1", colorFrustum);
        addLine("f1", "f2", colorFrustum);
        addLine("f2", "f4", colorFrustum);
        addLine("f4", "f3", colorFrustum);
        addLine("f3", "f1", colorFrustum);
        addLine("n1", "f1", colorFrustum);
        addLine("n2", "f2", colorFrustum);
        addLine("n3", "f3", colorFrustum);
        addLine("n4", "f4", colorFrustum);
        addLine("p", "n1", colorCone);
        addLine("p", "n2", colorCone);
        addLine("p", "n3", colorCone);
        addLine("p", "n4", colorCone);
        addLine("u1", "u2", colorUp);
        addLine("u2", "u3", colorUp);
        addLine("u3", "u1", colorUp);
        addLine("c", "t", colorTarget);
        addLine("p", "c", colorCross);
        addLine("cn1", "cn2", colorCross);
        addLine("cn3", "cn4", colorCross);
        addLine("cf1", "cf2", colorCross);
        addLine("cf3", "cf4", colorCross);
        function addLine(a, b2, color) {
          addPoint(a, color);
          addPoint(b2, color);
        }
        function addPoint(id, color) {
          vertices.push(0, 0, 0);
          colors.push(color.r, color.g, color.b);
          if (pointMap[id] === void 0) {
            pointMap[id] = [];
          }
          pointMap[id].push(vertices.length / 3 - 1);
        }
        geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
        super(geometry, material);
        this.type = "CameraHelper";
        this.camera = camera;
        if (this.camera.updateProjectionMatrix)
          this.camera.updateProjectionMatrix();
        this.matrix = camera.matrixWorld;
        this.matrixAutoUpdate = false;
        this.pointMap = pointMap;
        this.update();
      }
      update() {
        const geometry = this.geometry;
        const pointMap = this.pointMap;
        const w = 1, h = 1;
        _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
        setPoint("c", pointMap, geometry, _camera, 0, 0, -1);
        setPoint("t", pointMap, geometry, _camera, 0, 0, 1);
        setPoint("n1", pointMap, geometry, _camera, -w, -h, -1);
        setPoint("n2", pointMap, geometry, _camera, w, -h, -1);
        setPoint("n3", pointMap, geometry, _camera, -w, h, -1);
        setPoint("n4", pointMap, geometry, _camera, w, h, -1);
        setPoint("f1", pointMap, geometry, _camera, -w, -h, 1);
        setPoint("f2", pointMap, geometry, _camera, w, -h, 1);
        setPoint("f3", pointMap, geometry, _camera, -w, h, 1);
        setPoint("f4", pointMap, geometry, _camera, w, h, 1);
        setPoint("u1", pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);
        setPoint("u2", pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);
        setPoint("u3", pointMap, geometry, _camera, 0, h * 2, -1);
        setPoint("cf1", pointMap, geometry, _camera, -w, 0, 1);
        setPoint("cf2", pointMap, geometry, _camera, w, 0, 1);
        setPoint("cf3", pointMap, geometry, _camera, 0, -h, 1);
        setPoint("cf4", pointMap, geometry, _camera, 0, h, 1);
        setPoint("cn1", pointMap, geometry, _camera, -w, 0, -1);
        setPoint("cn2", pointMap, geometry, _camera, w, 0, -1);
        setPoint("cn3", pointMap, geometry, _camera, 0, -h, -1);
        setPoint("cn4", pointMap, geometry, _camera, 0, h, -1);
        geometry.getAttribute("position").needsUpdate = true;
      }
      dispose() {
        this.geometry.dispose();
        this.material.dispose();
      }
    };
    _box = /* @__PURE__ */ new Box3();
    BoxHelper = class extends LineSegments {
      constructor(object, color = 16776960) {
        const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
        const positions = new Float32Array(8 * 3);
        const geometry = new BufferGeometry();
        geometry.setIndex(new BufferAttribute(indices, 1));
        geometry.setAttribute("position", new BufferAttribute(positions, 3));
        super(geometry, new LineBasicMaterial({ color, toneMapped: false }));
        this.object = object;
        this.type = "BoxHelper";
        this.matrixAutoUpdate = false;
        this.update();
      }
      update(object) {
        if (object !== void 0) {
          console.warn("THREE.BoxHelper: .update() has no longer arguments.");
        }
        if (this.object !== void 0) {
          _box.setFromObject(this.object);
        }
        if (_box.isEmpty())
          return;
        const min = _box.min;
        const max = _box.max;
        const position = this.geometry.attributes.position;
        const array = position.array;
        array[0] = max.x;
        array[1] = max.y;
        array[2] = max.z;
        array[3] = min.x;
        array[4] = max.y;
        array[5] = max.z;
        array[6] = min.x;
        array[7] = min.y;
        array[8] = max.z;
        array[9] = max.x;
        array[10] = min.y;
        array[11] = max.z;
        array[12] = max.x;
        array[13] = max.y;
        array[14] = min.z;
        array[15] = min.x;
        array[16] = max.y;
        array[17] = min.z;
        array[18] = min.x;
        array[19] = min.y;
        array[20] = min.z;
        array[21] = max.x;
        array[22] = min.y;
        array[23] = min.z;
        position.needsUpdate = true;
        this.geometry.computeBoundingSphere();
      }
      setFromObject(object) {
        this.object = object;
        this.update();
        return this;
      }
      copy(source) {
        LineSegments.prototype.copy.call(this, source);
        this.object = source.object;
        return this;
      }
    };
    Box3Helper = class extends LineSegments {
      constructor(box, color = 16776960) {
        const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
        const positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
        const geometry = new BufferGeometry();
        geometry.setIndex(new BufferAttribute(indices, 1));
        geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
        super(geometry, new LineBasicMaterial({ color, toneMapped: false }));
        this.box = box;
        this.type = "Box3Helper";
        this.geometry.computeBoundingSphere();
      }
      updateMatrixWorld(force) {
        const box = this.box;
        if (box.isEmpty())
          return;
        box.getCenter(this.position);
        box.getSize(this.scale);
        this.scale.multiplyScalar(0.5);
        super.updateMatrixWorld(force);
      }
    };
    PlaneHelper = class extends Line {
      constructor(plane, size = 1, hex = 16776960) {
        const color = hex;
        const positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];
        const geometry = new BufferGeometry();
        geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
        geometry.computeBoundingSphere();
        super(geometry, new LineBasicMaterial({ color, toneMapped: false }));
        this.type = "PlaneHelper";
        this.plane = plane;
        this.size = size;
        const positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];
        const geometry2 = new BufferGeometry();
        geometry2.setAttribute("position", new Float32BufferAttribute(positions2, 3));
        geometry2.computeBoundingSphere();
        this.add(new Mesh(geometry2, new MeshBasicMaterial({ color, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false })));
      }
      updateMatrixWorld(force) {
        let scale = -this.plane.constant;
        if (Math.abs(scale) < 1e-8)
          scale = 1e-8;
        this.scale.set(0.5 * this.size, 0.5 * this.size, scale);
        this.children[0].material.side = scale < 0 ? BackSide : FrontSide;
        this.lookAt(this.plane.normal);
        super.updateMatrixWorld(force);
      }
    };
    _axis = /* @__PURE__ */ new Vector3();
    ArrowHelper = class extends Object3D {
      constructor(dir = new Vector3(0, 0, 1), origin = new Vector3(0, 0, 0), length = 1, color = 16776960, headLength = length * 0.2, headWidth = headLength * 0.2) {
        super();
        this.type = "ArrowHelper";
        if (_lineGeometry === void 0) {
          _lineGeometry = new BufferGeometry();
          _lineGeometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));
          _coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);
          _coneGeometry.translate(0, -0.5, 0);
        }
        this.position.copy(origin);
        this.line = new Line(_lineGeometry, new LineBasicMaterial({ color, toneMapped: false }));
        this.line.matrixAutoUpdate = false;
        this.add(this.line);
        this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({ color, toneMapped: false }));
        this.cone.matrixAutoUpdate = false;
        this.add(this.cone);
        this.setDirection(dir);
        this.setLength(length, headLength, headWidth);
      }
      setDirection(dir) {
        if (dir.y > 0.99999) {
          this.quaternion.set(0, 0, 0, 1);
        } else if (dir.y < -0.99999) {
          this.quaternion.set(1, 0, 0, 0);
        } else {
          _axis.set(dir.z, 0, -dir.x).normalize();
          const radians = Math.acos(dir.y);
          this.quaternion.setFromAxisAngle(_axis, radians);
        }
      }
      setLength(length, headLength = length * 0.2, headWidth = headLength * 0.2) {
        this.line.scale.set(1, Math.max(1e-4, length - headLength), 1);
        this.line.updateMatrix();
        this.cone.scale.set(headWidth, headLength, headWidth);
        this.cone.position.y = length;
        this.cone.updateMatrix();
      }
      setColor(color) {
        this.line.material.color.set(color);
        this.cone.material.color.set(color);
      }
      copy(source) {
        super.copy(source, false);
        this.line.copy(source.line);
        this.cone.copy(source.cone);
        return this;
      }
    };
    AxesHelper = class extends LineSegments {
      constructor(size = 1) {
        const vertices = [
          0,
          0,
          0,
          size,
          0,
          0,
          0,
          0,
          0,
          0,
          size,
          0,
          0,
          0,
          0,
          0,
          0,
          size
        ];
        const colors = [
          1,
          0,
          0,
          1,
          0.6,
          0,
          0,
          1,
          0,
          0.6,
          1,
          0,
          0,
          0,
          1,
          0,
          0.6,
          1
        ];
        const geometry = new BufferGeometry();
        geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
        geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
        const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
        super(geometry, material);
        this.type = "AxesHelper";
      }
      setColors(xAxisColor, yAxisColor, zAxisColor) {
        const color = new Color();
        const array = this.geometry.attributes.color.array;
        color.set(xAxisColor);
        color.toArray(array, 0);
        color.toArray(array, 3);
        color.set(yAxisColor);
        color.toArray(array, 6);
        color.toArray(array, 9);
        color.set(zAxisColor);
        color.toArray(array, 12);
        color.toArray(array, 15);
        this.geometry.attributes.color.needsUpdate = true;
        return this;
      }
      dispose() {
        this.geometry.dispose();
        this.material.dispose();
      }
    };
    ShapePath = class {
      constructor() {
        this.type = "ShapePath";
        this.color = new Color();
        this.subPaths = [];
        this.currentPath = null;
      }
      moveTo(x, y2) {
        this.currentPath = new Path();
        this.subPaths.push(this.currentPath);
        this.currentPath.moveTo(x, y2);
        return this;
      }
      lineTo(x, y2) {
        this.currentPath.lineTo(x, y2);
        return this;
      }
      quadraticCurveTo(aCPx, aCPy, aX, aY) {
        this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
        return this;
      }
      bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
        return this;
      }
      splineThru(pts) {
        this.currentPath.splineThru(pts);
        return this;
      }
      toShapes(isCCW, noHoles) {
        function toShapesNoHoles(inSubpaths) {
          const shapes2 = [];
          for (let i2 = 0, l = inSubpaths.length; i2 < l; i2++) {
            const tmpPath2 = inSubpaths[i2];
            const tmpShape2 = new Shape();
            tmpShape2.curves = tmpPath2.curves;
            shapes2.push(tmpShape2);
          }
          return shapes2;
        }
        function isPointInsidePolygon(inPt, inPolygon) {
          const polyLen = inPolygon.length;
          let inside = false;
          for (let p = polyLen - 1, q = 0; q < polyLen; p = q++) {
            let edgeLowPt = inPolygon[p];
            let edgeHighPt = inPolygon[q];
            let edgeDx = edgeHighPt.x - edgeLowPt.x;
            let edgeDy = edgeHighPt.y - edgeLowPt.y;
            if (Math.abs(edgeDy) > Number.EPSILON) {
              if (edgeDy < 0) {
                edgeLowPt = inPolygon[q];
                edgeDx = -edgeDx;
                edgeHighPt = inPolygon[p];
                edgeDy = -edgeDy;
              }
              if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y)
                continue;
              if (inPt.y === edgeLowPt.y) {
                if (inPt.x === edgeLowPt.x)
                  return true;
              } else {
                const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                if (perpEdge === 0)
                  return true;
                if (perpEdge < 0)
                  continue;
                inside = !inside;
              }
            } else {
              if (inPt.y !== edgeLowPt.y)
                continue;
              if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x)
                return true;
            }
          }
          return inside;
        }
        const isClockWise = ShapeUtils.isClockWise;
        const subPaths = this.subPaths;
        if (subPaths.length === 0)
          return [];
        if (noHoles === true)
          return toShapesNoHoles(subPaths);
        let solid, tmpPath, tmpShape;
        const shapes = [];
        if (subPaths.length === 1) {
          tmpPath = subPaths[0];
          tmpShape = new Shape();
          tmpShape.curves = tmpPath.curves;
          shapes.push(tmpShape);
          return shapes;
        }
        let holesFirst = !isClockWise(subPaths[0].getPoints());
        holesFirst = isCCW ? !holesFirst : holesFirst;
        const betterShapeHoles = [];
        const newShapes = [];
        let newShapeHoles = [];
        let mainIdx = 0;
        let tmpPoints;
        newShapes[mainIdx] = void 0;
        newShapeHoles[mainIdx] = [];
        for (let i2 = 0, l = subPaths.length; i2 < l; i2++) {
          tmpPath = subPaths[i2];
          tmpPoints = tmpPath.getPoints();
          solid = isClockWise(tmpPoints);
          solid = isCCW ? !solid : solid;
          if (solid) {
            if (!holesFirst && newShapes[mainIdx])
              mainIdx++;
            newShapes[mainIdx] = { s: new Shape(), p: tmpPoints };
            newShapes[mainIdx].s.curves = tmpPath.curves;
            if (holesFirst)
              mainIdx++;
            newShapeHoles[mainIdx] = [];
          } else {
            newShapeHoles[mainIdx].push({ h: tmpPath, p: tmpPoints[0] });
          }
        }
        if (!newShapes[0])
          return toShapesNoHoles(subPaths);
        if (newShapes.length > 1) {
          let ambiguous = false;
          let toChange = 0;
          for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
            betterShapeHoles[sIdx] = [];
          }
          for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
            const sho = newShapeHoles[sIdx];
            for (let hIdx = 0; hIdx < sho.length; hIdx++) {
              const ho = sho[hIdx];
              let hole_unassigned = true;
              for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
                if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                  if (sIdx !== s2Idx)
                    toChange++;
                  if (hole_unassigned) {
                    hole_unassigned = false;
                    betterShapeHoles[s2Idx].push(ho);
                  } else {
                    ambiguous = true;
                  }
                }
              }
              if (hole_unassigned) {
                betterShapeHoles[sIdx].push(ho);
              }
            }
          }
          if (toChange > 0 && ambiguous === false) {
            newShapeHoles = betterShapeHoles;
          }
        }
        let tmpHoles;
        for (let i2 = 0, il = newShapes.length; i2 < il; i2++) {
          tmpShape = newShapes[i2].s;
          shapes.push(tmpShape);
          tmpHoles = newShapeHoles[i2];
          for (let j = 0, jl = tmpHoles.length; j < jl; j++) {
            tmpShape.holes.push(tmpHoles[j].h);
          }
        }
        return shapes;
      }
    };
    DataUtils = class {
      static toHalfFloat(val) {
        if (Math.abs(val) > 65504)
          console.warn("THREE.DataUtils.toHalfFloat(): Value out of range.");
        val = clamp(val, -65504, 65504);
        _floatView[0] = val;
        const f = _uint32View[0];
        const e = f >> 23 & 511;
        return _baseTable[e] + ((f & 8388607) >> _shiftTable[e]);
      }
      static fromHalfFloat(val) {
        const m = val >> 10;
        _uint32View[0] = _mantissaTable[_offsetTable[m] + (val & 1023)] + _exponentTable[m];
        return _floatView[0];
      }
    };
    _buffer = new ArrayBuffer(4);
    _floatView = new Float32Array(_buffer);
    _uint32View = new Uint32Array(_buffer);
    _baseTable = new Uint32Array(512);
    _shiftTable = new Uint32Array(512);
    for (let i2 = 0; i2 < 256; ++i2) {
      const e = i2 - 127;
      if (e < -27) {
        _baseTable[i2] = 0;
        _baseTable[i2 | 256] = 32768;
        _shiftTable[i2] = 24;
        _shiftTable[i2 | 256] = 24;
      } else if (e < -14) {
        _baseTable[i2] = 1024 >> -e - 14;
        _baseTable[i2 | 256] = 1024 >> -e - 14 | 32768;
        _shiftTable[i2] = -e - 1;
        _shiftTable[i2 | 256] = -e - 1;
      } else if (e <= 15) {
        _baseTable[i2] = e + 15 << 10;
        _baseTable[i2 | 256] = e + 15 << 10 | 32768;
        _shiftTable[i2] = 13;
        _shiftTable[i2 | 256] = 13;
      } else if (e < 128) {
        _baseTable[i2] = 31744;
        _baseTable[i2 | 256] = 64512;
        _shiftTable[i2] = 24;
        _shiftTable[i2 | 256] = 24;
      } else {
        _baseTable[i2] = 31744;
        _baseTable[i2 | 256] = 64512;
        _shiftTable[i2] = 13;
        _shiftTable[i2 | 256] = 13;
      }
    }
    _mantissaTable = new Uint32Array(2048);
    _exponentTable = new Uint32Array(64);
    _offsetTable = new Uint32Array(64);
    for (let i2 = 1; i2 < 1024; ++i2) {
      let m = i2 << 13;
      let e = 0;
      while ((m & 8388608) === 0) {
        m <<= 1;
        e -= 8388608;
      }
      m &= ~8388608;
      e += 947912704;
      _mantissaTable[i2] = m | e;
    }
    for (let i2 = 1024; i2 < 2048; ++i2) {
      _mantissaTable[i2] = 939524096 + (i2 - 1024 << 13);
    }
    for (let i2 = 1; i2 < 31; ++i2) {
      _exponentTable[i2] = i2 << 23;
    }
    _exponentTable[31] = 1199570944;
    _exponentTable[32] = 2147483648;
    for (let i2 = 33; i2 < 63; ++i2) {
      _exponentTable[i2] = 2147483648 + (i2 - 32 << 23);
    }
    _exponentTable[63] = 3347054592;
    for (let i2 = 1; i2 < 64; ++i2) {
      if (i2 !== 32) {
        _offsetTable[i2] = 1024;
      }
    }
    LineStrip = 0;
    LinePieces = 1;
    NoColors = 0;
    FaceColors = 1;
    VertexColors = 2;
    PointCloud = class extends Points {
      constructor(geometry, material) {
        console.warn("THREE.PointCloud has been renamed to THREE.Points.");
        super(geometry, material);
      }
    };
    Particle = class extends Sprite {
      constructor(material) {
        console.warn("THREE.Particle has been renamed to THREE.Sprite.");
        super(material);
      }
    };
    ParticleSystem = class extends Points {
      constructor(geometry, material) {
        console.warn("THREE.ParticleSystem has been renamed to THREE.Points.");
        super(geometry, material);
      }
    };
    PointCloudMaterial = class extends PointsMaterial {
      constructor(parameters) {
        console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.");
        super(parameters);
      }
    };
    ParticleBasicMaterial = class extends PointsMaterial {
      constructor(parameters) {
        console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.");
        super(parameters);
      }
    };
    ParticleSystemMaterial = class extends PointsMaterial {
      constructor(parameters) {
        console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.");
        super(parameters);
      }
    };
    Vertex = class extends Vector3 {
      constructor(x, y2, z) {
        console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead.");
        super(x, y2, z);
      }
    };
    DynamicBufferAttribute = class extends BufferAttribute {
      constructor(array, itemSize) {
        console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.");
        super(array, itemSize);
        this.setUsage(DynamicDrawUsage);
      }
    };
    Int8Attribute = class extends Int8BufferAttribute {
      constructor(array, itemSize) {
        console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.");
        super(array, itemSize);
      }
    };
    Uint8Attribute = class extends Uint8BufferAttribute {
      constructor(array, itemSize) {
        console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.");
        super(array, itemSize);
      }
    };
    Uint8ClampedAttribute = class extends Uint8ClampedBufferAttribute {
      constructor(array, itemSize) {
        console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.");
        super(array, itemSize);
      }
    };
    Int16Attribute = class extends Int16BufferAttribute {
      constructor(array, itemSize) {
        console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.");
        super(array, itemSize);
      }
    };
    Uint16Attribute = class extends Uint16BufferAttribute {
      constructor(array, itemSize) {
        console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.");
        super(array, itemSize);
      }
    };
    Int32Attribute = class extends Int32BufferAttribute {
      constructor(array, itemSize) {
        console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.");
        super(array, itemSize);
      }
    };
    Uint32Attribute = class extends Uint32BufferAttribute {
      constructor(array, itemSize) {
        console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.");
        super(array, itemSize);
      }
    };
    Float32Attribute = class extends Float32BufferAttribute {
      constructor(array, itemSize) {
        console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.");
        super(array, itemSize);
      }
    };
    Float64Attribute = class extends Float64BufferAttribute {
      constructor(array, itemSize) {
        console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.");
        super(array, itemSize);
      }
    };
    Curve.create = function(construct, getPoint) {
      console.log("THREE.Curve.create() has been deprecated");
      construct.prototype = Object.create(Curve.prototype);
      construct.prototype.constructor = construct;
      construct.prototype.getPoint = getPoint;
      return construct;
    };
    Path.prototype.fromPoints = function(points) {
      console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");
      return this.setFromPoints(points);
    };
    AxisHelper = class extends AxesHelper {
      constructor(size) {
        console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper.");
        super(size);
      }
    };
    BoundingBoxHelper = class extends BoxHelper {
      constructor(object, color) {
        console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.");
        super(object, color);
      }
    };
    EdgesHelper = class extends LineSegments {
      constructor(object, hex) {
        console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.");
        super(new EdgesGeometry(object.geometry), new LineBasicMaterial({ color: hex !== void 0 ? hex : 16777215 }));
      }
    };
    GridHelper.prototype.setColors = function() {
      console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
    };
    SkeletonHelper.prototype.update = function() {
      console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
    };
    WireframeHelper = class extends LineSegments {
      constructor(object, hex) {
        console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.");
        super(new WireframeGeometry(object.geometry), new LineBasicMaterial({ color: hex !== void 0 ? hex : 16777215 }));
      }
    };
    Loader.prototype.extractUrlBase = function(url) {
      console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
      return LoaderUtils.extractUrlBase(url);
    };
    Loader.Handlers = {
      add: function() {
        console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
      },
      get: function() {
        console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
      }
    };
    XHRLoader = class extends FileLoader {
      constructor(manager) {
        console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader.");
        super(manager);
      }
    };
    BinaryTextureLoader = class extends DataTextureLoader {
      constructor(manager) {
        console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.");
        super(manager);
      }
    };
    Box2.prototype.center = function(optionalTarget) {
      console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
      return this.getCenter(optionalTarget);
    };
    Box2.prototype.empty = function() {
      console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
      return this.isEmpty();
    };
    Box2.prototype.isIntersectionBox = function(box) {
      console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
      return this.intersectsBox(box);
    };
    Box2.prototype.size = function(optionalTarget) {
      console.warn("THREE.Box2: .size() has been renamed to .getSize().");
      return this.getSize(optionalTarget);
    };
    Box3.prototype.center = function(optionalTarget) {
      console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
      return this.getCenter(optionalTarget);
    };
    Box3.prototype.empty = function() {
      console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
      return this.isEmpty();
    };
    Box3.prototype.isIntersectionBox = function(box) {
      console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
      return this.intersectsBox(box);
    };
    Box3.prototype.isIntersectionSphere = function(sphere) {
      console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
      return this.intersectsSphere(sphere);
    };
    Box3.prototype.size = function(optionalTarget) {
      console.warn("THREE.Box3: .size() has been renamed to .getSize().");
      return this.getSize(optionalTarget);
    };
    Euler.prototype.toVector3 = function() {
      console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead");
    };
    Sphere.prototype.empty = function() {
      console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty().");
      return this.isEmpty();
    };
    Frustum.prototype.setFromMatrix = function(m) {
      console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().");
      return this.setFromProjectionMatrix(m);
    };
    Line3.prototype.center = function(optionalTarget) {
      console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
      return this.getCenter(optionalTarget);
    };
    Matrix3.prototype.flattenToArrayOffset = function(array, offset) {
      console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
      return this.toArray(array, offset);
    };
    Matrix3.prototype.multiplyVector3 = function(vector) {
      console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
      return vector.applyMatrix3(this);
    };
    Matrix3.prototype.multiplyVector3Array = function() {
      console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
    };
    Matrix3.prototype.applyToBufferAttribute = function(attribute) {
      console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.");
      return attribute.applyMatrix3(this);
    };
    Matrix3.prototype.applyToVector3Array = function() {
      console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
    };
    Matrix3.prototype.getInverse = function(matrix) {
      console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
      return this.copy(matrix).invert();
    };
    Matrix4.prototype.extractPosition = function(m) {
      console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
      return this.copyPosition(m);
    };
    Matrix4.prototype.flattenToArrayOffset = function(array, offset) {
      console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
      return this.toArray(array, offset);
    };
    Matrix4.prototype.getPosition = function() {
      console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
      return new Vector3().setFromMatrixColumn(this, 3);
    };
    Matrix4.prototype.setRotationFromQuaternion = function(q) {
      console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
      return this.makeRotationFromQuaternion(q);
    };
    Matrix4.prototype.multiplyToArray = function() {
      console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
    };
    Matrix4.prototype.multiplyVector3 = function(vector) {
      console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
      return vector.applyMatrix4(this);
    };
    Matrix4.prototype.multiplyVector4 = function(vector) {
      console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
      return vector.applyMatrix4(this);
    };
    Matrix4.prototype.multiplyVector3Array = function() {
      console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
    };
    Matrix4.prototype.rotateAxis = function(v) {
      console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
      v.transformDirection(this);
    };
    Matrix4.prototype.crossVector = function(vector) {
      console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
      return vector.applyMatrix4(this);
    };
    Matrix4.prototype.translate = function() {
      console.error("THREE.Matrix4: .translate() has been removed.");
    };
    Matrix4.prototype.rotateX = function() {
      console.error("THREE.Matrix4: .rotateX() has been removed.");
    };
    Matrix4.prototype.rotateY = function() {
      console.error("THREE.Matrix4: .rotateY() has been removed.");
    };
    Matrix4.prototype.rotateZ = function() {
      console.error("THREE.Matrix4: .rotateZ() has been removed.");
    };
    Matrix4.prototype.rotateByAxis = function() {
      console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
    };
    Matrix4.prototype.applyToBufferAttribute = function(attribute) {
      console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.");
      return attribute.applyMatrix4(this);
    };
    Matrix4.prototype.applyToVector3Array = function() {
      console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
    };
    Matrix4.prototype.makeFrustum = function(left, right, bottom, top, near, far) {
      console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
      return this.makePerspective(left, right, top, bottom, near, far);
    };
    Matrix4.prototype.getInverse = function(matrix) {
      console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.");
      return this.copy(matrix).invert();
    };
    Plane.prototype.isIntersectionLine = function(line) {
      console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
      return this.intersectsLine(line);
    };
    Quaternion.prototype.multiplyVector3 = function(vector) {
      console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
      return vector.applyQuaternion(this);
    };
    Quaternion.prototype.inverse = function() {
      console.warn("THREE.Quaternion: .inverse() has been renamed to invert().");
      return this.invert();
    };
    Ray.prototype.isIntersectionBox = function(box) {
      console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
      return this.intersectsBox(box);
    };
    Ray.prototype.isIntersectionPlane = function(plane) {
      console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
      return this.intersectsPlane(plane);
    };
    Ray.prototype.isIntersectionSphere = function(sphere) {
      console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
      return this.intersectsSphere(sphere);
    };
    Triangle.prototype.area = function() {
      console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
      return this.getArea();
    };
    Triangle.prototype.barycoordFromPoint = function(point, target) {
      console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
      return this.getBarycoord(point, target);
    };
    Triangle.prototype.midpoint = function(target) {
      console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
      return this.getMidpoint(target);
    };
    Triangle.prototypenormal = function(target) {
      console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
      return this.getNormal(target);
    };
    Triangle.prototype.plane = function(target) {
      console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
      return this.getPlane(target);
    };
    Triangle.barycoordFromPoint = function(point, a, b2, c, target) {
      console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
      return Triangle.getBarycoord(point, a, b2, c, target);
    };
    Triangle.normal = function(a, b2, c, target) {
      console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
      return Triangle.getNormal(a, b2, c, target);
    };
    Shape.prototype.extractAllPoints = function(divisions) {
      console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
      return this.extractPoints(divisions);
    };
    Shape.prototype.extrude = function(options) {
      console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
      return new ExtrudeGeometry(this, options);
    };
    Shape.prototype.makeGeometry = function(options) {
      console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
      return new ShapeGeometry(this, options);
    };
    Vector2.prototype.fromAttribute = function(attribute, index, offset) {
      console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
      return this.fromBufferAttribute(attribute, index, offset);
    };
    Vector2.prototype.distanceToManhattan = function(v) {
      console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
      return this.manhattanDistanceTo(v);
    };
    Vector2.prototype.lengthManhattan = function() {
      console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
      return this.manhattanLength();
    };
    Vector3.prototype.setEulerFromRotationMatrix = function() {
      console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
    };
    Vector3.prototype.setEulerFromQuaternion = function() {
      console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
    };
    Vector3.prototype.getPositionFromMatrix = function(m) {
      console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
      return this.setFromMatrixPosition(m);
    };
    Vector3.prototype.getScaleFromMatrix = function(m) {
      console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
      return this.setFromMatrixScale(m);
    };
    Vector3.prototype.getColumnFromMatrix = function(index, matrix) {
      console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
      return this.setFromMatrixColumn(matrix, index);
    };
    Vector3.prototype.applyProjection = function(m) {
      console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
      return this.applyMatrix4(m);
    };
    Vector3.prototype.fromAttribute = function(attribute, index, offset) {
      console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
      return this.fromBufferAttribute(attribute, index, offset);
    };
    Vector3.prototype.distanceToManhattan = function(v) {
      console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
      return this.manhattanDistanceTo(v);
    };
    Vector3.prototype.lengthManhattan = function() {
      console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
      return this.manhattanLength();
    };
    Vector4.prototype.fromAttribute = function(attribute, index, offset) {
      console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
      return this.fromBufferAttribute(attribute, index, offset);
    };
    Vector4.prototype.lengthManhattan = function() {
      console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
      return this.manhattanLength();
    };
    Object3D.prototype.getChildByName = function(name) {
      console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
      return this.getObjectByName(name);
    };
    Object3D.prototype.renderDepth = function() {
      console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
    };
    Object3D.prototype.translate = function(distance, axis) {
      console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
      return this.translateOnAxis(axis, distance);
    };
    Object3D.prototype.getWorldRotation = function() {
      console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
    };
    Object3D.prototype.applyMatrix = function(matrix) {
      console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().");
      return this.applyMatrix4(matrix);
    };
    Object.defineProperties(Object3D.prototype, {
      eulerOrder: {
        get: function() {
          console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
          return this.rotation.order;
        },
        set: function(value) {
          console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
          this.rotation.order = value;
        }
      },
      useQuaternion: {
        get: function() {
          console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
        },
        set: function() {
          console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
        }
      }
    });
    Mesh.prototype.setDrawMode = function() {
      console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
    };
    Object.defineProperties(Mesh.prototype, {
      drawMode: {
        get: function() {
          console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.");
          return TrianglesDrawMode;
        },
        set: function() {
          console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
        }
      }
    });
    SkinnedMesh.prototype.initBones = function() {
      console.error("THREE.SkinnedMesh: initBones() has been removed.");
    };
    PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
      console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
      if (filmGauge !== void 0)
        this.filmGauge = filmGauge;
      this.setFocalLength(focalLength);
    };
    Object.defineProperties(Light.prototype, {
      onlyShadow: {
        set: function() {
          console.warn("THREE.Light: .onlyShadow has been removed.");
        }
      },
      shadowCameraFov: {
        set: function(value) {
          console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
          this.shadow.camera.fov = value;
        }
      },
      shadowCameraLeft: {
        set: function(value) {
          console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
          this.shadow.camera.left = value;
        }
      },
      shadowCameraRight: {
        set: function(value) {
          console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
          this.shadow.camera.right = value;
        }
      },
      shadowCameraTop: {
        set: function(value) {
          console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
          this.shadow.camera.top = value;
        }
      },
      shadowCameraBottom: {
        set: function(value) {
          console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
          this.shadow.camera.bottom = value;
        }
      },
      shadowCameraNear: {
        set: function(value) {
          console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
          this.shadow.camera.near = value;
        }
      },
      shadowCameraFar: {
        set: function(value) {
          console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
          this.shadow.camera.far = value;
        }
      },
      shadowCameraVisible: {
        set: function() {
          console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
        }
      },
      shadowBias: {
        set: function(value) {
          console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
          this.shadow.bias = value;
        }
      },
      shadowDarkness: {
        set: function() {
          console.warn("THREE.Light: .shadowDarkness has been removed.");
        }
      },
      shadowMapWidth: {
        set: function(value) {
          console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
          this.shadow.mapSize.width = value;
        }
      },
      shadowMapHeight: {
        set: function(value) {
          console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
          this.shadow.mapSize.height = value;
        }
      }
    });
    Object.defineProperties(BufferAttribute.prototype, {
      length: {
        get: function() {
          console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
          return this.array.length;
        }
      },
      dynamic: {
        get: function() {
          console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
          return this.usage === DynamicDrawUsage;
        },
        set: function() {
          console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
          this.setUsage(DynamicDrawUsage);
        }
      }
    });
    BufferAttribute.prototype.setDynamic = function(value) {
      console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.");
      this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
      return this;
    };
    BufferAttribute.prototype.copyIndicesArray = function() {
      console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
    }, BufferAttribute.prototype.setArray = function() {
      console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
    };
    BufferGeometry.prototype.addIndex = function(index) {
      console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
      this.setIndex(index);
    };
    BufferGeometry.prototype.addAttribute = function(name, attribute) {
      console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().");
      if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
        console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).");
        return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
      }
      if (name === "index") {
        console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.");
        this.setIndex(attribute);
        return this;
      }
      return this.setAttribute(name, attribute);
    };
    BufferGeometry.prototype.addDrawCall = function(start, count, indexOffset) {
      if (indexOffset !== void 0) {
        console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
      }
      console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
      this.addGroup(start, count);
    };
    BufferGeometry.prototype.clearDrawCalls = function() {
      console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
      this.clearGroups();
    };
    BufferGeometry.prototype.computeOffsets = function() {
      console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
    };
    BufferGeometry.prototype.removeAttribute = function(name) {
      console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().");
      return this.deleteAttribute(name);
    };
    BufferGeometry.prototype.applyMatrix = function(matrix) {
      console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().");
      return this.applyMatrix4(matrix);
    };
    Object.defineProperties(BufferGeometry.prototype, {
      drawcalls: {
        get: function() {
          console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
          return this.groups;
        }
      },
      offsets: {
        get: function() {
          console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
          return this.groups;
        }
      }
    });
    InterleavedBuffer.prototype.setDynamic = function(value) {
      console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.");
      this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
      return this;
    };
    InterleavedBuffer.prototype.setArray = function() {
      console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
    };
    ExtrudeGeometry.prototype.getArrays = function() {
      console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.");
    };
    ExtrudeGeometry.prototype.addShapeList = function() {
      console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.");
    };
    ExtrudeGeometry.prototype.addShape = function() {
      console.error("THREE.ExtrudeGeometry: .addShape() has been removed.");
    };
    Scene.prototype.dispose = function() {
      console.error("THREE.Scene: .dispose() has been removed.");
    };
    Uniform.prototype.onUpdate = function() {
      console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
      return this;
    };
    Object.defineProperties(Material.prototype, {
      wrapAround: {
        get: function() {
          console.warn("THREE.Material: .wrapAround has been removed.");
        },
        set: function() {
          console.warn("THREE.Material: .wrapAround has been removed.");
        }
      },
      overdraw: {
        get: function() {
          console.warn("THREE.Material: .overdraw has been removed.");
        },
        set: function() {
          console.warn("THREE.Material: .overdraw has been removed.");
        }
      },
      wrapRGB: {
        get: function() {
          console.warn("THREE.Material: .wrapRGB has been removed.");
          return new Color();
        }
      },
      shading: {
        get: function() {
          console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
        },
        set: function(value) {
          console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
          this.flatShading = value === FlatShading;
        }
      },
      stencilMask: {
        get: function() {
          console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
          return this.stencilFuncMask;
        },
        set: function(value) {
          console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
          this.stencilFuncMask = value;
        }
      },
      vertexTangents: {
        get: function() {
          console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
        },
        set: function() {
          console.warn("THREE." + this.type + ": .vertexTangents has been removed.");
        }
      }
    });
    Object.defineProperties(ShaderMaterial.prototype, {
      derivatives: {
        get: function() {
          console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
          return this.extensions.derivatives;
        },
        set: function(value) {
          console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
          this.extensions.derivatives = value;
        }
      }
    });
    WebGLRenderer.prototype.clearTarget = function(renderTarget, color, depth, stencil) {
      console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");
      this.setRenderTarget(renderTarget);
      this.clear(color, depth, stencil);
    };
    WebGLRenderer.prototype.animate = function(callback) {
      console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
      this.setAnimationLoop(callback);
    };
    WebGLRenderer.prototype.getCurrentRenderTarget = function() {
      console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
      return this.getRenderTarget();
    };
    WebGLRenderer.prototype.getMaxAnisotropy = function() {
      console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
      return this.capabilities.getMaxAnisotropy();
    };
    WebGLRenderer.prototype.getPrecision = function() {
      console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
      return this.capabilities.precision;
    };
    WebGLRenderer.prototype.resetGLState = function() {
      console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
      return this.state.reset();
    };
    WebGLRenderer.prototype.supportsFloatTextures = function() {
      console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
      return this.extensions.get("OES_texture_float");
    };
    WebGLRenderer.prototype.supportsHalfFloatTextures = function() {
      console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
      return this.extensions.get("OES_texture_half_float");
    };
    WebGLRenderer.prototype.supportsStandardDerivatives = function() {
      console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
      return this.extensions.get("OES_standard_derivatives");
    };
    WebGLRenderer.prototype.supportsCompressedTextureS3TC = function() {
      console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
      return this.extensions.get("WEBGL_compressed_texture_s3tc");
    };
    WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function() {
      console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
      return this.extensions.get("WEBGL_compressed_texture_pvrtc");
    };
    WebGLRenderer.prototype.supportsBlendMinMax = function() {
      console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
      return this.extensions.get("EXT_blend_minmax");
    };
    WebGLRenderer.prototype.supportsVertexTextures = function() {
      console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
      return this.capabilities.vertexTextures;
    };
    WebGLRenderer.prototype.supportsInstancedArrays = function() {
      console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
      return this.extensions.get("ANGLE_instanced_arrays");
    };
    WebGLRenderer.prototype.enableScissorTest = function(boolean) {
      console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
      this.setScissorTest(boolean);
    };
    WebGLRenderer.prototype.initMaterial = function() {
      console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
    };
    WebGLRenderer.prototype.addPrePlugin = function() {
      console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
    };
    WebGLRenderer.prototype.addPostPlugin = function() {
      console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
    };
    WebGLRenderer.prototype.updateShadowMap = function() {
      console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
    };
    WebGLRenderer.prototype.setFaceCulling = function() {
      console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
    };
    WebGLRenderer.prototype.allocTextureUnit = function() {
      console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
    };
    WebGLRenderer.prototype.setTexture = function() {
      console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
    };
    WebGLRenderer.prototype.setTexture2D = function() {
      console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
    };
    WebGLRenderer.prototype.setTextureCube = function() {
      console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
    };
    WebGLRenderer.prototype.getActiveMipMapLevel = function() {
      console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().");
      return this.getActiveMipmapLevel();
    };
    Object.defineProperties(WebGLRenderer.prototype, {
      shadowMapEnabled: {
        get: function() {
          return this.shadowMap.enabled;
        },
        set: function(value) {
          console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
          this.shadowMap.enabled = value;
        }
      },
      shadowMapType: {
        get: function() {
          return this.shadowMap.type;
        },
        set: function(value) {
          console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
          this.shadowMap.type = value;
        }
      },
      shadowMapCullFace: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
          return void 0;
        },
        set: function() {
          console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
        }
      },
      context: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.");
          return this.getContext();
        }
      },
      vr: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr");
          return this.xr;
        }
      },
      gammaInput: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
          return false;
        },
        set: function() {
          console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
        }
      },
      gammaOutput: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
          return false;
        },
        set: function(value) {
          console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
          this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
        }
      },
      toneMappingWhitePoint: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
          return 1;
        },
        set: function() {
          console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.");
        }
      },
      gammaFactor: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
          return 2;
        },
        set: function() {
          console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");
        }
      }
    });
    Object.defineProperties(WebGLShadowMap.prototype, {
      cullFace: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
          return void 0;
        },
        set: function() {
          console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
        }
      },
      renderReverseSided: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
          return void 0;
        },
        set: function() {
          console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
        }
      },
      renderSingleSided: {
        get: function() {
          console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
          return void 0;
        },
        set: function() {
          console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
        }
      }
    });
    WebGLRenderTargetCube = class extends WebGLCubeRenderTarget {
      constructor(width, height, options) {
        console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).");
        super(width, options);
      }
    };
    Object.defineProperties(WebGLRenderTarget.prototype, {
      wrapS: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
          return this.texture.wrapS;
        },
        set: function(value) {
          console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
          this.texture.wrapS = value;
        }
      },
      wrapT: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
          return this.texture.wrapT;
        },
        set: function(value) {
          console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
          this.texture.wrapT = value;
        }
      },
      magFilter: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
          return this.texture.magFilter;
        },
        set: function(value) {
          console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
          this.texture.magFilter = value;
        }
      },
      minFilter: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
          return this.texture.minFilter;
        },
        set: function(value) {
          console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
          this.texture.minFilter = value;
        }
      },
      anisotropy: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
          return this.texture.anisotropy;
        },
        set: function(value) {
          console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
          this.texture.anisotropy = value;
        }
      },
      offset: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
          return this.texture.offset;
        },
        set: function(value) {
          console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
          this.texture.offset = value;
        }
      },
      repeat: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
          return this.texture.repeat;
        },
        set: function(value) {
          console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
          this.texture.repeat = value;
        }
      },
      format: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
          return this.texture.format;
        },
        set: function(value) {
          console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
          this.texture.format = value;
        }
      },
      type: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
          return this.texture.type;
        },
        set: function(value) {
          console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
          this.texture.type = value;
        }
      },
      generateMipmaps: {
        get: function() {
          console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
          return this.texture.generateMipmaps;
        },
        set: function(value) {
          console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
          this.texture.generateMipmaps = value;
        }
      }
    });
    Audio.prototype.load = function(file) {
      console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
      const scope = this;
      const audioLoader = new AudioLoader();
      audioLoader.load(file, function(buffer) {
        scope.setBuffer(buffer);
      });
      return this;
    };
    AudioAnalyser.prototype.getData = function() {
      console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
      return this.getFrequencyData();
    };
    CubeCamera.prototype.updateCubeMap = function(renderer, scene) {
      console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
      return this.update(renderer, scene);
    };
    CubeCamera.prototype.clear = function(renderer, color, depth, stencil) {
      console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear().");
      return this.renderTarget.clear(renderer, color, depth, stencil);
    };
    ImageUtils.crossOrigin = void 0;
    ImageUtils.loadTexture = function(url, mapping, onLoad, onError) {
      console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
      const loader2 = new TextureLoader();
      loader2.setCrossOrigin(this.crossOrigin);
      const texture = loader2.load(url, onLoad, void 0, onError);
      if (mapping)
        texture.mapping = mapping;
      return texture;
    };
    ImageUtils.loadTextureCube = function(urls, mapping, onLoad, onError) {
      console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
      const loader2 = new CubeTextureLoader();
      loader2.setCrossOrigin(this.crossOrigin);
      const texture = loader2.load(urls, onLoad, void 0, onError);
      if (mapping)
        texture.mapping = mapping;
      return texture;
    };
    ImageUtils.loadCompressedTexture = function() {
      console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
    };
    ImageUtils.loadCompressedTextureCube = function() {
      console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
    };
    SceneUtils = {
      createMultiMaterialObject: function() {
        console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
      },
      detach: function() {
        console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
      },
      attach: function() {
        console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
      }
    };
    ParametricGeometry = class extends BufferGeometry {
      constructor() {
        console.error("THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js");
        super();
      }
    };
    TextGeometry = class extends BufferGeometry {
      constructor() {
        console.error("THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js");
        super();
      }
    };
    WebGLMultisampleRenderTarget = class extends WebGLRenderTarget {
      constructor(width, height, options) {
        console.error('THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.');
        super(width, height, options);
        this.samples = 4;
      }
    };
    DataTexture2DArray = class extends DataArrayTexture {
      constructor(data, width, height, depth) {
        console.warn("THREE.DataTexture2DArray has been renamed to DataArrayTexture.");
        super(data, width, height, depth);
      }
    };
    DataTexture3D = class extends Data3DTexture {
      constructor(data, width, height, depth) {
        console.warn("THREE.DataTexture3D has been renamed to Data3DTexture.");
        super(data, width, height, depth);
      }
    };
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
        revision: REVISION
      } }));
    }
    if (typeof window !== "undefined") {
      if (window.__THREE__) {
        console.warn("WARNING: Multiple instances of Three.js being imported.");
      } else {
        window.__THREE__ = REVISION;
      }
    }
  }
});

// src/cubing/twisty/controllers/easing.ts
function smootherStep(x) {
  return x * x * x * (10 - x * (15 - 6 * x));
}
var init_easing = __esm({
  "src/cubing/twisty/controllers/easing.ts"() {
  }
});

// src/cubing/twisty/model/props/puzzle/display/HintFaceletProp.ts
var hintFaceletStyles, HintFaceletProp;
var init_HintFaceletProp = __esm({
  "src/cubing/twisty/model/props/puzzle/display/HintFaceletProp.ts"() {
    init_TwistyProp();
    hintFaceletStyles = {
      floating: true,
      none: true
    };
    HintFaceletProp = class extends SimpleTwistyPropSource {
      getDefaultValue() {
        return "auto";
      }
    };
  }
});

// src/cubing/twisty/model/props/puzzle/display/StickeringProp.ts
var experimentalStickerings, StickeringProp;
var init_StickeringProp = __esm({
  "src/cubing/twisty/model/props/puzzle/display/StickeringProp.ts"() {
    init_TwistyProp();
    experimentalStickerings = {
      "full": true,
      "centers-only": true,
      "PLL": true,
      "CLS": true,
      "OLL": true,
      "COLL": true,
      "OCLL": true,
      "CLL": true,
      "ELL": true,
      "ELS": true,
      "LL": true,
      "F2L": true,
      "ZBLL": true,
      "ZBLS": true,
      "WVLS": true,
      "VLS": true,
      "LS": true,
      "EO": true,
      "EOline": true,
      "EOcross": true,
      "CMLL": true,
      "L6E": true,
      "L6EO": true,
      "Daisy": true,
      "Cross": true,
      "2x2x2": true,
      "2x2x3": true,
      "Void Cube": true,
      "invisible": true,
      "picture": true,
      "experimental-centers-U": true,
      "experimental-centers-U-D": true,
      "experimental-centers-U-L-D": true,
      "experimental-centers-U-L-B-D": true,
      "experimental-centers": true,
      "experimental-fto-fc": true,
      "experimental-fto-f2t": true,
      "experimental-fto-sc": true,
      "experimental-fto-l2c": true,
      "experimental-fto-lbt": true,
      "experimental-fto-l3t": true,
      "experimental-global-custom-1": true,
      "experimental-global-custom-2": true
    };
    StickeringProp = class extends SimpleTwistyPropSource {
      getDefaultValue() {
        return "full";
      }
    };
  }
});

// src/cubing/twisty/views/3D/TAU.ts
var TAU, DEGREES_PER_RADIAN;
var init_TAU = __esm({
  "src/cubing/twisty/views/3D/TAU.ts"() {
    TAU = Math.PI * 2;
    DEGREES_PER_RADIAN = 360 / TAU;
  }
});

// src/cubing/twisty/views/3D/puzzles/Cube3D.ts
function t(v, t4) {
  return new Quaternion().setFromAxisAngle(v, TAU * t4 / 4);
}
function sharedCubieFoundationGeometry() {
  return sharedCubieFoundationGeometryCache ?? (sharedCubieFoundationGeometryCache = new BoxGeometry(cubieDimensions.foundationWidth, cubieDimensions.foundationWidth, cubieDimensions.foundationWidth));
}
function newStickerGeometry() {
  const r3 = new BufferGeometry();
  const half = 0.5 * cubieDimensions.stickerWidth;
  r3.setAttribute("position", new BufferAttribute(new Float32Array([
    half,
    half,
    0,
    -half,
    half,
    0,
    half,
    -half,
    0,
    -half,
    half,
    0,
    -half,
    -half,
    0,
    half,
    -half,
    0
  ]), 3));
  r3.setAttribute("uv", new BufferAttribute(new Float32Array([
    1,
    1,
    0,
    1,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    1,
    0,
    0,
    1,
    0,
    1,
    1
  ]), 2));
  return r3;
}
function sharedStickerGeometry() {
  return sharedStickerGeometryCache ?? (sharedStickerGeometryCache = newStickerGeometry());
}
var svgLoader, ignoredMaterial, ignoredMaterialHint, invisibleMaterial, orientedMaterial, orientedMaterialHint, AxisInfo, axesInfo, face, familyToAxis, cubieDimensions, EXPERIMENTAL_PICTURE_CUBE_HINT_ELEVATION, cube3DOptionsDefaults, blackMesh, blackTranslucentMesh, CubieDef, r2, firstPiecePosition, orientationRotation, cubieStickerOrder, pieceDefs, CUBE_SCALE, pictureStickerCoords, sharedCubieFoundationGeometryCache, sharedStickerGeometryCache, Cube3D;
var init_Cube3D = __esm({
  "src/cubing/twisty/views/3D/puzzles/Cube3D.ts"() {
    init_three_module();
    init_puzzles();
    init_easing();
    init_HintFaceletProp();
    init_StickeringProp();
    init_TAU();
    svgLoader = new TextureLoader();
    ignoredMaterial = new MeshBasicMaterial({
      color: 4473924,
      side: DoubleSide
    });
    ignoredMaterialHint = new MeshBasicMaterial({
      color: 13421772,
      side: BackSide,
      transparent: true,
      opacity: 0.75
    });
    invisibleMaterial = new MeshBasicMaterial({
      visible: false
    });
    orientedMaterial = new MeshBasicMaterial({
      color: 4513228
    });
    orientedMaterialHint = new MeshBasicMaterial({
      color: 4513228,
      side: BackSide,
      transparent: true,
      opacity: 0.5
    });
    AxisInfo = class {
      constructor(vector, fromZ, color, dimColor, hintOpacityScale, options) {
        this.vector = vector;
        this.fromZ = fromZ;
        this.color = color;
        this.dimColor = dimColor;
        this.hintOpacityScale = hintOpacityScale;
        this.stickerMaterial = {
          regular: new MeshBasicMaterial({
            color,
            side: DoubleSide
          }),
          dim: new MeshBasicMaterial({
            color: dimColor,
            side: DoubleSide
          }),
          oriented: orientedMaterial,
          ignored: ignoredMaterial,
          invisible: invisibleMaterial
        };
        this.hintStickerMaterial = {
          regular: new MeshBasicMaterial({
            color: options?.hintColor ?? color,
            side: BackSide,
            transparent: true,
            opacity: 0.5 * hintOpacityScale
          }),
          dim: new MeshBasicMaterial({
            color: options?.hintDimColor ?? dimColor,
            side: BackSide,
            transparent: true,
            opacity: 0.5 * hintOpacityScale
          }),
          oriented: orientedMaterialHint,
          ignored: ignoredMaterialHint,
          invisible: invisibleMaterial
        };
      }
    };
    axesInfo = [
      new AxisInfo(new Vector3(0, 1, 0), new Euler(-TAU / 4, 0, 0), 16777215, 14540253, 1.25),
      new AxisInfo(new Vector3(-1, 0, 0), new Euler(0, -TAU / 4, 0), 16746496, 8930304, 1, { hintDimColor: 10053120 }),
      new AxisInfo(new Vector3(0, 0, 1), new Euler(0, 0, 0), 65280, 34816, 1, { hintDimColor: 39168 }),
      new AxisInfo(new Vector3(1, 0, 0), new Euler(0, TAU / 4, 0), 16711680, 6684672, 1, { hintDimColor: 10027008 }),
      new AxisInfo(new Vector3(0, 0, -1), new Euler(0, TAU / 2, 0), 255, 136, 0.75, { hintColor: 17663, hintDimColor: 6246 }),
      new AxisInfo(new Vector3(0, -1, 0), new Euler(TAU / 4, 0, 0), 16776960, 8947712, 1.25, { hintDimColor: 12303104 })
    ];
    face = {
      U: 0,
      L: 1,
      F: 2,
      R: 3,
      B: 4,
      D: 5
    };
    familyToAxis = {
      U: face.U,
      u: face.U,
      Uw: face.U,
      Uv: face.U,
      y: face.U,
      L: face.L,
      l: face.L,
      Lw: face.L,
      Lv: face.L,
      M: face.L,
      F: face.F,
      f: face.F,
      Fw: face.F,
      Fv: face.F,
      S: face.F,
      z: face.F,
      R: face.R,
      r: face.R,
      Rw: face.R,
      Rv: face.R,
      x: face.R,
      B: face.B,
      b: face.B,
      Bw: face.B,
      Bv: face.B,
      D: face.D,
      d: face.D,
      Dw: face.D,
      Dv: face.D,
      E: face.D
    };
    cubieDimensions = {
      stickerWidth: 1,
      stickerElevation: 0.503,
      foundationWidth: 1,
      hintStickerElevation: 1.45
    };
    EXPERIMENTAL_PICTURE_CUBE_HINT_ELEVATION = 2;
    cube3DOptionsDefaults = {
      showMainStickers: true,
      hintFacelets: "floating",
      showFoundation: true,
      experimentalStickering: "full",
      foundationSprite: null,
      hintSprite: null
    };
    blackMesh = new MeshBasicMaterial({
      color: 0,
      opacity: 1,
      transparent: true
    });
    blackTranslucentMesh = new MeshBasicMaterial({
      color: 0,
      opacity: 0.3,
      transparent: true
    });
    CubieDef = class {
      constructor(orbit, stickerFaceNames, q) {
        this.orbit = orbit;
        const individualStickerFaceNames = typeof stickerFaceNames === "string" ? stickerFaceNames.split("") : stickerFaceNames;
        this.stickerFaces = individualStickerFaceNames.map((s) => face[s]);
        this.matrix = new Matrix4();
        this.matrix.setPosition(firstPiecePosition[orbit]);
        this.matrix.premultiply(new Matrix4().makeRotationFromQuaternion(q));
      }
    };
    r2 = {
      O: new Vector3(0, 0, 0),
      U: new Vector3(0, -1, 0),
      L: new Vector3(1, 0, 0),
      F: new Vector3(0, 0, -1),
      R: new Vector3(-1, 0, 0),
      B: new Vector3(0, 0, 1),
      D: new Vector3(0, 1, 0)
    };
    firstPiecePosition = {
      EDGES: new Vector3(0, 1, 1),
      CORNERS: new Vector3(1, 1, 1),
      CENTERS: new Vector3(0, 1, 0)
    };
    orientationRotation = {
      EDGES: [0, 1].map((i2) => new Matrix4().makeRotationAxis(firstPiecePosition.EDGES.clone().normalize(), -i2 * TAU / 2)),
      CORNERS: [0, 1, 2].map((i2) => new Matrix4().makeRotationAxis(firstPiecePosition.CORNERS.clone().normalize(), -i2 * TAU / 3)),
      CENTERS: [0, 1, 2, 3].map((i2) => new Matrix4().makeRotationAxis(firstPiecePosition.CENTERS.clone().normalize(), -i2 * TAU / 4))
    };
    cubieStickerOrder = [face.U, face.F, face.R];
    pieceDefs = {
      EDGES: [
        new CubieDef("EDGES", "UF", t(r2.O, 0)),
        new CubieDef("EDGES", "UR", t(r2.U, 3)),
        new CubieDef("EDGES", "UB", t(r2.U, 2)),
        new CubieDef("EDGES", "UL", t(r2.U, 1)),
        new CubieDef("EDGES", "DF", t(r2.F, 2)),
        new CubieDef("EDGES", "DR", t(r2.F, 2).premultiply(t(r2.D, 1))),
        new CubieDef("EDGES", "DB", t(r2.F, 2).premultiply(t(r2.D, 2))),
        new CubieDef("EDGES", "DL", t(r2.F, 2).premultiply(t(r2.D, 3))),
        new CubieDef("EDGES", "FR", t(r2.U, 3).premultiply(t(r2.R, 3))),
        new CubieDef("EDGES", "FL", t(r2.U, 1).premultiply(t(r2.R, 3))),
        new CubieDef("EDGES", "BR", t(r2.U, 3).premultiply(t(r2.R, 1))),
        new CubieDef("EDGES", "BL", t(r2.U, 1).premultiply(t(r2.R, 1)))
      ],
      CORNERS: [
        new CubieDef("CORNERS", "UFR", t(r2.O, 0)),
        new CubieDef("CORNERS", "URB", t(r2.U, 3)),
        new CubieDef("CORNERS", "UBL", t(r2.U, 2)),
        new CubieDef("CORNERS", "ULF", t(r2.U, 1)),
        new CubieDef("CORNERS", "DRF", t(r2.F, 2).premultiply(t(r2.D, 1))),
        new CubieDef("CORNERS", "DFL", t(r2.F, 2).premultiply(t(r2.D, 0))),
        new CubieDef("CORNERS", "DLB", t(r2.F, 2).premultiply(t(r2.D, 3))),
        new CubieDef("CORNERS", "DBR", t(r2.F, 2).premultiply(t(r2.D, 2)))
      ],
      CENTERS: [
        new CubieDef("CENTERS", "U", t(r2.O, 0)),
        new CubieDef("CENTERS", "L", t(r2.R, 3).premultiply(t(r2.U, 1))),
        new CubieDef("CENTERS", "F", t(r2.R, 3)),
        new CubieDef("CENTERS", "R", t(r2.R, 3).premultiply(t(r2.D, 1))),
        new CubieDef("CENTERS", "B", t(r2.R, 3).premultiply(t(r2.D, 2))),
        new CubieDef("CENTERS", "D", t(r2.R, 2))
      ]
    };
    CUBE_SCALE = 1 / 3;
    pictureStickerCoords = {
      EDGES: [
        [
          [0, 4, 6],
          [0, 4, 5]
        ],
        [
          [3, 5, 7],
          [0, 7, 5]
        ],
        [
          [2, 4, 8],
          [0, 10, 5]
        ],
        [
          [1, 3, 7],
          [0, 1, 5]
        ],
        [
          [2, 4, 2],
          [2, 4, 3]
        ],
        [
          [3, 5, 1],
          [2, 7, 3]
        ],
        [
          [0, 4, 0],
          [2, 10, 3]
        ],
        [
          [1, 3, 1],
          [2, 1, 3]
        ],
        [
          [3, 5, 4],
          [3, 6, 4]
        ],
        [
          [1, 3, 4],
          [1, 2, 4]
        ],
        [
          [1, 9, 4],
          [1, 8, 4]
        ],
        [
          [3, 11, 4],
          [3, 0, 4]
        ]
      ],
      CORNERS: [
        [
          [0, 5, 6],
          [0, 5, 5],
          [0, 6, 5]
        ],
        [
          [3, 5, 8],
          [0, 8, 5],
          [0, 9, 5]
        ],
        [
          [2, 3, 8],
          [0, 11, 5],
          [0, 0, 5]
        ],
        [
          [1, 3, 6],
          [0, 2, 5],
          [0, 3, 5]
        ],
        [
          [3, 5, 2],
          [2, 6, 3],
          [2, 5, 3]
        ],
        [
          [2, 3, 2],
          [2, 3, 3],
          [2, 2, 3]
        ],
        [
          [1, 3, 0],
          [2, 0, 3],
          [2, 11, 3]
        ],
        [
          [0, 5, 0],
          [2, 9, 3],
          [2, 8, 3]
        ]
      ],
      CENTERS: [
        [[0, 4, 7]],
        [[0, 1, 4]],
        [[0, 4, 4]],
        [[0, 7, 4]],
        [[0, 10, 4]],
        [[0, 4, 1]]
      ]
    };
    sharedCubieFoundationGeometryCache = null;
    sharedStickerGeometryCache = null;
    Cube3D = class extends Object3D {
      constructor(kpuzzle, scheduleRenderCallback, options = {}) {
        super();
        this.kpuzzle = kpuzzle;
        this.scheduleRenderCallback = scheduleRenderCallback;
        this.pieces = {};
        this.experimentalHintStickerMeshes = [];
        this.experimentalFoundationMeshes = [];
        this.sprite = new Promise((resolve) => {
          this.setSpriteURL = (url) => {
            svgLoader.load(url, resolve);
          };
        });
        this.hintSprite = new Promise((resolve) => {
          this.setHintSpriteURL = (url) => {
            svgLoader.load(url, resolve);
          };
        });
        this.options = { ...cube3DOptionsDefaults };
        Object.assign(this.options, options);
        if (this.kpuzzle.name() !== "3x3x3") {
          throw new Error(`Invalid puzzle for this Cube3D implementation: ${this.kpuzzle.name()}`);
        }
        if (options.foundationSprite) {
          this.setSprite(options.foundationSprite);
        }
        if (options.hintSprite) {
          this.setHintSprite(options.hintSprite);
        }
        this.kpuzzleFaceletInfo = {};
        for (const orbit in pieceDefs) {
          const orbitFaceletInfo = [];
          this.kpuzzleFaceletInfo[orbit] = orbitFaceletInfo;
          this.pieces[orbit] = pieceDefs[orbit].map(this.createCubie.bind(this, orbit, orbitFaceletInfo));
        }
        this.scale.set(CUBE_SCALE, CUBE_SCALE, CUBE_SCALE);
        if (this.options.experimentalStickering) {
          this.setStickering(this.options.experimentalStickering);
        }
      }
      setSprite(texture) {
        this.sprite = texture;
      }
      setHintSprite(texture) {
        this.hintSprite = texture;
      }
      experimentalSetStickerSpriteURL(stickerSpriteURL) {
        this.setSpriteURL(stickerSpriteURL);
      }
      experimentalSetHintStickerSpriteURL(hintStickerSpriteURL) {
        this.setHintSpriteURL(hintStickerSpriteURL);
      }
      setStickering(stickering) {
        (async () => {
          const appearance = await puzzles["3x3x3"].appearance(stickering ?? "full");
          this.setAppearance(appearance ?? await puzzles["3x3x3"].appearance("full"));
        })();
      }
      setAppearance(appearance) {
        for (const [orbitName, orbitAppearance] of Object.entries(appearance.orbits)) {
          for (let pieceIdx = 0; pieceIdx < orbitAppearance.pieces.length; pieceIdx++) {
            const pieceAppearance = orbitAppearance.pieces[pieceIdx];
            if (pieceAppearance) {
              const pieceInfo = this.kpuzzleFaceletInfo[orbitName][pieceIdx];
              for (let faceletIdx = 0; faceletIdx < pieceInfo.length; faceletIdx++) {
                const faceletAppearance = pieceAppearance.facelets[faceletIdx];
                if (faceletAppearance) {
                  const faceletInfo = pieceInfo[faceletIdx];
                  const appearance2 = typeof faceletAppearance === "string" ? faceletAppearance : faceletAppearance?.appearance;
                  faceletInfo.facelet.material = axesInfo[faceletInfo.faceIdx].stickerMaterial[appearance2];
                  const hintAppearance = typeof faceletAppearance === "string" ? appearance2 : faceletAppearance.hintAppearance ?? appearance2;
                  if (faceletInfo.hintFacelet) {
                    faceletInfo.hintFacelet.material = axesInfo[faceletInfo.faceIdx].hintStickerMaterial[hintAppearance];
                  }
                }
              }
            }
          }
        }
        if (this.scheduleRenderCallback) {
          this.scheduleRenderCallback();
        }
      }
      experimentalUpdateOptions(options) {
        if ("showMainStickers" in options) {
          throw new Error("Unimplemented");
        }
        const showFoundation = options.showFoundation;
        if (typeof showFoundation !== "undefined" && this.options.showFoundation !== showFoundation) {
          this.options.showFoundation = showFoundation;
          for (const foundation of this.experimentalFoundationMeshes) {
            foundation.visible = showFoundation;
          }
        }
        const hintFacelets = options.hintFacelets;
        if (typeof hintFacelets !== "undefined" && this.options.hintFacelets !== hintFacelets && hintFaceletStyles[hintFacelets]) {
          this.options.hintFacelets = hintFacelets;
          for (const hintSticker of this.experimentalHintStickerMeshes) {
            hintSticker.visible = hintFacelets === "floating";
          }
          this.scheduleRenderCallback();
        }
        const experimentalStickering = options.experimentalStickering;
        if (typeof experimentalStickering !== "undefined" && this.options.experimentalStickering !== experimentalStickering && experimentalStickerings[experimentalStickering]) {
          this.options.experimentalStickering = experimentalStickering;
          this.setStickering(experimentalStickering);
          this.scheduleRenderCallback();
        }
      }
      onPositionChange(p) {
        const reid333 = p.state;
        for (const orbit in pieceDefs) {
          const pieces = pieceDefs[orbit];
          for (let i2 = 0; i2 < pieces.length; i2++) {
            const j = reid333.stateData[orbit].pieces[i2];
            this.pieces[orbit][j].matrix.copy(pieceDefs[orbit][i2].matrix);
            this.pieces[orbit][j].matrix.multiply(orientationRotation[orbit][reid333.stateData[orbit].orientation[i2]]);
          }
          for (const moveProgress of p.movesInProgress) {
            const move = moveProgress.move;
            const turnNormal = axesInfo[familyToAxis[move.family]].vector;
            const moveMatrix = new Matrix4().makeRotationAxis(turnNormal, -this.ease(moveProgress.fraction) * moveProgress.direction * move.amount * TAU / 4);
            for (let i2 = 0; i2 < pieces.length; i2++) {
              const k = this.kpuzzle.definition.moves[move.family][orbit].permutation[i2];
              if (i2 !== k || this.kpuzzle.definition.moves[move.family][orbit].orientation[i2] !== 0) {
                const j = reid333.stateData[orbit].pieces[i2];
                this.pieces[orbit][j].matrix.premultiply(moveMatrix);
              }
            }
          }
        }
        this.scheduleRenderCallback();
      }
      createCubie(orbit, orbitFacelets, piece, orbitPieceIdx) {
        const cubieFaceletInfo = [];
        orbitFacelets.push(cubieFaceletInfo);
        const cubie = new Group();
        if (this.options.showFoundation) {
          const foundation = this.createCubieFoundation();
          cubie.add(foundation);
          this.experimentalFoundationMeshes.push(foundation);
        }
        for (let i2 = 0; i2 < piece.stickerFaces.length; i2++) {
          const sticker = this.createSticker(axesInfo[cubieStickerOrder[i2]], axesInfo[piece.stickerFaces[i2]], false);
          const faceletInfo = {
            faceIdx: piece.stickerFaces[i2],
            facelet: sticker
          };
          cubie.add(sticker);
          if (this.options.hintFacelets === "floating") {
            const hintSticker = this.createSticker(axesInfo[cubieStickerOrder[i2]], axesInfo[piece.stickerFaces[i2]], true);
            cubie.add(hintSticker);
            faceletInfo.hintFacelet = hintSticker;
            this.experimentalHintStickerMeshes.push(hintSticker);
          }
          if (this.options.experimentalStickering === "picture" && pictureStickerCoords[orbit] && pictureStickerCoords[orbit][orbitPieceIdx] && pictureStickerCoords[orbit][orbitPieceIdx][i2]) {
            const [rotate, offsetX, offsetY] = pictureStickerCoords[orbit][orbitPieceIdx][i2];
            (async () => {
              const addImageSticker = async (hint) => {
                const texture = await (hint ? this.hintSprite : this.sprite);
                const mesh = this.createSticker(axesInfo[cubieStickerOrder[i2]], axesInfo[piece.stickerFaces[i2]], hint);
                mesh.material = new MeshBasicMaterial({
                  map: texture,
                  side: hint ? BackSide : DoubleSide,
                  transparent: true
                });
                const x1 = offsetX / 12;
                const x2 = (offsetX + 1) / 12;
                const y1 = offsetY / 9;
                const y2 = (offsetY + 1) / 9;
                let v1 = new Vector2(x1, y1);
                let v2 = new Vector2(x1, y2);
                let v3 = new Vector2(x2, y2);
                let v4 = new Vector2(x2, y1);
                switch (rotate) {
                  case 1:
                    [v1, v2, v3, v4] = [v2, v3, v4, v1];
                    break;
                  case 2:
                    [v1, v2, v3, v4] = [v3, v4, v1, v2];
                    break;
                  case 3:
                    [v1, v2, v3, v4] = [v4, v1, v2, v3];
                    break;
                }
                mesh.geometry.setAttribute("uv", new BufferAttribute(new Float32Array([
                  v3.x,
                  v3.y,
                  v2.x,
                  v2.y,
                  v4.x,
                  v4.y,
                  v2.x,
                  v2.y,
                  v1.x,
                  v1.y,
                  v4.x,
                  v4.y
                ]), 2));
                cubie.add(mesh);
              };
              addImageSticker(true);
              addImageSticker(false);
            })();
          }
          cubieFaceletInfo.push(faceletInfo);
        }
        cubie.matrix.copy(piece.matrix);
        cubie.matrixAutoUpdate = false;
        this.add(cubie);
        return cubie;
      }
      createCubieFoundation() {
        const box = sharedCubieFoundationGeometry();
        return new Mesh(box, this.options.experimentalStickering === "picture" ? blackMesh : blackTranslucentMesh);
      }
      createSticker(posAxisInfo, materialAxisInfo, isHint) {
        const geo = this.options.experimentalStickering === "picture" ? newStickerGeometry() : sharedStickerGeometry();
        const stickerMesh = new Mesh(geo, isHint ? materialAxisInfo.hintStickerMaterial.regular : materialAxisInfo.stickerMaterial.regular);
        stickerMesh.setRotationFromEuler(posAxisInfo.fromZ);
        stickerMesh.position.copy(posAxisInfo.vector);
        stickerMesh.position.multiplyScalar(isHint ? this.options.experimentalStickering === "picture" ? EXPERIMENTAL_PICTURE_CUBE_HINT_ELEVATION : cubieDimensions.hintStickerElevation : cubieDimensions.stickerElevation);
        return stickerMesh;
      }
      experimentalSetFoundationOpacity(opacity) {
        this.experimentalFoundationMeshes[0].material.opacity = opacity;
      }
      experimentalSetStickerWidth(width) {
        for (const orbitInfo of Object.values(this.kpuzzleFaceletInfo)) {
          for (const pieceInfo of orbitInfo) {
            for (const faceletInfo of pieceInfo) {
              faceletInfo.facelet.scale.setScalar(width / cubieDimensions.stickerWidth);
            }
          }
        }
      }
      experimentalSetCenterStickerWidth(width) {
        for (const orbitInfo of [this.kpuzzleFaceletInfo["CENTERS"]]) {
          for (const pieceInfo of orbitInfo) {
            for (const faceletInfo of pieceInfo) {
              faceletInfo.facelet.scale.setScalar(width / cubieDimensions.stickerWidth);
            }
          }
        }
      }
      ease(fraction) {
        return smootherStep(fraction);
      }
    };
  }
});

// src/cubing/twisty/views/3D/puzzles/PG3D.ts
function dist(coords, a, b2) {
  return Math.hypot(coords[3 * a] - coords[3 * b2], coords[3 * a + 1] - coords[3 * b2 + 1], coords[3 * a + 2] - coords[3 * b2 + 2]);
}
function triarea(coords, a, b2, c) {
  const ab = dist(coords, a, b2);
  const bc = dist(coords, b2, c);
  const ac = dist(coords, a, c);
  const p = (ab + bc + ac) / 2;
  return Math.sqrt(p * (p - ab) * (p - bc) * (p - ac));
}
function polyarea(coords) {
  let sum = 0;
  for (let i2 = 2; 3 * i2 < coords.length; i2++) {
    sum += triarea(coords, 0, 1, i2);
  }
  return sum;
}
function normalize2(r3) {
  const m = Math.hypot(r3[0], r3[1], r3[2]);
  r3[0] /= m;
  r3[1] /= m;
  r3[2] /= m;
  return r3;
}
function cross(a, b2) {
  const r3 = new Array(3);
  r3[0] = a[1] * b2[2] - a[2] * b2[1];
  r3[1] = a[2] * b2[0] - a[0] * b2[2];
  r3[2] = a[0] * b2[1] - a[1] * b2[0];
  return r3;
}
function normal(c) {
  const a = [c[3] - c[0], c[4] - c[1], c[5] - c[2]];
  const b2 = [c[6] - c[3], c[7] - c[4], c[8] - c[5]];
  const r3 = cross(a, b2);
  return normalize2(r3);
}
function trimEdges(face2, tr) {
  const r3 = [];
  const A = new Array(3);
  const B = new Array(3);
  for (let iter = 1; iter < 10; iter++) {
    for (let i2 = 0; i2 < face2.length; i2 += 3) {
      const pi = (i2 + face2.length - 3) % face2.length;
      const ni = (i2 + 3) % face2.length;
      for (let k = 0; k < 3; k++) {
        A[k] = face2[pi + k] - face2[i2 + k];
        B[k] = face2[ni + k] - face2[i2 + k];
      }
      const alen = Math.hypot(A[0], A[1], A[2]);
      const blen = Math.hypot(B[0], B[1], B[2]);
      for (let k = 0; k < 3; k++) {
        A[k] /= alen;
        B[k] /= blen;
      }
      const d2 = A[0] * B[0] + A[1] * B[1] + A[2] * B[2];
      const m = tr / Math.sqrt(1 - d2 * d2);
      for (let k = 0; k < 3; k++) {
        r3[i2 + k] = face2[i2 + k] + (A[k] + B[k]) * m;
      }
    }
    let good = true;
    for (let i2 = 0; good && i2 < r3.length; i2 += 3) {
      const ni = (i2 + 3) % face2.length;
      let t2 = 0;
      for (let k = 0; k < 3; k++) {
        const a = face2[ni + k] - face2[i2 + k];
        const b2 = r3[ni + k] - r3[i2 + k];
        t2 += a * b2;
      }
      if (t2 <= 0) {
        good = false;
      }
    }
    if (good) {
      return r3;
    }
    tr /= 2;
  }
  return face2;
}
var foundationMaterial, invisMaterial, basicStickerMaterial, Filler, StickerDef, HitPlaneDef, AxisInfo2, DEFAULT_COLOR_FRACTION, PG_SCALE, _pendingStickeringUpdate, _isValidMove, isValidMove_fn, PG3D;
var init_PG3D = __esm({
  "src/cubing/twisty/views/3D/puzzles/PG3D.ts"() {
    init_three_module();
    init_alg();
    init_puzzles();
    init_easing();
    init_TAU();
    foundationMaterial = new MeshBasicMaterial({
      side: DoubleSide,
      color: 0
    });
    invisMaterial = new MeshBasicMaterial({
      visible: false
    });
    basicStickerMaterial = new MeshBasicMaterial({
      vertexColors: true
    });
    Filler = class {
      constructor(sz, tm) {
        this.sz = sz;
        this.tm = tm;
        this.vertices = new Float32Array(9 * sz);
        this.uvs = void 0;
        this.colors = new Uint8Array(18 * sz);
        this.ind = new Uint8Array(sz);
        this.pos = 0;
        this.ipos = 0;
      }
      add(pt, i2, c) {
        this.vertices[this.pos] = pt[3 * i2 + 0];
        this.vertices[this.pos + 1] = pt[3 * i2 + 1];
        this.vertices[this.pos + 2] = pt[3 * i2 + 2];
        this.colors[this.pos] = c >> 16;
        this.colors[this.pos + 1] = c >> 8 & 255;
        this.colors[this.pos + 2] = c & 255;
        this.pos += 3;
      }
      addUncolored(pt, i2) {
        this.vertices[this.pos] = pt[3 * i2 + 0];
        this.vertices[this.pos + 1] = pt[3 * i2 + 1];
        this.vertices[this.pos + 2] = pt[3 * i2 + 2];
        this.pos += 3;
      }
      setind(i2) {
        this.ind[this.ipos++] = i2;
      }
      makePoly(coords, color, ind) {
        const ncoords = coords;
        for (let g = 1; 3 * (g + 1) < ncoords.length; g++) {
          this.add(ncoords, 0, color);
          this.add(ncoords, g, color);
          this.add(ncoords, g + 1, color);
          this.setind(ind);
        }
      }
      setAttributes(geo) {
        geo.setAttribute("position", new BufferAttribute(this.vertices, 3));
        const sa2 = this.colors.subarray(0, 9 * this.sz);
        geo.setAttribute("color", new BufferAttribute(sa2, 3, true));
      }
      makeGroups(geo) {
        geo.clearGroups();
        for (let i2 = 0; i2 < this.ipos; ) {
          const si = i2++;
          const iv = this.ind[si];
          while (this.ind[i2] === iv) {
            i2++;
          }
          geo.addGroup(3 * si, 3 * (i2 - si), iv);
        }
      }
      saveOriginalColors() {
        this.colors.copyWithin(this.pos, 0, this.pos);
      }
    };
    StickerDef = class {
      constructor(filler, stickerDat, trim, options) {
        this.texturePtr = void 0;
        this.twistVal = -1;
        this.isDup = !!stickerDat.isDup;
        this.faceNum = stickerDat.face;
        this.stickerStart = filler.ipos;
        const sdColor = new Color(stickerDat.color).getHex();
        this.origColor = sdColor;
        this.origColorAppearance = sdColor;
        if (options?.appearance) {
          this.setAppearance(filler, options.appearance);
        }
        this.faceColor = sdColor;
        const coords = this.stickerCoords(stickerDat.coords, trim);
        filler.makePoly(coords, this.faceColor, this.isDup ? 4 : 0);
        this.stickerEnd = filler.ipos;
      }
      stickerCoords(coords, trim) {
        return trimEdges(coords.slice(), trim);
      }
      hintCoords(coords, hintStickerHeightScale, trim, normal2) {
        coords = this.stickerCoords(coords, trim);
        normal2 = normal2.slice();
        for (let i2 = 0; i2 < 3; i2++) {
          normal2[i2] *= 0.5 * hintStickerHeightScale;
        }
        const hCoords = new Array(coords.length);
        for (let i2 = 0; 3 * i2 < coords.length; i2++) {
          const j = coords.length / 3 - 1 - i2;
          hCoords[3 * i2] = coords[3 * j] + normal2[0];
          hCoords[3 * i2 + 1] = coords[3 * j + 1] + normal2[1];
          hCoords[3 * i2 + 2] = coords[3 * j + 2] + normal2[2];
        }
        return hCoords;
      }
      foundationCoords(coords) {
        const ncoords = coords.slice();
        for (let i2 = 0; i2 < coords.length; i2++) {
          ncoords[i2] = coords[i2] * 0.999;
        }
        return ncoords;
      }
      addHint(filler, stickerDat, hintStickers, hintStickerHeightScale, trim, normal2) {
        this.hintStart = filler.ipos;
        const coords = this.hintCoords(stickerDat.coords, hintStickerHeightScale, trim, normal2);
        filler.makePoly(coords, this.faceColor, hintStickers && !this.isDup ? 2 : 4);
        this.hintEnd = filler.ipos;
      }
      addFoundation(filler, stickerDat, black) {
        this.foundationStart = filler.ipos;
        const coords = this.foundationCoords(stickerDat.coords);
        filler.makePoly(coords, black, this.isDup ? 4 : 6);
        this.foundationEnd = filler.ipos;
      }
      setHintStickers(filler, hintStickers) {
        const indv = this.isDup || !hintStickers ? 4 : 2;
        for (let i2 = this.hintStart; i2 < this.hintEnd; i2++) {
          filler.ind[i2] = indv | filler.ind[i2] & 1;
        }
      }
      setAppearance(filler, faceletMeshAppearance) {
        let c = 0;
        switch (faceletMeshAppearance) {
          case "regular":
            c = this.origColor;
            break;
          case "dim":
            if (this.origColor === 16777215) {
              c = 14540253;
            } else {
              c = new Color(this.origColor).multiplyScalar(0.5).getHex();
            }
            break;
          case "oriented":
            c = 16746751;
            break;
          case "ignored":
            c = 4473924;
            break;
          case "invisible":
            c = this.origColor;
        }
        this.origColorAppearance = c;
        for (let i2 = 9 * this.stickerStart; i2 < 9 * this.stickerEnd; i2 += 3) {
          filler.colors[filler.pos + i2] = c >> 16;
          filler.colors[filler.pos + i2 + 1] = c >> 8 & 255;
          filler.colors[filler.pos + i2 + 2] = c & 255;
        }
        for (let i2 = 9 * this.hintStart; i2 < 9 * this.hintEnd; i2 += 3) {
          filler.colors[filler.pos + i2] = c >> 16;
          filler.colors[filler.pos + i2 + 1] = c >> 8 & 255;
          filler.colors[filler.pos + i2 + 2] = c & 255;
        }
        this.setHintStickers(filler, faceletMeshAppearance !== "invisible" && !this.isDup);
      }
      addUVs(filler) {
        const uvs = filler.uvs;
        const vert = filler.vertices;
        const coords = new Array(3);
        for (let i2 = 3 * this.stickerStart; i2 < 3 * this.stickerEnd; i2++) {
          coords[0] = vert[3 * i2];
          coords[1] = vert[3 * i2 + 1];
          coords[2] = vert[3 * i2 + 2];
          const uv = filler.tm.getuv(this.faceNum, coords);
          uvs[2 * i2] = uv[0];
          uvs[2 * i2 + 1] = uv[1];
        }
        for (let i2 = 3 * this.hintStart; i2 < 3 * this.hintEnd; i2++) {
          coords[0] = vert[3 * i2];
          coords[1] = vert[3 * i2 + 1];
          coords[2] = vert[3 * i2 + 2];
          const uv = filler.tm.getuv(this.faceNum, coords);
          uvs[2 * i2] = uv[0];
          uvs[2 * i2 + 1] = uv[1];
        }
      }
      setTexture(filler, sd) {
        if (this.texturePtr === sd) {
          return 0;
        }
        this.texturePtr = sd;
        const sz = 6 * filler.sz;
        filler.uvs.copyWithin(6 * this.stickerStart, 6 * sd.stickerStart + sz, 6 * sd.stickerEnd + sz);
        filler.uvs.copyWithin(6 * this.hintStart, 6 * sd.hintStart + sz, 6 * sd.hintEnd + sz);
        return 1;
      }
      setColor(filler, sd) {
        const c = sd.origColorAppearance;
        if (this.faceColor !== c) {
          this.faceColor = c;
          const sz = filler.pos;
          filler.colors.copyWithin(9 * this.stickerStart, 9 * sd.stickerStart + sz, 9 * sd.stickerEnd + sz);
          filler.colors.copyWithin(9 * this.hintStart, 9 * sd.hintStart + sz, 9 * sd.hintEnd + sz);
          return 1;
        } else {
          return 0;
        }
      }
    };
    HitPlaneDef = class {
      constructor(hitface, tm, stickerDat) {
        this.cubie = new Group();
        const coords = hitface.coords;
        const filler = new Filler(coords.length / 3 - 2, tm);
        for (let g = 1; 3 * g + 3 < coords.length; g++) {
          filler.addUncolored(coords, 0);
          filler.addUncolored(coords, g);
          filler.addUncolored(coords, g + 1);
        }
        this.geo = new BufferGeometry();
        filler.setAttributes(this.geo);
        const obj = new Mesh(this.geo, invisMaterial);
        obj.userData.quantumMove = stickerDat.notationMapper.notationToExternal(new Move(hitface.name));
        this.cubie.scale.setScalar(0.99);
        this.cubie.add(obj);
      }
    };
    AxisInfo2 = class {
      constructor(axisDat) {
        const vec = axisDat.coordinates;
        this.axis = new Vector3(vec[0], vec[1], vec[2]);
        this.order = axisDat.order;
      }
    };
    DEFAULT_COLOR_FRACTION = 0.71;
    PG_SCALE = 0.5;
    PG3D = class extends Object3D {
      constructor(scheduleRenderCallback, kpuzzle, stickerDat, enableFoundationOpt = false, enableHintStickersOpt = false, hintStickerHeightScale = 1, params = {}) {
        super();
        this.scheduleRenderCallback = scheduleRenderCallback;
        this.kpuzzle = kpuzzle;
        this.stickerDat = stickerDat;
        this.params = params;
        __privateAdd(this, _isValidMove);
        this.stickerTargets = [];
        this.controlTargets = [];
        this.textured = false;
        this.showHintStickers = false;
        this.showFoundations = false;
        __privateAdd(this, _pendingStickeringUpdate, false);
        if (stickerDat.stickers.length === 0) {
          throw Error("Reuse of stickerdat from pg; please don't do that.");
        }
        this.hintMaterial = new MeshBasicMaterial({
          vertexColors: true,
          transparent: true,
          opacity: 0.5
        });
        this.hintMaterialDisposable = true;
        this.stickerMaterial = basicStickerMaterial;
        this.stickerMaterialDisposable = false;
        this.axesInfo = {};
        const axesDef = this.stickerDat.axis;
        for (const axis of axesDef) {
          this.axesInfo[axis.quantumMove.family] = new AxisInfo2(axis);
        }
        const stickers = this.stickerDat.stickers;
        this.stickers = {};
        this.materialArray1 = new Array(8);
        this.materialArray2 = new Array(8);
        this.showFoundation(enableFoundationOpt);
        enableFoundationOpt = true;
        let triangleCount = 0;
        const multiplier = 3;
        for (const sticker of stickers) {
          const sides = sticker.coords.length / 3;
          triangleCount += multiplier * (sides - 2);
        }
        const filler = new Filler(triangleCount, stickerDat.textureMapper);
        const black = 0;
        const normals = [];
        let totArea = 0;
        for (const f of stickerDat.faces) {
          normals.push(normal(f.coords));
          totArea += polyarea(f.coords);
        }
        const colorfrac = DEFAULT_COLOR_FRACTION;
        let nonDupStickers = 0;
        for (const sticker of stickers) {
          if (!sticker.isDup) {
            nonDupStickers++;
          }
        }
        const trim = Math.sqrt(totArea / nonDupStickers) * (1 - Math.sqrt(colorfrac)) / 2;
        for (const sticker of stickers) {
          const orbit = sticker.orbit;
          const ord = sticker.ord;
          const ori = sticker.ori;
          if (!this.stickers[orbit]) {
            this.stickers[orbit] = [];
          }
          if (!this.stickers[orbit][ori]) {
            this.stickers[orbit][ori] = [];
          }
          const options = {};
          if (params.appearance) {
            options.appearance = getFaceletAppearance(params.appearance, orbit, ord, ori, false);
          }
          const stickerdef = new StickerDef(filler, sticker, trim, options);
          this.stickers[orbit][ori][ord] = stickerdef;
        }
        this.showHintStickers = enableHintStickersOpt;
        enableHintStickersOpt = true;
        for (const sticker of stickers) {
          const orbit = sticker.orbit;
          const ord = sticker.ord;
          const ori = sticker.ori;
          this.stickers[orbit][ori][ord].addHint(filler, sticker, enableHintStickersOpt, hintStickerHeightScale, trim, normals[sticker.face]);
        }
        this.foundationBound = filler.ipos;
        for (const sticker of stickers) {
          const orbit = sticker.orbit;
          const ord = sticker.ord;
          const ori = sticker.ori;
          if (enableFoundationOpt) {
            this.stickers[orbit][ori][ord].addFoundation(filler, sticker, black);
          }
        }
        const fixedGeo = new BufferGeometry();
        filler.setAttributes(fixedGeo);
        filler.makeGroups(fixedGeo);
        const obj = new Mesh(fixedGeo, this.materialArray1);
        obj.scale.set(PG_SCALE, PG_SCALE, PG_SCALE);
        this.add(obj);
        const obj2 = new Mesh(fixedGeo, this.materialArray2);
        obj2.scale.set(PG_SCALE, PG_SCALE, PG_SCALE);
        this.add(obj2);
        const hitfaces = this.stickerDat.faces;
        this.movingObj = obj2;
        this.fixedGeo = fixedGeo;
        this.filler = filler;
        for (const hitface of hitfaces) {
          const facedef = new HitPlaneDef(hitface, stickerDat.textureMapper, this.stickerDat);
          facedef.cubie.scale.set(PG_SCALE, PG_SCALE, PG_SCALE);
          this.add(facedef.cubie);
          this.controlTargets.push(facedef.cubie.children[0]);
        }
        filler.saveOriginalColors();
        stickerDat.stickers = [];
        this.updateMaterialArrays();
      }
      dispose() {
        if (this.fixedGeo) {
          this.fixedGeo.dispose();
        }
        if (this.stickerMaterialDisposable) {
          this.stickerMaterial.dispose();
          this.stickerMaterial = basicStickerMaterial;
          this.stickerMaterialDisposable = false;
        }
        if (this.hintMaterialDisposable) {
          this.hintMaterial.dispose();
          this.hintMaterial = basicStickerMaterial;
          this.hintMaterialDisposable = false;
        }
      }
      experimentalGetStickerTargets() {
        return this.stickerTargets;
      }
      experimentalGetControlTargets() {
        return this.controlTargets;
      }
      getClosestMoveToAxis(point, transformations) {
        let closestMove = null;
        let closestMoveDotProduct = 0;
        let modify = (m) => m;
        switch (transformations.depth) {
          case "secondSlice":
            modify = (m) => m.modified({ innerLayer: 2 });
            break;
          case "rotation":
            modify = (m) => m.modified({ family: m.family + "v" });
            break;
        }
        for (const axis of this.stickerDat.axis) {
          const product = point.dot(new Vector3(...axis.coordinates));
          if (product > closestMoveDotProduct) {
            const modified = this.stickerDat.notationMapper.notationToExternal(modify(axis.quantumMove));
            if (!modified) {
              continue;
            }
            if (__privateMethod(this, _isValidMove, isValidMove_fn).call(this, modified)) {
              closestMoveDotProduct = product;
              closestMove = modified;
            }
          }
        }
        if (!closestMove) {
          return null;
        }
        if (transformations.invert) {
          closestMove = closestMove.invert();
        }
        const order = this.kpuzzle.moveToTransformation(closestMove).repetitionOrder();
        return { move: closestMove, order };
      }
      experimentalSetAppearance(appearance) {
        this.params.appearance = appearance;
        for (const orbitName in this.kpuzzle.definition.orbits) {
          const { numPieces, numOrientations: orientations } = this.kpuzzle.definition.orbits[orbitName];
          for (let pieceIdx = 0; pieceIdx < numPieces; pieceIdx++) {
            for (let faceletIdx = 0; faceletIdx < orientations; faceletIdx++) {
              const faceletAppearance = getFaceletAppearance(appearance, orbitName, pieceIdx, faceletIdx, false);
              const stickerDef = this.stickers[orbitName][faceletIdx][pieceIdx];
              if (this.textured && this.hintMaterialDisposable && faceletAppearance === "invisible") {
              } else {
                stickerDef.setAppearance(this.filler, faceletAppearance);
              }
            }
          }
        }
        __privateSet(this, _pendingStickeringUpdate, true);
        if (this.lastPos) {
          this.onPositionChange(this.lastPos);
        }
      }
      onPositionChange(p) {
        const transformation = p.state.experimentalToTransformation();
        if (!transformation) {
          throw new Error("indistinguishable pieces are not supported by PG3D yet");
        }
        const noRotation = new Euler();
        this.movingObj.rotation.copy(noRotation);
        let colormods = 0;
        const filler = this.filler;
        const ind = filler.ind;
        if (!this.lastPos || __privateGet(this, _pendingStickeringUpdate) || !this.lastPos.state.experimentalToTransformation().isIdentical(transformation)) {
          for (const orbit in this.stickers) {
            const pieces = this.stickers[orbit];
            const pos2 = transformation.transformationData[orbit];
            const orin = pieces.length;
            if (orin === 1) {
              const pieces2 = pieces[0];
              for (let i2 = 0; i2 < pieces2.length; i2++) {
                const ni = pos2.permutation[i2];
                if (this.textured) {
                  colormods += pieces2[i2].setTexture(filler, pieces2[ni]);
                } else {
                  colormods += pieces2[i2].setColor(filler, pieces2[ni]);
                }
              }
            } else {
              for (let ori = 0; ori < orin; ori++) {
                const pieces2 = pieces[ori];
                for (let i2 = 0; i2 < pieces2.length; i2++) {
                  const nori = (ori + orin - pos2.orientation[i2]) % orin;
                  const ni = pos2.permutation[i2];
                  if (this.textured) {
                    colormods += pieces2[i2].setTexture(filler, pieces[nori][ni]);
                  } else {
                    colormods += pieces2[i2].setColor(filler, pieces[nori][ni]);
                  }
                }
              }
            }
          }
          this.lastPos = p;
        }
        let vismods = 0;
        for (const moveProgress of p.movesInProgress) {
          const externalMove = moveProgress.move;
          const unswizzled = this.stickerDat.unswizzle(externalMove);
          if (!unswizzled) {
            return;
          }
          const move = externalMove;
          const quantumTransformation = this.kpuzzle.moveToTransformation(move.modified({ amount: 1 }));
          const ax = this.axesInfo[unswizzled.family];
          const turnNormal = ax.axis;
          const angle = -this.ease(moveProgress.fraction) * moveProgress.direction * unswizzled.amount * TAU / ax.order;
          this.movingObj.rotateOnAxis(turnNormal, angle);
          if (this.lastMoveTransformation !== quantumTransformation) {
            for (const orbit in this.stickers) {
              const pieces = this.stickers[orbit];
              const orin = pieces.length;
              const bmv = quantumTransformation.transformationData[orbit];
              for (let ori = 0; ori < orin; ori++) {
                const pieces2 = pieces[ori];
                for (let i2 = 0; i2 < pieces2.length; i2++) {
                  const p2 = pieces2[i2];
                  const ni = bmv.permutation[i2];
                  let tv = 0;
                  if (ni !== i2 || bmv.orientation[i2] !== 0) {
                    tv = 1;
                  }
                  if (tv !== p2.twistVal) {
                    if (tv) {
                      for (let j = p2.stickerStart; j < p2.stickerEnd; j++) {
                        ind[j] |= 1;
                      }
                      for (let j = p2.hintStart; j < p2.hintEnd; j++) {
                        ind[j] |= 1;
                      }
                      for (let j = p2.foundationStart; j < p2.foundationEnd; j++) {
                        ind[j] |= 1;
                      }
                    } else {
                      for (let j = p2.stickerStart; j < p2.stickerEnd; j++) {
                        ind[j] &= ~1;
                      }
                      for (let j = p2.hintStart; j < p2.hintEnd; j++) {
                        ind[j] &= ~1;
                      }
                      for (let j = p2.foundationStart; j < p2.foundationEnd; j++) {
                        ind[j] &= ~1;
                      }
                    }
                    p2.twistVal = tv;
                    vismods++;
                  }
                }
              }
            }
            this.lastMoveTransformation = quantumTransformation;
          }
        }
        if (__privateGet(this, _pendingStickeringUpdate) || vismods) {
          this.filler.makeGroups(this.fixedGeo);
        }
        if (__privateGet(this, _pendingStickeringUpdate) || colormods) {
          if (this.textured) {
            this.fixedGeo.getAttribute("uv").updateRange = {
              offset: 0,
              count: 6 * this.foundationBound
            };
            this.fixedGeo.getAttribute("uv").needsUpdate = true;
          }
          if (__privateGet(this, _pendingStickeringUpdate) || !this.textured) {
            this.fixedGeo.getAttribute("color").updateRange = {
              offset: 0,
              count: 9 * this.foundationBound
            };
            this.fixedGeo.getAttribute("color").needsUpdate = true;
          }
        }
        this.scheduleRenderCallback();
        __privateSet(this, _pendingStickeringUpdate, false);
      }
      ease(fraction) {
        return smootherStep(fraction);
      }
      showHintFacelets(v) {
        this.showHintStickers = v;
      }
      updateMaterialArrays() {
        for (let i2 = 0; i2 < 8; i2++) {
          this.materialArray1[i2] = invisMaterial;
          this.materialArray2[i2] = invisMaterial;
        }
        this.materialArray1[0] = this.stickerMaterial;
        this.materialArray2[1] = this.stickerMaterial;
        if (this.showHintStickers) {
          this.materialArray1[2] = this.hintMaterial;
          this.materialArray2[3] = this.hintMaterial;
        } else {
          this.materialArray1[2] = invisMaterial;
          this.materialArray2[3] = invisMaterial;
        }
        if (this.showFoundations) {
          this.materialArray1[6] = foundationMaterial;
          this.materialArray2[7] = foundationMaterial;
        } else {
          this.materialArray1[6] = invisMaterial;
          this.materialArray2[7] = invisMaterial;
        }
      }
      showFoundation(v) {
        this.showFoundations = v;
      }
      setHintStickerOpacity(v) {
        if (this.hintMaterialDisposable) {
          this.hintMaterial.dispose();
          this.hintMaterialDisposable = false;
        }
        if (v === 0) {
          this.hintMaterial = invisMaterial;
        } else if (v === 1) {
          this.hintMaterial = this.stickerMaterial;
        } else {
          this.hintMaterial = new MeshBasicMaterial({
            vertexColors: true,
            transparent: true,
            opacity: 0.5
          });
          this.hintMaterialDisposable = true;
        }
      }
      experimentalUpdateOptions(options) {
        if (options.hintFacelets !== void 0) {
          this.showHintFacelets(options.hintFacelets !== "none");
        }
        if (options.showFoundation !== void 0) {
          this.showFoundation(options.showFoundation);
        }
        if (options.hintStickerOpacity !== void 0) {
          this.setHintStickerOpacity(options.hintStickerOpacity);
        }
        __privateSet(this, _pendingStickeringUpdate, true);
        if (this.lastPos) {
          this.onPositionChange(this.lastPos);
        }
        this.updateMaterialArrays();
        this.scheduleRenderCallback();
      }
      adduvs() {
        const filler = this.filler;
        if (filler.uvs) {
          return;
        }
        this.filler.uvs = new Float32Array(12 * filler.sz);
        for (const orbit in this.stickers) {
          const pieces = this.stickers[orbit];
          const orin = pieces.length;
          for (let ori = 0; ori < orin; ori++) {
            const pieces2 = pieces[ori];
            for (const piece2 of pieces2) {
              piece2.addUVs(this.filler);
            }
          }
        }
        filler.uvs.copyWithin(6 * filler.sz, 0, 6 * filler.sz);
        const sa1 = filler.uvs.subarray(0, 6 * filler.sz);
        this.fixedGeo.setAttribute("uv", new BufferAttribute(sa1, 2, true));
      }
      experimentalUpdateTexture(enabled, stickerTexture, hintTexture) {
        if (!stickerTexture) {
          enabled = false;
        }
        if (enabled && !this.filler.uvs) {
          this.adduvs();
        }
        this.textured = enabled;
        if (this.stickerMaterialDisposable) {
          this.stickerMaterial.dispose();
          this.stickerMaterialDisposable = false;
        }
        if (enabled) {
          this.stickerMaterial = new MeshBasicMaterial({
            map: stickerTexture,
            side: FrontSide,
            transparent: false
          });
          this.stickerMaterialDisposable = true;
        } else {
          this.stickerMaterial = basicStickerMaterial;
        }
        if (this.hintMaterialDisposable) {
          this.hintMaterial.dispose();
          this.hintMaterialDisposable = false;
        }
        if (enabled) {
          this.hintMaterial = new MeshBasicMaterial({
            map: hintTexture,
            side: FrontSide,
            transparent: false
          });
          this.hintMaterialDisposable = true;
        } else {
          this.hintMaterial = basicStickerMaterial;
        }
        if (enabled) {
          this.showHintFacelets(hintTexture !== null);
        }
        this.updateMaterialArrays();
        __privateSet(this, _pendingStickeringUpdate, true);
        if (this.lastPos) {
          this.onPositionChange(this.lastPos);
        }
        this.scheduleRenderCallback();
      }
    };
    _pendingStickeringUpdate = new WeakMap();
    _isValidMove = new WeakSet();
    isValidMove_fn = function(move) {
      try {
        this.kpuzzle.moveToTransformation(move);
        return true;
      } catch (_) {
        return false;
      }
    };
  }
});

// src/cubing/twisty/views/3D/Twisty3DScene.ts
var Twisty3DScene;
var init_Twisty3DScene = __esm({
  "src/cubing/twisty/views/3D/Twisty3DScene.ts"() {
    init_d();
    Twisty3DScene = class {
      constructor() {
        this.renderTargets = /* @__PURE__ */ new Set();
        this.twisty3Ds = /* @__PURE__ */ new Set();
        this.threeJSScene = (async () => new (await THREEJS).Scene())();
      }
      addRenderTarget(renderTarget) {
        this.renderTargets.add(renderTarget);
      }
      scheduleRender() {
        for (const renderTarget of this.renderTargets) {
          renderTarget.scheduleRender();
        }
      }
      async addTwisty3DPuzzle(twisty3DPuzzle) {
        this.twisty3Ds.add(twisty3DPuzzle);
        (await this.threeJSScene).add(twisty3DPuzzle);
      }
      async removeTwisty3DPuzzle(twisty3DPuzzle) {
        this.twisty3Ds.delete(twisty3DPuzzle);
        (await this.threeJSScene).remove(twisty3DPuzzle);
      }
      async clearPuzzles() {
        for (const puz of this.twisty3Ds) {
          (await this.threeJSScene).remove(puz);
        }
        this.twisty3Ds.clear();
      }
    };
  }
});

// src/cubing/twisty/heavy-code-imports/dynamic-entries/3d-dynamic.ts
var d_dynamic_exports = {};
__export(d_dynamic_exports, {
  Cube3D: () => Cube3D,
  PG3D: () => PG3D,
  T3I: () => three_module_exports,
  Twisty3DScene: () => Twisty3DScene,
  cube3DShim: () => cube3DShim,
  pg3dShim: () => pg3dShim
});
async function cube3DShim(options) {
  const renderCallbackShim = () => {
  };
  return new Cube3D(await cube3x3x3.kpuzzle(), renderCallbackShim, options);
}
async function pg3dShim(puzzleLoader, hintFacelets) {
  const renderCallbackShim = () => {
  };
  return new PG3D(renderCallbackShim, await puzzleLoader.kpuzzle(), (await puzzleLoader.pg()).get3d(), true, hintFacelets === "floating");
}
var init_d_dynamic = __esm({
  "src/cubing/twisty/heavy-code-imports/dynamic-entries/3d-dynamic.ts"() {
    init_puzzles();
    init_Cube3D();
    init_PG3D();
    init_three_module();
    init_Cube3D();
    init_PG3D();
    init_Twisty3DScene();
  }
});

// src/cubing/twisty/heavy-code-imports/3d.ts
async function proxy3D() {
  return cachedConstructorProxy ?? (cachedConstructorProxy = Promise.resolve().then(() => (init_d_dynamic(), d_dynamic_exports)));
}
var cachedConstructorProxy, THREEJS;
var init_d = __esm({
  "src/cubing/twisty/heavy-code-imports/3d.ts"() {
    init_p_lazy();
    cachedConstructorProxy = null;
    THREEJS = from(async () => (await proxy3D()).T3I);
  }
});

// src/cubing/twisty/controllers/AnimationTypes.ts
function directionScalar(direction) {
  return direction;
}

// src/cubing/twisty/controllers/RenderScheduler.ts
var RenderScheduler = class {
  constructor(callback) {
    this.callback = callback;
    this.animFrameID = null;
    this.animFrame = this.animFrameWrapper.bind(this);
  }
  requestAnimFrame() {
    if (!this.animFrameID) {
      this.animFrameID = requestAnimationFrame(this.animFrame);
    }
  }
  cancelAnimFrame() {
    if (this.animFrameID) {
      cancelAnimationFrame(this.animFrameID);
      this.animFrameID = 0;
    }
  }
  animFrameWrapper(timestamp) {
    this.animFrameID = 0;
    this.callback(timestamp);
  }
};

// src/cubing/twisty/controllers/TwistyAnimationController.ts
init_PromiseFreshener();

// src/cubing/twisty/model/helpers.ts
function arrayEquals(a, b2) {
  if (a === b2) {
    return true;
  }
  if (a.length !== b2.length) {
    return false;
  }
  for (let i2 = 0; i2 < a.length; i2++) {
    if (a[i2] !== b2[i2]) {
      return false;
    }
  }
  return true;
}
function arrayEqualsCompare(a, b2, compare) {
  if (a === b2) {
    return true;
  }
  if (a.length !== b2.length) {
    return false;
  }
  for (let i2 = 0; i2 < a.length; i2++) {
    if (!compare(a[i2], b2[i2])) {
      return false;
    }
  }
  return true;
}
function mod(v, m, offset = 0) {
  return (v % m + m + offset) % m - offset;
}
function modIntoRange(v, rangeMin, rangeMax) {
  return mod(v - rangeMin, rangeMax - rangeMin) + rangeMin;
}

// src/cubing/twisty/controllers/TwistyAnimationController.ts
var CatchUpHelper = class {
  constructor(model) {
    this.model = model;
    this.catchingUp = false;
    this.pendingFrame = false;
    this.scheduler = new RenderScheduler(this.animFrame.bind(this));
    this.catchUpMs = 500;
    this.lastTimestamp = 0;
  }
  start() {
    if (!this.catchingUp) {
      this.lastTimestamp = performance.now();
    }
    this.catchingUp = true;
    this.pendingFrame = true;
    this.scheduler.requestAnimFrame();
  }
  stop() {
    this.catchingUp = false;
    this.scheduler.cancelAnimFrame();
  }
  animFrame(timestamp) {
    this.scheduler.requestAnimFrame();
    const delta = (timestamp - this.lastTimestamp) / this.catchUpMs;
    this.lastTimestamp = timestamp;
    this.model.catchUpMove.set((async () => {
      const previousCatchUpMove = await this.model.catchUpMove.get();
      if (previousCatchUpMove.move === null) {
        return previousCatchUpMove;
      }
      const amount = previousCatchUpMove.amount + delta;
      if (amount >= 1) {
        this.pendingFrame = true;
        this.stop();
        this.model.timestampRequest.set("end");
        return {
          move: null,
          amount: 0
        };
      }
      this.pendingFrame = false;
      return {
        move: previousCatchUpMove.move,
        amount
      };
    })());
  }
};
var _effectiveTimestampMilliseconds, effectiveTimestampMilliseconds_fn, _animFrameEffectiveTimestampStaleDropper;
var TwistyAnimationController = class {
  constructor(model, delegate) {
    this.delegate = delegate;
    __privateAdd(this, _effectiveTimestampMilliseconds);
    this.playing = false;
    this.direction = 1 /* Forwards */;
    this.lastDatestamp = 0;
    this.scheduler = new RenderScheduler(this.animFrame.bind(this));
    __privateAdd(this, _animFrameEffectiveTimestampStaleDropper, new StaleDropper());
    this.model = model;
    this.lastTimestampPromise = __privateMethod(this, _effectiveTimestampMilliseconds, effectiveTimestampMilliseconds_fn).call(this);
    this.model.playingInfo.addFreshListener(this.onPlayingProp.bind(this));
    this.catchUpHelper = new CatchUpHelper(this.model);
    this.model.catchUpMove.addFreshListener(this.onCatchUpMoveProp.bind(this));
  }
  async onPlayingProp(playingInfo) {
    if (playingInfo.playing !== this.playing) {
      playingInfo.playing ? this.play(playingInfo) : this.pause();
    }
  }
  async onCatchUpMoveProp(catchUpMove) {
    const catchingUp = catchUpMove.move !== null;
    if (catchingUp !== this.catchUpHelper.catchingUp) {
      catchingUp ? this.catchUpHelper.start() : this.catchUpHelper.stop();
    }
    this.scheduler.requestAnimFrame();
  }
  jumpToStart(options) {
    this.model.timestampRequest.set("start");
    this.pause();
    if (options?.flash) {
      this.delegate.flash();
    }
  }
  jumpToEnd(options) {
    this.model.timestampRequest.set("end");
    this.pause();
    if (options?.flash) {
      this.delegate.flash();
    }
  }
  playPause() {
    if (this.playing) {
      this.pause();
    } else {
      this.play();
    }
  }
  async play(options) {
    const direction = options?.direction ?? 1 /* Forwards */;
    const coarseTimelineInfo = await this.model.coarseTimelineInfo.get();
    if (options?.autoSkipToOtherEndIfStartingAtBoundary ?? true) {
      if (direction === 1 /* Forwards */ && coarseTimelineInfo.atEnd) {
        this.model.timestampRequest.set("start");
        this.delegate.flash();
      }
      if (direction === -1 /* Backwards */ && coarseTimelineInfo.atStart) {
        this.model.timestampRequest.set("end");
        this.delegate.flash();
      }
    }
    this.model.playingInfo.set({
      playing: true,
      direction,
      untilBoundary: options?.untilBoundary ?? "entire-timeline" /* EntireTimeline */,
      loop: options?.loop ?? false
    });
    this.playing = true;
    this.lastDatestamp = performance.now();
    this.lastTimestampPromise = __privateMethod(this, _effectiveTimestampMilliseconds, effectiveTimestampMilliseconds_fn).call(this);
    this.scheduler.requestAnimFrame();
  }
  pause() {
    this.playing = false;
    this.scheduler.cancelAnimFrame();
    this.model.playingInfo.set({
      playing: false,
      untilBoundary: "entire-timeline" /* EntireTimeline */
    });
  }
  async animFrame(frameDatestamp) {
    if (this.playing) {
      this.scheduler.requestAnimFrame();
    }
    const lastDatestamp = this.lastDatestamp;
    const freshenerResult = await __privateGet(this, _animFrameEffectiveTimestampStaleDropper).queue(Promise.all([
      this.model.playingInfo.get(),
      this.lastTimestampPromise,
      this.model.timeRange.get(),
      this.model.tempoScale.get(),
      this.model.currentMoveInfo.get()
    ]));
    const [playingInfo, lastTimestamp, timeRange, tempoScale, currentMoveInfo] = freshenerResult;
    if (!playingInfo.playing) {
      this.playing = false;
      return;
    }
    let end = currentMoveInfo.earliestEnd;
    if (currentMoveInfo.currentMoves.length === 0 || playingInfo.untilBoundary === "entire-timeline" /* EntireTimeline */) {
      end = timeRange.end;
    }
    let start = currentMoveInfo.latestStart;
    if (currentMoveInfo.currentMoves.length === 0 || playingInfo.untilBoundary === "entire-timeline" /* EntireTimeline */) {
      start = timeRange.start;
    }
    let delta = (frameDatestamp - lastDatestamp) * directionScalar(this.direction) * tempoScale;
    delta = Math.max(delta, 1);
    delta *= playingInfo.direction;
    let newTimestamp = lastTimestamp + delta;
    let newSmartTimestampRequest = null;
    if (newTimestamp >= end) {
      if (playingInfo.loop) {
        newTimestamp = modIntoRange(newTimestamp, timeRange.start, timeRange.end);
      } else {
        if (newTimestamp === timeRange.end) {
          newSmartTimestampRequest = "end";
        } else {
          newTimestamp = end;
        }
        this.playing = false;
        this.model.playingInfo.set({
          playing: false
        });
      }
    } else if (newTimestamp <= start) {
      if (playingInfo.loop) {
        newTimestamp = modIntoRange(newTimestamp, timeRange.start, timeRange.end);
      } else {
        if (newTimestamp === timeRange.start) {
          newSmartTimestampRequest = "start";
        } else {
          newTimestamp = start;
        }
        this.playing = false;
        this.model.playingInfo.set({
          playing: false
        });
      }
    }
    this.lastDatestamp = frameDatestamp;
    this.lastTimestampPromise = Promise.resolve(newTimestamp);
    this.model.timestampRequest.set(newSmartTimestampRequest ?? newTimestamp);
  }
};
_effectiveTimestampMilliseconds = new WeakSet();
effectiveTimestampMilliseconds_fn = async function() {
  return (await this.model.detailedTimelineInfo.get()).timestamp;
};
_animFrameEffectiveTimestampStaleDropper = new WeakMap();

// src/cubing/twisty/controllers/TwistyPlayerController.ts
var TwistyPlayerController = class {
  constructor(model, delegate) {
    this.model = model;
    this.animationController = new TwistyAnimationController(model, delegate);
  }
  jumpToStart(options) {
    this.animationController.jumpToStart(options);
  }
  jumpToEnd(options) {
    this.animationController.jumpToEnd(options);
  }
  togglePlay(play) {
    if (typeof play === "undefined") {
      this.animationController.playPause();
    }
    play ? this.animationController.play() : this.animationController.pause();
  }
  async visitTwizzleLink() {
    const a = document.createElement("a");
    a.href = await this.model.twizzleLink();
    a.target = "_blank";
    a.click();
  }
};

// src/cubing/twisty/model/props/viewer/ControlPanelProp.ts
init_TwistyProp();
var controlsLocations = {
  "bottom-row": true,
  "none": true
};
var ControlPanelProp = class extends SimpleTwistyPropSource {
  getDefaultValue() {
    return "auto";
  }
};

// src/cubing/twisty/views/2D/Twisty2DSceneWrapper.ts
init_d();
init_TwistyProp();

// src/cubing/twisty/views/node-custom-element-shims.ts
var HTMLElementStub = class {
};
var HTMLElementShim;
if (globalThis.HTMLElement) {
  HTMLElementShim = HTMLElement;
} else {
  HTMLElementShim = HTMLElementStub;
}
var CustomElementsStub = class {
  define() {
  }
};
var customElementsShim;
if (globalThis.customElements) {
  customElementsShim = customElements;
} else {
  customElementsShim = new CustomElementsStub();
}

// src/cubing/twisty/views/ManagedCustomElement.ts
var CSSSource = class {
  constructor(sourceText) {
    this.sourceText = sourceText;
  }
  getAsString() {
    return this.sourceText;
  }
};
var _cssSourceMap;
var ManagedCustomElement = class extends HTMLElementShim {
  constructor(options) {
    super();
    __privateAdd(this, _cssSourceMap, /* @__PURE__ */ new Map());
    this.shadow = this.attachShadow({ mode: options?.mode ?? "closed" });
    this.contentWrapper = document.createElement("div");
    this.contentWrapper.classList.add("wrapper");
    this.shadow.appendChild(this.contentWrapper);
  }
  addCSS(cssSource) {
    const existing = __privateGet(this, _cssSourceMap).get(cssSource);
    if (existing) {
      return existing;
    }
    const cssElem = document.createElement("style");
    cssElem.textContent = cssSource.getAsString();
    __privateGet(this, _cssSourceMap).set(cssSource, cssElem);
    this.shadow.appendChild(cssElem);
    return cssElem;
  }
  removeCSS(cssSource) {
    const cssElem = __privateGet(this, _cssSourceMap).get(cssSource);
    if (!cssElem) {
      return;
    }
    this.shadow.removeChild(cssElem);
    __privateGet(this, _cssSourceMap).delete(cssSource);
  }
  addElement(element) {
    return this.contentWrapper.appendChild(element);
  }
  prependElement(element) {
    this.contentWrapper.prepend(element);
  }
  removeElement(element) {
    return this.contentWrapper.removeChild(element);
  }
};
_cssSourceMap = new WeakMap();
customElementsShim.define("twisty-managed-custom-element", ManagedCustomElement);

// src/cubing/twisty/views/TwistyViewerWrapper.css.ts
var twistyViewerWrapperCSS = new CSSSource(`
:host {
  width: 384px;
  height: 256px;
  display: grid;
}

.wrapper {
  width: 100%;
  height: 100%;
  display: grid;
  overflow: hidden;
}

.wrapper > * {
  width: 100%;
  height: 100%;
  overflow: hidden;
}

.wrapper.back-view-side-by-side {
  grid-template-columns: 1fr 1fr;
}

.wrapper.back-view-top-right {
  grid-template-columns: 3fr 1fr;
  grid-template-rows: 1fr 3fr;
}

.wrapper.back-view-top-right > :nth-child(1) {
  grid-row: 1 / 3;
  grid-column: 1 / 3;
}

.wrapper.back-view-top-right > :nth-child(2) {
  grid-row: 1 / 2;
  grid-column: 2 / 3;
}
`);

// src/cubing/twisty/views/2D/Twisty2DPuzzleWrapper.ts
init_TwistyProp();

// src/cubing/twisty/views/2D/Twisty2DPuzzle.ts
init_TwistyProp();

// src/cubing/twisty/views/2D/Twisty2DPuzzle.css.ts
var twisty2DSVGCSS = new CSSSource(`
:host {
  width: 384px;
  height: 256px;
  display: grid;
}

.wrapper {
  width: 100%;
  height: 100%;
  display: grid;
  overflow: hidden;
}

.svg-wrapper,
twisty-2d-svg,
svg {
  width: 100%;
  height: 100%;
  display: grid;
  min-height: 0;
}

svg {
  animation: fade-in 0.25s ease-in;
}

@keyframes fade-in {
  from { opacity: 0; }
  to { opacity: 1; }
}
`);

// src/cubing/twisty/views/2D/KPuzzleSVGWrapper.ts
var xmlns = "http://www.w3.org/2000/svg";
var svgCounter = 0;
function nextSVGID() {
  svgCounter += 1;
  return "svg" + svgCounter.toString();
}
var colorMaps = {
  dim: {
    "white": "#dddddd",
    "orange": "#884400",
    "limegreen": "#008800",
    "red": "#660000",
    "rgb(34, 102, 255)": "#000088",
    "yellow": "#888800"
  },
  oriented: {
    "white": "#44ddcc",
    "orange": "#44ddcc",
    "limegreen": "#44ddcc",
    "red": "#44ddcc",
    "rgb(34, 102, 255)": "#44ddcc",
    "yellow": "#44ddcc"
  },
  ignored: {
    "white": "#444444",
    "orange": "#444444",
    "limegreen": "#444444",
    "red": "#444444",
    "rgb(34, 102, 255)": "#444444",
    "yellow": "#444444"
  },
  invisible: {
    "white": "#00000000",
    "orange": "#00000000",
    "limegreen": "#00000000",
    "red": "#00000000",
    "rgb(34, 102, 255)": "#00000000",
    "yellow": "#00000000"
  }
};
var KPuzzleSVGWrapper = class {
  constructor(kpuzzle, svgSource, experimentalAppearance) {
    this.kpuzzle = kpuzzle;
    this.originalColors = {};
    this.gradients = {};
    if (!svgSource) {
      throw new Error(`No SVG definition for puzzle type: ${kpuzzle.name()}`);
    }
    this.svgID = nextSVGID();
    this.element = document.createElement("div");
    this.element.classList.add("svg-wrapper");
    this.element.innerHTML = svgSource;
    const svgElem = this.element.querySelector("svg");
    if (!svgElem) {
      throw new Error("Could not get SVG element");
    }
    if (xmlns !== svgElem.namespaceURI) {
      throw new Error("Unexpected XML namespace");
    }
    svgElem.style.maxWidth = "100%";
    svgElem.style.maxHeight = "100%";
    this.gradientDefs = document.createElementNS(xmlns, "defs");
    svgElem.insertBefore(this.gradientDefs, svgElem.firstChild);
    for (const orbitName in kpuzzle.definition.orbits) {
      const orbitDefinition = kpuzzle.definition.orbits[orbitName];
      for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {
        for (let orientation = 0; orientation < orbitDefinition.numOrientations; orientation++) {
          const id = this.elementID(orbitName, idx, orientation);
          const elem = this.elementByID(id);
          let originalColor = elem.style.fill;
          if (experimentalAppearance) {
            (() => {
              const a = experimentalAppearance.orbits;
              if (!a) {
                return;
              }
              const orbitAppearance = a[orbitName];
              if (!orbitAppearance) {
                return;
              }
              const pieceAppearance = orbitAppearance.pieces[idx];
              if (!pieceAppearance) {
                return;
              }
              const faceletAppearance = pieceAppearance.facelets[orientation];
              if (!faceletAppearance) {
                return;
              }
              const appearance = typeof faceletAppearance === "string" ? faceletAppearance : faceletAppearance?.appearance;
              const colorMap = colorMaps[appearance];
              if (colorMap) {
                originalColor = colorMap[originalColor];
              }
            })();
          } else {
            originalColor = elem.style.fill;
          }
          this.originalColors[id] = originalColor;
          this.gradients[id] = this.newGradient(id, originalColor);
          this.gradientDefs.appendChild(this.gradients[id]);
          elem.setAttribute("style", `fill: url(#grad-${this.svgID}-${id})`);
        }
      }
    }
  }
  drawState(state, nextState, fraction) {
    this.draw(state, nextState, fraction);
  }
  draw(state, nextState, fraction) {
    const transformation = state.experimentalToTransformation();
    const nextTransformation = nextState?.experimentalToTransformation();
    if (!transformation) {
      throw new Error("Distinguishable pieces are not handled for SVG yet!");
    }
    for (const orbitName in transformation.kpuzzle.definition.orbits) {
      const orbitDefinition = transformation.kpuzzle.definition.orbits[orbitName];
      const curTransformationOrbit = transformation.transformationData[orbitName];
      const nextTransformationOrbit = nextTransformation ? nextTransformation.transformationData[orbitName] : null;
      for (let idx = 0; idx < orbitDefinition.numPieces; idx++) {
        for (let orientation = 0; orientation < orbitDefinition.numOrientations; orientation++) {
          const id = this.elementID(orbitName, idx, orientation);
          const fromCur = this.elementID(orbitName, curTransformationOrbit.permutation[idx], (orbitDefinition.numOrientations - curTransformationOrbit.orientation[idx] + orientation) % orbitDefinition.numOrientations);
          let singleColor = false;
          if (nextTransformationOrbit) {
            const fromNext = this.elementID(orbitName, nextTransformationOrbit.permutation[idx], (orbitDefinition.numOrientations - nextTransformationOrbit.orientation[idx] + orientation) % orbitDefinition.numOrientations);
            if (fromCur === fromNext) {
              singleColor = true;
            }
            fraction = fraction || 0;
            const easedBackwardsPercent = 100 * (1 - fraction * fraction * (2 - fraction * fraction));
            this.gradients[id].children[0].setAttribute("stop-color", this.originalColors[fromCur]);
            this.gradients[id].children[1].setAttribute("stop-color", this.originalColors[fromCur]);
            this.gradients[id].children[1].setAttribute("offset", `${Math.max(easedBackwardsPercent - 5, 0)}%`);
            this.gradients[id].children[2].setAttribute("offset", `${Math.max(easedBackwardsPercent - 5, 0)}%`);
            this.gradients[id].children[3].setAttribute("offset", `${easedBackwardsPercent}%`);
            this.gradients[id].children[4].setAttribute("offset", `${easedBackwardsPercent}%`);
            this.gradients[id].children[4].setAttribute("stop-color", this.originalColors[fromNext]);
            this.gradients[id].children[5].setAttribute("stop-color", this.originalColors[fromNext]);
          } else {
            singleColor = true;
          }
          if (singleColor) {
            this.gradients[id].children[0].setAttribute("stop-color", this.originalColors[fromCur]);
            this.gradients[id].children[1].setAttribute("stop-color", this.originalColors[fromCur]);
            this.gradients[id].children[1].setAttribute("offset", `100%`);
            this.gradients[id].children[2].setAttribute("offset", `100%`);
            this.gradients[id].children[3].setAttribute("offset", `100%`);
            this.gradients[id].children[4].setAttribute("offset", `100%`);
          }
        }
      }
    }
  }
  newGradient(id, originalColor) {
    const grad = document.createElementNS(xmlns, "radialGradient");
    grad.setAttribute("id", `grad-${this.svgID}-${id}`);
    grad.setAttribute("r", `70.7107%`);
    const stopDefs = [
      { offset: 0, color: originalColor },
      { offset: 0, color: originalColor },
      { offset: 0, color: "black" },
      { offset: 0, color: "black" },
      { offset: 0, color: originalColor },
      { offset: 100, color: originalColor }
    ];
    for (const stopDef of stopDefs) {
      const stop = document.createElementNS(xmlns, "stop");
      stop.setAttribute("offset", `${stopDef.offset}%`);
      stop.setAttribute("stop-color", stopDef.color);
      stop.setAttribute("stop-opacity", "1");
      grad.appendChild(stop);
    }
    return grad;
  }
  elementID(orbitName, idx, orientation) {
    return orbitName + "-l" + idx + "-o" + orientation;
  }
  elementByID(id) {
    return this.element.querySelector("#" + id);
  }
};

// src/cubing/twisty/views/2D/Twisty2DPuzzle.ts
var _cachedPosition, _freshListenerManager;
var Twisty2DPuzzle = class extends ManagedCustomElement {
  constructor(model, kpuzzle, svgSource, options, puzzleLoader) {
    super();
    this.model = model;
    this.kpuzzle = kpuzzle;
    this.svgSource = svgSource;
    this.options = options;
    this.puzzleLoader = puzzleLoader;
    this.scheduler = new RenderScheduler(this.render.bind(this));
    __privateAdd(this, _cachedPosition, null);
    __privateAdd(this, _freshListenerManager, new FreshListenerManager());
    this.addCSS(twisty2DSVGCSS);
    this.resetSVG();
    __privateGet(this, _freshListenerManager).addListener(this.model.puzzleID, (puzzleID) => {
      if (puzzleLoader?.id !== puzzleID) {
        this.disconnect();
      }
    });
    __privateGet(this, _freshListenerManager).addListener(this.model.legacyPosition, this.onPositionChange.bind(this));
    if (this.options?.experimentalStickering) {
      this.experimentalSetStickering(this.options.experimentalStickering);
    }
  }
  disconnect() {
    __privateGet(this, _freshListenerManager).disconnect();
  }
  onPositionChange(position) {
    try {
      if (position.movesInProgress.length > 0) {
        const move = position.movesInProgress[0].move;
        let partialMove = move;
        if (position.movesInProgress[0].direction === -1 /* Backwards */) {
          partialMove = move.invert();
        }
        const newState = position.state.applyMove(partialMove);
        this.svg.draw(position.state, newState, position.movesInProgress[0].fraction);
      } else {
        this.svg.draw(position.state);
        __privateSet(this, _cachedPosition, position);
      }
    } catch (e) {
      console.warn("Bad position (this doesn't necessarily mean something is wrong). Pre-emptively disconnecting:", this.puzzleLoader?.id, e);
      this.disconnect();
    }
  }
  scheduleRender() {
    this.scheduler.requestAnimFrame();
  }
  experimentalSetStickering(stickering) {
    (async () => {
      if (!this.puzzleLoader?.appearance) {
        return;
      }
      const appearance = await this.puzzleLoader.appearance(stickering);
      this.resetSVG(appearance);
    })();
  }
  resetSVG(appearance) {
    if (this.svg) {
      this.removeElement(this.svg.element);
    }
    if (!this.kpuzzle) {
      return;
    }
    this.svg = new KPuzzleSVGWrapper(this.kpuzzle, this.svgSource, appearance);
    this.addElement(this.svg.element);
    if (__privateGet(this, _cachedPosition)) {
      this.onPositionChange(__privateGet(this, _cachedPosition));
    }
  }
  render() {
  }
};
_cachedPosition = new WeakMap();
_freshListenerManager = new WeakMap();
customElementsShim.define("twisty-2d-puzzle", Twisty2DPuzzle);

// src/cubing/twisty/views/2D/Twisty2DPuzzleWrapper.ts
var _freshListenerManager2, _cachedTwisty2DPuzzle;
var Twisty2DPuzzleWrapper = class {
  constructor(model, schedulable, puzzleLoader, effectiveVisualization) {
    this.model = model;
    this.schedulable = schedulable;
    this.puzzleLoader = puzzleLoader;
    this.effectiveVisualization = effectiveVisualization;
    __privateAdd(this, _freshListenerManager2, new FreshListenerManager());
    __privateAdd(this, _cachedTwisty2DPuzzle, null);
    this.twisty2DPuzzle();
    __privateGet(this, _freshListenerManager2).addListener(this.model.twistySceneModel.stickering, async (stickering) => {
      (await this.twisty2DPuzzle()).experimentalSetStickering(stickering);
    });
  }
  disconnect() {
    __privateGet(this, _freshListenerManager2).disconnect();
  }
  scheduleRender() {
  }
  async twisty2DPuzzle() {
    return __privateGet(this, _cachedTwisty2DPuzzle) ?? __privateSet(this, _cachedTwisty2DPuzzle, (async () => {
      const svgPromise = this.effectiveVisualization === "experimental-2D-LL" ? this.puzzleLoader.llSVG() : this.puzzleLoader.svg();
      return new Twisty2DPuzzle(this.model, await this.puzzleLoader.kpuzzle(), await svgPromise, {}, this.puzzleLoader);
    })());
  }
};
_freshListenerManager2 = new WeakMap();
_cachedTwisty2DPuzzle = new WeakMap();

// src/cubing/twisty/views/2D/Twisty2DSceneWrapper.ts
var _freshListenerManager3, _cachedScene, _currentTwisty2DPuzzleWrapper;
var Twisty2DSceneWrapper = class extends ManagedCustomElement {
  constructor(model, effectiveVisualization) {
    super();
    this.model = model;
    this.effectiveVisualization = effectiveVisualization;
    __privateAdd(this, _freshListenerManager3, new FreshListenerManager());
    __privateAdd(this, _cachedScene, void 0);
    __privateAdd(this, _currentTwisty2DPuzzleWrapper, null);
  }
  disconnect() {
    __privateGet(this, _freshListenerManager3).disconnect();
  }
  async connectedCallback() {
    this.addCSS(twistyViewerWrapperCSS);
    if (this.model) {
      __privateGet(this, _freshListenerManager3).addListener(this.model.twistyPlayerModel.puzzleLoader, this.onPuzzleLoader.bind(this));
    }
  }
  async scene() {
    return __privateGet(this, _cachedScene) ?? __privateSet(this, _cachedScene, (async () => new (await THREEJS).Scene())());
  }
  scheduleRender() {
    __privateGet(this, _currentTwisty2DPuzzleWrapper)?.scheduleRender();
  }
  currentTwisty2DPuzzleWrapper() {
    return __privateGet(this, _currentTwisty2DPuzzleWrapper);
  }
  async setCurrentTwisty2DPuzzleWrapper(twisty2DPuzzleWrapper) {
    const old = __privateGet(this, _currentTwisty2DPuzzleWrapper);
    __privateSet(this, _currentTwisty2DPuzzleWrapper, twisty2DPuzzleWrapper);
    old?.disconnect();
    const twisty2DPuzzlePromise = twisty2DPuzzleWrapper.twisty2DPuzzle();
    this.contentWrapper.textContent = "";
    this.addElement(await twisty2DPuzzlePromise);
  }
  async onPuzzleLoader(puzzleLoader) {
    __privateGet(this, _currentTwisty2DPuzzleWrapper)?.disconnect();
    const twisty2DPuzzleWrapper = new Twisty2DPuzzleWrapper(this.model.twistyPlayerModel, this, puzzleLoader, this.effectiveVisualization);
    this.setCurrentTwisty2DPuzzleWrapper(twisty2DPuzzleWrapper);
  }
};
_freshListenerManager3 = new WeakMap();
_cachedScene = new WeakMap();
_currentTwisty2DPuzzleWrapper = new WeakMap();
customElementsShim.define("twisty-2d-scene-wrapper", Twisty2DSceneWrapper);

// src/cubing/twisty/views/3D/Twisty3DSceneWrapper.ts
init_d();
init_PromiseFreshener();
init_TwistyProp();

// src/cubing/twisty/views/ClassListManager.ts
var _currentClassName;
var ClassListManager = class {
  constructor(elem, prefix, validSuffixes) {
    this.elem = elem;
    this.prefix = prefix;
    this.validSuffixes = validSuffixes;
    __privateAdd(this, _currentClassName, null);
  }
  clearValue() {
    if (__privateGet(this, _currentClassName)) {
      this.elem.contentWrapper.classList.remove(__privateGet(this, _currentClassName));
    }
    __privateSet(this, _currentClassName, null);
  }
  setValue(suffix) {
    if (!this.validSuffixes.includes(suffix)) {
      throw new Error(`Invalid suffix: ${suffix}`);
    }
    const newClassName = `${this.prefix}${suffix}`;
    const changed = __privateGet(this, _currentClassName) !== newClassName;
    if (changed) {
      this.clearValue();
      this.elem.contentWrapper.classList.add(newClassName);
      __privateSet(this, _currentClassName, newClassName);
    }
    return changed;
  }
};
_currentClassName = new WeakMap();

// src/cubing/twisty/views/3D/Twisty3DPuzzleWrapper.ts
init_puzzles();
init_d();
init_TwistyProp();
var _freshListenerManager4, _cachedTwisty3DPuzzle;
var Twisty3DPuzzleWrapper = class {
  constructor(model, schedulable, puzzleLoader, visualizationStrategy) {
    this.model = model;
    this.schedulable = schedulable;
    this.puzzleLoader = puzzleLoader;
    this.visualizationStrategy = visualizationStrategy;
    __privateAdd(this, _freshListenerManager4, new FreshListenerManager());
    __privateAdd(this, _cachedTwisty3DPuzzle, null);
    this.twisty3DPuzzle();
    __privateGet(this, _freshListenerManager4).addListener(this.model.puzzleLoader, (puzzleLoader2) => {
      if (this.puzzleLoader.id !== puzzleLoader2.id) {
        this.disconnect();
      }
    });
    __privateGet(this, _freshListenerManager4).addListener(this.model.legacyPosition, async (position) => {
      try {
        (await this.twisty3DPuzzle()).onPositionChange(position);
        this.scheduleRender();
      } catch (e) {
        this.disconnect();
      }
    });
    __privateGet(this, _freshListenerManager4).addListener(this.model.twistySceneModel.hintFacelet, async (hintFaceletStyle) => {
      (await this.twisty3DPuzzle()).experimentalUpdateOptions({
        hintFacelets: hintFaceletStyle === "auto" ? "floating" : hintFaceletStyle
      });
      this.scheduleRender();
    });
    __privateGet(this, _freshListenerManager4).addListener(this.model.twistySceneModel.foundationDisplay, async (foundationDisplay) => {
      (await this.twisty3DPuzzle()).experimentalUpdateOptions({
        showFoundation: foundationDisplay !== "none"
      });
      this.scheduleRender();
    });
    __privateGet(this, _freshListenerManager4).addListener(this.model.twistySceneModel.stickering, async (stickering) => {
      if ("setStickering" in await this.twisty3DPuzzle()) {
        (await this.twisty3DPuzzle()).setStickering(stickering);
        this.scheduleRender();
      } else {
        if ([
          "experimental-global-custom-1",
          "experimental-global-custom-2"
        ].includes(stickering)) {
          const [twisty3D] = await Promise.all([this.twisty3DPuzzle()]);
          twisty3D.experimentalSetAppearance(await cubeAppearance(this.puzzleLoader, stickering));
          this.scheduleRender();
          return;
        }
        if ("appearance" in this.puzzleLoader) {
          const [twisty3D, appearancePromise] = await Promise.all([
            this.twisty3DPuzzle(),
            this.puzzleLoader.appearance(stickering ?? "full")
          ]);
          twisty3D.experimentalSetAppearance(appearancePromise);
          this.scheduleRender();
        }
      }
    });
    __privateGet(this, _freshListenerManager4).addMultiListener([
      this.model.twistySceneModel.foundationStickerSprite,
      this.model.twistySceneModel.hintStickerSprite
    ], async (inputs) => {
      if ("experimentalUpdateTexture" in await this.twisty3DPuzzle()) {
        (await this.twisty3DPuzzle()).experimentalUpdateTexture(true, ...inputs);
        this.scheduleRender();
      }
    });
  }
  disconnect() {
    __privateGet(this, _freshListenerManager4).disconnect();
  }
  scheduleRender() {
    this.schedulable.scheduleRender();
  }
  async twisty3DPuzzle() {
    return __privateGet(this, _cachedTwisty3DPuzzle) ?? __privateSet(this, _cachedTwisty3DPuzzle, (async () => {
      const proxyPromise = proxy3D();
      if (this.puzzleLoader.id === "3x3x3" && this.visualizationStrategy === "Cube3D") {
        const [foundationSprite, hintSprite, experimentalStickering] = await Promise.all([
          this.model.twistySceneModel.foundationStickerSprite.get(),
          this.model.twistySceneModel.hintStickerSprite.get(),
          this.model.twistySceneModel.stickering.get()
        ]);
        return (await proxyPromise).cube3DShim({
          foundationSprite,
          hintSprite,
          experimentalStickering
        });
      } else {
        const [hintFacelets, foundationSprite, hintSprite] = await Promise.all([
          this.model.twistySceneModel.hintFacelet.get(),
          this.model.twistySceneModel.foundationStickerSprite.get(),
          this.model.twistySceneModel.hintStickerSprite.get()
        ]);
        const pg3d = (await proxyPromise).pg3dShim(this.puzzleLoader, hintFacelets === "auto" ? "floating" : hintFacelets);
        pg3d.then((p) => p.experimentalUpdateTexture(true, foundationSprite ?? void 0, hintSprite ?? void 0));
        return pg3d;
      }
    })());
  }
  async raycastMove(raycasterPromise, transformations) {
    const puzzle = await this.twisty3DPuzzle();
    if (!("experimentalGetControlTargets" in puzzle)) {
      console.info("not PG3D! skipping raycast");
      return;
    }
    const targets = puzzle.experimentalGetControlTargets();
    const [raycaster] = await Promise.all([raycasterPromise]);
    const intersects2 = raycaster.intersectObjects(targets);
    if (intersects2.length > 0) {
      const closestMove = puzzle.getClosestMoveToAxis(intersects2[0].point, transformations);
      if (closestMove) {
        this.model.experimentalAddMove(closestMove.move, {
          coalesce: true,
          mod: closestMove.order
        });
      } else {
        console.info("Skipping move!");
      }
    }
  }
};
_freshListenerManager4 = new WeakMap();
_cachedTwisty3DPuzzle = new WeakMap();

// src/cubing/vendor/three/examples/jsm/libs/stats.modified.module.ts
var performance2 = globalThis.performance;
var Stats = class {
  constructor() {
    this.mode = 0;
    this.dom = document.createElement("div");
    this.beginTime = (performance2 || Date).now();
    this.prevTime = this.beginTime;
    this.frames = 0;
    this.fpsPanel = this.addPanel(new StatsPanel("FPS", "#0ff", "#002"));
    this.msPanel = this.addPanel(new StatsPanel("MS", "#0f0", "#020"));
    this.memPanel = performance2?.memory ? this.addPanel(new StatsPanel("MB", "#f08", "#201")) : null;
    this.REVISION = 16;
    this.dom.style.cssText = "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000";
    this.dom.addEventListener("click", (event) => {
      event.preventDefault();
      this.showPanel(++this.mode % this.dom.children.length);
    }, false);
    this.showPanel(0);
  }
  addPanel(panel) {
    this.dom.appendChild(panel.dom);
    return panel;
  }
  showPanel(id) {
    for (let i2 = 0; i2 < this.dom.children.length; i2++) {
      this.dom.children[i2].style.display = i2 === id ? "block" : "none";
    }
    this.mode = id;
  }
  begin() {
    this.beginTime = (performance2 || Date).now();
  }
  end() {
    this.frames++;
    const time = (performance2 || Date).now();
    this.msPanel.update(time - this.beginTime, 200);
    if (time >= this.prevTime + 1e3) {
      this.fpsPanel.update(this.frames * 1e3 / (time - this.prevTime), 100);
      this.prevTime = time;
      this.frames = 0;
      if (this.memPanel) {
        const memory = performance2.memory;
        this.memPanel.update(memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576);
      }
    }
    return time;
  }
  update() {
    this.beginTime = this.end();
  }
};
var PR = Math.round(globalThis?.window?.devicePixelRatio ?? 1);
var WIDTH = 80 * PR;
var HEIGHT = 48 * PR;
var TEXT_X = 3 * PR;
var TEXT_Y = 2 * PR;
var GRAPH_X = 3 * PR;
var GRAPH_Y = 15 * PR;
var GRAPH_WIDTH = 74 * PR;
var GRAPH_HEIGHT = 30 * PR;
var StatsPanel = class {
  constructor(name, fg, bg) {
    this.name = name;
    this.fg = fg;
    this.bg = bg;
    this.min = Infinity;
    this.max = 0;
    this.dom = document.createElement("canvas");
    this.context = this.dom.getContext("2d");
    this.dom.width = WIDTH;
    this.dom.height = HEIGHT;
    this.dom.style.cssText = "width:80px;height:48px";
    this.context.font = `bold ${9 * PR}px Helvetica,Arial,sans-serif`;
    this.context.textBaseline = "top";
    this.context.fillStyle = bg;
    this.context.fillRect(0, 0, WIDTH, HEIGHT);
    this.context.fillStyle = fg;
    this.context.fillText(name, TEXT_X, TEXT_Y);
    this.context.fillRect(GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT);
    this.context.fillStyle = bg;
    this.context.globalAlpha = 0.9;
    this.context.fillRect(GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT);
  }
  update(value, maxValue) {
    this.min = Math.min(this.min, value);
    this.max = Math.max(this.max, value);
    this.context.fillStyle = this.bg;
    this.context.globalAlpha = 1;
    this.context.fillRect(0, 0, WIDTH, GRAPH_Y);
    this.context.fillStyle = this.fg;
    this.context.fillText(Math.round(value) + " " + this.name + " (" + Math.round(this.min) + "-" + Math.round(this.max) + ")", TEXT_X, TEXT_Y);
    this.context.drawImage(this.dom, GRAPH_X + PR, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT, GRAPH_X, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT);
    this.context.fillRect(GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, GRAPH_HEIGHT);
    this.context.fillStyle = this.bg;
    this.context.globalAlpha = 0.9;
    this.context.fillRect(GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, Math.round((1 - value / maxValue) * GRAPH_HEIGHT));
  }
};

// src/cubing/twisty/views/3D/Twisty3DVantage.ts
init_d();
init_PromiseFreshener();

// src/cubing/twisty/views/canvas.ts
var globalPixelRatioOverride = null;
function setGlobalPixelRatioOverride(override) {
  globalPixelRatioOverride = override;
}
function pixelRatio() {
  return globalPixelRatioOverride ?? (devicePixelRatio || 1);
}

// src/cubing/twisty/views/3D/Twisty3DVantage.css.ts
var twisty3DVantageCSS = new CSSSource(`
:host {
  width: 384px;
  height: 256px;
  display: grid;
}

.wrapper {
  width: 100%;
  height: 100%;
  display: grid;
  overflow: hidden;
  place-content: center;
  contain: strict;
}

.loading {
  width: 4em;
  height: 4em;
  border-radius: 2.5em;
  border: 0.5em solid rgba(0, 0, 0, 0);
  border-top: 0.5em solid rgba(0, 0, 0, 0.7);
  border-right: 0.5em solid rgba(0, 0, 0, 0.7);
  animation: fade-in-delayed 4s, rotate 1s linear infinite;
}

@keyframes fade-in-delayed {
  0% { opacity: 0; }
  25% {opacity: 0; }
  100% { opacity: 1; }
}

@keyframes rotate {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

/* TODO: This is due to stats hack. Replace with \`canvas\`. */
.wrapper > canvas {
  max-width: 100%;
  max-height: 100%;
  cursor: grab;
  animation: fade-in 0.25s ease-in;
}

@keyframes fade-in {
  from { opacity: 0; }
  to { opacity: 1; }
}

.wrapper > canvas:active {
  cursor: grabbing;
}

.wrapper.invisible {
  opacity: 0;
}
`);

// src/cubing/twisty/views/3D/DragTracker.ts
var MOVEMENT_EPSILON = 0.1;
var _dragInfoMap, _lazyListenersRegistered, _registerLazyListeners, registerLazyListeners_fn, _clear, clear_fn, _trackDrag, trackDrag_fn;
var DragTracker = class extends EventTarget {
  constructor(target) {
    super();
    this.target = target;
    __privateAdd(this, _registerLazyListeners);
    __privateAdd(this, _clear);
    __privateAdd(this, _trackDrag);
    __privateAdd(this, _dragInfoMap, /* @__PURE__ */ new Map());
    __privateAdd(this, _lazyListenersRegistered, false);
    target.addEventListener("pointerdown", this.onPointerDown.bind(this));
    this.target.addEventListener("contextmenu", (e) => {
      e.preventDefault();
    });
    this.target.addEventListener("touchmove", (e) => e.preventDefault());
    this.target.addEventListener("dblclick", (e) => e.preventDefault());
  }
  onPointerDown(e) {
    __privateMethod(this, _registerLazyListeners, registerLazyListeners_fn).call(this);
    const newDragInfo = {
      attachedInfo: {},
      hasMoved: false,
      lastClientX: e.clientX,
      lastClientY: e.clientY,
      lastTimeStamp: e.timeStamp
    };
    __privateGet(this, _dragInfoMap).set(e.pointerId, newDragInfo);
    this.target.setPointerCapture(e.pointerId);
  }
  onPointerMove(e) {
    const movementInfo = __privateMethod(this, _trackDrag, trackDrag_fn).call(this, e).movementInfo;
    if (movementInfo) {
      e.preventDefault();
      this.dispatchEvent(new CustomEvent("move", {
        detail: movementInfo
      }));
    }
  }
  onPointerUp(e) {
    const trackDragResult = __privateMethod(this, _trackDrag, trackDrag_fn).call(this, e);
    const existing = __privateGet(this, _dragInfoMap).get(e.pointerId);
    __privateMethod(this, _clear, clear_fn).call(this, e);
    this.target.releasePointerCapture(e.pointerId);
    let event;
    if (trackDragResult.hasMoved) {
      event = new CustomEvent("up", {
        detail: { attachedInfo: existing.attachedInfo }
      });
    } else {
      const { altKey, ctrlKey, metaKey, shiftKey } = e;
      event = new CustomEvent("press", {
        detail: {
          normalizedX: e.offsetX / this.target.offsetWidth * 2 - 1,
          normalizedY: 1 - e.offsetY / this.target.offsetHeight * 2,
          rightClick: !!(e.button & 2),
          keys: {
            altKey,
            ctrlOrMetaKey: ctrlKey || metaKey,
            shiftKey
          }
        }
      });
    }
    this.dispatchEvent(event);
  }
};
_dragInfoMap = new WeakMap();
_lazyListenersRegistered = new WeakMap();
_registerLazyListeners = new WeakSet();
registerLazyListeners_fn = function() {
  if (__privateGet(this, _lazyListenersRegistered)) {
    return;
  }
  this.target.addEventListener("pointermove", this.onPointerMove.bind(this));
  this.target.addEventListener("pointerup", this.onPointerUp.bind(this));
  __privateSet(this, _lazyListenersRegistered, true);
};
_clear = new WeakSet();
clear_fn = function(e) {
  __privateGet(this, _dragInfoMap).delete(e.pointerId);
};
_trackDrag = new WeakSet();
trackDrag_fn = function(e) {
  const existing = __privateGet(this, _dragInfoMap).get(e.pointerId);
  if (!existing) {
    return { movementInfo: null, hasMoved: false };
  }
  let movementInfo;
  if ((e.movementX ?? 0) !== 0 || (e.movementY ?? 0) !== 0) {
    movementInfo = {
      attachedInfo: existing.attachedInfo,
      movementX: e.movementX,
      movementY: e.movementY,
      elapsedMs: e.timeStamp - existing.lastTimeStamp
    };
  } else {
    movementInfo = {
      attachedInfo: existing.attachedInfo,
      movementX: e.clientX - existing.lastClientX,
      movementY: e.clientY - existing.lastClientY,
      elapsedMs: e.timeStamp - existing.lastTimeStamp
    };
  }
  existing.lastClientX = e.clientX;
  existing.lastClientY = e.clientY;
  existing.lastTimeStamp = e.timeStamp;
  if (Math.abs(movementInfo.movementX) < MOVEMENT_EPSILON && Math.abs(movementInfo.movementY) < MOVEMENT_EPSILON) {
    return { movementInfo: null, hasMoved: existing.hasMoved };
  } else {
    existing.hasMoved = true;
    return { movementInfo, hasMoved: existing.hasMoved };
  }
};

// src/cubing/twisty/views/3D/RendererPool.ts
init_d();
var renderers = [];
async function renderPooled(width, height, canvas, scene, camera) {
  if (width === 0 || height === 0) {
    return;
  }
  if (renderers.length === 0) {
    renderers.push(newRenderer());
  }
  const renderer = await renderers[0];
  renderer.setSize(width, height);
  renderer.render(scene, camera);
  const context = canvas.getContext("2d");
  context.clearRect(0, 0, canvas.width, canvas.height);
  context.drawImage(renderer.domElement, 0, 0);
}
async function newRenderer() {
  const rendererConstructor = (await THREEJS).WebGLRenderer;
  const renderer = new rendererConstructor({
    antialias: true,
    alpha: true
  });
  renderer.setPixelRatio(pixelRatio());
  return renderer;
}

// src/cubing/twisty/views/3D/Twisty3DVantage.ts
init_TAU();

// src/cubing/twisty/views/3D/TwistyOrbitControls.ts
init_d();
init_TAU();
var INERTIA_DEFAULT = true;
var INERTIA_DURATION_MS = 500;
var INERTIA_TIMEOUT_MS = 50;
var VERTICAL_MOVEMENT_BASE_SCALE = 0.75;
function momentumScale(progress) {
  return (Math.exp(1 - progress) - (1 - progress)) / (1 - Math.E) + 1;
}
var Inertia = class {
  constructor(startTimestamp, momentumX, momentumY, callback) {
    this.startTimestamp = startTimestamp;
    this.momentumX = momentumX;
    this.momentumY = momentumY;
    this.callback = callback;
    this.scheduler = new RenderScheduler(this.render.bind(this));
    this.scheduler.requestAnimFrame();
    this.lastTimestamp = startTimestamp;
  }
  render(now2) {
    const progressBefore = (this.lastTimestamp - this.startTimestamp) / INERTIA_DURATION_MS;
    const progressAfter = Math.min(1, (now2 - this.startTimestamp) / INERTIA_DURATION_MS);
    if (progressBefore === 0 && progressAfter > INERTIA_TIMEOUT_MS / INERTIA_DURATION_MS) {
      return;
    }
    const delta = momentumScale(progressAfter) - momentumScale(progressBefore);
    this.callback(this.momentumX * delta * 1e3, this.momentumY * delta * 1e3);
    if (progressAfter < 1) {
      this.scheduler.requestAnimFrame();
    }
    this.lastTimestamp = now2;
  }
};
var TwistyOrbitControls = class {
  constructor(model, mirror, canvas, dragTracker) {
    this.model = model;
    this.mirror = mirror;
    this.canvas = canvas;
    this.dragTracker = dragTracker;
    this.experimentalInertia = INERTIA_DEFAULT;
    this.onMovementBound = this.onMovement.bind(this);
    this.experimentalHasBeenMoved = false;
    this.dragTracker.addEventListener("move", this.onMove.bind(this));
    this.dragTracker.addEventListener("up", this.onUp.bind(this));
  }
  temperMovement(f) {
    return Math.sign(f) * Math.log(Math.abs(f * 10) + 1) / 6;
  }
  onMove(e) {
    var _a;
    (_a = e.detail).attachedInfo ?? (_a.attachedInfo = {});
    const { temperedX, temperedY } = this.onMovement(e.detail.movementX, e.detail.movementY);
    const attachedInfo = e.detail.attachedInfo;
    attachedInfo.lastTemperedX = temperedX * 10;
    attachedInfo.lastTemperedY = temperedY * 10;
    attachedInfo.timestamp = e.timeStamp;
  }
  onMovement(movementX, movementY) {
    const scale = this.mirror ? -1 : 1;
    const minDim = Math.min(this.canvas.offsetWidth, this.canvas.offsetHeight);
    const temperedX = this.temperMovement(movementX / minDim);
    const temperedY = this.temperMovement(movementY / minDim * VERTICAL_MOVEMENT_BASE_SCALE);
    this.model.twistySceneModel.orbitCoordinatesRequest.set((async () => {
      const prevCoords = await this.model.twistySceneModel.orbitCoordinates.get();
      const newCoords = {
        latitude: prevCoords.latitude + 2 * temperedY * DEGREES_PER_RADIAN * scale,
        longitude: prevCoords.longitude - 2 * temperedX * DEGREES_PER_RADIAN
      };
      return newCoords;
    })());
    return { temperedX, temperedY };
  }
  onUp(e) {
    e.preventDefault();
    if ("lastTemperedX" in e.detail.attachedInfo && "lastTemperedY" in e.detail.attachedInfo && "timestamp" in e.detail.attachedInfo && e.timeStamp - e.detail.attachedInfo.timestamp < 60) {
      new Inertia(e.timeStamp, e.detail.attachedInfo.lastTemperedX, e.detail.attachedInfo.lastTemperedY, this.onMovementBound);
    }
  }
};

// src/cubing/twisty/views/3D/Twisty3DVantage.ts
var SHOW_STATS = false;
async function setCameraFromOrbitCoordinates(camera, orbitCoordinates, backView = false) {
  const spherical = new (await THREEJS).Spherical(orbitCoordinates.distance, (90 - (backView ? -1 : 1) * orbitCoordinates.latitude) / DEGREES_PER_RADIAN, ((backView ? 180 : 0) + orbitCoordinates.longitude) / DEGREES_PER_RADIAN);
  spherical.makeSafe();
  camera.position.setFromSpherical(spherical);
  camera.lookAt(0, 0, 0);
}
var shareAllNewRenderers = null;
var dedicatedRenderersSoFar = 0;
var DEFAULT_MAX_DEDICATED_RENDERERS = 2;
function shareRenderer() {
  if (shareAllNewRenderers !== null) {
    if (!shareAllNewRenderers) {
      dedicatedRenderersSoFar++;
    }
    return shareAllNewRenderers;
  }
  if (dedicatedRenderersSoFar < DEFAULT_MAX_DEDICATED_RENDERERS) {
    dedicatedRenderersSoFar++;
    return false;
  } else {
    return true;
  }
}
var _setupBasicPresses, setupBasicPresses_fn, _onResizeStaleDropper, _width, _height, _onResize, onResize_fn, _cachedRenderer, _cachedCanvas, _cachedDragTracker, _dragTracker, dragTracker_fn, _cachedCamera, _cachedOrbitControls, _disconnectionFunctions2, _scheduler;
var Twisty3DVantage = class extends ManagedCustomElement {
  constructor(model, scene, options) {
    super();
    this.model = model;
    this.options = options;
    __privateAdd(this, _setupBasicPresses);
    __privateAdd(this, _onResize);
    __privateAdd(this, _dragTracker);
    this.scene = null;
    this.stats = null;
    this.rendererIsShared = shareRenderer();
    this.loadingElement = null;
    __privateAdd(this, _onResizeStaleDropper, new StaleDropper());
    __privateAdd(this, _width, 0);
    __privateAdd(this, _height, 0);
    __privateAdd(this, _cachedRenderer, null);
    __privateAdd(this, _cachedCanvas, null);
    __privateAdd(this, _cachedDragTracker, null);
    __privateAdd(this, _cachedCamera, null);
    __privateAdd(this, _cachedOrbitControls, null);
    __privateAdd(this, _disconnectionFunctions2, []);
    __privateAdd(this, _scheduler, new RenderScheduler(this.render.bind(this)));
    this.scene = scene ?? null;
    this.loadingElement = this.addElement(document.createElement("div"));
    this.loadingElement.classList.add("loading");
    if (SHOW_STATS) {
      this.stats = new Stats();
      this.stats.dom.style.position = "absolute";
      this.contentWrapper.appendChild(this.stats.dom);
    }
  }
  async connectedCallback() {
    this.addCSS(twisty3DVantageCSS);
    this.addElement((await this.canvasInfo()).canvas);
    __privateMethod(this, _onResize, onResize_fn).call(this);
    const observer = new ResizeObserver(__privateMethod(this, _onResize, onResize_fn).bind(this));
    observer.observe(this.contentWrapper);
    this.orbitControls();
    __privateMethod(this, _setupBasicPresses, setupBasicPresses_fn).call(this);
    this.scheduleRender();
  }
  async clearCanvas() {
    if (this.rendererIsShared) {
      const canvasInfo = await this.canvasInfo();
      canvasInfo.context.clearRect(0, 0, canvasInfo.canvas.width, canvasInfo.canvas.height);
    } else {
      const renderer = await this.renderer();
      const context = renderer.getContext();
      context.clear(context.COLOR_BUFFER_BIT);
    }
  }
  async renderer() {
    if (this.rendererIsShared) {
      throw new Error("renderer expected to be shared.");
    }
    return __privateGet(this, _cachedRenderer) ?? __privateSet(this, _cachedRenderer, newRenderer());
  }
  async canvasInfo() {
    return __privateGet(this, _cachedCanvas) ?? __privateSet(this, _cachedCanvas, (async () => {
      let canvas;
      if (this.rendererIsShared) {
        canvas = this.addElement(document.createElement("canvas"));
      } else {
        const renderer = await this.renderer();
        canvas = this.addElement(renderer.domElement);
      }
      this.loadingElement?.remove();
      const context = canvas.getContext("2d");
      return { canvas, context };
    })());
  }
  async camera() {
    return __privateGet(this, _cachedCamera) ?? __privateSet(this, _cachedCamera, (async () => {
      const camera = new (await THREEJS).OrthographicCamera();
      camera.position.copy(new (await THREEJS).Vector3(2, 4, 4).multiplyScalar(this.options?.backView ? -1 : 1));
      camera.lookAt(0, 0, 0);
      return camera;
    })());
  }
  async orbitControls() {
    return __privateGet(this, _cachedOrbitControls) ?? __privateSet(this, _cachedOrbitControls, (async () => {
      const orbitControls = new TwistyOrbitControls(this.model, !!this.options?.backView, (await this.canvasInfo()).canvas, await __privateMethod(this, _dragTracker, dragTracker_fn).call(this));
      if (this.model) {
        this.addListener(this.model.twistySceneModel.orbitCoordinates, async (orbitCoordinates) => {
          const camera = await this.camera();
          setCameraFromOrbitCoordinates(camera, orbitCoordinates, this.options?.backView);
          this.scheduleRender();
        });
      }
      return orbitControls;
    })());
  }
  addListener(prop, listener) {
    prop.addFreshListener(listener);
    __privateGet(this, _disconnectionFunctions2).push(() => {
      prop.removeFreshListener(listener);
    });
  }
  disconnect() {
    for (const fn of __privateGet(this, _disconnectionFunctions2)) {
      fn();
    }
    __privateSet(this, _disconnectionFunctions2, []);
  }
  async render() {
    if (!this.scene) {
      throw new Error("Attempted to render without a scene");
    }
    this.stats?.begin();
    const [scene, camera, canvas] = await Promise.all([
      this.scene.scene(),
      this.camera(),
      this.canvasInfo()
    ]);
    if (this.rendererIsShared) {
      renderPooled(__privateGet(this, _width), __privateGet(this, _height), canvas.canvas, scene, camera);
    } else {
      (await this.renderer()).render(scene, camera);
    }
    this.stats?.end();
  }
  scheduleRender() {
    __privateGet(this, _scheduler).requestAnimFrame();
  }
};
_setupBasicPresses = new WeakSet();
setupBasicPresses_fn = async function() {
  const dragTracker = await __privateMethod(this, _dragTracker, dragTracker_fn).call(this);
  dragTracker.addEventListener("press", async (e) => {
    const movePressInput = await this.model.twistySceneModel.movePressInput.get();
    if (movePressInput !== "basic") {
      return;
    }
    this.dispatchEvent(new CustomEvent("press", {
      detail: {
        pressInfo: e.detail,
        cameraPromise: this.camera()
      }
    }));
  });
};
_onResizeStaleDropper = new WeakMap();
_width = new WeakMap();
_height = new WeakMap();
_onResize = new WeakSet();
onResize_fn = async function() {
  const camera = await __privateGet(this, _onResizeStaleDropper).queue(this.camera());
  const w = this.contentWrapper.clientWidth;
  const h = this.contentWrapper.clientHeight;
  __privateSet(this, _width, w);
  __privateSet(this, _height, h);
  const off = 0;
  let yoff = 0;
  let excess = 0;
  if (h > w) {
    excess = h - w;
    yoff = -Math.floor(0.5 * excess);
  }
  const s = 700;
  camera.left = -w / 2 / s;
  camera.right = w / 2 / s;
  camera.top = h / 2 / s;
  camera.bottom = -h / 2 / s;
  camera.updateProjectionMatrix();
  this.clearCanvas();
  if (this.rendererIsShared) {
    const canvasInfo = await this.canvasInfo();
    canvasInfo.canvas.width = w * pixelRatio();
    canvasInfo.canvas.height = h * pixelRatio();
    canvasInfo.canvas.style.width = w.toString();
    canvasInfo.canvas.style.height = h.toString();
  } else {
    const renderer = await this.renderer();
    renderer.setSize(w, h, true);
  }
  this.scheduleRender();
};
_cachedRenderer = new WeakMap();
_cachedCanvas = new WeakMap();
_cachedDragTracker = new WeakMap();
_dragTracker = new WeakSet();
dragTracker_fn = async function() {
  return __privateGet(this, _cachedDragTracker) ?? __privateSet(this, _cachedDragTracker, (async () => {
    return new DragTracker((await this.canvasInfo()).canvas);
  })());
};
_cachedCamera = new WeakMap();
_cachedOrbitControls = new WeakMap();
_disconnectionFunctions2 = new WeakMap();
_scheduler = new WeakMap();
customElementsShim.define("twisty-3d-vantage", Twisty3DVantage);

// src/cubing/twisty/views/3D/Twisty3DSceneWrapper.ts
var _backViewClassListManager, _freshListenerManager5, _backViewVantage, _cachedScene2, _vantages, _currentTwisty3DPuzzleWrapper, _twisty3DStaleDropper;
var Twisty3DSceneWrapper = class extends ManagedCustomElement {
  constructor(model) {
    super();
    this.model = model;
    __privateAdd(this, _backViewClassListManager, new ClassListManager(this, "back-view-", [
      "auto",
      "none",
      "side-by-side",
      "top-right"
    ]));
    __privateAdd(this, _freshListenerManager5, new FreshListenerManager());
    __privateAdd(this, _backViewVantage, null);
    __privateAdd(this, _cachedScene2, void 0);
    __privateAdd(this, _vantages, /* @__PURE__ */ new Set());
    __privateAdd(this, _currentTwisty3DPuzzleWrapper, null);
    __privateAdd(this, _twisty3DStaleDropper, new StaleDropper());
  }
  disconnect() {
    __privateGet(this, _freshListenerManager5).disconnect();
  }
  async connectedCallback() {
    this.addCSS(twistyViewerWrapperCSS);
    const vantage = new Twisty3DVantage(this.model, this);
    this.addVantage(vantage);
    if (this.model) {
      __privateGet(this, _freshListenerManager5).addMultiListener([this.model.puzzleLoader, this.model.visualizationStrategy], this.onPuzzle.bind(this));
      __privateGet(this, _freshListenerManager5).addListener(this.model.backView, this.onBackView.bind(this));
    }
    this.scheduleRender();
  }
  setBackView(backView) {
    const shouldHaveBackView = ["side-by-side", "top-right"].includes(backView);
    const hasBackView = __privateGet(this, _backViewVantage) !== null;
    __privateGet(this, _backViewClassListManager).setValue(backView);
    if (shouldHaveBackView) {
      if (!hasBackView) {
        __privateSet(this, _backViewVantage, new Twisty3DVantage(this.model, this, {
          backView: true
        }));
        this.addVantage(__privateGet(this, _backViewVantage));
        this.scheduleRender();
      }
    } else {
      if (__privateGet(this, _backViewVantage)) {
        this.removeVantage(__privateGet(this, _backViewVantage));
        __privateSet(this, _backViewVantage, null);
      }
    }
  }
  onBackView(backView) {
    this.setBackView(backView);
  }
  async onPress(e) {
    const twisty3DPuzzleWrapper = __privateGet(this, _currentTwisty3DPuzzleWrapper);
    if (!twisty3DPuzzleWrapper) {
      console.info("no wrapper; skipping scene wrapper press!");
      return;
    }
    const raycasterPromise = (async () => {
      const [camera, three] = await Promise.all([
        e.detail.cameraPromise,
        THREEJS
      ]);
      const raycaster = new three.Raycaster();
      const mouse = new (await THREEJS).Vector2(e.detail.pressInfo.normalizedX, e.detail.pressInfo.normalizedY);
      raycaster.setFromCamera(mouse, camera);
      return raycaster;
    })();
    twisty3DPuzzleWrapper.raycastMove(raycasterPromise, {
      invert: !e.detail.pressInfo.rightClick,
      depth: e.detail.pressInfo.keys.ctrlOrMetaKey ? "rotation" : e.detail.pressInfo.keys.shiftKey ? "secondSlice" : "none"
    });
  }
  async scene() {
    return __privateGet(this, _cachedScene2) ?? __privateSet(this, _cachedScene2, (async () => new (await THREEJS).Scene())());
  }
  addVantage(vantage) {
    vantage.addEventListener("press", this.onPress.bind(this));
    __privateGet(this, _vantages).add(vantage);
    this.contentWrapper.appendChild(vantage);
  }
  removeVantage(vantage) {
    __privateGet(this, _vantages).delete(vantage);
    vantage.remove();
    vantage.disconnect();
    __privateGet(this, _currentTwisty3DPuzzleWrapper)?.disconnect();
  }
  experimentalVantages() {
    return __privateGet(this, _vantages).values();
  }
  scheduleRender() {
    for (const vantage of __privateGet(this, _vantages)) {
      vantage.scheduleRender();
    }
  }
  async setCurrentTwisty3DPuzzleWrapper(scene, twisty3DPuzzleWrapper) {
    const old = __privateGet(this, _currentTwisty3DPuzzleWrapper);
    try {
      __privateSet(this, _currentTwisty3DPuzzleWrapper, twisty3DPuzzleWrapper);
      old?.disconnect();
      scene.add(await twisty3DPuzzleWrapper.twisty3DPuzzle());
    } finally {
      if (old) {
        scene.remove(await old.twisty3DPuzzle());
      }
    }
  }
  async onPuzzle(inputs) {
    if (inputs[1] === "2D") {
      return;
    }
    __privateGet(this, _currentTwisty3DPuzzleWrapper)?.disconnect();
    const [scene, twisty3DPuzzleWrapper] = await __privateGet(this, _twisty3DStaleDropper).queue(Promise.all([
      this.scene(),
      new Twisty3DPuzzleWrapper(this.model, this, inputs[0], inputs[1])
    ]));
    this.setCurrentTwisty3DPuzzleWrapper(scene, twisty3DPuzzleWrapper);
  }
};
_backViewClassListManager = new WeakMap();
_freshListenerManager5 = new WeakMap();
_backViewVantage = new WeakMap();
_cachedScene2 = new WeakMap();
_vantages = new WeakMap();
_currentTwisty3DPuzzleWrapper = new WeakMap();
_twisty3DStaleDropper = new WeakMap();
customElementsShim.define("twisty-3d-scene-wrapper", Twisty3DSceneWrapper);

// src/cubing/twisty/views/control-panel/TwistyButtons.css.ts
var buttonGridCSS = new CSSSource(`
:host {
  width: 384px;
  height: 24px;
  display: grid;
}

.wrapper {
  width: 100%;
  height: 100%;
  display: grid;
  overflow: hidden;
  backdrop-filter: blur(4px);
  -webkit-backdrop-filter: blur(4px);
}

.wrapper {
  grid-auto-flow: column;
}

.viewer-link-none .twizzle-link-button {
  display: none;
}

.wrapper twisty-button,
.wrapper twisty-control-button {
  width: inherit;
  height: inherit;
}
`);
var buttonCSS = new CSSSource(`
:host:not([hidden]) {
  display: grid;
}

:host {
  width: 48px;
  height: 24px;
}

.wrapper {
  width: 100%;
  height: 100%;
}

button {
  width: 100%;
  height: 100%;
  border: none;
  
  background-position: center;
  background-repeat: no-repeat;
  background-size: contain;

  background-color: rgba(196, 196, 196, 0.75);
}

button:enabled {
  background-color: rgba(196, 196, 196, 0.75)
}

button:disabled {
  background-color: rgba(0, 0, 0, 0.4);
  opacity: 0.25;
  pointer-events: none;
}

button:enabled:hover {
  background-color: rgba(255, 255, 255, 0.75);
  box-shadow: 0 0 1em rgba(0, 0, 0, 0.25);
  cursor: pointer;
}

/* TODO: fullscreen icons have too much padding?? */
.svg-skip-to-start button,
button.svg-skip-to-start {
  background-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzNTg0IiBoZWlnaHQ9IjM1ODQiIHZpZXdCb3g9IjAgMCAzNTg0IDM1ODQiPjxwYXRoIGQ9Ik0yNjQzIDEwMzdxMTktMTkgMzItMTN0MTMgMzJ2MTQ3MnEwIDI2LTEzIDMydC0zMi0xM2wtNzEwLTcxMHEtOS05LTEzLTE5djcxMHEwIDI2LTEzIDMydC0zMi0xM2wtNzEwLTcxMHEtOS05LTEzLTE5djY3OHEwIDI2LTE5IDQ1dC00NSAxOUg5NjBxLTI2IDAtNDUtMTl0LTE5LTQ1VjEwODhxMC0yNiAxOS00NXQ0NS0xOWgxMjhxMjYgMCA0NSAxOXQxOSA0NXY2NzhxNC0xMSAxMy0xOWw3MTAtNzEwcTE5LTE5IDMyLTEzdDEzIDMydjcxMHE0LTExIDEzLTE5eiIvPjwvc3ZnPg==");
}

.svg-skip-to-end button,
button.svg-skip-to-end {
  background-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzNTg0IiBoZWlnaHQ9IjM1ODQiIHZpZXdCb3g9IjAgMCAzNTg0IDM1ODQiPjxwYXRoIGQ9Ik05NDEgMjU0N3EtMTkgMTktMzIgMTN0LTEzLTMyVjEwNTZxMC0yNiAxMy0zMnQzMiAxM2w3MTAgNzEwcTggOCAxMyAxOXYtNzEwcTAtMjYgMTMtMzJ0MzIgMTNsNzEwIDcxMHE4IDggMTMgMTl2LTY3OHEwLTI2IDE5LTQ1dDQ1LTE5aDEyOHEyNiAwIDQ1IDE5dDE5IDQ1djE0MDhxMCAyNi0xOSA0NXQtNDUgMTloLTEyOHEtMjYgMC00NS0xOXQtMTktNDV2LTY3OHEtNSAxMC0xMyAxOWwtNzEwIDcxMHEtMTkgMTktMzIgMTN0LTEzLTMydi03MTBxLTUgMTAtMTMgMTl6Ii8+PC9zdmc+");
}

.svg-step-forward button,
button.svg-step-forward {
  background-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzNTg0IiBoZWlnaHQ9IjM1ODQiIHZpZXdCb3g9IjAgMCAzNTg0IDM1ODQiPjxwYXRoIGQ9Ik0yNjg4IDE1NjhxMCAyNi0xOSA0NWwtNTEyIDUxMnEtMTkgMTktNDUgMTl0LTQ1LTE5cS0xOS0xOS0xOS00NXYtMjU2aC0yMjRxLTk4IDAtMTc1LjUgNnQtMTU0IDIxLjVxLTc2LjUgMTUuNS0xMzMgNDIuNXQtMTA1LjUgNjkuNXEtNDkgNDIuNS04MCAxMDF0LTQ4LjUgMTM4LjVxLTE3LjUgODAtMTcuNSAxODEgMCA1NSA1IDEyMyAwIDYgMi41IDIzLjV0Mi41IDI2LjVxMCAxNS04LjUgMjV0LTIzLjUgMTBxLTE2IDAtMjgtMTctNy05LTEzLTIydC0xMy41LTMwcS03LjUtMTctMTAuNS0yNC0xMjctMjg1LTEyNy00NTEgMC0xOTkgNTMtMzMzIDE2Mi00MDMgODc1LTQwM2gyMjR2LTI1NnEwLTI2IDE5LTQ1dDQ1LTE5cTI2IDAgNDUgMTlsNTEyIDUxMnExOSAxOSAxOSA0NXoiLz48L3N2Zz4=");
}

.svg-step-backward button,
button.svg-step-backward {
  background-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzNTg0IiBoZWlnaHQ9IjM1ODQiIHZpZXdCb3g9IjAgMCAzNTg0IDM1ODQiPjxwYXRoIGQ9Ik0yNjg4IDIwNDhxMCAxNjYtMTI3IDQ1MS0zIDctMTAuNSAyNHQtMTMuNSAzMHEtNiAxMy0xMyAyMi0xMiAxNy0yOCAxNy0xNSAwLTIzLjUtMTB0LTguNS0yNXEwLTkgMi41LTI2LjV0Mi41LTIzLjVxNS02OCA1LTEyMyAwLTEwMS0xNy41LTE4MXQtNDguNS0xMzguNXEtMzEtNTguNS04MC0xMDF0LTEwNS41LTY5LjVxLTU2LjUtMjctMTMzLTQyLjV0LTE1NC0yMS41cS03Ny41LTYtMTc1LjUtNmgtMjI0djI1NnEwIDI2LTE5IDQ1dC00NSAxOXEtMjYgMC00NS0xOWwtNTEyLTUxMnEtMTktMTktMTktNDV0MTktNDVsNTEyLTUxMnExOS0xOSA0NS0xOXQ0NSAxOXExOSAxOSAxOSA0NXYyNTZoMjI0cTcxMyAwIDg3NSA0MDMgNTMgMTM0IDUzIDMzM3oiLz48L3N2Zz4=");
}

.svg-pause button,
button.svg-pause {
  background-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzNTg0IiBoZWlnaHQ9IjM1ODQiIHZpZXdCb3g9IjAgMCAzNTg0IDM1ODQiPjxwYXRoIGQ9Ik0yNTYwIDEwODh2MTQwOHEwIDI2LTE5IDQ1dC00NSAxOWgtNTEycS0yNiAwLTQ1LTE5dC0xOS00NVYxMDg4cTAtMjYgMTktNDV0NDUtMTloNTEycTI2IDAgNDUgMTl0MTkgNDV6bS04OTYgMHYxNDA4cTAgMjYtMTkgNDV0LTQ1IDE5aC01MTJxLTI2IDAtNDUtMTl0LTE5LTQ1VjEwODhxMC0yNiAxOS00NXQ0NS0xOWg1MTJxMjYgMCA0NSAxOXQxOSA0NXoiLz48L3N2Zz4=");
}

.svg-play button,
button.svg-play {
  background-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzNTg0IiBoZWlnaHQ9IjM1ODQiIHZpZXdCb3g9IjAgMCAzNTg0IDM1ODQiPjxwYXRoIGQ9Ik0yNDcyLjUgMTgyM2wtMTMyOCA3MzhxLTIzIDEzLTM5LjUgM3QtMTYuNS0zNlYxMDU2cTAtMjYgMTYuNS0zNnQzOS41IDNsMTMyOCA3MzhxMjMgMTMgMjMgMzF0LTIzIDMxeiIvPjwvc3ZnPg==");
}

.svg-enter-fullscreen button,
button.svg-enter-fullscreen {
  background-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjgiIHZpZXdCb3g9IjAgMCAyOCAyOCIgd2lkdGg9IjI4Ij48cGF0aCBkPSJNMiAyaDI0djI0SDJ6IiBmaWxsPSJub25lIi8+PHBhdGggZD0iTTkgMTZIN3Y1aDV2LTJIOXYtM3ptLTItNGgyVjloM1Y3SDd2NXptMTIgN2gtM3YyaDV2LTVoLTJ2M3pNMTYgN3YyaDN2M2gyVjdoLTV6Ii8+PC9zdmc+");
}

.svg-exit-fullscreen button,
button.svg-exit-fullscreen {
  background-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjgiIHZpZXdCb3g9IjAgMCAyOCAyOCIgd2lkdGg9IjI4Ij48cGF0aCBkPSJNMiAyaDI0djI0SDJ6IiBmaWxsPSJub25lIi8+PHBhdGggZD0iTTcgMThoM3YzaDJ2LTVIN3Yyem0zLThIN3YyaDVWN2gtMnYzem02IDExaDJ2LTNoM3YtMmgtNXY1em0yLTExVjdoLTJ2NWg1di0yaC0zeiIvPjwvc3ZnPg==");
}

.svg-twizzle-tw button,
button.svg-twizzle-tw {
  background-image: url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODY0IiBoZWlnaHQ9IjYwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMzk3LjU4MSAxNTEuMTh2NTcuMDg0aC04OS43MDN2MjQwLjM1MmgtNjYuOTU1VjIwOC4yNjRIMTUxLjIydi01Ny4wODNoMjQ2LjM2MXptNTQuMzEgNzEuNjc3bDcuNTEyIDMzLjY5MmMyLjcxOCAxMi4xNiA1LjU4IDI0LjY4IDguNTg0IDM3LjU1NWEyMTgwLjc3NSAyMTgwLjc3NSAwIDAwOS40NDIgMzguODQzIDEyNjYuMyAxMjY2LjMgMCAwMDEwLjA4NiAzNy41NTVjMy43Mi0xMi41OSA3LjM2OC0yNS40NjYgMTAuOTQ1LTM4LjYyOCAzLjU3Ni0xMy4xNjIgNy4wMS0yNi4xMSAxMC4zLTM4Ljg0M2w1Ljc2OS0yMi40NTZjMS4yNDgtNC44ODcgMi40NzItOS43MDUgMy42NzQtMTQuNDU1IDMuMDA0LTExLjg3NSA1LjY1MS0yMi45NjIgNy45NC0zMy4yNjNoNDYuMzU0bDIuMzg0IDEwLjU2M2EyMDAwLjc3IDIwMDAuNzcgMCAwMDMuOTM1IDE2LjgyOGw2LjcxMSAyNy43MWMxLjIxMyA0Ljk1NiAyLjQ1IDkuOTggMy43MDkgMTUuMDczYTMxMTkuNzc3IDMxMTkuNzc3IDAgMDA5Ljg3MSAzOC44NDMgMTI0OS4yMjcgMTI0OS4yMjcgMCAwMDEwLjczIDM4LjYyOCAxOTA3LjYwNSAxOTA3LjYwNSAwIDAwMTAuMzAxLTM3LjU1NSAxMzk3Ljk0IDEzOTcuOTQgMCAwMDkuNjU3LTM4Ljg0M2w0LjQtMTkuMDQ2Yy43MTUtMy4xMyAxLjQyMS02LjIzNiAyLjExOC05LjMyMWw5LjU3Ny00Mi44OGg2Ni41MjZhMjk4OC43MTggMjk4OC43MTggMCAwMS0xOS41MjkgNjYuMzExbC01LjcyOCAxOC40ODJhMzIzNy40NiAzMjM3LjQ2IDAgMDEtMTQuMDE1IDQzLjc1MmMtNi40MzggMTkuNi0xMi43MzMgMzcuNjk4LTE4Ljg4NSA1NC4yOTRsLTMuMzA2IDguODI1Yy00Ljg4NCAxMi44OTgtOS40MzMgMjQuMjYzLTEzLjY0NyAzNC4wOTVoLTQ5Ljc4N2E4NDE3LjI4OSA4NDE3LjI4OSAwIDAxLTIxLjAzMS02NC44MDkgMTI4OC42ODYgMTI4OC42ODYgMCAwMS0xOC44ODUtNjQuODEgMTk3Mi40NDQgMTk3Mi40NDQgMCAwMS0xOC4yNCA2NC44MSAyNTc5LjQxMiAyNTc5LjQxMiAwIDAxLTIwLjM4OCA2NC44MWgtNDkuNzg3Yy00LjY4Mi0xMC45MjYtOS43Mi0yMy43NDMtMTUuMTEtMzguNDUxbC0xLjYyOS00LjQ3Yy01LjI1OC0xNC41MjEtMTAuNjgtMzAuMTkyLTE2LjI2Ni00Ny4wMTRsLTIuNDA0LTcuMjhjLTYuNDM4LTE5LjYtMTMuMDItNDAuMzQ0LTE5Ljc0My02Mi4yMzRhMjk4OC43MDcgMjk4OC43MDcgMCAwMS0xOS41MjktNjYuMzExaDY3LjM4NXoiIGZpbGw9IiM0Mjg1RjQiIGZpbGwtcnVsZT0ibm9uemVybyIvPjwvc3ZnPg==");
}
`);

// src/cubing/twisty/views/document.ts
var globalSafeDocument = typeof document === "undefined" ? null : document;

// src/cubing/twisty/views/control-panel/webkit-fullscreen.ts
var fullscreenEnabled = globalSafeDocument?.fullscreenEnabled || !!globalSafeDocument?.webkitFullscreenEnabled;
function documentExitFullscreen() {
  if (document.exitFullscreen) {
    return document.exitFullscreen();
  } else {
    return document.webkitExitFullscreen();
  }
}
function documentFullscreenElement() {
  if (document.fullscreenElement) {
    return document.fullscreenElement;
  } else {
    return document.webkitFullscreenElement ?? null;
  }
}
function requestFullscreen(element) {
  if (element.requestFullscreen) {
    return element.requestFullscreen();
  } else {
    return element.webkitRequestFullscreen();
  }
}

// src/cubing/twisty/model/props/viewer/ButtonAppearanceProp.ts
init_TwistyProp();
var buttonIcons = [
  "skip-to-start",
  "skip-to-end",
  "step-forward",
  "step-backward",
  "pause",
  "play",
  "enter-fullscreen",
  "exit-fullscreen",
  "twizzle-tw"
];
var ButtonAppearanceProp = class extends TwistyPropDerived {
  derive(inputs) {
    const buttonAppearances = {
      "fullscreen": {
        enabled: fullscreenEnabled,
        icon: document.fullscreenElement === null ? "enter-fullscreen" : "exit-fullscreen",
        title: "Enter fullscreen"
      },
      "jump-to-start": {
        enabled: !inputs.coarseTimelineInfo.atStart,
        icon: "skip-to-start",
        title: "Restart"
      },
      "play-step-backwards": {
        enabled: !inputs.coarseTimelineInfo.atStart,
        icon: "step-backward",
        title: "Step backward"
      },
      "play-pause": {
        enabled: !(inputs.coarseTimelineInfo.atStart && inputs.coarseTimelineInfo.atEnd),
        icon: inputs.coarseTimelineInfo.playing ? "pause" : "play",
        title: inputs.coarseTimelineInfo.playing ? "Pause" : "Play"
      },
      "play-step": {
        enabled: !inputs.coarseTimelineInfo.atEnd,
        icon: "step-forward",
        title: "Step forward"
      },
      "jump-to-end": {
        enabled: !inputs.coarseTimelineInfo.atEnd,
        icon: "skip-to-end",
        title: "Skip to End"
      },
      "twizzle-link": {
        enabled: true,
        icon: "twizzle-tw",
        title: "View at Twizzle",
        hidden: inputs.viewerLink === "none"
      }
    };
    return buttonAppearances;
  }
};

// src/cubing/twisty/views/control-panel/TwistyButtons.ts
var buttonCommands = {
  "fullscreen": true,
  "jump-to-start": true,
  "play-step-backwards": true,
  "play-pause": true,
  "play-step": true,
  "jump-to-end": true,
  "twizzle-link": true
};
var _onCommand, onCommand_fn;
var TwistyButtons = class extends ManagedCustomElement {
  constructor(model, controller, fullscreenElement) {
    super();
    this.model = model;
    this.controller = controller;
    this.fullscreenElement = fullscreenElement;
    __privateAdd(this, _onCommand);
    this.buttons = null;
  }
  connectedCallback() {
    this.addCSS(buttonGridCSS);
    const buttons = {};
    for (const command in buttonCommands) {
      const button = new TwistyButton();
      buttons[command] = button;
      button.addEventListener("click", () => __privateMethod(this, _onCommand, onCommand_fn).call(this, command));
      this.addElement(button);
    }
    this.buttons = buttons;
    this.model?.buttonAppearance.addFreshListener(this.update.bind(this));
  }
  async onFullscreenButton() {
    if (!this.fullscreenElement) {
      throw new Error("Attempted to go fullscreen without an element.");
    }
    if (documentFullscreenElement() === this.fullscreenElement) {
      documentExitFullscreen();
    } else {
      this.buttons?.fullscreen.setIcon("exit-fullscreen");
      requestFullscreen(this.fullscreenElement);
      const onFullscreen = () => {
        if (documentFullscreenElement() !== this.fullscreenElement) {
          this.buttons?.fullscreen.setIcon("enter-fullscreen");
          window.removeEventListener("fullscreenchange", onFullscreen);
        }
      };
      window.addEventListener("fullscreenchange", onFullscreen);
    }
  }
  async update(buttonAppearances) {
    for (const command in buttonCommands) {
      const button = this.buttons[command];
      const info = buttonAppearances[command];
      button.button.disabled = !info.enabled;
      button.button.title = info.title;
      button.setIcon(info.icon);
      button.hidden = !!info.hidden;
    }
  }
};
_onCommand = new WeakSet();
onCommand_fn = function(command) {
  switch (command) {
    case "fullscreen":
      this.onFullscreenButton();
      break;
    case "jump-to-start":
      this.controller?.jumpToStart({ flash: true });
      break;
    case "play-step-backwards":
      this.controller?.animationController.play({
        direction: -1 /* Backwards */,
        untilBoundary: "move" /* Move */
      });
      break;
    case "play-pause":
      this.controller?.togglePlay();
      break;
    case "play-step":
      this.controller?.animationController.play({
        direction: 1 /* Forwards */,
        untilBoundary: "move" /* Move */
      });
      break;
    case "jump-to-end":
      this.controller?.jumpToEnd({ flash: true });
      break;
    case "twizzle-link":
      this.controller?.visitTwizzleLink();
      break;
    default:
      throw new Error("Missing command");
  }
};
customElementsShim.define("twisty-buttons", TwistyButtons);
var _iconManager;
var TwistyButton = class extends ManagedCustomElement {
  constructor() {
    super(...arguments);
    this.button = document.createElement("button");
    __privateAdd(this, _iconManager, new ClassListManager(this, "svg-", buttonIcons));
  }
  connectedCallback() {
    this.addCSS(buttonCSS);
    this.addElement(this.button);
  }
  setIcon(iconName) {
    __privateGet(this, _iconManager).setValue(iconName);
  }
};
_iconManager = new WeakMap();
customElementsShim.define("twisty-button", TwistyButton);

// src/cubing/twisty/views/control-panel/TwistyScrubber.css.ts
var twistyScrubberCSS = new CSSSource(`
:host {
  width: 384px;
  height: 16px;
  display: grid;
}

.wrapper {
  width: 100%;
  height: 100%;
  display: grid;
  overflow: hidden;
  backdrop-filter: blur(4px);
  -webkit-backdrop-filter: blur(4px);
  background: rgba(196, 196, 196, 0.75)
}

input:not(:disabled) {
  cursor: ew-resize;
}
`);

// src/cubing/twisty/views/control-panel/TwistyScrubber.ts
var SLOW_DOWN_SCRUBBING = false;
var isMouseDown = false;
globalSafeDocument?.addEventListener("mousedown", function(event) {
  if (event.which) {
    isMouseDown = true;
  }
}, true);
globalSafeDocument?.addEventListener("mouseup", function(event) {
  if (event.which) {
    isMouseDown = false;
  }
}, true);
var y = 0;
var clickNum = 0;
globalSafeDocument?.addEventListener("mousedown", () => {
  clickNum++;
}, false);
globalSafeDocument?.addEventListener("mousemove", onMouseUpdate, false);
globalSafeDocument?.addEventListener("mouseenter", onMouseUpdate, false);
function onMouseUpdate(e) {
  y = e.pageY;
}
var lastVal = 0;
var lastPreval = 0;
var scaling = false;
var currentClickNum = 0;
var _inputElem;
var TwistyScrubber = class extends ManagedCustomElement {
  constructor(model) {
    super();
    this.model = model;
    __privateAdd(this, _inputElem, null);
  }
  async onDetailedTimelineInfo(detailedTimelineInfo) {
    const inputElem = await this.inputElem();
    inputElem.min = detailedTimelineInfo.timeRange.start.toString();
    inputElem.max = detailedTimelineInfo.timeRange.end.toString();
    inputElem.disabled = inputElem.min === inputElem.max;
    inputElem.value = detailedTimelineInfo.timestamp.toString();
  }
  async connectedCallback() {
    this.addCSS(twistyScrubberCSS);
    this.addElement(await this.inputElem());
  }
  async inputElem() {
    return __privateGet(this, _inputElem) ?? __privateSet(this, _inputElem, (async () => {
      const elem = document.createElement("input");
      elem.type = "range";
      elem.disabled = true;
      this.model?.detailedTimelineInfo.addFreshListener(this.onDetailedTimelineInfo.bind(this));
      elem.addEventListener("input", this.onInput.bind(this));
      return elem;
    })());
  }
  async onInput(e) {
    if (scaling) {
      return;
    }
    const inputElem = await this.inputElem();
    await this.slowDown(e, inputElem);
    const value = parseInt(inputElem.value);
    this.model?.playingInfo.set({ playing: false });
    this.model?.timestampRequest.set(value);
  }
  async slowDown(e, inputElem) {
    if (!SLOW_DOWN_SCRUBBING) {
      return;
    }
    if (isMouseDown) {
      const rect = inputElem.getBoundingClientRect();
      const sliderY = rect.top + rect.height / 2;
      console.log(sliderY, e, y, isMouseDown);
      const yDist = Math.abs(sliderY - y);
      let scale = 1;
      if (yDist > 64) {
        scale = Math.max(Math.pow(2, -(yDist - 64) / 64), 1 / 32);
      }
      const preVal = parseInt(inputElem.value);
      console.log("cl", currentClickNum, clickNum, preVal);
      if (currentClickNum === clickNum) {
        const delta = (preVal - lastPreval) * scale;
        console.log("delta", delta, yDist);
        scaling = true;
        let newVal = preVal;
        newVal = lastVal + delta * scale + (preVal - lastVal) * Math.min(1, Math.pow(1 / 2, yDist * yDist / 64));
        inputElem.value = newVal.toString();
        console.log(scale);
        scaling = false;
        this.contentWrapper.style.opacity = scale.toString();
      } else {
        currentClickNum = clickNum;
      }
      lastPreval = preVal;
    }
  }
};
_inputElem = new WeakMap();
customElementsShim.define("twisty-scrubber", TwistyScrubber);

// src/cubing/twisty/views/screenshot.ts
init_d();
var cachedCamera = null;
async function screenshot(model, options) {
  const width = options?.width ?? 2048;
  const height = options?.height ?? 2048;
  const aspectRatio = width / height;
  const camera = cachedCamera ?? (cachedCamera = await (async () => {
    return new (await THREEJS).OrthographicCamera(20, aspectRatio, 0.1, 20);
  })());
  const scene = new (await THREEJS).Scene();
  const twisty3DWrapper = new Twisty3DPuzzleWrapper(model, { scheduleRender: () => {
  } }, await model.puzzleLoader.get(), await model.visualizationStrategy.get());
  await model.twistySceneModel.stickering.get();
  await new Promise((resolve) => setTimeout(resolve, 1e3));
  await model.legacyPosition.get();
  scene.add(await twisty3DWrapper.twisty3DPuzzle());
  const orbitCoordinates = await model.twistySceneModel.orbitCoordinates.get();
  await setCameraFromOrbitCoordinates(camera, orbitCoordinates);
  const renderer = new (await THREEJS).WebGLRenderer({
    antialias: true,
    alpha: true
  });
  renderer.setSize(width, height);
  renderer.render(scene, camera);
  const dataURL = renderer.domElement.toDataURL();
  const defaultFilename = await getDefaultFilename(model);
  return {
    dataURL,
    download: async (filename) => {
      downloadURL(dataURL, filename ?? defaultFilename);
    }
  };
}
async function getDefaultFilename(model) {
  const [puzzleID, algWithIssues] = await Promise.all([
    model.puzzleID.get(),
    model.alg.get()
  ]);
  return `[${puzzleID}]${algWithIssues.alg.experimentalNumUnits() === 0 ? "" : " " + algWithIssues.alg.toString()}`;
}
function downloadURL(url, name, extension = "png") {
  const a = document.createElement("a");
  a.href = url;
  a.download = `${name}.${extension}`;
  a.click();
}

// src/cubing/twisty/views/TwistyPlayer.css.ts
var twistyPlayerCSS = new CSSSource(`
:host {
  width: 384px;
  height: 256px;
  display: grid;

  -webkit-user-select: none;
  user-select: none;
}

.wrapper {
  display: grid;
  overflow: hidden;
  grid-template-rows: 7fr minmax(1.5em, 0.5fr) minmax(2em, 1fr);
}

.wrapper > * {
  width: inherit;
  height: inherit;
  overflow: hidden;
}

.wrapper.controls-none {
  grid-template-rows: 7fr;
}

.wrapper.controls-none twisty-scrubber,
.wrapper.controls-none twisty-control-button-panel ,
.wrapper.controls-none twisty-scrubber,
.wrapper.controls-none twisty-buttons {
  display: none;
}

twisty-scrubber {
  background: rgba(196, 196, 196, 0.5);
}

.wrapper.checkered {
  background-color: #EAEAEA;
  background-image: linear-gradient(45deg, #DDD 25%, transparent 25%, transparent 75%, #DDD 75%, #DDD),
    linear-gradient(45deg, #DDD 25%, transparent 25%, transparent 75%, #DDD 75%, #DDD);
  background-size: 32px 32px;
  background-position: 0 0, 16px 16px;
}

.visualization-wrapper > * {
  width: 100%;
  height: 100%;
}

.error-elem {
  width: 100%;
  height: 100%;
  display: none;
  place-content: center;
  font-family: sans-serif;
  box-shadow: inset 0 0 2em rgb(255, 0, 0);
  color: red;
  text-shadow: 0 0 0.2em white;
  background: rgba(255, 255, 255, 0.25);
}

.wrapper.error .visualization-wrapper {
  display: none;
}

.wrapper.error .error-elem {
  display: grid;
}
`);

// src/cubing/twisty/model/TwistyPlayerModel.ts
init_alg();

// src/cubing/twisty/model/props/general/ArbitraryStringProp.ts
init_TwistyProp();
var ArbitraryStringProp = class extends SimpleTwistyPropSource {
  getDefaultValue() {
    return null;
  }
};

// src/cubing/twisty/model/props/general/URLProp.ts
init_TwistyProp();
var URLProp = class extends TwistyPropSource {
  getDefaultValue() {
    return null;
  }
  derive(input) {
    if (typeof input === "string") {
      return new URL(input, location.href);
    }
    return input;
  }
};

// src/cubing/twisty/model/props/puzzle/state/AlgProp.ts
init_alg();
init_TwistyProp();
var AlgIssues = class {
  constructor(issues) {
    this.warnings = Object.freeze(issues?.warnings ?? []);
    this.errors = Object.freeze(issues?.errors ?? []);
    Object.freeze(this);
  }
  add(issues) {
    return new AlgIssues({
      warnings: this.warnings.concat(issues?.warnings ?? []),
      errors: this.errors.concat(issues?.errors ?? [])
    });
  }
  log() {
    if (this.errors.length > 0) {
      console.error(`\u{1F6A8} ${this.errors[0]}`);
    } else if (this.warnings.length > 0) {
      console.warn(`\u26A0\uFE0F ${this.warnings[0]}`);
    } else {
      console.info("\u{1F60E} No issues!");
    }
  }
};
function algWithIssuesFromString(s) {
  try {
    const alg = Alg.fromString(s);
    const warnings = [];
    if (alg.toString() !== s) {
      warnings.push(`Alg is non-canonical!`);
    }
    return {
      alg,
      issues: new AlgIssues({ warnings })
    };
  } catch (e) {
    return {
      alg: new Alg(),
      issues: new AlgIssues({
        errors: [`Malformed alg: ${e.toString()}`]
      })
    };
  }
}
function algWithIssuesEquals(a1, a2) {
  return a1.alg.isIdentical(a2.alg) && arrayEquals(a1.issues.warnings, a2.issues.warnings) && arrayEquals(a1.issues.errors, a2.issues.errors);
}
var AlgProp = class extends TwistyPropSource {
  getDefaultValue() {
    return { alg: new Alg(), issues: new AlgIssues() };
  }
  canReuseValue(v1, v2) {
    return algWithIssuesEquals(v1, v2);
  }
  async derive(newAlg) {
    if (typeof newAlg === "string") {
      return algWithIssuesFromString(newAlg);
    } else {
      return {
        alg: newAlg,
        issues: new AlgIssues()
      };
    }
  }
};

// src/cubing/twisty/model/props/puzzle/state/AlgTransformationProp.ts
init_TwistyProp();
var AlgTransformationProp = class extends TwistyPropDerived {
  derive(input) {
    return input.kpuzzle.algToTransformation(input.setupAlg.alg);
  }
};

// src/cubing/twisty/model/props/puzzle/state/AnchorTransformationProp.ts
init_TwistyProp();
var AnchorTransformationProp = class extends TwistyPropDerived {
  derive(inputs) {
    if (inputs.setupTransformation) {
      return inputs.setupTransformation;
    }
    switch (inputs.setupAnchor) {
      case "start":
        return inputs.setupAlgTransformation;
      case "end": {
        const algTransformation = inputs.indexer.transformationAtIndex(inputs.indexer.numAnimatedLeaves());
        const inverseAlgTransformation = algTransformation.invert();
        return inputs.setupAlgTransformation.applyTransformation(inverseAlgTransformation);
      }
      default:
        throw new Error("Unimplemented!");
    }
  }
};

// src/cubing/twisty/model/props/puzzle/state/CatchUpMoveProp.ts
init_TwistyProp();
var CatchUpMoveProp = class extends SimpleTwistyPropSource {
  getDefaultValue() {
    return { move: null, amount: 0 };
  }
  canReuseValue(v1, v2) {
    return v1.move === v2.move && v1.amount === v2.amount;
  }
};

// src/cubing/twisty/model/props/puzzle/state/CurrentLeavesSimplified.ts
init_TwistyProp();
var CurrentLeavesSimplifiedProp = class extends TwistyPropDerived {
  derive(inputs) {
    return {
      stateIndex: inputs.currentMoveInfo.stateIndex,
      movesFinishing: inputs.currentMoveInfo.movesFinishing.map((currentMoveInfo) => currentMoveInfo.move),
      movesFinished: inputs.currentMoveInfo.movesFinished.map((currentMoveInfo) => currentMoveInfo.move)
    };
  }
  canReuse(v1, v2) {
    return v1.stateIndex === v2.stateIndex && arrayEqualsCompare(v1.movesFinishing, v2.movesFinishing, (m1, m2) => m1.isIdentical(m2)) && arrayEqualsCompare(v1.movesFinished, v2.movesFinished, (m1, m2) => m1.isIdentical(m2));
  }
};

// src/cubing/twisty/model/props/puzzle/state/CurrentMoveInfoProp.ts
init_alg();
init_TwistyProp();
var CurrentMoveInfoProp = class extends TwistyPropDerived {
  derive(inputs) {
    function addCatchUpMove(currentMoveInfo) {
      if (inputs.detailedTimelineInfo.atEnd && inputs.catchUpMove.move !== null) {
        currentMoveInfo.currentMoves.push({
          move: inputs.catchUpMove.move,
          direction: -1 /* Backwards */,
          fraction: 1 - inputs.catchUpMove.amount,
          startTimestamp: -1,
          endTimestamp: -1
        });
      }
      return currentMoveInfo;
    }
    if (inputs.indexer.currentMoveInfo) {
      return addCatchUpMove(inputs.indexer.currentMoveInfo(inputs.detailedTimelineInfo.timestamp));
    } else {
      const idx = inputs.indexer.timestampToIndex(inputs.detailedTimelineInfo.timestamp);
      const currentMoveInfo = {
        stateIndex: idx,
        currentMoves: [],
        movesFinishing: [],
        movesFinished: [],
        movesStarting: [],
        latestStart: -Infinity,
        earliestEnd: Infinity
      };
      if (inputs.indexer.numAnimatedLeaves() > 0) {
        const move = inputs.indexer.getAnimLeaf(idx)?.as(Move);
        if (!move) {
          return addCatchUpMove(currentMoveInfo);
        }
        const start = inputs.indexer.indexToMoveStartTimestamp(idx);
        const duration = inputs.indexer.moveDuration(idx);
        const fraction = (inputs.detailedTimelineInfo.timestamp - start) / duration;
        const end = start + duration;
        const currentMove = {
          move,
          direction: 1 /* Forwards */,
          fraction,
          startTimestamp: start,
          endTimestamp: end
        };
        if (fraction === 0) {
          currentMoveInfo.movesStarting.push(currentMove);
        } else if (fraction === 1) {
          currentMoveInfo.movesFinishing.push(currentMove);
        } else {
          currentMoveInfo.currentMoves.push(currentMove);
          currentMoveInfo.latestStart = Math.max(currentMoveInfo.latestStart, start);
          currentMoveInfo.earliestEnd = Math.min(currentMoveInfo.earliestEnd, end);
        }
      }
      return addCatchUpMove(currentMoveInfo);
    }
  }
};

// src/cubing/twisty/model/props/puzzle/state/CurrentStateProp.ts
init_TwistyProp();
var CurrentStateProp = class extends TwistyPropDerived {
  derive(inputs) {
    let transformation = inputs.indexer.transformationAtIndex(inputs.currentLeavesSimplified.stateIndex);
    transformation = inputs.anchoredStart.applyTransformation(transformation);
    for (const finishingMove of inputs.currentLeavesSimplified.movesFinishing) {
      transformation = transformation.applyMove(finishingMove);
    }
    for (const finishedMove of inputs.currentLeavesSimplified.movesFinished) {
      transformation = transformation.applyMove(finishedMove);
    }
    return transformation.toKState();
  }
};

// src/cubing/notation/CountMoves.ts
init_alg();
var CountMoves = class extends TraversalUp {
  constructor(metric) {
    super();
    this.metric = metric;
  }
  traverseAlg(alg) {
    let r3 = 0;
    for (const unit of alg.units()) {
      r3 += this.traverseUnit(unit);
    }
    return r3;
  }
  traverseGrouping(grouping) {
    const alg = grouping.alg;
    return this.traverseAlg(alg) * Math.abs(grouping.amount);
  }
  traverseMove(move) {
    return this.metric(move);
  }
  traverseCommutator(commutator) {
    return 2 * (this.traverseAlg(commutator.A) + this.traverseAlg(commutator.B));
  }
  traverseConjugate(conjugate) {
    return 2 * this.traverseAlg(conjugate.A) + this.traverseAlg(conjugate.B);
  }
  traversePause(_pause) {
    return 0;
  }
  traverseNewline(_newLine) {
    return 0;
  }
  traverseLineComment(_comment) {
    return 0;
  }
};
function isCharUppercase(c) {
  return "A" <= c && c <= "Z";
}
function baseMetric(move) {
  const fam = move.family;
  if (isCharUppercase(fam[0]) && fam[fam.length - 1] === "v" || fam === "x" || fam === "y" || fam === "z" || fam === "T") {
    return 0;
  } else {
    return 1;
  }
}
function quantumMetric(move) {
  const fam = move.family;
  if (isCharUppercase(fam[0]) && fam[fam.length - 1] === "v" || fam === "x" || fam === "y" || fam === "z" || fam === "T") {
    return 0;
  } else {
    return Math.abs(move.amount);
  }
}
var countMovesInstance = new CountMoves(baseMetric);
var countMoves = countMovesInstance.traverseAlg.bind(countMovesInstance);
var countQuantumMovesInstance = new CountMoves(quantumMetric);
var countQuantumMoves = countQuantumMovesInstance.traverseAlg.bind(countQuantumMovesInstance);

// src/cubing/notation/CountAnimatedLeaves.ts
init_alg();
var CountAnimatedLeaves = class extends TraversalUp {
  traverseAlg(alg) {
    let total = 0;
    for (const part of alg.units()) {
      total += this.traverseUnit(part);
    }
    return total;
  }
  traverseGrouping(grouping) {
    return this.traverseAlg(grouping.alg) * Math.abs(grouping.amount);
  }
  traverseMove(_move) {
    return 1;
  }
  traverseCommutator(commutator) {
    return 2 * (this.traverseAlg(commutator.A) + this.traverseAlg(commutator.B));
  }
  traverseConjugate(conjugate) {
    return 2 * this.traverseAlg(conjugate.A) + this.traverseAlg(conjugate.B);
  }
  traversePause(_pause) {
    return 1;
  }
  traverseNewline(_newline) {
    return 0;
  }
  traverseLineComment(_comment) {
    return 0;
  }
};
var countAnimatedLeavesInstance = new CountAnimatedLeaves();
var countAnimatedLeaves = countAnimatedLeavesInstance.traverseAlg.bind(countAnimatedLeavesInstance);

// src/cubing/twisty/controllers/indexer/SimpleAlgIndexer.ts
init_alg();

// src/cubing/twisty/controllers/indexer/AlgDuration.ts
init_alg();
function defaultDurationForAmount(amount) {
  switch (Math.abs(amount)) {
    case 0:
      return 0;
    case 1:
      return 1e3;
    case 2:
      return 1500;
    default:
      return 2e3;
  }
}
var AlgDuration = class extends TraversalUp {
  constructor(durationForAmount = defaultDurationForAmount) {
    super();
    this.durationForAmount = durationForAmount;
  }
  traverseAlg(alg) {
    let total = 0;
    for (const unit of alg.units()) {
      total += this.traverseUnit(unit);
    }
    return total;
  }
  traverseGrouping(grouping) {
    return grouping.amount * this.traverseAlg(grouping.alg);
  }
  traverseMove(move) {
    return this.durationForAmount(move.amount);
  }
  traverseCommutator(commutator) {
    return 2 * (this.traverseAlg(commutator.A) + this.traverseAlg(commutator.B));
  }
  traverseConjugate(conjugate) {
    return 2 * this.traverseAlg(conjugate.A) + this.traverseAlg(conjugate.B);
  }
  traversePause(_pause) {
    return this.durationForAmount(1);
  }
  traverseNewline(_newline) {
    return this.durationForAmount(1);
  }
  traverseLineComment(_comment) {
    return this.durationForAmount(0);
  }
};

// src/cubing/twisty/controllers/indexer/SimpleAlgIndexer.ts
var SimpleAlgIndexer = class {
  constructor(kpuzzle, alg) {
    this.kpuzzle = kpuzzle;
    this.durationFn = new AlgDuration(defaultDurationForAmount);
    this.moves = new Alg(alg.experimentalExpand());
  }
  getAnimLeaf(index) {
    return Array.from(this.moves.units())[index];
  }
  indexToMoveStartTimestamp(index) {
    const alg = new Alg(Array.from(this.moves.units()).slice(0, index));
    return this.durationFn.traverseAlg(alg);
  }
  timestampToIndex(timestamp) {
    let cumulativeTime = 0;
    let i2;
    for (i2 = 0; i2 < this.numAnimatedLeaves(); i2++) {
      cumulativeTime += this.durationFn.traverseMove(this.getAnimLeaf(i2));
      if (cumulativeTime >= timestamp) {
        return i2;
      }
    }
    return i2;
  }
  stateAtIndex(index) {
    return this.kpuzzle.startState().applyTransformation(this.transformationAtIndex(index));
  }
  transformationAtIndex(index) {
    let state = this.kpuzzle.identityTransformation();
    for (const move of Array.from(this.moves.units()).slice(0, index)) {
      state = state.applyMove(move);
    }
    return state;
  }
  algDuration() {
    return this.durationFn.traverseAlg(this.moves);
  }
  numAnimatedLeaves() {
    return countAnimatedLeaves(this.moves);
  }
  moveDuration(index) {
    return this.durationFn.traverseMove(this.getAnimLeaf(index));
  }
};

// src/cubing/twisty/controllers/indexer/simultaneous-moves/SimultaneousMoveIndexer.ts
init_alg();

// src/cubing/twisty/controllers/indexer/simultaneous-moves/simul-moves.ts
init_alg();
var axisLookup = {
  u: "y",
  l: "x",
  f: "z",
  r: "x",
  b: "z",
  d: "y",
  m: "x",
  e: "y",
  s: "z",
  x: "x",
  y: "y",
  z: "z"
};
function isSameAxis(move1, move2) {
  return axisLookup[move1.family[0].toLowerCase()] === axisLookup[move2.family[0].toLowerCase()];
}
var LocalSimulMoves = class extends TraversalUp {
  traverseAlg(alg) {
    const processed = [];
    for (const nestedUnit of alg.units()) {
      processed.push(this.traverseUnit(nestedUnit));
    }
    return Array.prototype.concat(...processed);
  }
  traverseGroupingOnce(alg) {
    if (alg.experimentalIsEmpty()) {
      return [];
    }
    for (const unit of alg.units()) {
      if (!unit.is(Move)) {
        return this.traverseAlg(alg);
      }
    }
    const moves = Array.from(alg.units());
    let maxSimulDur = defaultDurationForAmount(moves[0].amount);
    for (let i2 = 0; i2 < moves.length - 1; i2++) {
      for (let j = 1; j < moves.length; j++) {
        if (!isSameAxis(moves[i2], moves[j])) {
          return this.traverseAlg(alg);
        }
      }
      maxSimulDur = Math.max(maxSimulDur, defaultDurationForAmount(moves[i2].amount));
    }
    const localMovesWithRange = moves.map((blockMove) => {
      return {
        animLeafUnit: blockMove,
        msUntilNext: 0,
        duration: maxSimulDur
      };
    });
    localMovesWithRange[localMovesWithRange.length - 1].msUntilNext = maxSimulDur;
    return localMovesWithRange;
  }
  traverseGrouping(grouping) {
    const processed = [];
    const segmentOnce = grouping.amount > 0 ? grouping.alg : grouping.alg.invert();
    for (let i2 = 0; i2 < Math.abs(grouping.amount); i2++) {
      processed.push(this.traverseGroupingOnce(segmentOnce));
    }
    return Array.prototype.concat(...processed);
  }
  traverseMove(move) {
    const duration = defaultDurationForAmount(move.amount);
    return [
      {
        animLeafUnit: move,
        msUntilNext: duration,
        duration
      }
    ];
  }
  traverseCommutator(commutator) {
    const processed = [];
    const segmentsOnce = [
      commutator.A,
      commutator.B,
      commutator.A.invert(),
      commutator.B.invert()
    ];
    for (const segment of segmentsOnce) {
      processed.push(this.traverseGroupingOnce(segment));
    }
    return Array.prototype.concat(...processed);
  }
  traverseConjugate(conjugate) {
    const processed = [];
    const segmentsOnce = [
      conjugate.A,
      conjugate.B,
      conjugate.A.invert()
    ];
    for (const segment of segmentsOnce) {
      processed.push(this.traverseGroupingOnce(segment));
    }
    return Array.prototype.concat(...processed);
  }
  traversePause(pause) {
    const duration = defaultDurationForAmount(1);
    return [
      {
        animLeafUnit: pause,
        msUntilNext: duration,
        duration
      }
    ];
  }
  traverseNewline(_newline) {
    return [];
  }
  traverseLineComment(_comment) {
    return [];
  }
};
var localSimulMovesInstance = new LocalSimulMoves();
var localSimulMoves = localSimulMovesInstance.traverseAlg.bind(localSimulMovesInstance);
function simulMoves(a) {
  let timestamp = 0;
  const l = localSimulMoves(a).map((localSimulMove) => {
    const leafWithRange = {
      animLeaf: localSimulMove.animLeafUnit,
      start: timestamp,
      end: timestamp + localSimulMove.duration
    };
    timestamp += localSimulMove.msUntilNext;
    return leafWithRange;
  });
  return l;
}

// src/cubing/twisty/controllers/indexer/simultaneous-moves/SimultaneousMoveIndexer.ts
var b = 2e3;
var demos = {
  "R M' L' y R M' L' y R M' L' U E' D": [
    { animLeaf: new Move("R"), start: b + 0, end: b + 1e3 },
    { animLeaf: new Move("M", -1), start: b + 250, end: b + 1200 },
    { animLeaf: new Move("L", -1), start: b + 400, end: b + 1400 },
    { animLeaf: new Move("y"), start: b + 600, end: b + 2e3 },
    { animLeaf: new Move("R"), start: b + 2e3 + 0, end: b + 2e3 + 1e3 },
    {
      animLeaf: new Move("M", -1),
      start: b + 2e3 + 250,
      end: b + 2e3 + 1200
    },
    {
      animLeaf: new Move("L", -1),
      start: b + 2e3 + 400,
      end: b + 2e3 + 1400
    },
    { animLeaf: new Move("y"), start: b + 2e3 + 600, end: b + 2e3 + 2e3 },
    { animLeaf: new Move("R"), start: b + 4e3 + 0, end: b + 4e3 + 1e3 },
    {
      animLeaf: new Move("M", -1),
      start: b + 4e3 + 250,
      end: b + 4e3 + 1200
    },
    {
      animLeaf: new Move("L", -1),
      start: b + 4e3 + 400,
      end: b + 4e3 + 1400
    },
    { animLeaf: new Move("U"), start: b + 5400, end: b + 6400 },
    { animLeaf: new Move("E'"), start: b + 5800, end: b + 6800 },
    { animLeaf: new Move("D'"), start: b + 6200, end: b + 7200 }
  ],
  "y' y' U' E D R2 r2 F2 B2 U E D' R2 L2' z2 S2 U U D D S2 F2' B2": [
    { animLeaf: new Move("y", -1), start: 0, end: 1e3 },
    { animLeaf: new Move("y", -1), start: 1e3, end: 2e3 },
    { animLeaf: new Move("U", -1), start: 1e3, end: 1600 },
    { animLeaf: new Move("E"), start: 1200, end: 1800 },
    { animLeaf: new Move("D"), start: 1400, end: 2e3 },
    { animLeaf: new Move("R", 2), start: 2e3, end: 3500 },
    { animLeaf: new Move("r", 2), start: 2e3, end: 3500 },
    { animLeaf: new Move("F", 2), start: 3500, end: 4200 },
    { animLeaf: new Move("B", 2), start: 3800, end: 4500 },
    { animLeaf: new Move("U"), start: 4500, end: 5500 },
    { animLeaf: new Move("E"), start: 4500, end: 5500 },
    { animLeaf: new Move("D", -1), start: 4500, end: 5500 },
    { animLeaf: new Move("R", 2), start: 5500, end: 6500 },
    { animLeaf: new Move("L", -2), start: 5500, end: 6500 },
    { animLeaf: new Move("z", 2), start: 5500, end: 6500 },
    { animLeaf: new Move("S", 2), start: 6500, end: 7500 },
    { animLeaf: new Move("U"), start: 7500, end: 8e3 },
    { animLeaf: new Move("D"), start: 7750, end: 8250 },
    { animLeaf: new Move("U"), start: 8e3, end: 8500 },
    { animLeaf: new Move("D"), start: 8250, end: 8750 },
    { animLeaf: new Move("S", 2), start: 8750, end: 9250 },
    { animLeaf: new Move("F", -2), start: 8750, end: 1e4 },
    { animLeaf: new Move("B", 2), start: 8750, end: 1e4 }
  ],
  "M' R' U' D' M R": [
    { animLeaf: new Move("M", -1), start: 0, end: 1e3 },
    { animLeaf: new Move("R", -1), start: 0, end: 1e3 },
    { animLeaf: new Move("U", -1), start: 1e3, end: 2e3 },
    { animLeaf: new Move("D", -1), start: 1e3, end: 2e3 },
    { animLeaf: new Move("M"), start: 2e3, end: 3e3 },
    { animLeaf: new Move("R"), start: 2e3, end: 3e3 }
  ],
  "U' E' r E r2' E r U E": [
    { animLeaf: new Move("U", -1), start: 0, end: 1e3 },
    { animLeaf: new Move("E'"), start: 0, end: 1e3 },
    { animLeaf: new Move("r"), start: 1e3, end: 2500 },
    { animLeaf: new Move("E"), start: 2500, end: 3500 },
    { animLeaf: new Move("r", -2), start: 3500, end: 5e3 },
    { animLeaf: new Move("E"), start: 5e3, end: 6e3 },
    { animLeaf: new Move("r"), start: 6e3, end: 7e3 },
    { animLeaf: new Move("U"), start: 7e3, end: 8e3 },
    { animLeaf: new Move("E"), start: 7e3, end: 8e3 }
  ]
};
var SimultaneousMoveIndexer = class {
  constructor(kpuzzle, alg) {
    this.kpuzzle = kpuzzle;
    this.animLeaves = demos[alg.toString()] ?? simulMoves(alg);
  }
  getAnimLeaf(index) {
    return this.animLeaves[Math.min(index, this.animLeaves.length - 1)]?.animLeaf ?? null;
  }
  getAnimLeafWithRange(index) {
    return this.animLeaves[Math.min(index, this.animLeaves.length - 1)];
  }
  indexToMoveStartTimestamp(index) {
    let start = 0;
    if (this.animLeaves.length > 0) {
      start = this.animLeaves[Math.min(index, this.animLeaves.length - 1)].start;
    }
    return start;
  }
  timestampToIndex(timestamp) {
    let i2 = 0;
    for (i2 = 0; i2 < this.animLeaves.length; i2++) {
      if (this.animLeaves[i2].start >= timestamp) {
        return Math.max(0, i2 - 1);
      }
    }
    return Math.max(0, i2 - 1);
  }
  timestampToPosition(timestamp, startState) {
    const currentMoveInfo = this.currentMoveInfo(timestamp);
    let state = startState ?? this.kpuzzle.identityTransformation().toKState();
    for (const leafWithRange of this.animLeaves.slice(0, currentMoveInfo.stateIndex)) {
      const move = leafWithRange.animLeaf.as(Move);
      if (move !== null) {
        state = state.applyMove(move);
      }
    }
    return {
      state,
      movesInProgress: currentMoveInfo.currentMoves
    };
  }
  currentMoveInfo(timestamp) {
    let windowEarliestTimestamp = Infinity;
    for (const leafWithRange of this.animLeaves) {
      if (leafWithRange.start <= timestamp && leafWithRange.end >= timestamp) {
        windowEarliestTimestamp = Math.min(windowEarliestTimestamp, leafWithRange.start);
      } else if (leafWithRange.start > timestamp) {
        break;
      }
    }
    const currentMoves = [];
    const movesStarting = [];
    const movesFinishing = [];
    const movesFinished = [];
    let latestStart = -Infinity;
    let earliestEnd = Infinity;
    let stateIndex = 0;
    for (const leafWithRange of this.animLeaves) {
      if (leafWithRange.end <= windowEarliestTimestamp) {
        stateIndex++;
      } else if (leafWithRange.start > timestamp) {
        break;
      } else {
        const move = leafWithRange.animLeaf.as(Move);
        if (move !== null) {
          let fraction = (timestamp - leafWithRange.start) / (leafWithRange.end - leafWithRange.start);
          let moveFinished = false;
          if (fraction > 1) {
            fraction = 1;
            moveFinished = true;
          }
          const currentMove = {
            move,
            direction: 1 /* Forwards */,
            fraction,
            startTimestamp: leafWithRange.start,
            endTimestamp: leafWithRange.end
          };
          switch (fraction) {
            case 0:
              movesStarting.push(currentMove);
              break;
            case 1:
              if (moveFinished) {
                movesFinished.push(currentMove);
              } else {
                movesFinishing.push(currentMove);
              }
              break;
            default:
              currentMoves.push(currentMove);
              latestStart = Math.max(latestStart, leafWithRange.start);
              earliestEnd = Math.min(earliestEnd, leafWithRange.end);
          }
        }
      }
    }
    return {
      stateIndex,
      currentMoves,
      latestStart,
      earliestEnd,
      movesStarting,
      movesFinishing,
      movesFinished
    };
  }
  stateAtIndex(index, startState) {
    let state = startState ?? this.kpuzzle.startState();
    for (let i2 = 0; i2 < this.animLeaves.length && i2 < index; i2++) {
      const leafWithRange = this.animLeaves[i2];
      const move = leafWithRange.animLeaf.as(Move);
      if (move !== null) {
        state = state.applyMove(move);
      }
    }
    return state;
  }
  transformationAtIndex(index) {
    let transformation = this.kpuzzle.identityTransformation();
    for (const leafWithRange of this.animLeaves.slice(0, index)) {
      const move = leafWithRange.animLeaf.as(Move);
      if (move !== null) {
        transformation = transformation.applyMove(move);
      }
    }
    return transformation;
  }
  algDuration() {
    let max = 0;
    for (const leafWithRange of this.animLeaves) {
      max = Math.max(max, leafWithRange.end);
    }
    return max;
  }
  numAnimatedLeaves() {
    return this.animLeaves.length;
  }
  moveDuration(index) {
    const move = this.getAnimLeafWithRange(index);
    return move.end - move.start;
  }
};

// src/cubing/twisty/controllers/indexer/tree/AlgWalker.ts
init_alg();
var AlgPartDecoration = class {
  constructor(moveCount, duration, forward, backward, children = []) {
    this.moveCount = moveCount;
    this.duration = duration;
    this.forward = forward;
    this.backward = backward;
    this.children = children;
  }
};
var DecoratorConstructor = class extends TraversalUp {
  constructor(kpuzzle) {
    super();
    this.kpuzzle = kpuzzle;
    this.durationFn = new AlgDuration(defaultDurationForAmount);
    this.cache = {};
    this.identity = kpuzzle.identityTransformation();
    this.dummyLeaf = new AlgPartDecoration(0, 0, this.identity, this.identity, []);
  }
  traverseAlg(alg) {
    let moveCount = 0;
    let duration = 0;
    let transformation = this.identity;
    const child = [];
    for (const unit of alg.units()) {
      const apd = this.traverseUnit(unit);
      moveCount += apd.moveCount;
      duration += apd.duration;
      if (transformation === this.identity) {
        transformation = apd.forward;
      } else {
        transformation = transformation.applyTransformation(apd.forward);
      }
      child.push(apd);
    }
    return new AlgPartDecoration(moveCount, duration, transformation, transformation.invert(), child);
  }
  traverseGrouping(grouping) {
    const dec = this.traverseAlg(grouping.alg);
    return this.mult(dec, grouping.amount, [dec]);
  }
  traverseMove(move) {
    const key = move.toString();
    let r3 = this.cache[key];
    if (r3) {
      return r3;
    }
    const transformation = this.kpuzzle.moveToTransformation(move);
    r3 = new AlgPartDecoration(1, this.durationFn.traverseUnit(move), transformation, transformation.invert());
    this.cache[key] = r3;
    return r3;
  }
  traverseCommutator(commutator) {
    const decA = this.traverseAlg(commutator.A);
    const decB = this.traverseAlg(commutator.B);
    const AB = decA.forward.applyTransformation(decB.forward);
    const ApBp = decA.backward.applyTransformation(decB.backward);
    const ABApBp = AB.applyTransformation(ApBp);
    const dec = new AlgPartDecoration(2 * (decA.moveCount + decB.moveCount), 2 * (decA.duration + decB.duration), ABApBp, ABApBp.invert(), [decA, decB]);
    return this.mult(dec, 1, [dec, decA, decB]);
  }
  traverseConjugate(conjugate) {
    const decA = this.traverseAlg(conjugate.A);
    const decB = this.traverseAlg(conjugate.B);
    const AB = decA.forward.applyTransformation(decB.forward);
    const ABAp = AB.applyTransformation(decA.backward);
    const dec = new AlgPartDecoration(2 * decA.moveCount + decB.moveCount, 2 * decA.duration + decB.duration, ABAp, ABAp.invert(), [decA, decB]);
    return this.mult(dec, 1, [dec, decA, decB]);
  }
  traversePause(pause) {
    return new AlgPartDecoration(1, this.durationFn.traverseUnit(pause), this.identity, this.identity);
  }
  traverseNewline(_newline) {
    return this.dummyLeaf;
  }
  traverseLineComment(_comment) {
    return this.dummyLeaf;
  }
  mult(apd, n, child) {
    const absn = Math.abs(n);
    const st = apd.forward.selfMultiply(n);
    return new AlgPartDecoration(apd.moveCount * absn, apd.duration * absn, st, st.invert(), child);
  }
};
var WalkerDown = class {
  constructor(apd, back) {
    this.apd = apd;
    this.back = back;
  }
};
var AlgWalker = class extends TraversalDownUp {
  constructor(kpuzzle, algOrUnit, apd) {
    super();
    this.kpuzzle = kpuzzle;
    this.algOrUnit = algOrUnit;
    this.apd = apd;
    this.i = -1;
    this.dur = -1;
    this.goali = -1;
    this.goaldur = -1;
    this.move = void 0;
    this.back = false;
    this.moveDuration = 0;
    this.st = this.kpuzzle.identityTransformation();
    this.root = new WalkerDown(this.apd, false);
  }
  moveByIndex(loc) {
    if (this.i >= 0 && this.i === loc) {
      return this.move !== void 0;
    }
    return this.dosearch(loc, Infinity);
  }
  moveByDuration(dur) {
    if (this.dur >= 0 && this.dur < dur && this.dur + this.moveDuration >= dur) {
      return this.move !== void 0;
    }
    return this.dosearch(Infinity, dur);
  }
  dosearch(loc, dur) {
    this.goali = loc;
    this.goaldur = dur;
    this.i = 0;
    this.dur = 0;
    this.move = void 0;
    this.moveDuration = 0;
    this.back = false;
    this.st = this.kpuzzle.identityTransformation();
    const r3 = this.algOrUnit.is(Alg) ? this.traverseAlg(this.algOrUnit, this.root) : this.traverseUnit(this.algOrUnit, this.root);
    return r3;
  }
  traverseAlg(alg, wd) {
    if (!this.firstcheck(wd)) {
      return false;
    }
    let i2 = wd.back ? alg.experimentalNumUnits() - 1 : 0;
    for (const unit of directedGenerator(alg.units(), wd.back ? -1 /* Backwards */ : 1 /* Forwards */)) {
      if (this.traverseUnit(unit, new WalkerDown(wd.apd.children[i2], wd.back))) {
        return true;
      }
      i2 += wd.back ? -1 : 1;
    }
    return false;
  }
  traverseGrouping(grouping, wd) {
    if (!this.firstcheck(wd)) {
      return false;
    }
    const back = this.domult(wd, grouping.amount);
    return this.traverseAlg(grouping.alg, new WalkerDown(wd.apd.children[0], back));
  }
  traverseMove(move, wd) {
    if (!this.firstcheck(wd)) {
      return false;
    }
    this.move = move;
    this.moveDuration = wd.apd.duration;
    this.back = wd.back;
    return true;
  }
  traverseCommutator(commutator, wd) {
    if (!this.firstcheck(wd)) {
      return false;
    }
    const back = this.domult(wd, 1);
    if (back) {
      return this.traverseAlg(commutator.B, new WalkerDown(wd.apd.children[2], !back)) || this.traverseAlg(commutator.A, new WalkerDown(wd.apd.children[1], !back)) || this.traverseAlg(commutator.B, new WalkerDown(wd.apd.children[2], back)) || this.traverseAlg(commutator.A, new WalkerDown(wd.apd.children[1], back));
    } else {
      return this.traverseAlg(commutator.A, new WalkerDown(wd.apd.children[1], back)) || this.traverseAlg(commutator.B, new WalkerDown(wd.apd.children[2], back)) || this.traverseAlg(commutator.A, new WalkerDown(wd.apd.children[1], !back)) || this.traverseAlg(commutator.B, new WalkerDown(wd.apd.children[2], !back));
    }
  }
  traverseConjugate(conjugate, wd) {
    if (!this.firstcheck(wd)) {
      return false;
    }
    const back = this.domult(wd, 1);
    if (back) {
      return this.traverseAlg(conjugate.A, new WalkerDown(wd.apd.children[1], !back)) || this.traverseAlg(conjugate.B, new WalkerDown(wd.apd.children[2], back)) || this.traverseAlg(conjugate.A, new WalkerDown(wd.apd.children[1], back));
    } else {
      return this.traverseAlg(conjugate.A, new WalkerDown(wd.apd.children[1], back)) || this.traverseAlg(conjugate.B, new WalkerDown(wd.apd.children[2], back)) || this.traverseAlg(conjugate.A, new WalkerDown(wd.apd.children[1], !back));
    }
  }
  traversePause(pause, wd) {
    if (!this.firstcheck(wd)) {
      return false;
    }
    this.move = pause;
    this.moveDuration = wd.apd.duration;
    this.back = wd.back;
    return true;
  }
  traverseNewline(_newline, _wd) {
    return false;
  }
  traverseLineComment(_lineComment, _wd) {
    return false;
  }
  firstcheck(wd) {
    if (wd.apd.moveCount + this.i <= this.goali && wd.apd.duration + this.dur < this.goaldur) {
      return this.keepgoing(wd);
    }
    return true;
  }
  domult(wd, amount) {
    let back = wd.back;
    if (amount === 0) {
      return back;
    }
    if (amount < 0) {
      back = !back;
      amount = -amount;
    }
    const base = wd.apd.children[0];
    const full = Math.min(Math.floor((this.goali - this.i) / base.moveCount), Math.ceil((this.goaldur - this.dur) / base.duration - 1));
    if (full > 0) {
      this.keepgoing(new WalkerDown(base, back), full);
    }
    return back;
  }
  keepgoing(wd, mul = 1) {
    this.i += mul * wd.apd.moveCount;
    this.dur += mul * wd.apd.duration;
    if (mul !== 1) {
      if (wd.back) {
        this.st = this.st.applyTransformation(wd.apd.backward.selfMultiply(mul));
      } else {
        this.st = this.st.applyTransformation(wd.apd.forward.selfMultiply(mul));
      }
    } else {
      if (wd.back) {
        this.st = this.st.applyTransformation(wd.apd.backward);
      } else {
        this.st = this.st.applyTransformation(wd.apd.forward);
      }
    }
    return false;
  }
};

// src/cubing/twisty/controllers/indexer/tree/chunkAlgs.ts
init_alg();
init_alg();
var MIN_CHUNKING_THRESHOLD = 16;
function chunkifyAlg(alg, chunkMaxLength) {
  const mainAlgBuilder = new AlgBuilder();
  const chunkAlgBuilder = new AlgBuilder();
  for (const unit of alg.units()) {
    chunkAlgBuilder.push(unit);
    if (chunkAlgBuilder.experimentalNumUnits() >= chunkMaxLength) {
      mainAlgBuilder.push(new Grouping(chunkAlgBuilder.toAlg()));
      chunkAlgBuilder.reset();
    }
  }
  mainAlgBuilder.push(new Grouping(chunkAlgBuilder.toAlg()));
  return mainAlgBuilder.toAlg();
}
var ChunkAlgs = class extends TraversalUp {
  traverseAlg(alg) {
    const algLength = alg.experimentalNumUnits();
    if (algLength < MIN_CHUNKING_THRESHOLD) {
      return alg;
    }
    return chunkifyAlg(alg, Math.ceil(Math.sqrt(algLength)));
  }
  traverseGrouping(grouping) {
    return new Grouping(this.traverseAlg(grouping.alg), grouping.amount);
  }
  traverseMove(move) {
    return move;
  }
  traverseCommutator(commutator) {
    return new Conjugate(this.traverseAlg(commutator.A), this.traverseAlg(commutator.B));
  }
  traverseConjugate(conjugate) {
    return new Conjugate(this.traverseAlg(conjugate.A), this.traverseAlg(conjugate.B));
  }
  traversePause(pause) {
    return pause;
  }
  traverseNewline(newline) {
    return newline;
  }
  traverseLineComment(comment) {
    return comment;
  }
};
var chunkAlgsInstance = new ChunkAlgs();
var chunkAlgs = chunkAlgsInstance.traverseAlg.bind(chunkAlgsInstance);

// src/cubing/twisty/controllers/indexer/tree/TreeAlgIndexer.ts
var TreeAlgIndexer = class {
  constructor(kpuzzle, alg) {
    this.kpuzzle = kpuzzle;
    const deccon = new DecoratorConstructor(this.kpuzzle);
    const chunkedAlg = chunkAlgs(alg);
    this.decoration = deccon.traverseAlg(chunkedAlg);
    this.walker = new AlgWalker(this.kpuzzle, chunkedAlg, this.decoration);
  }
  getAnimLeaf(index) {
    if (this.walker.moveByIndex(index)) {
      if (!this.walker.move) {
        throw new Error("`this.walker.mv` missing");
      }
      const move = this.walker.move;
      if (this.walker.back) {
        return move.invert();
      }
      return move;
    }
    return null;
  }
  indexToMoveStartTimestamp(index) {
    if (this.walker.moveByIndex(index) || this.walker.i === index) {
      return this.walker.dur;
    }
    throw new Error(`Out of algorithm: index ${index}`);
  }
  indexToMovesInProgress(index) {
    if (this.walker.moveByIndex(index) || this.walker.i === index) {
      return this.walker.dur;
    }
    throw new Error(`Out of algorithm: index ${index}`);
  }
  stateAtIndex(index, startState) {
    this.walker.moveByIndex(index);
    return (startState ?? this.kpuzzle.startState()).applyTransformation(this.walker.st);
  }
  transformationAtIndex(index) {
    this.walker.moveByIndex(index);
    return this.walker.st;
  }
  numAnimatedLeaves() {
    return this.decoration.moveCount;
  }
  timestampToIndex(timestamp) {
    this.walker.moveByDuration(timestamp);
    return this.walker.i;
  }
  algDuration() {
    return this.decoration.duration;
  }
  moveDuration(index) {
    this.walker.moveByIndex(index);
    return this.walker.moveDuration;
  }
};

// src/cubing/twisty/model/props/puzzle/state/IndexerConstructorProp.ts
init_TwistyProp();
var IndexerConstructorProp = class extends TwistyPropDerived {
  derive(inputs) {
    switch (inputs.indexerConstructorRequest) {
      case "auto":
        if (countMoves(inputs.alg.alg) < 100 && inputs.puzzle === "3x3x3" && inputs.visualizationStrategy === "Cube3D") {
          return SimultaneousMoveIndexer;
        } else {
          return TreeAlgIndexer;
        }
      case "tree":
        return TreeAlgIndexer;
      case "simple":
        return SimpleAlgIndexer;
      case "simultaneous":
        return SimultaneousMoveIndexer;
      default:
        throw new Error("Invalid indexer request!");
    }
  }
};

// src/cubing/twisty/model/props/puzzle/state/IndexerConstructorRequestProp.ts
init_TwistyProp();
var IndexerConstructorRequestProp = class extends SimpleTwistyPropSource {
  getDefaultValue() {
    return "auto";
  }
};

// src/cubing/twisty/model/props/puzzle/state/IndexerProp.ts
init_TwistyProp();
var IndexerProp = class extends TwistyPropDerived {
  derive(input) {
    return new input.indexerConstructor(input.kpuzzle, input.algWithIssues.alg);
  }
};

// src/cubing/twisty/model/props/puzzle/state/LegacyPositionProp.ts
init_TwistyProp();
var LegacyPositionProp = class extends TwistyPropDerived {
  derive(inputs) {
    return {
      state: inputs.state,
      movesInProgress: inputs.currentMoveInfo.currentMoves
    };
  }
};

// src/cubing/twisty/model/props/puzzle/state/NaiveMoveCountProp.ts
init_TwistyProp();
var NaiveMoveCountProp = class extends TwistyPropDerived {
  derive(inputs) {
    if (inputs.alg.issues.errors.length > 0) {
      return null;
    }
    return countMoves(inputs.alg.alg);
  }
};

// src/cubing/twisty/model/props/puzzle/state/PuzzleAlgProp.ts
init_alg();
init_TwistyProp();
var validate = true;
var PuzzleAlgProp = class extends TwistyPropDerived {
  async derive(inputs) {
    try {
      if (validate) {
        inputs.kpuzzle.algToTransformation(inputs.algWithIssues.alg);
      }
      return inputs.algWithIssues;
    } catch (e) {
      return {
        alg: new Alg(),
        issues: new AlgIssues({
          errors: [`Invalid alg for puzzle: ${e.toString()}`]
        })
      };
    }
  }
};

// src/cubing/twisty/model/props/puzzle/state/SetupAnchorProp.ts
init_TwistyProp();
var SetupAnchorProp = class extends SimpleTwistyPropSource {
  getDefaultValue() {
    return "start";
  }
};

// src/cubing/twisty/model/props/puzzle/state/SetupTransformationProp.ts
init_TwistyProp();
var SetupTransformationProp = class extends SimpleTwistyPropSource {
  getDefaultValue() {
    return null;
  }
};

// src/cubing/twisty/model/props/puzzle/structure/KPuzzleProp.ts
init_TwistyProp();
var KPuzzleProp = class extends TwistyPropDerived {
  async derive(inputs) {
    return inputs.puzzleLoader.kpuzzle();
  }
};

// src/cubing/twisty/model/props/puzzle/structure/PuzzleDescriptionProp.ts
init_TwistyProp();
var PGPuzzleDescriptionStringProp = class extends SimpleTwistyPropSource {
  getDefaultValue() {
    return NO_VALUE;
  }
};

// src/cubing/twisty/model/props/puzzle/structure/PuzzleIDProp.ts
init_TwistyProp();
var PuzzleIDProp = class extends TwistyPropDerived {
  async derive(inputs) {
    return inputs.puzzleLoader.id;
  }
};

// src/cubing/twisty/model/props/puzzle/structure/PuzzleIDRequestProp.ts
init_TwistyProp();
var PuzzleIDRequestProp = class extends SimpleTwistyPropSource {
  getDefaultValue() {
    return NO_VALUE;
  }
};

// src/cubing/twisty/model/props/puzzle/structure/PuzzleLoaderProp.ts
init_puzzles();
init_TwistyProp();
var PuzzleLoaderProp = class extends TwistyPropDerived {
  derive(inputs) {
    if (inputs.puzzleIDRequest && inputs.puzzleIDRequest !== NO_VALUE) {
      const puzzleLoader = puzzles[inputs.puzzleIDRequest];
      if (!puzzleLoader) {
        this.userVisibleErrorTracker.set({
          errors: [`Invalid puzzle ID: ${inputs.puzzleIDRequest}`]
        });
      }
      return puzzleLoader;
    }
    if (inputs.puzzleDescriptionRequest && inputs.puzzleDescriptionRequest !== NO_VALUE) {
      return customPGPuzzleLoader(inputs.puzzleDescriptionRequest);
    }
    return cube3x3x3;
  }
};

// src/cubing/twisty/model/props/timeline/CoarseTimelineInfoProp.ts
init_TwistyProp();
var CoarseTimelineInfoProp = class extends TwistyPropDerived {
  derive(inputs) {
    return {
      playing: inputs.playingInfo.playing,
      atStart: inputs.detailedTimelineInfo.atStart,
      atEnd: inputs.detailedTimelineInfo.atEnd
    };
  }
  canReuseValue(v1, v2) {
    return v1.playing === v2.playing && v1.atStart === v2.atStart && v1.atEnd === v2.atEnd;
  }
};

// src/cubing/twisty/model/props/timeline/DetailedTimelineInfoProp.ts
init_TwistyProp();
var _requestedTimestampToMilliseconds, requestedTimestampToMilliseconds_fn;
var DetailedTimelineInfoProp = class extends TwistyPropDerived {
  constructor() {
    super(...arguments);
    __privateAdd(this, _requestedTimestampToMilliseconds);
  }
  derive(inputs) {
    let timestamp = __privateMethod(this, _requestedTimestampToMilliseconds, requestedTimestampToMilliseconds_fn).call(this, inputs);
    let atStart = false;
    let atEnd = false;
    if (timestamp >= inputs.timeRange.end) {
      atEnd = true;
      timestamp = Math.min(inputs.timeRange.end, timestamp);
    }
    if (timestamp <= inputs.timeRange.start) {
      atStart = true;
      timestamp = Math.max(inputs.timeRange.start, timestamp);
    }
    return {
      timestamp,
      timeRange: inputs.timeRange,
      atStart,
      atEnd
    };
  }
  canReuse(v1, v2) {
    return v1.timestamp === v2.timestamp && v1.timeRange.start === v2.timeRange.start && v1.timeRange.end === v2.timeRange.end && v1.atStart === v2.atStart && v1.atEnd === v2.atEnd;
  }
};
_requestedTimestampToMilliseconds = new WeakSet();
requestedTimestampToMilliseconds_fn = function(inputs) {
  switch (inputs.timestampRequest) {
    case "start":
      return inputs.timeRange.start;
    case "end":
      return inputs.timeRange.end;
    case "anchor":
      return inputs.setupAnchor === "start" ? inputs.timeRange.start : inputs.timeRange.end;
    case "opposite-anchor":
      return inputs.setupAnchor === "start" ? inputs.timeRange.end : inputs.timeRange.start;
    default:
      return inputs.timestampRequest;
  }
};

// src/cubing/twisty/model/props/timeline/PlayingInfoProp.ts
init_TwistyProp();
var PlayingInfoProp = class extends TwistyPropSource {
  async getDefaultValue() {
    return {
      direction: 1 /* Forwards */,
      playing: false,
      untilBoundary: "entire-timeline" /* EntireTimeline */,
      loop: false
    };
  }
  async derive(newInfo, oldValuePromise) {
    const oldValue = await oldValuePromise;
    const newValue = Object.assign({}, oldValue);
    Object.assign(newValue, newInfo);
    return newValue;
  }
  canReuseValue(v1, v2) {
    return v1.direction === v2.direction && v1.playing === v2.playing && v1.untilBoundary === v2.untilBoundary && v1.loop === v2.loop;
  }
};

// src/cubing/twisty/model/props/timeline/TempoScaleProp.ts
init_TwistyProp();
var TempoScaleProp = class extends TwistyPropSource {
  getDefaultValue() {
    return 1;
  }
  derive(v) {
    return v < 0 ? 1 : v;
  }
};

// src/cubing/twisty/model/props/timeline/TimestampRequestProp.ts
init_TwistyProp();
var smartTimestamps = {
  "start": true,
  "end": true,
  "anchor": true,
  "opposite-anchor": true
};
var TimestampRequestProp = class extends SimpleTwistyPropSource {
  getDefaultValue() {
    return "opposite-anchor";
  }
  set(v) {
    if (!this.validInput(v)) {
      return;
    }
    super.set(v);
  }
  validInput(v) {
    if (typeof v === "number") {
      return true;
    }
    if (smartTimestamps[v]) {
      return true;
    }
    return false;
  }
};

// src/cubing/twisty/model/TwistyPlayerModel.ts
init_TwistyProp();

// src/cubing/twisty/model/props/viewer/BackViewProp.ts
init_TwistyProp();
var BackViewProp = class extends SimpleTwistyPropSource {
  getDefaultValue() {
    return "auto";
  }
};

// src/cubing/twisty/model/props/viewer/TimeRangeProp.ts
init_TwistyProp();
var TimeRangeProp = class extends TwistyPropDerived {
  derive(inputs) {
    return {
      start: 0,
      end: inputs.indexer.algDuration()
    };
  }
};

// src/cubing/twisty/model/props/viewer/ViewerLinkProp.ts
init_TwistyProp();
var ViewerLinkProp = class extends SimpleTwistyPropSource {
  getDefaultValue() {
    return "auto";
  }
};

// src/cubing/twisty/model/props/viewer/VisualizationProp.ts
init_TwistyProp();
var VisualizationFormatProp = class extends SimpleTwistyPropSource {
  getDefaultValue() {
    return "auto";
  }
};

// src/cubing/twisty/model/props/viewer/VisualizationStrategyProp.ts
init_TwistyProp();
var VisualizationStrategyProp = class extends TwistyPropDerived {
  derive(inputs) {
    switch (inputs.puzzleID) {
      case "clock":
      case "square1":
      case "kilominx":
      case "redi_cube":
        return "2D";
      case "3x3x3":
        switch (inputs.visualizationRequest) {
          case "auto":
          case "3D":
            return "Cube3D";
          default:
            return inputs.visualizationRequest;
        }
      default:
        switch (inputs.visualizationRequest) {
          case "auto":
          case "3D":
            return "PG3D";
          case "experimental-2D-LL":
            return "2D";
          default:
            return inputs.visualizationRequest;
        }
    }
  }
};

// src/cubing/twisty/model/props/puzzle/display/FoundationDisplayProp.ts
init_TwistyProp();
var FoundationDisplayProp = class extends SimpleTwistyPropSource {
  getDefaultValue() {
    return "auto";
  }
};

// src/cubing/twisty/model/TwistySceneModel.ts
init_HintFaceletProp();

// src/cubing/twisty/model/props/puzzle/display/SpriteProp.ts
init_d();
init_TwistyProp();
var cachedLoader = null;
async function loader() {
  return cachedLoader ?? (cachedLoader = new (await THREEJS).TextureLoader());
}
var SpriteProp = class extends TwistyPropDerived {
  async derive(inputs) {
    const { spriteURL: textureURL } = inputs;
    if (textureURL === null) {
      return null;
    }
    return new Promise(async (resolve, _reject) => {
      const onLoadingError = () => {
        console.warn("Could not load sprite:", textureURL.toString());
        resolve(null);
      };
      try {
        (await loader()).load(textureURL.toString(), resolve, onLoadingError, onLoadingError);
      } catch (e) {
        onLoadingError();
      }
    });
  }
};

// src/cubing/twisty/model/TwistySceneModel.ts
init_StickeringProp();

// src/cubing/twisty/model/props/puzzle/state/MovePressInputProp.ts
init_TwistyProp();
var MovePressInputProp = class extends SimpleTwistyPropSource {
  getDefaultValue() {
    return "auto";
  }
};

// src/cubing/twisty/model/props/viewer/BackgroundProp.ts
init_TwistyProp();
var BackgroundProp = class extends SimpleTwistyPropSource {
  getDefaultValue() {
    return "auto";
  }
};

// src/cubing/twisty/model/props/viewer/LatitudeLimit.ts
init_TwistyProp();
var DEFAULT_LATITUDE_LIMIT = 35;
var LatitudeLimitProp = class extends SimpleTwistyPropSource {
  getDefaultValue() {
    return DEFAULT_LATITUDE_LIMIT;
  }
};

// src/cubing/twisty/model/props/viewer/OrbitCoordinatesProp.ts
init_TAU();
init_TwistyProp();

// src/cubing/twisty/model/props/viewer/OrbitCoordinatesRequestProp.ts
init_TwistyProp();
function orbitCoordinatesEqual(c1, c2) {
  return c1.latitude === c2.latitude && c1.longitude === c2.longitude && c1.distance === c2.distance;
}
var OrbitCoordinatesRequestProp = class extends TwistyPropSource {
  getDefaultValue() {
    return "auto";
  }
  canReuseValue(v1, v2) {
    return v1 === v2 || orbitCoordinatesEqual(v1, v2);
  }
  async derive(newCoordinates, oldValuePromise) {
    if (newCoordinates === "auto") {
      return "auto";
    }
    let oldValue = await oldValuePromise;
    if (oldValue === "auto") {
      oldValue = {};
    }
    const newValue = Object.assign({}, oldValue);
    Object.assign(newValue, newCoordinates);
    if (typeof newValue.latitude !== "undefined") {
      newValue.latitude = Math.min(Math.max(newValue.latitude, -90), 90);
    }
    if (typeof newValue.longitude !== "undefined") {
      newValue.longitude = mod(newValue.longitude, 360, 180);
    }
    return newValue;
  }
};

// src/cubing/twisty/model/props/viewer/OrbitCoordinatesProp.ts
var OrbitCoordinatesProp = class extends TwistyPropDerived {
  canReuseValue(v1, v2) {
    return orbitCoordinatesEqual(v1, v2);
  }
  async derive(inputs) {
    if (inputs.orbitCoordinatesRequest === "auto") {
      return defaultCameraOrbitCoordinates(inputs.puzzleID, inputs.strategy);
    }
    const req = Object.assign(Object.assign({}, defaultCameraOrbitCoordinates(inputs.puzzleID, inputs.strategy), inputs.orbitCoordinatesRequest));
    if (Math.abs(req.latitude) <= inputs.latitudeLimit) {
      return req;
    } else {
      const { latitude, longitude, distance } = req;
      return {
        latitude: inputs.latitudeLimit * Math.sign(latitude),
        longitude,
        distance
      };
    }
  }
};
var centeredCameraOrbitCoordinates = {
  latitude: 31.717474411461005,
  longitude: 0,
  distance: 5.877852522924731
};
var cubeCube3DCameraOrbitCoordinates = {
  latitude: 35,
  longitude: 30,
  distance: 6
};
var cubePG3DCameraOrbitCoordinates = {
  latitude: 35,
  longitude: 30,
  distance: 6.25
};
var megaminxCameraOrbitCoordinates = {
  latitude: Math.atan(1 / 2) * DEGREES_PER_RADIAN,
  longitude: 0,
  distance: 6.7
};
var pyraminxCameraOrbitCoordinates = {
  latitude: 26.56505117707799,
  longitude: 0,
  distance: 6
};
function defaultCameraOrbitCoordinates(puzzleID, strategy) {
  if (puzzleID[1] === "x") {
    if (strategy === "Cube3D") {
      return cubeCube3DCameraOrbitCoordinates;
    } else {
      return cubePG3DCameraOrbitCoordinates;
    }
  } else {
    switch (puzzleID) {
      case "megaminx":
      case "gigaminx":
        return megaminxCameraOrbitCoordinates;
      case "pyraminx":
      case "master_tetraminx":
        return pyraminxCameraOrbitCoordinates;
      case "skewb":
        return cubePG3DCameraOrbitCoordinates;
      default:
        return centeredCameraOrbitCoordinates;
    }
  }
}

// src/cubing/twisty/model/TwistySceneModel.ts
var TwistySceneModel = class {
  constructor(twistyPlayerModel) {
    this.twistyPlayerModel = twistyPlayerModel;
    this.background = new BackgroundProp();
    this.foundationDisplay = new FoundationDisplayProp();
    this.foundationStickerSpriteURL = new URLProp();
    this.hintFacelet = new HintFaceletProp();
    this.hintStickerSpriteURL = new URLProp();
    this.latitudeLimit = new LatitudeLimitProp();
    this.movePressInput = new MovePressInputProp();
    this.orbitCoordinatesRequest = new OrbitCoordinatesRequestProp();
    this.stickering = new StickeringProp();
    this.foundationStickerSprite = new SpriteProp({
      spriteURL: this.foundationStickerSpriteURL
    });
    this.hintStickerSprite = new SpriteProp({
      spriteURL: this.hintStickerSpriteURL
    });
    this.orbitCoordinates = new OrbitCoordinatesProp({
      orbitCoordinatesRequest: this.orbitCoordinatesRequest,
      latitudeLimit: this.latitudeLimit,
      puzzleID: twistyPlayerModel.puzzleID,
      strategy: twistyPlayerModel.visualizationStrategy
    });
  }
};

// src/cubing/twisty/model/UserVisibleErrorTracker.ts
init_TwistyProp();
var EMPTY_ERRORS = { errors: [] };
var UserVisibleErrorTracker = class extends SimpleTwistyPropSource {
  getDefaultValue() {
    return EMPTY_ERRORS;
  }
  reset() {
    this.set(this.getDefaultValue());
  }
  canReuseValue(_v12, _v22) {
    return arrayEquals(_v12.errors, _v22.errors);
  }
};

// src/cubing/twisty/model/TwistyPlayerModel.ts
var TwistyPlayerModel = class {
  constructor() {
    this.userVisibleErrorTracker = new UserVisibleErrorTracker();
    this.alg = new AlgProp();
    this.backView = new BackViewProp();
    this.controlPanel = new ControlPanelProp();
    this.catchUpMove = new CatchUpMoveProp();
    this.indexerConstructorRequest = new IndexerConstructorRequestProp();
    this.playingInfo = new PlayingInfoProp();
    this.puzzleDescriptionRequest = new PGPuzzleDescriptionStringProp();
    this.puzzleIDRequest = new PuzzleIDRequestProp();
    this.setupAnchor = new SetupAnchorProp();
    this.setupAlg = new AlgProp();
    this.setupTransformation = new SetupTransformationProp();
    this.tempoScale = new TempoScaleProp();
    this.timestampRequest = new TimestampRequestProp();
    this.viewerLink = new ViewerLinkProp();
    this.visualizationFormat = new VisualizationFormatProp();
    this.title = new ArbitraryStringProp();
    this.videoURL = new URLProp();
    this.competitionID = new ArbitraryStringProp();
    this.puzzleLoader = new PuzzleLoaderProp({
      puzzleIDRequest: this.puzzleIDRequest,
      puzzleDescriptionRequest: this.puzzleDescriptionRequest
    }, this.userVisibleErrorTracker);
    this.kpuzzle = new KPuzzleProp({ puzzleLoader: this.puzzleLoader });
    this.puzzleID = new PuzzleIDProp({ puzzleLoader: this.puzzleLoader });
    this.puzzleAlg = new PuzzleAlgProp({
      algWithIssues: this.alg,
      kpuzzle: this.kpuzzle
    });
    this.puzzleSetupAlg = new PuzzleAlgProp({
      algWithIssues: this.setupAlg,
      kpuzzle: this.kpuzzle
    });
    this.visualizationStrategy = new VisualizationStrategyProp({
      visualizationRequest: this.visualizationFormat,
      puzzleID: this.puzzleID
    });
    this.indexerConstructor = new IndexerConstructorProp({
      alg: this.alg,
      puzzle: this.puzzleID,
      visualizationStrategy: this.visualizationStrategy,
      indexerConstructorRequest: this.indexerConstructorRequest
    });
    this.moveCount = new NaiveMoveCountProp({ alg: this.puzzleAlg });
    this.setupAlgTransformation = new AlgTransformationProp({
      setupAlg: this.puzzleSetupAlg,
      kpuzzle: this.kpuzzle
    });
    this.indexer = new IndexerProp({
      indexerConstructor: this.indexerConstructor,
      algWithIssues: this.puzzleAlg,
      kpuzzle: this.kpuzzle
    });
    this.anchorTransformation = new AnchorTransformationProp({
      setupTransformation: this.setupTransformation,
      setupAnchor: this.setupAnchor,
      setupAlgTransformation: this.setupAlgTransformation,
      indexer: this.indexer
    });
    this.timeRange = new TimeRangeProp({
      indexer: this.indexer
    });
    this.detailedTimelineInfo = new DetailedTimelineInfoProp({
      timestampRequest: this.timestampRequest,
      timeRange: this.timeRange,
      setupAnchor: this.setupAnchor
    });
    this.coarseTimelineInfo = new CoarseTimelineInfoProp({
      detailedTimelineInfo: this.detailedTimelineInfo,
      playingInfo: this.playingInfo
    });
    this.currentMoveInfo = new CurrentMoveInfoProp({
      indexer: this.indexer,
      detailedTimelineInfo: this.detailedTimelineInfo,
      catchUpMove: this.catchUpMove
    });
    this.buttonAppearance = new ButtonAppearanceProp({
      coarseTimelineInfo: this.coarseTimelineInfo,
      viewerLink: this.viewerLink
    });
    this.currentLeavesSimplified = new CurrentLeavesSimplifiedProp({
      currentMoveInfo: this.currentMoveInfo
    });
    this.currentState = new CurrentStateProp({
      anchoredStart: this.anchorTransformation,
      currentLeavesSimplified: this.currentLeavesSimplified,
      indexer: this.indexer
    });
    this.legacyPosition = new LegacyPositionProp({
      currentMoveInfo: this.currentMoveInfo,
      state: this.currentState
    });
    this.twistySceneModel = new TwistySceneModel(this);
  }
  async twizzleLink() {
    const [
      viewerLink,
      puzzleID,
      puzzleDescription,
      alg,
      setup,
      anchor,
      experimentalStickering
    ] = await Promise.all([
      this.viewerLink.get(),
      this.puzzleID.get(),
      this.puzzleDescriptionRequest.get(),
      this.alg.get(),
      this.setupAlg.get(),
      this.setupAnchor.get(),
      this.twistySceneModel.stickering.get()
    ]);
    const isExplorer = viewerLink === "experimental-twizzle-explorer";
    console.log({ isExplorer, viewerLink });
    const url = new URL(`https://alpha.twizzle.net/${isExplorer ? "explore" : "edit"}/`);
    if (!alg.alg.experimentalIsEmpty()) {
      url.searchParams.set("alg", alg.alg.toString());
    }
    if (!setup.alg.experimentalIsEmpty()) {
      url.searchParams.set("setup-alg", setup.alg.toString());
    }
    if (anchor !== "start") {
      url.searchParams.set("setup-anchor", anchor);
    }
    if (experimentalStickering !== "full") {
      url.searchParams.set("experimental-stickering", experimentalStickering);
    }
    if (isExplorer && puzzleDescription !== NO_VALUE) {
      url.searchParams.set("puzzle-description", puzzleDescription);
    } else if (puzzleID !== "3x3x3") {
      url.searchParams.set("puzzle", puzzleID);
    }
    return url.toString();
  }
  experimentalAddMove(flexibleMove, options = {}) {
    const move = typeof flexibleMove === "string" ? new Move(flexibleMove) : flexibleMove;
    (async () => {
      const alg = (await this.alg.get()).alg;
      const newAlg = experimentalAppendMove(alg, move, {
        coalesce: options?.coalesce,
        mod: options?.mod
      });
      this.alg.set(newAlg);
      this.timestampRequest.set("end");
      this.catchUpMove.set({
        move,
        amount: 0
      });
    })();
  }
  get playingInfoProp() {
    console.warn("Using deprecated prop: `playingInfoProp`. Please switch to: `playingInfo`");
    return this.playingInfo;
  }
};

// src/cubing/twisty/views/TwistyPlayerSettable.ts
function err(propName) {
  return new Error(`Cannot get \`.${propName}\` directly from a \`TwistyPlayer\`.`);
}
var TwistyPlayerSettable = class extends ManagedCustomElement {
  constructor() {
    super(...arguments);
    this.experimentalModel = new TwistyPlayerModel();
    this.experimentalGet = new ExperimentalGetters(this.experimentalModel);
  }
  set alg(newAlg) {
    this.experimentalModel.alg.set(newAlg);
  }
  get alg() {
    throw err("alg");
  }
  set experimentalSetupAlg(newSetup) {
    this.experimentalModel.setupAlg.set(newSetup);
  }
  get experimentalSetupAlg() {
    throw err("setup");
  }
  set experimentalSetupAnchor(anchor) {
    this.experimentalModel.setupAnchor.set(anchor);
  }
  get experimentalSetupAnchor() {
    throw err("anchor");
  }
  set puzzle(puzzleID) {
    this.experimentalModel.puzzleIDRequest.set(puzzleID);
  }
  get puzzle() {
    throw err("puzzle");
  }
  set experimentalPuzzleDescription(puzzleDescription) {
    this.experimentalModel.puzzleDescriptionRequest.set(puzzleDescription);
  }
  get experimentalPuzzleDescription() {
    throw err("experimentalPuzzleDescription");
  }
  set timestamp(timestamp) {
    this.experimentalModel.timestampRequest.set(timestamp);
  }
  get timestamp() {
    throw err("timestamp");
  }
  set hintFacelets(hintFaceletStyle) {
    this.experimentalModel.twistySceneModel.hintFacelet.set(hintFaceletStyle);
  }
  get hintFacelets() {
    throw err("hintFacelets");
  }
  set experimentalStickering(stickering) {
    this.experimentalModel.twistySceneModel.stickering.set(stickering);
  }
  get experimentalStickering() {
    throw err("stickering");
  }
  set backView(backView) {
    this.experimentalModel.backView.set(backView);
  }
  get backView() {
    throw err("backView");
  }
  set background(backgroundTheme) {
    this.experimentalModel.twistySceneModel.background.set(backgroundTheme);
  }
  get background() {
    throw err("background");
  }
  set controlPanel(newControlPanel) {
    this.experimentalModel.controlPanel.set(newControlPanel);
  }
  get controlPanel() {
    throw err("controlPanel");
  }
  set visualization(visualizationFormat) {
    this.experimentalModel.visualizationFormat.set(visualizationFormat);
  }
  get visualization() {
    throw err("visualization");
  }
  set experimentalTitle(title) {
    this.experimentalModel.title.set(title);
  }
  get experimentalTitle() {
    throw err("experimentalTitle");
  }
  set experimentalVideoURL(videoURL) {
    this.experimentalModel.videoURL.set(videoURL);
  }
  get experimentalVideoURL() {
    throw err("experimentalVideoURL");
  }
  set experimentalCompetitionID(competitionID) {
    this.experimentalModel.competitionID.set(competitionID);
  }
  get experimentalCompetitionID() {
    throw err("experimentalCompetitionID");
  }
  set viewerLink(viewerLinkPage) {
    this.experimentalModel.viewerLink.set(viewerLinkPage);
  }
  get viewerLink() {
    throw err("viewerLink");
  }
  set experimentalMovePressInput(movePressInput) {
    this.experimentalModel.twistySceneModel.movePressInput.set(movePressInput);
  }
  get experimentalMovePressInput() {
    throw err("experimentalMovePressInput");
  }
  set cameraLatitude(latitude) {
    this.experimentalModel.twistySceneModel.orbitCoordinatesRequest.set({ latitude });
  }
  get cameraLatitude() {
    throw err("cameraLatitude");
  }
  set cameraLongitude(longitude) {
    this.experimentalModel.twistySceneModel.orbitCoordinatesRequest.set({ longitude });
  }
  get cameraLongitude() {
    throw err("cameraLongitude");
  }
  set cameraDistance(distance) {
    this.experimentalModel.twistySceneModel.orbitCoordinatesRequest.set({ distance });
  }
  get cameraDistance() {
    throw err("cameraDistance");
  }
  set cameraLatitudeLimit(latitudeLimit) {
    this.experimentalModel.twistySceneModel.latitudeLimit.set(latitudeLimit);
  }
  get cameraLatitudeLimit() {
    throw err("cameraLatitudeLimit");
  }
  set indexer(indexer) {
    this.experimentalModel.indexerConstructorRequest.set(indexer);
  }
  get indexer() {
    throw err("indexer");
  }
  set tempoScale(newTempoScale) {
    this.experimentalModel.tempoScale.set(newTempoScale);
  }
  get tempoScale() {
    throw err("tempoScale");
  }
  set experimentalSprite(url) {
    this.experimentalModel.twistySceneModel.foundationStickerSpriteURL.set(url);
  }
  get experimentalSprite() {
    throw err("experimentalSprite");
  }
  set experimentalHintSprite(url) {
    this.experimentalModel.twistySceneModel.hintStickerSpriteURL.set(url);
  }
  get experimentalHintSprite() {
    throw err("experimentalHintSprite");
  }
};
var ExperimentalGetters = class {
  constructor(model) {
    this.model = model;
  }
  async alg() {
    return (await this.model.alg.get()).alg;
  }
  async setupAlg() {
    return (await this.model.setupAlg.get()).alg;
  }
  puzzleID() {
    return this.model.puzzleID.get();
  }
  async timestamp() {
    return (await this.model.detailedTimelineInfo.get()).timestamp;
  }
};

// src/cubing/twisty/views/TwistyPlayer.ts
var DATA_ATTRIBUTE_PREFIX = "data-";
var twistyPlayerAttributeMap = {
  "alg": "alg",
  "experimental-setup-alg": "experimentalSetupAlg",
  "experimental-setup-anchor": "experimentalSetupAnchor",
  "puzzle": "puzzle",
  "experimental-puzzle-description": "experimentalPuzzleDescription",
  "visualization": "visualization",
  "hint-facelets": "hintFacelets",
  "experimental-stickering": "experimentalStickering",
  "background": "background",
  "control-panel": "controlPanel",
  "back-view": "backView",
  "viewer-link": "viewerLink",
  "experimental-move-press-input": "experimentalMovePressInput",
  "experimental-title": "experimentalTitle",
  "experimental-video-url": "experimentalVideoURL",
  "experimental-competition-id": "experimentalCompetitionID",
  "camera-latitude": "cameraLatitude",
  "camera-longitude": "cameraLongitude",
  "camera-distance": "cameraDistance",
  "camera-latitude-limit": "cameraLatitudeLimit",
  "tempo-scale": "tempoScale",
  "experimental-sprite": "experimentalSprite",
  "experimental-hint-sprite": "experimentalHintSprite"
};
var configKeys = Object.fromEntries(Object.values(twistyPlayerAttributeMap).map((s) => [s, true]));
var _controlsManager, _visualizationWrapperElem, _errorElem, _alreadyConnected, _flashLevel, _visualizationWrapper, _visualizationStrategy, _setVisualizationWrapper, setVisualizationWrapper_fn;
var TwistyPlayer = class extends TwistyPlayerSettable {
  constructor(config = {}) {
    super();
    __privateAdd(this, _setVisualizationWrapper);
    this.controller = new TwistyPlayerController(this.experimentalModel, this);
    this.experimentalCanvasClickCallback = () => {
    };
    __privateAdd(this, _controlsManager, new ClassListManager(this, "controls-", ["auto"].concat(Object.keys(controlsLocations))));
    __privateAdd(this, _visualizationWrapperElem, document.createElement("div"));
    __privateAdd(this, _errorElem, document.createElement("div"));
    __privateAdd(this, _alreadyConnected, false);
    __privateAdd(this, _flashLevel, "auto");
    __privateAdd(this, _visualizationWrapper, null);
    __privateAdd(this, _visualizationStrategy, null);
    for (const [propName, value] of Object.entries(config)) {
      if (!configKeys[propName]) {
        console.warn(`Invalid config passed to TwistyPlayer: ${propName}`);
        break;
      }
      this[propName] = value;
    }
  }
  async connectedCallback() {
    if (__privateGet(this, _alreadyConnected)) {
      return;
    }
    __privateSet(this, _alreadyConnected, true);
    this.addCSS(twistyPlayerCSS);
    this.addElement(__privateGet(this, _visualizationWrapperElem)).classList.add("visualization-wrapper");
    this.addElement(__privateGet(this, _errorElem)).classList.add("error-elem");
    __privateGet(this, _errorElem).textContent = "Error";
    this.experimentalModel.userVisibleErrorTracker.addFreshListener((userVisibleError) => {
      const errorString = userVisibleError.errors[0] ?? null;
      this.contentWrapper.classList.toggle("error", !!errorString);
      if (errorString) {
        __privateGet(this, _errorElem).textContent = errorString;
      }
    });
    const scrubber = new TwistyScrubber(this.experimentalModel);
    this.contentWrapper.appendChild(scrubber);
    this.buttons = new TwistyButtons(this.experimentalModel, this.controller, this);
    this.contentWrapper.appendChild(this.buttons);
    this.experimentalModel.twistySceneModel.background.addFreshListener((backgroundTheme) => {
      this.contentWrapper.classList.toggle("checkered", backgroundTheme !== "none");
    });
    this.experimentalModel.controlPanel.addFreshListener((controlPanel) => {
      __privateGet(this, _controlsManager).setValue(controlPanel);
    });
    this.experimentalModel.visualizationStrategy.addFreshListener(__privateMethod(this, _setVisualizationWrapper, setVisualizationWrapper_fn).bind(this));
    this.experimentalModel.puzzleID.addFreshListener(this.flash.bind(this));
  }
  experimentalSetFlashLevel(newLevel) {
    __privateSet(this, _flashLevel, newLevel);
  }
  flash() {
    if (__privateGet(this, _flashLevel) === "auto") {
      __privateGet(this, _visualizationWrapper)?.animate([{ opacity: 0.25 }, { opacity: 1 }], {
        duration: 250
      });
    }
  }
  async experimentalCurrentCanvases() {
    this.connectedCallback();
    const wrapper = __privateGet(this, _visualizationWrapper);
    const canvases = [];
    if (wrapper instanceof Twisty3DSceneWrapper) {
      const vantages = wrapper.experimentalVantages();
      for (const vantage of vantages) {
        canvases.push((await vantage.canvasInfo()).canvas);
      }
    }
    return canvases;
  }
  async experimentalPG3D() {
    this.connectedCallback();
    const wrapper = __privateGet(this, _visualizationWrapper);
    if (wrapper instanceof Twisty3DSceneWrapper) {
      wrapper;
    }
    return null;
  }
  jumpToStart(options) {
    this.controller.jumpToStart(options);
  }
  jumpToEnd(options) {
    this.controller.jumpToEnd(options);
  }
  play() {
    this.controller.togglePlay(true);
  }
  pause() {
    this.controller.togglePlay(false);
  }
  togglePlay(play) {
    this.controller.togglePlay(play);
  }
  experimentalAddMove(flexibleMove, options = {}) {
    this.experimentalModel.experimentalAddMove(flexibleMove, options);
  }
  static get observedAttributes() {
    const observed = [];
    for (const key of Object.keys(twistyPlayerAttributeMap)) {
      observed.push(key, DATA_ATTRIBUTE_PREFIX + key);
    }
    return observed;
  }
  attributeChangedCallback(attributeName, _oldValue, newValue) {
    if (attributeName.startsWith("data-")) {
      attributeName = attributeName.slice("data-".length);
    }
    const setterName = twistyPlayerAttributeMap[attributeName];
    if (!setterName) {
      return;
    }
    this[setterName] = newValue;
  }
  async experimentalScreenshot(options) {
    return (await screenshot(this.experimentalModel, options)).dataURL;
  }
  async experimentalDownloadScreenshot(filename) {
    if (["2D", "experimental-2D-LL"].includes(await this.experimentalModel.visualizationStrategy.get())) {
      const wrapper2D = __privateGet(this, _visualizationWrapper);
      const twisty2DPuzzle = await wrapper2D.currentTwisty2DPuzzleWrapper().twisty2DPuzzle();
      const str = new XMLSerializer().serializeToString(twisty2DPuzzle.svg.element);
      const url = URL.createObjectURL(new Blob([str]));
      downloadURL(url, filename ?? await getDefaultFilename(this.experimentalModel), "svg");
    } else {
      await (await screenshot(this.experimentalModel)).download(filename);
    }
  }
};
_controlsManager = new WeakMap();
_visualizationWrapperElem = new WeakMap();
_errorElem = new WeakMap();
_alreadyConnected = new WeakMap();
_flashLevel = new WeakMap();
_visualizationWrapper = new WeakMap();
_visualizationStrategy = new WeakMap();
_setVisualizationWrapper = new WeakSet();
setVisualizationWrapper_fn = function(strategy) {
  if (strategy !== __privateGet(this, _visualizationStrategy)) {
    __privateGet(this, _visualizationWrapper)?.remove();
    __privateGet(this, _visualizationWrapper)?.disconnect();
    let newWrapper;
    switch (strategy) {
      case "2D":
      case "experimental-2D-LL":
        newWrapper = new Twisty2DSceneWrapper(this.experimentalModel.twistySceneModel, strategy);
        break;
      case "Cube3D":
      case "PG3D":
        newWrapper = new Twisty3DSceneWrapper(this.experimentalModel);
        break;
      default:
        throw new Error("Invalid visualization");
    }
    __privateGet(this, _visualizationWrapperElem).appendChild(newWrapper);
    __privateSet(this, _visualizationWrapper, newWrapper);
    __privateSet(this, _visualizationStrategy, strategy);
  }
};
customElementsShim.define("twisty-player", TwistyPlayer);

// src/cubing/twisty/views/TwistyAlgViewer.ts
init_alg();

// src/cubing/twisty/views/TwistyAlgViewer.css.ts
var twistyAlgViewerCSS = new CSSSource(`
:host {
  display: inline-grid;
}

a:not(:hover) {
  color: inherit;
  text-decoration: none;
}

twisty-alg-leaf-elem.twisty-alg-comment {
  color: rgba(0, 0, 0, 0.4);
}

.wrapper.current-move {
  background: rgba(66, 133, 244, 0.3);
  margin-left: -0.1em;
  margin-right: -0.1em;
  padding-left: 0.1em;
  padding-right: 0.1em;
  border-radius: 0.1em;
}
`);

// src/cubing/twisty/views/TwistyAlgViewer.ts
var DEFAULT_OFFSET_MS = 250;
var TwistyAlgLeafElem = class extends ManagedCustomElement {
  constructor(className, text, dataDown, algOrUnit, offsetIntoMove, clickable) {
    super({ mode: "open" });
    this.algOrUnit = algOrUnit;
    this.classList.add(className);
    this.addCSS(twistyAlgViewerCSS);
    if (clickable) {
      const anchor = this.contentWrapper.appendChild(document.createElement("a"));
      anchor.href = "#";
      anchor.textContent = text;
      anchor.addEventListener("click", (e) => {
        e.preventDefault();
        dataDown.twistyAlgViewer.jumpToIndex(dataDown.earliestMoveIndex, offsetIntoMove);
      });
    } else {
      this.contentWrapper.appendChild(document.createElement("span")).textContent = text;
    }
  }
  pathToIndex(_index) {
    return [];
  }
  setCurrentMove(current) {
    this.contentWrapper.classList.toggle("current-move", current);
  }
};
customElementsShim.define("twisty-alg-leaf-elem", TwistyAlgLeafElem);
var TwistyAlgWrapperElem = class extends HTMLElementShim {
  constructor(className, algOrUnit) {
    super();
    this.algOrUnit = algOrUnit;
    this.queue = [];
    this.classList.add(className);
  }
  addString(str) {
    this.queue.push(document.createTextNode(str));
  }
  addElem(dataUp) {
    this.queue.push(dataUp.element);
    return dataUp.moveCount;
  }
  flushQueue(direction = 1 /* Forwards */) {
    for (const node of maybeReverseList(this.queue, direction)) {
      this.append(node);
    }
    this.queue = [];
  }
  pathToIndex(_index) {
    return [];
  }
};
customElementsShim.define("twisty-alg-wrapper-elem", TwistyAlgWrapperElem);
function oppositeDirection(direction) {
  return direction === 1 /* Forwards */ ? -1 /* Backwards */ : 1 /* Forwards */;
}
function updateDirectionByAmount(currentDirection, amount) {
  return amount < 0 ? oppositeDirection(currentDirection) : currentDirection;
}
function maybeReverseList(l, direction) {
  if (direction === 1 /* Forwards */) {
    return l;
  }
  const copy = Array.from(l);
  copy.reverse();
  return copy;
}
var AlgToDOMTree = class extends TraversalDownUp {
  traverseAlg(alg, dataDown) {
    let moveCount = 0;
    const element = new TwistyAlgWrapperElem("twisty-alg-alg", alg);
    let first = true;
    for (const unit of direct(alg.units(), dataDown.direction)) {
      if (!first) {
        element.addString(" ");
      }
      first = false;
      moveCount += element.addElem(this.traverseUnit(unit, {
        earliestMoveIndex: dataDown.earliestMoveIndex + moveCount,
        twistyAlgViewer: dataDown.twistyAlgViewer,
        direction: dataDown.direction
      }));
    }
    element.flushQueue(dataDown.direction);
    return {
      moveCount,
      element
    };
  }
  traverseGrouping(grouping, dataDown) {
    const square1Tuple = grouping.experimentalAsSquare1Tuple();
    const direction = updateDirectionByAmount(dataDown.direction, grouping.amount);
    let moveCount = 0;
    const element = new TwistyAlgWrapperElem("twisty-alg-grouping", grouping);
    element.addString("(");
    if (square1Tuple) {
      moveCount += element.addElem({
        moveCount: 1,
        element: new TwistyAlgLeafElem("twisty-alg-move", square1Tuple[0].amount.toString(), dataDown, square1Tuple[0], true, true)
      });
      element.addString(", ");
      moveCount += element.addElem({
        moveCount: 1,
        element: new TwistyAlgLeafElem("twisty-alg-move", square1Tuple[1].amount.toString(), dataDown, square1Tuple[1], true, true)
      });
    } else {
      moveCount += element.addElem(this.traverseAlg(grouping.alg, {
        earliestMoveIndex: dataDown.earliestMoveIndex + moveCount,
        twistyAlgViewer: dataDown.twistyAlgViewer,
        direction
      }));
    }
    element.addString(")" + grouping.experimentalRepetitionSuffix);
    element.flushQueue();
    return {
      moveCount: moveCount * Math.abs(grouping.amount),
      element
    };
  }
  traverseMove(move, dataDown) {
    const element = new TwistyAlgLeafElem("twisty-alg-move", move.toString(), dataDown, move, true, true);
    dataDown.twistyAlgViewer.highlighter.addMove(move.startCharIndex, element);
    return {
      moveCount: 1,
      element
    };
  }
  traverseCommutator(commutator, dataDown) {
    let moveCount = 0;
    const element = new TwistyAlgWrapperElem("twisty-alg-commutator", commutator);
    element.addString("[");
    element.flushQueue();
    const [first, second] = maybeReverseList([commutator.A, commutator.B], dataDown.direction);
    moveCount += element.addElem(this.traverseAlg(first, {
      earliestMoveIndex: dataDown.earliestMoveIndex + moveCount,
      twistyAlgViewer: dataDown.twistyAlgViewer,
      direction: dataDown.direction
    }));
    element.addString(", ");
    moveCount += element.addElem(this.traverseAlg(second, {
      earliestMoveIndex: dataDown.earliestMoveIndex + moveCount,
      twistyAlgViewer: dataDown.twistyAlgViewer,
      direction: dataDown.direction
    }));
    element.flushQueue(dataDown.direction);
    element.addString("]");
    element.flushQueue();
    return {
      moveCount: moveCount * 2,
      element
    };
  }
  traverseConjugate(conjugate, dataDown) {
    let moveCount = 0;
    const element = new TwistyAlgWrapperElem("twisty-alg-conjugate", conjugate);
    element.addString("[");
    const aLen = element.addElem(this.traverseAlg(conjugate.A, {
      earliestMoveIndex: dataDown.earliestMoveIndex + moveCount,
      twistyAlgViewer: dataDown.twistyAlgViewer,
      direction: dataDown.direction
    }));
    moveCount += aLen;
    element.addString(": ");
    moveCount += element.addElem(this.traverseAlg(conjugate.B, {
      earliestMoveIndex: dataDown.earliestMoveIndex + moveCount,
      twistyAlgViewer: dataDown.twistyAlgViewer,
      direction: dataDown.direction
    }));
    element.addString("]");
    element.flushQueue();
    return {
      moveCount: moveCount + aLen,
      element
    };
  }
  traversePause(pause, dataDown) {
    return {
      moveCount: 1,
      element: new TwistyAlgLeafElem("twisty-alg-pause", ".", dataDown, pause, true, true)
    };
  }
  traverseNewline(newline, _dataDown) {
    const element = new TwistyAlgWrapperElem("twisty-alg-newline", newline);
    element.append(document.createElement("br"));
    return {
      moveCount: 0,
      element
    };
  }
  traverseLineComment(lineComment, dataDown) {
    return {
      moveCount: 0,
      element: new TwistyAlgLeafElem("twisty-alg-line-comment", `//${lineComment.text}`, dataDown, lineComment, false, false)
    };
  }
};
var algToDOMTreeInstance = new AlgToDOMTree();
var algToDOMTree = algToDOMTreeInstance.traverseAlg.bind(algToDOMTreeInstance);
var MoveHighlighter = class {
  constructor() {
    this.moveCharIndexMap = /* @__PURE__ */ new Map();
    this.currentElem = null;
  }
  addMove(charIndex, elem) {
    this.moveCharIndexMap.set(charIndex, elem);
  }
  set(move) {
    const newElem = move ? this.moveCharIndexMap.get(move.startCharIndex) ?? null : null;
    if (this.currentElem === newElem) {
      return;
    }
    this.currentElem?.classList.remove("twisty-alg-current-move");
    this.currentElem?.setCurrentMove(false);
    newElem?.classList.add("twisty-alg-current-move");
    newElem?.setCurrentMove(true);
    this.currentElem = newElem;
  }
};
var _domTree, _twistyPlayer, _setTwistyPlayer, setTwistyPlayer_fn;
var TwistyAlgViewer = class extends HTMLElementShim {
  constructor(options) {
    super();
    __privateAdd(this, _setTwistyPlayer);
    this.highlighter = new MoveHighlighter();
    __privateAdd(this, _domTree, void 0);
    __privateAdd(this, _twistyPlayer, null);
    this.lastClickTimestamp = null;
    if (options?.twistyPlayer) {
      this.twistyPlayer = options?.twistyPlayer;
    }
  }
  connectedCallback() {
  }
  setAlg(alg) {
    __privateSet(this, _domTree, algToDOMTree(alg, {
      earliestMoveIndex: 0,
      twistyAlgViewer: this,
      direction: 1 /* Forwards */
    }).element);
    this.textContent = "";
    this.appendChild(__privateGet(this, _domTree));
  }
  get twistyPlayer() {
    return __privateGet(this, _twistyPlayer);
  }
  set twistyPlayer(twistyPlayer2) {
    __privateMethod(this, _setTwistyPlayer, setTwistyPlayer_fn).call(this, twistyPlayer2);
  }
  async jumpToIndex(index, offsetIntoMove) {
    const twistyPlayer2 = __privateGet(this, _twistyPlayer);
    if (twistyPlayer2) {
      twistyPlayer2.pause();
      const timestampPromise = (async () => {
        const indexer = await twistyPlayer2.experimentalModel.indexer.get();
        const offset = offsetIntoMove ? DEFAULT_OFFSET_MS : 0;
        return (indexer.indexToMoveStartTimestamp(index) ?? -offset) + offset;
      })();
      twistyPlayer2.experimentalModel.timestampRequest.set(await timestampPromise);
      if (this.lastClickTimestamp === await timestampPromise) {
        twistyPlayer2.play();
        this.lastClickTimestamp = null;
      } else {
        this.lastClickTimestamp = await timestampPromise;
      }
    }
  }
  async attributeChangedCallback(attributeName, _oldValue, newValue) {
    if (attributeName === "for") {
      const elem = document.getElementById(newValue);
      if (!elem) {
        console.warn("for= elem does not exist");
        return;
      }
      await customElements.whenDefined("twisty-player");
      if (!(elem instanceof TwistyPlayer)) {
        console.warn("for= elem is not a twisty-player");
        return;
      }
      this.twistyPlayer = elem;
    }
  }
  static get observedAttributes() {
    return ["for"];
  }
};
_domTree = new WeakMap();
_twistyPlayer = new WeakMap();
_setTwistyPlayer = new WeakSet();
setTwistyPlayer_fn = async function(twistyPlayer2) {
  if (__privateGet(this, _twistyPlayer)) {
    console.warn("twisty-player reassignment is not supported");
    return;
  }
  if (twistyPlayer2 === null) {
    throw new Error("clearing twistyPlayer is not supported");
  }
  __privateSet(this, _twistyPlayer, twistyPlayer2);
  __privateGet(this, _twistyPlayer).experimentalModel.alg.addFreshListener((algWithIssues) => {
    this.setAlg(algWithIssues.alg);
  });
  const sourceAlg = (await __privateGet(this, _twistyPlayer).experimentalModel.alg.get()).alg;
  const parsedAlg = "startCharIndex" in sourceAlg ? sourceAlg : Alg.fromString(sourceAlg.toString());
  this.setAlg(parsedAlg);
  twistyPlayer2.experimentalModel.currentMoveInfo.addFreshListener((currentMoveInfo) => {
    let moveInfo = currentMoveInfo.currentMoves[0];
    moveInfo ?? (moveInfo = currentMoveInfo.movesStarting[0]);
    moveInfo ?? (moveInfo = currentMoveInfo.movesFinishing[0]);
    if (!moveInfo) {
      this.highlighter.set(null);
    } else {
      const mainCurrentMove = moveInfo.move;
      this.highlighter.set(mainCurrentMove);
    }
  });
  twistyPlayer2.experimentalModel.detailedTimelineInfo.addFreshListener((detailedTimelineInfo) => {
    if (detailedTimelineInfo.timestamp !== this.lastClickTimestamp) {
      this.lastClickTimestamp = null;
    }
  });
};
customElementsShim.define("twisty-alg-viewer", TwistyAlgViewer);

// src/cubing/twisty/views/TwistyAlgEditor/TwistyAlgEditor.ts
init_alg();

// src/cubing/twisty/views/TwistyAlgEditor/model.ts
init_TwistyProp();

// src/cubing/twisty/views/TwistyAlgEditor/LeafTokens.ts
init_alg();
var LeafTokens = class extends TraversalDownUp {
  traverseAlg(alg, dataDown) {
    const unitArrays = [];
    let numMovesInside = 0;
    for (const unit of alg.units()) {
      const dataUp = this.traverseUnit(unit, {
        numMovesSofar: dataDown.numMovesSofar + numMovesInside
      });
      unitArrays.push(dataUp.tokens);
      numMovesInside += dataUp.numLeavesInside;
    }
    return {
      tokens: Array.prototype.concat(...unitArrays),
      numLeavesInside: numMovesInside
    };
  }
  traverseGrouping(grouping, dataDown) {
    const dataUp = this.traverseAlg(grouping.alg, dataDown);
    return {
      tokens: dataUp.tokens,
      numLeavesInside: dataUp.numLeavesInside * grouping.amount
    };
  }
  traverseMove(move, dataDown) {
    return {
      tokens: [{ leaf: move, idx: dataDown.numMovesSofar }],
      numLeavesInside: 1
    };
  }
  traverseCommutator(commutator, dataDown) {
    const dataUpA = this.traverseAlg(commutator.A, dataDown);
    const dataUpB = this.traverseAlg(commutator.B, {
      numMovesSofar: dataDown.numMovesSofar + dataUpA.numLeavesInside
    });
    return {
      tokens: dataUpA.tokens.concat(dataUpB.tokens),
      numLeavesInside: dataUpA.numLeavesInside * 2 + dataUpB.numLeavesInside
    };
  }
  traverseConjugate(conjugate, dataDown) {
    const dataUpA = this.traverseAlg(conjugate.A, dataDown);
    const dataUpB = this.traverseAlg(conjugate.B, {
      numMovesSofar: dataDown.numMovesSofar + dataUpA.numLeavesInside
    });
    return {
      tokens: dataUpA.tokens.concat(dataUpB.tokens),
      numLeavesInside: dataUpA.numLeavesInside * 2 + dataUpB.numLeavesInside * 2
    };
  }
  traversePause(pause, dataDown) {
    return {
      tokens: [{ leaf: pause, idx: dataDown.numMovesSofar }],
      numLeavesInside: 1
    };
  }
  traverseNewline(_newline, _dataDown) {
    return {
      tokens: [],
      numLeavesInside: 0
    };
  }
  traverseLineComment(_comment, _dataDown) {
    return {
      tokens: [],
      numLeavesInside: 0
    };
  }
};
var leafTokensInstance = new LeafTokens();
var leafTokens = leafTokensInstance.traverseAlg.bind(leafTokensInstance);

// src/cubing/twisty/views/TwistyAlgEditor/model.ts
var TwistyAlgEditorValueProp = class extends SimpleTwistyPropSource {
  getDefaultValue() {
    return "";
  }
};
var AlgEditorAlgWithIssuesProp = class extends TwistyPropDerived {
  derive(input) {
    return algWithIssuesFromString(input.value);
  }
};
var TwistyAlgEditorSelectionProp = class extends TwistyPropSource {
  getDefaultValue() {
    return {
      selectionStart: 0,
      selectionEnd: 0,
      endChangedMostRecently: false
    };
  }
  async derive(input, oldValue) {
    const { selectionStart, selectionEnd } = input;
    const lastResult = await oldValue;
    const endChangedMostRecently = input.selectionStart === lastResult.selectionStart && input.selectionEnd !== (await oldValue).selectionEnd;
    return {
      selectionStart,
      selectionEnd,
      endChangedMostRecently
    };
  }
};
var TargetCharProp = class extends TwistyPropDerived {
  derive(inputs) {
    return inputs.selectionInfo.endChangedMostRecently ? inputs.selectionInfo.selectionEnd : inputs.selectionInfo.selectionStart;
  }
};
var LeafTokensProp = class extends TwistyPropDerived {
  derive(inputs) {
    return leafTokens(inputs.algWithIssues.alg, {
      numMovesSofar: 0
    }).tokens;
  }
};
var LeafToHighlightProp = class extends TwistyPropDerived {
  derive(inputs) {
    function withWhere(leafInfo) {
      if (leafInfo === null) {
        return null;
      }
      let where;
      if (inputs.targetChar < leafInfo.leaf.startCharIndex) {
        where = "before";
      } else if (inputs.targetChar === leafInfo.leaf.startCharIndex) {
        where = "start";
      } else if (inputs.targetChar < leafInfo.leaf.endCharIndex) {
        where = "inside";
      } else if (inputs.targetChar === leafInfo.leaf.endCharIndex) {
        where = "end";
      } else {
        where = "after";
      }
      return {
        leafInfo,
        where
      };
    }
    let lastLeafInfo = null;
    for (const leafInfo of inputs.leafTokens) {
      if (inputs.targetChar < leafInfo.leaf.startCharIndex && lastLeafInfo !== null) {
        return withWhere(lastLeafInfo);
      }
      if (inputs.targetChar <= leafInfo.leaf.endCharIndex) {
        return withWhere(leafInfo);
      }
      lastLeafInfo = leafInfo;
    }
    return withWhere(lastLeafInfo);
  }
};
var TwistyAlgEditorModel = class {
  constructor() {
    this.valueProp = new TwistyAlgEditorValueProp();
    this.selectionProp = new TwistyAlgEditorSelectionProp();
    this.targetCharProp = new TargetCharProp({ selectionInfo: this.selectionProp });
    this.algEditorAlgWithIssues = new AlgEditorAlgWithIssuesProp({
      value: this.valueProp
    });
    this.leafTokensProp = new LeafTokensProp({
      algWithIssues: this.algEditorAlgWithIssues
    });
    this.leafToHighlight = new LeafToHighlightProp({
      leafTokens: this.leafTokensProp,
      targetChar: this.targetCharProp
    });
  }
};

// src/cubing/twisty/views/TwistyAlgEditor/TwistyAlgEditor.css.ts
var twistyAlgEditorCSS = new CSSSource(`
:host {
  width: 384px;
  display: grid;
}

.wrapper {
  /*overflow: hidden;
  resize: horizontal;*/

  background: var(--background, none);
  display: grid;
}

textarea, .carbon-copy {
  grid-area: 1 / 1 / 2 / 2;

  width: 100%;
  font-family: sans-serif;
  line-height: 1.2em;

  font-size: var(--font-size, inherit);
  font-family: var(--font-family, sans-serif);

  box-sizing: border-box;

  padding: var(--padding, 0.5em);
  /* Prevent horizontal growth. */
  overflow-x: hidden;
}

textarea {
  resize: none;
  background: none;
  z-index: 2;
  overflow: hidden;
  border: 1px solid var(--border-color, rgba(0, 0, 0, 0.25));
}

.carbon-copy {
  white-space: pre-wrap;
  word-wrap: break-word;
  color: transparent;
  user-select: none;
  pointer-events: none;

  z-index: 1;
}

.carbon-copy .highlight {
  background: var(--highlight-color, rgba(255, 128, 0, 0.5));
  padding: 0.1em 0.2em;
  margin: -0.1em -0.2em;
  border-radius: 0.2em;
}

.wrapper.issue-warning textarea,
.wrapper.valid-for-puzzle-warning textarea {
  outline: none;
  border: 1px solid rgba(200, 200, 0, 0.5);
  background: rgba(255, 255, 0, 0.1);
}

.wrapper.issue-error textarea,
.wrapper.valid-for-puzzle-error textarea {
  outline: none;
  border: 1px solid red;
  background: rgba(255, 0, 0, 0.1);
}
`);

// src/cubing/twisty/views/TwistyAlgEditor/TwistyAlgEditor.ts
var ATTRIBUTE_FOR_TWISTY_PLAYER = "for-twisty-player";
var ATTRIBUTE_PLACEHOLDER = "placeholder";
var ATTRIBUTE_TWISTY_PLAYER_PROP = "twisty-player-prop";
var _textarea, _carbonCopy, _carbonCopyPrefix, _carbonCopyHighlight, _carbonCopySuffix, _textareaClassListValidForPuzzleManager, _twistyPlayer2, _twistyPlayerProp, _algProp, algProp_get, _onInputHasFired, _padSuffix, padSuffix_fn, _highlightedLeaf;
var TwistyAlgEditor = class extends ManagedCustomElement {
  constructor(options) {
    super();
    __privateAdd(this, _algProp);
    __privateAdd(this, _padSuffix);
    this.model = new TwistyAlgEditorModel();
    __privateAdd(this, _textarea, document.createElement("textarea"));
    __privateAdd(this, _carbonCopy, document.createElement("div"));
    __privateAdd(this, _carbonCopyPrefix, document.createElement("span"));
    __privateAdd(this, _carbonCopyHighlight, document.createElement("span"));
    __privateAdd(this, _carbonCopySuffix, document.createElement("span"));
    __privateAdd(this, _textareaClassListValidForPuzzleManager, new ClassListManager(this, "valid-for-puzzle-", [
      "none",
      "warning",
      "error"
    ]));
    __privateAdd(this, _twistyPlayer2, null);
    __privateAdd(this, _twistyPlayerProp, void 0);
    this.debugNeverRequestTimestamp = false;
    __privateAdd(this, _onInputHasFired, false);
    __privateAdd(this, _highlightedLeaf, null);
    __privateGet(this, _carbonCopy).classList.add("carbon-copy");
    this.addElement(__privateGet(this, _carbonCopy));
    __privateGet(this, _textarea).rows = 1;
    this.addElement(__privateGet(this, _textarea));
    __privateGet(this, _carbonCopyPrefix).classList.add("prefix");
    __privateGet(this, _carbonCopy).appendChild(__privateGet(this, _carbonCopyPrefix));
    __privateGet(this, _carbonCopyHighlight).classList.add("highlight");
    __privateGet(this, _carbonCopy).appendChild(__privateGet(this, _carbonCopyHighlight));
    __privateGet(this, _carbonCopySuffix).classList.add("suffix");
    __privateGet(this, _carbonCopy).appendChild(__privateGet(this, _carbonCopySuffix));
    __privateGet(this, _textarea).placeholder = "Alg";
    __privateGet(this, _textarea).setAttribute("spellcheck", "false");
    this.addCSS(twistyAlgEditorCSS);
    __privateGet(this, _textarea).addEventListener("input", () => {
      __privateSet(this, _onInputHasFired, true);
      this.onInput();
    });
    __privateGet(this, _textarea).addEventListener("blur", () => this.onBlur());
    document.addEventListener("selectionchange", () => this.onSelectionChange());
    if (options?.twistyPlayer) {
      this.twistyPlayer = options.twistyPlayer;
    }
    __privateSet(this, _twistyPlayerProp, options?.twistyPlayerProp ?? "alg");
    if (options?.twistyPlayerProp === "alg") {
      this.model.leafToHighlight.addFreshListener((highlightInfo) => {
        if (highlightInfo) {
          this.highlightLeaf(highlightInfo.leafInfo.leaf);
        }
      });
    }
  }
  set algString(s) {
    __privateGet(this, _textarea).value = s;
    this.onInput();
  }
  get algString() {
    return __privateGet(this, _textarea).value;
  }
  set placeholder(placeholderText) {
    __privateGet(this, _textarea).placeholder = placeholderText;
  }
  onInput() {
    __privateGet(this, _carbonCopyHighlight).hidden = true;
    this.highlightLeaf(null);
    const endTrimmed = __privateGet(this, _textarea).value.trimEnd();
    this.model.valueProp.set(endTrimmed);
    __privateGet(this, _algProp, algProp_get)?.set(endTrimmed);
  }
  async onSelectionChange() {
    if (document.activeElement !== this || this.shadow.activeElement !== __privateGet(this, _textarea)) {
      return;
    }
    if (__privateGet(this, _twistyPlayerProp) !== "alg") {
      return;
    }
    const { selectionStart, selectionEnd } = __privateGet(this, _textarea);
    this.model.selectionProp.set({
      selectionStart,
      selectionEnd
    });
  }
  async onBlur() {
  }
  setAlgIssueClassForPuzzle(issues) {
    __privateGet(this, _textareaClassListValidForPuzzleManager).setValue(issues);
  }
  highlightLeaf(leaf) {
    if (__privateGet(this, _twistyPlayerProp) !== "alg") {
      return;
    }
    if (leaf === null) {
      __privateGet(this, _carbonCopyPrefix).textContent = "";
      __privateGet(this, _carbonCopyHighlight).textContent = "";
      __privateGet(this, _carbonCopySuffix).textContent = __privateMethod(this, _padSuffix, padSuffix_fn).call(this, __privateGet(this, _textarea).value);
      return;
    }
    if (leaf === __privateGet(this, _highlightedLeaf)) {
      return;
    }
    __privateSet(this, _highlightedLeaf, leaf);
    __privateGet(this, _carbonCopyPrefix).textContent = __privateGet(this, _textarea).value.slice(0, leaf.startCharIndex);
    __privateGet(this, _carbonCopyHighlight).textContent = __privateGet(this, _textarea).value.slice(leaf.startCharIndex, leaf.endCharIndex);
    __privateGet(this, _carbonCopySuffix).textContent = __privateMethod(this, _padSuffix, padSuffix_fn).call(this, __privateGet(this, _textarea).value.slice(leaf.endCharIndex));
    __privateGet(this, _carbonCopyHighlight).hidden = false;
  }
  get twistyPlayer() {
    return __privateGet(this, _twistyPlayer2);
  }
  set twistyPlayer(twistyPlayer2) {
    if (__privateGet(this, _twistyPlayer2)) {
      console.warn("twisty-player reassignment/clearing is not supported");
      return;
    }
    __privateSet(this, _twistyPlayer2, twistyPlayer2);
    if (!twistyPlayer2) {
      return;
    }
    (async () => {
      this.algString = __privateGet(this, _algProp, algProp_get) ? (await __privateGet(this, _algProp, algProp_get).get()).alg.toString() : "";
    })();
    if (__privateGet(this, _twistyPlayerProp) === "alg") {
      __privateGet(this, _twistyPlayer2)?.experimentalModel.puzzleAlg.addFreshListener((algWithIssues) => {
        if (algWithIssues.issues.errors.length === 0) {
          this.setAlgIssueClassForPuzzle(algWithIssues.issues.warnings.length === 0 ? "none" : "warning");
          const newAlg = algWithIssues.alg;
          const oldAlg = Alg.fromString(this.algString);
          if (!newAlg.isIdentical(oldAlg)) {
            this.algString = newAlg.toString();
            this.onInput();
          } else {
          }
        } else {
          this.setAlgIssueClassForPuzzle("error");
        }
      });
      this.model.leafToHighlight.addFreshListener(async (highlightInfo) => {
        if (highlightInfo === null) {
          return;
        }
        const [indexer, timestampRequest] = await Promise.all([
          await twistyPlayer2.experimentalModel.indexer.get(),
          await twistyPlayer2.experimentalModel.timestampRequest.get()
        ]);
        if (timestampRequest === "opposite-anchor" && !__privateGet(this, _onInputHasFired)) {
          return;
        }
        const moveStartTimestamp = indexer.indexToMoveStartTimestamp(highlightInfo.leafInfo.idx);
        const duration = indexer.moveDuration(highlightInfo.leafInfo.idx);
        let newTimestamp;
        switch (highlightInfo.where) {
          case "before":
            newTimestamp = moveStartTimestamp;
            break;
          case "start":
          case "inside":
            newTimestamp = moveStartTimestamp + duration / 4;
            break;
          case "end":
          case "after":
            newTimestamp = moveStartTimestamp + duration;
            break;
          default:
            console.log("invalid where");
            throw new Error("Invalid where!");
        }
        if (!this.debugNeverRequestTimestamp) {
          twistyPlayer2.experimentalModel.timestampRequest.set(newTimestamp);
        }
      });
      twistyPlayer2.experimentalModel.currentLeavesSimplified.addFreshListener(async (currentLeavesSimplified) => {
        const indexer = await twistyPlayer2.experimentalModel.indexer.get();
        const leaf = indexer.getAnimLeaf(currentLeavesSimplified.stateIndex);
        this.highlightLeaf(leaf);
      });
    }
  }
  attributeChangedCallback(attributeName, _oldValue, newValue) {
    switch (attributeName) {
      case ATTRIBUTE_FOR_TWISTY_PLAYER: {
        const elem = document.getElementById(newValue);
        if (!elem) {
          console.warn(`${ATTRIBUTE_FOR_TWISTY_PLAYER}= elem does not exist`);
          return;
        }
        if (!(elem instanceof TwistyPlayer)) {
          console.warn(`${ATTRIBUTE_FOR_TWISTY_PLAYER}=is not a twisty-player`);
          return;
        }
        this.twistyPlayer = elem;
        return;
      }
      case ATTRIBUTE_PLACEHOLDER:
        this.placeholder = newValue;
        return;
      case ATTRIBUTE_TWISTY_PLAYER_PROP:
        if (__privateGet(this, _twistyPlayer2)) {
          console.log("cannot set prop");
          throw new Error("cannot set prop after twisty player");
        }
        __privateSet(this, _twistyPlayerProp, newValue);
        return;
    }
  }
  static get observedAttributes() {
    return [
      ATTRIBUTE_FOR_TWISTY_PLAYER,
      ATTRIBUTE_PLACEHOLDER,
      ATTRIBUTE_TWISTY_PLAYER_PROP
    ];
  }
};
_textarea = new WeakMap();
_carbonCopy = new WeakMap();
_carbonCopyPrefix = new WeakMap();
_carbonCopyHighlight = new WeakMap();
_carbonCopySuffix = new WeakMap();
_textareaClassListValidForPuzzleManager = new WeakMap();
_twistyPlayer2 = new WeakMap();
_twistyPlayerProp = new WeakMap();
_algProp = new WeakSet();
algProp_get = function() {
  if (__privateGet(this, _twistyPlayer2) === null) {
    return null;
  } else {
    return __privateGet(this, _twistyPlayer2).experimentalModel[__privateGet(this, _twistyPlayerProp)];
  }
};
_onInputHasFired = new WeakMap();
_padSuffix = new WeakSet();
padSuffix_fn = function(s) {
  return s.endsWith("\n") ? s + " " : s;
};
_highlightedLeaf = new WeakMap();
customElementsShim.define("twisty-alg-editor", TwistyAlgEditor);

// src/cubing/twisty/index.ts
init_TwistyProp();
init_StickeringProp();

// src/cubing/twisty/views/twizzle/TwizzleLink.ts
init_alg();
init_puzzles();

// src/cubing/twisty/views/twizzle/TwizzleLink.css.ts
var twizzleLinkCSS = new CSSSource(`
.wrapper {
  background: rgb(255, 245, 235);
  display: grid;
  grid-template-columns: 1fr;
  border: 1px solid rgba(0, 0, 0, 0.25);
}

.setup-alg, twisty-alg-viewer {
  padding: 0.5em 1em;
}

.heading {
  background: rgba(255, 230, 210, 1);
  font-weight: bold;
  padding: 0.25em 0.5em;
}

.heading.title {
  background: rgb(255, 245, 235);
  font-size: 150%;
  white-space: pre;
}

twisty-player {
  width: 100%;
  resize: vertical;
  overflow-y: hidden;
}

twisty-player + .heading {
  padding-top: 0.5em;
}
`);

// src/cubing/twisty/views/twizzle/url-params.ts
function updateURL(url) {
  window.history.replaceState("", "", url.toString());
}
var _prefix;
var URLParamUpdater = class {
  constructor(model, options) {
    __privateAdd(this, _prefix, void 0);
    __privateSet(this, _prefix, options?.prefix ?? "");
    this.listenToAlgProp(model.alg, "alg");
    this.listenToAlgProp(model.setupAlg, "setup-alg");
    this.listenToStringSourceProp(model.twistySceneModel.stickering, "stickering");
    this.listenToStringSourceProp(model.setupAnchor, "setup-anchor");
    this.listenToStringOrNoValueProp(model.puzzleIDRequest, "puzzle", NO_VALUE);
    this.listenToStringOrNoValueProp(model.puzzleDescriptionRequest, "puzzle-description", NO_VALUE);
  }
  setURLParam(unprefixedKey, value, defaultString) {
    const prefixedKey = __privateGet(this, _prefix) + unprefixedKey;
    const url = new URL(location.href);
    if (value === defaultString) {
      url.searchParams.delete(prefixedKey);
    } else {
      url.searchParams.set(prefixedKey, value);
    }
    updateURL(url);
  }
  async listenToStringSourceProp(prop, key, defaultString) {
    const actualDefaultString = defaultString ?? await prop.getDefaultValue();
    prop.addFreshListener((s) => {
      this.setURLParam(key, s, actualDefaultString);
    });
  }
  async listenToStringOrNoValueProp(prop, key, defaultString) {
    prop.addFreshListener((s) => {
      if (s === NO_VALUE) {
        s = defaultString;
      }
      if (s === NO_VALUE) {
        this.setURLParam(key, "", "");
      } else {
        this.setURLParam(key, s, "");
      }
    });
  }
  listenToAlgProp(prop, key) {
    prop.addFreshListener((algWithIssues) => {
      this.setURLParam(key, algWithIssues.alg.toString(), "");
    });
  }
};
_prefix = new WeakMap();
function getConfigFromURL(prefix = "", url = location.href) {
  const paramMapping = {
    "alg": "alg",
    "setup-alg": "experimental-setup-alg",
    "setup-anchor": "experimental-setup-anchor",
    "puzzle": "puzzle",
    "stickering": "experimental-stickering",
    "puzzle-description": "experimental-puzzle-description",
    "title": "experimental-title",
    "video-url": "experimental-video-url",
    "competition": "experimental-competition-id"
  };
  const params = new URL(url).searchParams;
  const config = {};
  for (const [ourParam, twistyPlayerParam] of Object.entries(paramMapping)) {
    const paramValue = params.get(prefix + ourParam);
    if (paramValue !== null) {
      const configKey = twistyPlayerAttributeMap[twistyPlayerParam];
      config[configKey] = paramValue;
    }
  }
  return config;
}

// src/cubing/twisty/views/twizzle/TwizzleLink.ts
var _cssElem;
var TwizzleLink = class extends ManagedCustomElement {
  constructor() {
    super({ mode: "open" });
    this.twistyPlayer = null;
    this.a = null;
    __privateAdd(this, _cssElem, void 0);
  }
  fallback() {
    this.contentWrapper.textContent = "";
    if (this.a) {
      const span = this.contentWrapper.appendChild(document.createElement("span"));
      span.textContent = "\u2757\uFE0F";
      span.title = "Could not show a player for link";
      this.addElement(this.a);
    }
    if (__privateGet(this, _cssElem)) {
      __privateGet(this, _cssElem).remove();
    }
  }
  async connectedCallback() {
    __privateSet(this, _cssElem, this.addCSS(twizzleLinkCSS));
    this.a = this.querySelector("a");
    if (!this.a) {
      return;
    }
    const config = getConfigFromURL("", this.a.href);
    const href = this.a?.href;
    const { hostname, pathname } = new URL(href);
    if (hostname !== "alpha.twizzle.net") {
      this.fallback();
      return;
    }
    if (["/edit/", "/explore/"].includes(pathname)) {
      const isExplorer = pathname === "/explore/";
      if (config.puzzle && !(config.puzzle in puzzles)) {
        const puzzleDescription = (await Promise.resolve().then(() => (init_puzzle_geometry(), puzzle_geometry_exports))).getPuzzleDescriptionString(config.puzzle);
        delete config.puzzle;
        config.experimentalPuzzleDescription = puzzleDescription;
      }
      this.twistyPlayer = this.addElement(new TwistyPlayer({
        ...config,
        viewerLink: isExplorer ? "experimental-twizzle-explorer" : "auto"
      }));
      if (config.experimentalTitle) {
        this.addHeading(config.experimentalTitle).classList.add("title");
      }
      if (config.experimentalSetupAlg) {
        this.addHeading("Setup");
        const setupAlgDiv = this.addElement(document.createElement("div"));
        setupAlgDiv.classList.add("setup-alg");
        setupAlgDiv.textContent = new Alg(config.experimentalSetupAlg).toString();
      }
      this.addHeading("Moves");
      const twistyAlgViewer = this.addElement(new TwistyAlgViewer({ twistyPlayer: this.twistyPlayer }));
      twistyAlgViewer.part.add("twisty-alg-viewer");
    } else {
      this.fallback();
    }
  }
  addHeading(text) {
    const headingDiv = this.addElement(document.createElement("div"));
    headingDiv.classList.add("heading");
    headingDiv.textContent = text;
    return headingDiv;
  }
};
_cssElem = new WeakMap();
customElementsShim.define("twizzle-link", TwizzleLink);

// src/sites/experiments.cubing.net/cubing.js/twisty/g4g-talk.ts
var pixelRatio2 = new URL(location.href).searchParams.get("pixelRatio") ?? "0.5";
if (pixelRatio2 !== null) {
  setGlobalPixelRatioOverride(parseFloat(pixelRatio2));
}
var twistyPlayer = document.querySelector("twisty-player");
var tempo = new URL(location.href).searchParams.get("tempo");
if (tempo !== null) {
  twistyPlayer.tempoScale = parseFloat(tempo);
} else {
  twistyPlayer.tempoScale = 1.25;
}
twistyPlayer.experimentalModel.playingInfo.set({
  playing: true,
  loop: true
});
/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
